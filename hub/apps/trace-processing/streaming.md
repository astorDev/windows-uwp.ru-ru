---
title: Использование потоковой передачи .NET Трацепроцессинг
description: Из этого руководства вы узнаете, как использовать потоковую передачу для немедленного доступа к данным трассировки и использования меньшего объема памяти.
author: maiak
ms.author: maiak
ms.date: 02/23/2020
ms.topic: tutorial
ms.openlocfilehash: e04f306a6a5c03d1f502b9cfb6c2cbb737e0098f
ms.sourcegitcommit: 4fdab7be28aca18cb3879fc205eb49edc4f9a96b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/26/2020
ms.locfileid: "77629085"
---
# <a name="use-streaming-with-traceprocessor"></a>Использование потоковой передачи с помощью Трацепроцессор

По умолчанию Трацепроцессор обращается к данным, загружая их в память при обработке трассировки. Такой подход к буферизации прост в использовании, но он может быть дорогостоящим с точки зрения использования памяти.

Трацепроцессор также обеспечивает трассировку. Усестреаминг (), который поддерживает доступ к нескольким типам данных трассировки в потоковой манере (обработка данных при считывании из файла трассировки, а не буферизация этих данных в памяти). Например, трассировка syscall может быть достаточно большой, и буферизация всего списка syscall в трассировке может быть довольно дорогостоящей.

## <a name="accessing-buffered-data"></a>Доступ к буферизованным данным

В следующем коде показан доступ к данным syscall в стандартном буферном режиме с помощью трассировки. Усесискаллс ():

```csharp
using Microsoft.Windows.EventTracing;
using Microsoft.Windows.EventTracing.Processes;
using Microsoft.Windows.EventTracing.Syscalls;
using System;
using System.Collections.Generic;

class Program
{
    static void Main(string[] args)
    {
        if (args.Length != 1)
        {
            Console.Error.WriteLine("Usage: <trace.etl>");
            return;
        }

        using (ITraceProcessor trace = TraceProcessor.Create(args[0]))
        {
            IPendingResult<ISyscallDataSource> pendingSyscallData = trace.UseSyscalls();

            trace.Process();

            ISyscallDataSource syscallData = pendingSyscallData.Result;

            Dictionary<IProcess, int> syscallsPerCommandLine = new Dictionary<IProcess, int>();

            foreach (ISyscall syscall in syscallData.Syscalls)
            {
                IProcess process = syscall.Thread?.Process;

                if (process == null)
                {
                    continue;
                }

                if (!syscallsPerCommandLine.ContainsKey(process))
                {
                    syscallsPerCommandLine.Add(process, 0);
                }

                ++syscallsPerCommandLine[process];
            }

            Console.WriteLine("Process Command Line: Syscalls Count");

            foreach (IProcess process in syscallsPerCommandLine.Keys)
            {
                Console.WriteLine($"{process.CommandLine}: {syscallsPerCommandLine[process]}");
            }
        }
    }
}
```

## <a name="accessing-streaming-data"></a>Доступ к потоковой передаче данных

При большой трассировке syscall попытка буферизации данных syscall в памяти может быть довольно дорогостоящей или даже невозможной. В следующем коде показано, как получить доступ к одним и тем же данным syscall в потоковой манере, заменив трассировку. Усесискаллс () с трассировкой. Усестреаминг (). Усесискаллс ():

```csharp
using Microsoft.Windows.EventTracing;
using Microsoft.Windows.EventTracing.Processes;
using Microsoft.Windows.EventTracing.Syscalls;
using System;
using System.Collections.Generic;

class Program
{
    static void Main(string[] args)
    {
        if (args.Length != 1)
        {
            Console.Error.WriteLine("Usage: <trace.etl>");
            return;
        }

        using (ITraceProcessor trace = TraceProcessor.Create(args[0]))
        {
            IPendingResult<IThreadDataSource> pendingThreadData = trace.UseThreads();

            Dictionary<IProcess, int> syscallsPerCommandLine = new Dictionary<IProcess, int>();

            trace.UseStreaming().UseSyscalls(ConsumerSchedule.SecondPass, context =>
            {
                Syscall syscall = context.Data;
                IProcess process = syscall.GetThread(pendingThreadData.Result)?.Process;

                if (process == null)
                {
                    return;
                }

                if (!syscallsPerCommandLine.ContainsKey(process))
                {
                    syscallsPerCommandLine.Add(process, 0);
                }

                ++syscallsPerCommandLine[process];
            });

            trace.Process();

            Console.WriteLine("Process Command Line: Syscalls Count");

            foreach (IProcess process in syscallsPerCommandLine.Keys)
            {
                Console.WriteLine($"{process.CommandLine}: {syscallsPerCommandLine[process]}");
            }
        }
    }
}
```

## <a name="how-streaming-works"></a>Принцип работы потоковой передачи

По умолчанию все потоковые данные предоставляются во время первого прохода по трассировке, а буферизованные данные из других источников недоступны. В приведенном выше примере показано, как объединить потоковую передачу с буферизацией — потоковые данные буферизуются до потоковой передачи данных syscall. В результате трассировка должна быть прочитана дважды — один раз для получения данных буферизованного потока, а второй раз для доступа к потоковой передаче данных syscall с помощью буферизованных данных потоков. Чтобы объединить потоковую передачу и буферизацию таким образом, в примере передается трассировка Консумерсчедуле. Секондпасс. Усестреаминг (). Усесискаллс (), что приводит к тому, что обработка syscall происходит во второй проход по трассировке. Выполнив второй проход, обратный вызов syscall может получить доступ к ожидающему результату из трассировки. Усесреадс () при обработке каждого syscall. Без этого необязательного аргумента потоковая передача syscall была бы выполнена в первом проходе через трассировку (будет только один проход) и отложенный результат трассировки. Усесреадс () пока недоступен. В этом случае обратный вызов по-прежнему будет иметь доступ к ThreadId из syscall, но у него не будет доступа к процессу потока (поскольку поток для обработки данных связывания предоставляется через другие события, которые, возможно, еще не обработаны).

Некоторые ключевые отличия в использовании между буферизацией и потоковой передачей:

1. Буферизация возвращает [ипендингресулт&lt;t&gt;](https://docs.microsoft.com/dotnet/api/microsoft.windows.eventtracing.ipendingresult-1), и результат, который он содержит, доступен только до обработки трассировки. После обработки трассировки результаты можно перечислить с помощью таких методов, как foreach и LINQ.
2. Потоковая передача возвращает значение void, а вместо этого принимает аргумент обратного вызова. Он вызывает обратный вызов по мере того, как каждый элемент станет доступным. Так как данные не помещены в буфер, список результатов для перечисления с помощью foreach или LINQ никогда не существует — потоковый обратный вызов должен буферизовать любую часть данных, которую нужно сохранить для использования после завершения обработки.
3. Код для обработки буферизованных данных появляется после вызова функции trace. Process (), если ожидающие результаты доступны.
4. Код для обработки потоковых данных отображается перед вызовом функции trace. Process () в качестве обратного вызова трассировки. Усестреаминг. Используйте... метод ().
5. Потребитель потоковой передачи может выбрать обработку только части потока и отменить последующие обратные вызовы, вызвав контекст. Cancel (). Потребитель буферизации всегда предоставляет полный буферизованный список.

## <a name="correlated-streaming-data"></a>Коррелированные данные потоковой передачи

Иногда данные трассировки поступают в последовательность событий, например syscall регистрируются с помощью отдельных событий Enter и Exit, но объединенные данные из обоих событий могут быть более полезными. Трассировка метода. Усестреаминг (). Усесискаллс () сопоставляет данные обоих этих событий и предоставляет их по мере того, как пара станет доступной. Несколько типов коррелированных данных доступны через трассировку. Усестреаминг ():

| Код                                        | Описание                                                                                                                                     |
|---------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------|
| трассировки. Усестреаминг (). Усеконтекстсвитчдата () | Потоки взаимокоррелированные данные переключения контекста (из сжатых и несжатых событий с более точным Свитчинсреадидс, чем необработанные несжатые события). |
| трассировки. Усестреаминг (). Усесчедуледтаскс ()    | Потоки, коррелированные данные запланированной задачи.                                                                                                         |
| трассировки. Усестреаминг (). Усесискаллс ()          | Потоки взаимосвязанные данные системного вызова.                                                                                                            |
| трассировки. Усестреаминг (). Усевиндовинфокус ()     | Потоки, коррелированные в фокусе окна данных.                                                                                                        |

## <a name="standalone-streaming-events"></a>События автономной потоковой передачи

Кроме того, трассировка. Усестреаминг () предоставляет проанализированные события для нескольких разных изолированных типов событий:

| Код                                               | Описание                                     |
|----------------------------------------------------|-------------------------------------------------|
| трассировки. Усестреаминг (). Уселастбранчрекордевентс ()   | Потоки, анализирующие последние события записи ветви (ЛБР). |
| трассировки. Усестреаминг (). Усереадисреадевентс ()        | Потоки, проанализированные готовые события потока.             |
| трассировки. Усестреаминг (). Усесреадкреативентс ()       | Потоки, проанализируемые события создания потоков.            |
| трассировки. Усестреаминг (). Усесреадекситевентс ()         | Потоки, проанализируемые события выхода потока.              |
| трассировки. Усестреаминг (). Усесреадрундовнстартевентс () | События запуска очистки потока проанализированы потоком.     |
| трассировки. Усестреаминг (). Усесреадрундовнстопевентс ()  | События отмены очистки потока проанализированных потоков.      |
| трассировки. Усестреаминг (). Усесреадсетнамивентс ()      | Потоки проанализировали события имени набора потоков.          |

## <a name="underlying-streaming-events-for-correlated-data"></a>Базовые события потоковой передачи для коррелированных данных

Наконец, трассировка. Усестреаминг () также предоставляет базовые события, используемые для корреляции данных в приведенном выше списке. Эти базовые события:

| Код                                                        | Описание                                                                                | Включено в                                 |
|-------------------------------------------------------------|--------------------------------------------------------------------------------------------|---------------------------------------------|
| трассировки. Усестреаминг (). Усекомпактконтекстсвитчевентс ()        | Потоки, проанализировали свернутые события переключения контекста.                                              | трассировки. Усестреаминг (). Усеконтекстсвитчдата () |
| трассировки. Усестреаминг (). Усеконтекстсвитчевентс ()               | Потоки, анализирующие события переключения контекста. В некоторых случаях Свитчинсреадидс может быть неточным. | трассировки. Усестреаминг (). Усеконтекстсвитчдата () |
| трассировки. Усестреаминг (). Усефокусчанжеевентс ()                 | Потоки проанализированные события изменения фокуса окна.                                                 | трассировки. Усестреаминг (). Усевиндовинфокус ()     |
| трассировки. Усестреаминг (). Усесчедуледтаскстартевентс ()          | Потоков событий запуска запланированной задачи, проанализированных по расписанию.                                                | трассировки. Усестреаминг (). Усесчедуледтаскс ()    |
| трассировки. Усестреаминг (). Усесчедуледтаскстопевентс ()           | Потоки, проанализированные событиями завершения запланированной задачи.                                                 | трассировки. Усестреаминг (). Усесчедуледтаскс ()    |
| трассировки. Усестреаминг (). Усесчедуледтасктригжеревентс ()        | Потоки, проанализируемые события триггера запланированной задачи.                                              | трассировки. Усестреаминг (). Усесчедуледтаскс ()    |
| трассировки. Усестреаминг (). Усесессионлайерсетактивевиндовевентс () | Потоки проанализированы события активного окна на уровне сеанса.                                     | трассировки. Усестреаминг (). Усевиндовинфокус ()     |
| трассировки. Усестреаминг (). Усесискаллентеревентс ()                | Потоки, проанализированные с syscall, вводят события.                                                       | трассировки. Усестреаминг (). Усесискаллс ()          |
| трассировки. Усестреаминг (). Усесискаллекситевентс ()                 | Потоки, анализируемые события выхода syscall.                                                        | трассировки. Усестреаминг (). Усесискаллс ()          |

## <a name="next-steps"></a>Следующие шаги

В этом руководстве вы узнали, как использовать потоковую передачу для немедленного доступа к данным трассировки и использования меньшего объема памяти.

Следующим шагом является просмотр доступа к нужным данным из трассировок. Ознакомьтесь с [примерами](https://github.com/microsoft/eventtracing-processing-samples) для некоторых идей. Обратите внимание, что не все трассировки включают в себя все поддерживаемые типы данных.
