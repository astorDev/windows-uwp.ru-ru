---
title: Использование дополнительных свойств
description: Введение в использование дополнительных свойств и сведения о том, как они реализованы в Windows.
ms.date: 01/10/2017
ms.topic: article
keywords: windows 10, uwp, API WinRT, индексатор, поиск
localizationpriority: medium
ms.openlocfilehash: 2a77bfc37d853efd28bde9bc3043d072888822f2
ms.sourcegitcommit: 76e8b4fb3f76cc162aab80982a441bfc18507fb4
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/29/2020
ms.locfileid: "66369267"
---
# <a name="using-supplemental-properties"></a>Использование дополнительных свойств  

## <a name="summary"></a>Сводка  
- Дополнительные свойства позволяют приложениям помечать файлы тегами свойств без изменения самих файлов. 
- Это удобно, когда имеются свойства, которые трудно вычислить, или файл невозможно изменить. 
- Использование дополнительных свойств не отличается от использования любого другого свойства в системе свойств Windows.  

## <a name="introduction"></a>Введение 
Многим из замечательных новых приложений за последние несколько лет требуются операции с интенсивным использованием ЦП, которые извлекают из файлов пользователя полезные свойства, не ограничивающиеся такими простыми сведениями, как дата создания. Эти приложения распознают объекты на изображениях, извлекают намерения из сообщений электронной почты и анализируют текст, чтобы группировать связанные документы. Это стало возможным благодаря высокой вычислительной мощности, которая теперь доступна в большинстве потребительских компьютеров.   

Обеспечив возможность мгновенного поиска по этим метаданным, пользователи могут экспоненциально повысить свою продуктивность. Просто знать, что на изображении — ваша дочь, интересно, но возможность искать изображения, на которых она вместе с бабушкой, намного полезнее. Таким образом использование компьютера ощущается более личным и живым. Как-будто кто-то в компьютере протягивает вам руку, чтобы помочь найти ваши ценные воспоминания. 

В течение десятилетий решением для быстрого поиска в Windows служил индексатор, и в выпуске Creators Update он был обновлен для поддержки новых сценариев. Теперь приложения могут помечать файлы тегами дополнительных свойств, помимо тех, которые извлекаются системой. Эти свойства считаются привилегированными.  

## <a name="windows-properties"></a>Свойства Windows 
[Система свойств Windows](https://docs.microsoft.com/windows/desktop/properties/windows-properties-system) годами была ключевой частью взаимодействия с файлами. Она позволяет приложениям считывать свойства из файлов, не вникая в их внутреннее содержимое, которое может быть представлено разными форматами файла или языками. Все это абстрагируется с точки зрения разработчика. Все, что нужно сделать, — запросить список и указать порядок сортировки по возрастанию или по убыванию.  

Система свойств связана с индексатором Windows. Она считывает все свойства из файлов в своей области и сохраняет их. Позже, когда приложение запросит список всех DOCX-файлов в папке, чтобы отсортировать по дате изменения, кроме тех, что созданы пользователем John Smith, индексатор сможет мгновенно вернуть соответствующий список.  

Недостаток такого взаимодействия состоит в том, что индексатор, используемый для запроса всех свойств, которые он будет хранить в данных о файле, должен быть доступен мгновенно. Это ограничивает его, не позволяя узнать о более интересных свойствах, которые вычисляются дольше, так как время операции жестко лимитировано.  

Хотя использовать свойства несложно, приложение может запросить отсортированный набор свойств файла, как при работе с базой данных, или оно может передать запрос, как при использовании поисковой системы. Индексатор обработает запрос и вернет результаты. Это дает разработчикам возможность объединять свои фильтры (например, искать только JPG-файлы) с пользовательским запросом (например, имя файла, начинающееся с "bird"). 

## <a name="supplemental-properties"></a>Дополнительные свойства 

Дополнительные свойства функционируют точно так же, как обычные свойства Windows, с одним очень важным отличием — они не записываются при добавлении файла в индексатор. Дополнительное свойство должно быть добавлено позже другим приложением в системе. Это может быть через две минуты после завершения распознавания объектов или через несколько дней. 

После записи свойство становится доступно для поиска, фильтрации, сортировки и группирования, как и любое другое свойство в системе. Кроме того, оно может использоваться в запросах вместе с другими свойствами в системе, как обычными, так и дополнительными. Это дает возможность легко совместить дополнительные свойства с существующим кодом файловой системы без необходимости перезаписи.  

### <a name="example-scenarios"></a>Примеры сценариев 

Существуют тысячи различных свойств, которые можно записать в качестве дополнительных свойств, но есть ряд ключевых сценариев, к которым мы будем обращаться в этом руководстве.  

#### <a name="tagging-pictures-with-extracted-properties"></a>Добавление тегов изображений с извлеченными свойствами 
Эти приложения могут использовать обученную модель машинного обучения для извлечения признаков из изображения, которые неизвестны системе. Например, это может быть объект на изображении. Затем приложение может получить объекты, обнаруженные на изображении, и добавить их в систему свойств для последующего поиска или группирования.  

#### <a name="tagging-files-with-an-app-specific-id"></a>Добавление тегов файлов со специальным идентификатором приложения 
Во многих приложениях синхронизации файлов используются собственные уникальные идентификаторы для отслеживания файлов, перемещаемых между сервером и различными клиентскими устройствами. Клиент синхронизации может записывать эти идентификаторы в систему свойств, никак не влияя на сами файлы. После этого данные идентификаторы становятся доступны приложению. Оно, как и любое другое приложение в системе, может быстро читать их, обмениваясь данными с поставщиком синхронизации. 

Существует множество других вариантов использования дополнительных свойств, но эти два являются хорошими примерами. Они требуют быстрого просмотра или поиска, а используемые в них свойства — это фрагменты данных, о которых не знает система, и их невозможно добавить в сам файл.  

### <a name="using-supplemental-properties"></a>Использование дополнительных свойств 
Использование дополнительных свойств не отличается от записи обычного свойства в файловую систему. Если вам удобно использовать StorageFiles и свойства, вы можете пропустить этот раздел. В противном случае давайте подробно рассмотрим краткий пример, который записывает отдельное свойство в файл и затем считывает его.  

### <a name="writing-supplemental-properties"></a>Запись дополнительных свойств  
Для простоты пример будет изменять только первый файл, которое он найдет. Однако обычно приложение будет добавлять свойство ко всем найденным файлам.  

```csharp
// Only indexed jpg files are going to be used 
QueryOptions option = new QueryOptions(CommonFileQuery.DefaultQuery, new string[] { ".jpg" }); 
option.IndexerOption = IndexerOption.OnlyUseIndexer; 
// Typically an app would loop over all the files in the library, updating them all with the new 
// value. To make the sample easier to understand however, this app is only going to update the  
// first file it finds 
var query = KnownFolders.PicturesLibrary.CreateFileQueryWithOptions(option); 
StorageFile file = (await query.GetFilesAsync()).FirstOrDefault(); 
if (file == null) 
{ 
    log("No jpg file found in the library. Stopping"); 
    return; 
} 
log("Found file: " + file.Path); 
// Selecting the property to modify and writing it out 
List<KeyValuePair<string, object>> props = new List<KeyValuePair<string, object>>();             
props.Add(new KeyValuePair<string, object>("System.Supplemental.ResourceId", fileId)); 
await file.Properties.SavePropertiesAsync(props); 
```

Перед записью свойства важно проверить, индексировано ли расположение. В этом примере мы используем параметры запроса, чтобы задать фильтр только для индексированных расположений. Если это вам не подходит, можно проверить состояние индексирования родительской папки (file.GetParentAsync().GetIndexedStateAsync()). В любом случае вы получите одинаковые результаты. 

### <a name="reading-supplemental-properties"></a>Чтение дополнительных свойств 
Опять же, чтение дополнительного свойства не отличается от чтения любого другого свойства файловой системы. В этом примере приложение просто считает одно свойство из файла, для которого уже задан объект StorageFile, но в то же время оно может считать и другие свойства.  

```csharp
// An object to hold the result from the indexer, and a string to store  
// the value in once we have confirmed it is valid. 
object uncheckedResourceId; 
string resourceId = ""; 
// Fetching the key value pair from the indexer 
IDictionary<string,object> returnedProps =  
    await file.Properties.RetrievePropertiesAsync(new string[] { "System.Supplemental.ResourceId" });             
if (returnedProps.TryGetValue("System.Supplemental.ResourceId", out uncheckedResourceId)) 
{ 
    if (uncheckedResourceId != null && !String.IsNullOrEmpty(uncheckedResourceId.ToString())) 
    { 
        resourceId = uncheckedResourceId.ToString(); 
    } 
} 
```
Выполняется проверка, чтобы убедиться в том, что значение, возвращаемое из системы свойств, соответствует ожиданиям. Несмотря на то, что это маловероятно, может оказаться, что значение было очищено после того, как ваше приложение записало его в последний раз. Это будет рассмотрено более подробно ниже.  

### <a name="implementation-notes"></a>Примечания к реализации 
Существует несколько неочевидных решений, которые были реализованы в дополнительных свойствах. Чтобы упросить реализацию, мы скопировали следующие разделы из технической проектной спецификации этого компонента. Они позволяют вкратце ознакомиться с тем, как он был разработан и почему существуют некоторые ограничения. 

### <a name="supplemental-properties-available"></a>Доступные дополнительные свойства 
Изначально существуют только два свойства, которые можно использовать для приложений: System.Supplemental.ResourceId и System.Supplemental.AlbumID. При необходимости можно добавить и другие свойства. Идентификатор альбома — это многозначная строка, которая может использоваться множеством различных приложений, а ResourceId используется в качестве уникального идентификатора для поставщиков облачной синхронизации. 

#### <a name="file-system-support"></a>Поддержка файловой системы 
Так как сценарий на основе съемного носителя в формате FAT является важным, дополнительные свойства будут поддерживать диски FAT и NTFS. Это гарантирует, что дополнительные свойства будут доступны для всех пользователей, независимо от их типа устройства.   

### <a name="non-indexed-locations"></a>Неиндексированные расположения  
На компьютере существует определенное число папок, которые не индексированы. В этих случаях приложениям все равно может потребоваться доступ к дополнительным свойствам. Однако дополнительные свойства недоступны за пределами индексированных расположений. Мы пошли на этот компромисс по нескольким причинам:  

- По умолчанию индексируются все расположения библиотек и облачных хранилищ.   
  Именно эти расположения главным образом используют приложения UWP. Существуют другие расположения, которые не индексируются (системные или сетевые диски), но они реже используются для хранения пользовательских данных. 

- В поверхности разработки API WinRT предполагается, что индексатор почти всегда доступен.  
  Поэтому индексатор уже доступен в большинстве расположений, которые интересны приложениям. Если обнаруживается, что пользователи хранят данные в неиндексированных расположениях, проще всего будет добавить эти расположения в индекс. Это позволит использовать дополнительные свойства, перечисление будет выполняться быстрее, а приложения смогут отслеживать изменения в этих расположениях.

### <a name="reading-or-writing-supplemental-properties-from-a-file-in-a-non-indexed-location"></a>Чтение или запись дополнительных свойств файла в неиндексированном расположении 
В случае, если приложение попытается записать дополнительное свойство в расположение, которое в настоящее время не индексировано, то вызов API породит исключение. Такое же исключение порождается, когда кто-то пытается обновить свойство System.Music.AlbumArtist DOCX-файла (недопустимые аргументы).  
 
### <a name="change-notifications"></a>Уведомления об изменениях  
Уведомления об изменениях и отслеживание изменений UWP будут работать для дополнительных свойств, как и для стандартных свойств. Это позволит приложениям, предоставляющим данные, отслеживать все изменения, происходящие с одним из этих приложений. 
  
### <a name="invalidating-properties"></a>Аннулирование свойств  
Дополнительные свойства файла могут устареть, если файл был изменен или перемещен в системе. Именно приложения, отправляющие данные, будут предоставлять сведения о том, являются эти данные допустимыми или их нужно обновить, чтобы система просто предоставила инструменты, позволяющие это выяснить.  
 
В случае, если файл был изменен, но не перемещен или переименован, все его дополнительные свойства останутся без изменений. Приложения смогут зарегистрироваться для получения уведомлений об изменении через существующую плоскость API и обновить свойства, когда это потребуется. 
 
Если файл перемещен, его свойства становятся недействительными. Приложение будет получать уведомления об изменении при удалении, создании, переименовании или перемещении, в зависимости от того, как именно выполнена операция. Когда приложение получит уведомление об изменении, оно сможет проверить файл и обновить его дополнительные свойства, если это необходимо. 
 
### <a name="indexer-rebuilds"></a>Перестроение индексатора  
Иногда индекс системы необходимо перестроить по одной из целого ряда причин: может измениться схема свойств, пользователь может включить EDP или просто может быть поврежден файл базы данных. В этом случае дополнительные свойства не сохраняются. Мы рассматривали возможность сохранения дополнительных свойств при перестроении индекса, но возникло несколько существенных препятствий.  

### <a name="protecting-the-data"></a>Защита данных 
В случае, когда файл базы данных поврежден из-за сбоев диска или злоумышленного программного обеспечения, невозможно защитить данные, хранящиеся в этом файле. Его нужно хранить в другом месте в системе или каким-либо образом изолировать от остальной базы данных. 

Так как мы уже прилагаем массу усилий, чтобы уменьшить вероятность повреждения индекса, в любом случае это позволит снизить частоту возникновения таких ситуаций.  
Обслуживание сопоставления файлов и их метаданных во время перестроения 

Даже если индекс может защищать данные при перестроении, невозможно узнать, был ли файл изменен во время перестроения индекса. Данные из файла, которые защищает индекс, могут быть уже недействительны, если файл был изменен или перемещен.  
Поведение 

В случае перестроения индексатора все дополнительные данные будут потеряны. Приложения будут отвечать за возвращение в индексатор данных, которые были потеряны во время перестроения. Это усложняет логику приложений, но считается разумным, так как они всегда будут хранить главное состояние всех своих данных.  

### <a name="recovering"></a>Восстановление 
Когда приложения обнаружат, что происходит перестроение индекса, они будут отвечать за обновление дополнительных свойств, когда им будет удобно.  
### <a name="privacy"></a>Конфиденциальность 
Некоторые свойства, которые могут быть записаны в файлы, пользователи могут не хотеть использовать совместно с другими приложениями. Приложение должно иметь возможность указать, что сведения, которые оно записывает в свойства, будут частными для данного приложения, общими с несколькими другими приложениями или доступными для всех приложений в системе.  

Несмотря на то, что это потенциально интересная функция для некоторых ее первых соразработчиков, они считают, что применение общедоступных свойств по-прежнему имеет большое значение для проектирования. Поэтому она помечена как рекомендуемая, и на следует продолжать создание этой функции без поддержки скрытия значений при необходимости. Ее последующее добавление сделает возможной реализацию множества сценариев, поэтому ее необходимо будет учитывать при проектировании любых приложений.  

## <a name="conclusions"></a>Заключение 
Таким образом, дополнительные свойства обеспечивают простой способ хранения свойств файла в системе. Их использование, конечно, не является обязательным, но они могут дать вашему приложению преимущество перед другими приложениями, которые не могут сортировать и находить данные так быстро. 

Мы надеемся увидеть, как появляются приложения, которые используют эти свойства. Если у вас есть вопросы о том, как использовать заголовок, сообщите нам об этом в комментариях ниже. 
