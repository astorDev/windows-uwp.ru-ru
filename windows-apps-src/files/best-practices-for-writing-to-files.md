---
title: Рекомендации по составлению файлов
description: Рекомендации по использованию различных написание методов классов файловый ввод-вывод и PathIO файла.
ms.date: 02/06/2019
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: f8bed97e060015f92ff95c9f7d797bbcb83db431
ms.sourcegitcommit: 079801609165bc7eb69670d771a05bffe236d483
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/27/2019
ms.locfileid: "9115715"
---
# <a name="best-practices-for-writing-to-files"></a>Рекомендации по составлению файлов

**Важные API**

* [**Класс FileIO**](https://docs.microsoft.com/uwp/api/Windows.Storage.FileIO)
* [**Класс PathIO**](https://docs.microsoft.com/uwp/api/windows.storage.pathio)

Разработчики иногда возникать набор распространенных проблем при использовании методы **Write** классов [**файловый ввод-вывод**](https://docs.microsoft.com/uwp/api/Windows.Storage.FileIO) и [**PathIO**](https://docs.microsoft.com/uwp/api/windows.storage.pathio) для выполнения операций файловой системы ввода-вывода. Например включить распространенных проблем:

• Приложение получает исключение при вызове одного из методов частично записываются • файла. • Терять операции. Файлы TMP с именем файла аналогично имя целевого файла.

Ниже перечислены методы **Write** классов [**файловый ввод-вывод**](https://docs.microsoft.com/uwp/api/Windows.Storage.FileIO) и [**PathIO**](https://docs.microsoft.com/uwp/api/windows.storage.pathio) .

* **WriteBufferAsync**
* **WriteBytesAsync**
* **WriteLinesAsync**
* **WriteTextAsync**

 Эта статья содержит сведения о том, как эти методы работают так разработчикам лучше понять о сроках и способах их использования. В этой статье представлены рекомендации и не будет пытаться представляют собой решение для всех возможных файл ввода-вывода проблемы. 

> [!NOTE]
> В этой статье основное внимание уделяется методы **FileIO** обсуждения и примеры. Тем не менее методы **PathIO** выполните аналогичную схему и большинство рекомендации, представленные в этой статье также применяется для этих методов. 

## <a name="conveience-vs-control"></a>Conveience и управления

Объект [**StorageFile**](https://docs.microsoft.com/uwp/api/windows.storage.storagefile) не дескриптор файла как собственной модели программирования Win32. Вместо этого [**StorageFile**](https://docs.microsoft.com/uwp/api/windows.storage.storagefile) представляет собой файл с помощью методов для управления содержимым.

Общие сведения об этой концепции полезна при выполнении операций ввода-вывода с **StorageFile**. Например в разделе [записи в файл](quickstart-reading-and-writing-files.md#writing-to-a-file) предоставляет три способа записи в файл:

* С помощью метода [**FileIO.WriteTextAsync**](https://docs.microsoft.com/uwp/api/windows.storage.fileio.writetextasync) .
* Создание буфера и затем вызвать метод [**FileIO.WriteBufferAsync**](https://docs.microsoft.com/en-us/uwp/api/windows.storage.fileio.writebufferasync) .
* Шаг 4 модели, используя поток:
  1. [Откройте](https://docs.microsoft.com/uwp/api/windows.storage.storagefile.openasync) файл для получения потока.
  2. [Получите](https://docs.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.getoutputstreamat) выходной поток.
  3. Создание объекта [**DataWriter**](https://docs.microsoft.com/uwp/api/windows.storage.streams.datawriter) и вызовите соответствующий метод **записи** .
  4. [Фиксация](https://docs.microsoft.com/uwp/api/windows.storage.streams.datawriter.storeasync) данные в записи данных и [удаляют](https://docs.microsoft.com/uwp/api/windows.storage.streams.ioutputstream.flushasync) выходного потока.

Первые два сценария являются наиболее часто используемых приложений. Запись в файл в одной операции проще кода и поддерживать, и он также удаляет ответственности приложения из выполнению многие из сложностей файловый ввод-вывод. Тем не менее, это удобство сказывается на плата: потери контроль над тем, вся операция и возможность перехватывать ошибки в определенных точках.

## <a name="the-transactional-model"></a>Модель транзакций

Методы **Write** классов [**файловый ввод-вывод**](https://docs.microsoft.com/uwp/api/Windows.Storage.FileIO) и [**PathIO**](https://docs.microsoft.com/uwp/api/windows.storage.pathio) оболочку действия, указанные на третьем записи модель, описанную выше, с помощью дополнительного уровня. Этот уровень инкапсулируется в хранилище транзакции.

Для защиты целостности исходный файл на случай, если что-то пойдет не так при записи данных, методы **записи** используют модель транзакций, запустив файл с помощью [**OpenTransactedWriteAsync**](https://docs.microsoft.com/uwp/api/windows.storage.storagefile.opentransactedwriteasync). Эта процедура создает объект [**StorageStreamTransaction**](https://docs.microsoft.com/uwp/api/windows.storage.storagestreamtransaction) . После создания этот объект транзакции API-интерфейсы записи данных после аналогичному пример [Доступа к файлам](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/FileAccess) или в примере кода в статье [**StorageStreamTransaction**](https://docs.microsoft.com/uwp/api/windows.storage.storagestreamtransaction) .

На следующей схеме показана базовые задачи, выполняемые метод **WriteTextAsync** в операция записи успешно. На следующем рисунке представлены упрощенная операции. Например он пропускает действия, например завершения кодирования и async текст в различных потоках.

![Схема последовательности вызовов API-Интерфейс UWP для записи в файл](images/file-write-call-sequence.svg)

Имеет следующие преимущества использования методов **записи** классов [**файловый ввод-вывод**](https://docs.microsoft.com/uwp/api/Windows.Storage.FileIO) и [**PathIO**](https://docs.microsoft.com/uwp/api/windows.storage.pathio) вместо более сложные модели четырех шагов, используя поток.

* Один вызов API для обработки всех промежуточных шагов, включая ошибки.
* Исходный файл хранится в том случае, если что-то пойдет не так.
* Состояние системы попытается сохранены как чистой максимальной продуктивности.

Тем не менее так много возможных промежуточные точки сбоя, существует увеличить вероятность сбоя. При возникновении ошибки может быть трудно понять, где в процессе произошла ошибка. В следующих разделах представлены некоторые из ошибок, которые могут возникнуть при использовании методов **записи** и предлагать возможные решения.

## <a name="common-error-codes-for-write-methods-of-the-fileio-and-pathio-classes"></a>Распространенные коды ошибок для методов записи классов файловый ввод-вывод и PathIO

В этой таблице представлены распространенные коды ошибки, возникающие разработчики приложений при использовании методов **записи** . Действия, описанные в таблице соответствуют действия на предыдущей схеме.

|  Имя ошибки (value)  |  Действия  |  Причины  |  Решения  |
|----------------------|---------|----------|-------------|
|  ERROR_ACCESS_DENIED (0X80070005)  |  5  |  Исходный файл может быть помечено для удаления, возможно, из предыдущей операции.  |  Повторите попытку.</br>Убедитесь, синхронизировать доступ к файлу.  |
|  ERROR_SHARING_VIOLATION (0X80070020)  |  5  |  Исходный файл открывается другой монопольный записи.   |  Повторите попытку.</br>Убедитесь, синхронизировать доступ к файлу.  |
|  ERROR_UNABLE_TO_REMOVE_REPLACED (0X80070497)  |  19 – 20  |  Исходный файл (file.txt) не может быть заменен, так как он используется. Другого процесса или операции получивший доступ к файлу, прежде чем его можно заменить.  |  Повторите попытку.</br>Убедитесь, синхронизировать доступ к файлу.  |
|  ERROR_DISK_FULL (0X80070070)  |  7, 14, 16, 20  |  Модель транзакций создает дополнительный файл, и это занимает дополнительное хранилище.  |    |
|  ERROR_OUTOFMEMORY (0X8007000E)  |  14, 16  |  Это может произойти из-за несколько невыполненные операции ввода-вывода или размеры больших файлов.  |  Более тщательный подход, контролируя поток для устранения ошибки.  |
|  E_FAIL (0X80004005.) |  Любой  |  Прочее  |  Повторите попытку. Если он по-прежнему не удается, может быть ошибку платформа и приложение завершит, так как это целостность. |

## <a name="other-considerations-for-file-states-that-might-lead-to-errors"></a>Другие рекомендации для состояния файлов, которые могут привести к ошибкам

Помимо ошибки, возвращаемый методами **записи** Вот некоторые моменты на то, что приложение может ожидать, что при записи в файл.

### <a name="data-was-written-to-the-file-if-and-only-if-operation-completed"></a>Данные были записаны в файл только в том случае, если операция завершена

Ваше приложение должно не никаких предположений о данных в файле во время операции записи. Получить доступ к файлу до завершения операции может привести к непредсказуемому данных. Ваше приложение должно быть ответственность отслеживания невыполненные операции ввода-вывода.

### <a name="readers"></a>Средства чтения с

Если файл, который записывается также используется средство чтения вежливы (то есть открыт с [**FileAccessMode.Read**](https://docs.microsoft.com/uwp/api/Windows.Storage.FileAccessMode), последующие операции чтения приведет к сбою с ошибку ERROR_OPLOCK_HANDLE_CLOSED (0x80070323). Иногда приложения повторить попытку открыть файл для чтения во время операции **записи** . Это может привести к гонки, на котором **записи** в конечном счете происходит сбой при попытке перезаписать исходный файл, так как он не может быть заменен.

### <a name="files-from-knownfolders"></a>Файлы из KnownFolders

Ваше приложение не может быть только приложения, которое пытается получить доступ к файлу, расположенный на какие-либо из [**KnownFolders**](https://docs.microsoft.com/uwp/api/Windows.Storage.KnownFolders). Нет никакой гарантии, что если операция выполнена успешно, содержимое, которое приложение написал к файлу будет оставаться констант следующий раз, когда он пытается выполнить чтение файла. Кроме того общий доступ к или отказе ошибки становится более популярным в этом сценарии.

### <a name="conflicting-io"></a>Конфликтующие ввода-вывода

Если наше приложение использует методы **записи** для файлов в локальные данные, но по-прежнему требуется осторожно может снижено вероятность параллельная обработка ошибок. Если нескольких операций **записи** отправляются одновременно в файл, нет никакой гарантии, о том, какие данные может оказаться в файле. Чтобы решить эту проблему, мы рекомендуем, что ваше приложение сериализует операции **записи** в файл.

### <a name="tmp-files"></a>~ Файлы TMP

Время от времени Если операция отменяется принудительно (например, если приложение было была приостановлена или прекращена в операционной системе), не фиксации или закрытия соответствующим образом. Это может терять файлов (. ~ TMP) расширения. Удалите эти временные файлы (если они существуют в локальные данные приложения) при обработке активации приложения.

## <a name="considerations-based-on-file-types"></a>Вопросы, в зависимости от типов файлов

Некоторые ошибки можно получить более широкое распространение в зависимости от типа файлов, частоту, на котором они доступны и их размера. Как правило существует три категории файлов, которые вашему приложению.

* Создавать и редактировать пользователем в папке Локальные данные приложения файлы. Они создаются и изменять только при работе в вашем приложении, и они существуют только в приложении.
* Метаданные приложения. Ваше приложение использует эти файлы, чтобы отслеживать собственное состояние.
* Другие файлы в расположение которых приложение объявило возможностей для доступа к файловой системе. Чаще всего они находятся в одном из [**KnownFolders**](https://docs.microsoft.com/uwp/api/Windows.Storage.KnownFolders).

Ваше приложение имеет полный доступ в первых двух категорий файлов, поскольку они являются компонентом файлы пакета приложения и осуществляется только вашим приложением. Для файлов в последней категории ваше приложение должно находиться в виду, что другие приложения и службы операционной системы может обращаться к файлам одновременно.

Приложение доступ к файлам, зависит от частоты:

* Очень низкой. Обычно это файлы, открытые сохраненные при запусков приложения и их, когда приложение приостановлено.
* Низкий. Это файлы, которые пользователь выполняет специально много то или иное действие (например, сохранения и загрузки).
* Средний или высокий. Это файлы, в которых приложение постоянно необходимо обновить данные (например, функции сохранять или констант метаданных отслеживания).

Размер файла рассмотрите возможность данные о производительности на следующей диаграмме для метода **WriteBytesAsync** . В этой таблице сравниваются время размер файла и операции, через средние данные производительности 10000 операций на размер файла в контролируемом окружении.

![WriteBytesAsync производительности](images/writebytesasync-performance.png)

Значения времени на оси y пропускаются на этой диаграмме намеренно, поскольку различного оборудования и конфигурации дают разные абсолютные значения времени. Тем не менее мы постоянно наблюдался эти тенденции согласно проведенным тестам:

* Для небольших файлов (< = 1 МБ): время для завершения операций согласованно быстро.
* Для больших файлов (> 1 МБ): время для завершения операций начала для увеличения экспоненциально.

## <a name="io-during-app-suspension"></a>Операций ввода-вывода во время приостановки приложения

Ваше приложение должно быть создано на обработка приостановки работы, если вы хотите хранить сведения о состоянии или метаданных для использования в более поздних сеансах. Общие сведения о приостановки приложения см. в разделе [жизненный цикл приложения](../launch-resume/app-lifecycle.md) и [в этой записи блога](https://blogs.windows.com/buildingapps/2016/04/28/the-lifecycle-of-a-uwp-app/#qLwdmV5zfkAPMEco.97).

Если операционная система не расширенный сеанс выполнения для вашего приложения, когда оно будет приостановлено имеет 5 секунд, чтобы освободить все ресурсы и сохранить свои данные. Для наиболее надежности и пользователя возникают, всегда предполагается, что время, необходимое для обработки заданий приостановки ограничено. Учитывайте следующие рекомендации при 5 второй период времени для обработки приостановки задачи:

* Попробуйте свести к минимуму во избежание гонки, вызванный останавливается и выпуска операций ввода-вывода.
* Избегайте записи файлов, которые требуют сотни и более написать миллисекунд.
* Если ваше приложение использует методы **Write** , имейте в виду промежуточного действия, которые требуют этих методов.

Если ваше приложение работает с небольшого количества данные о состоянии во время приостановки, в большинстве случаев можно использовать методы **записи** для очистки данных. Тем не менее если ваше приложение использует большой объем данных о состоянии, рассмотрите возможность использования потоков непосредственно храниться ваши данные. Это помогает сократить задержку принадлежат транзакций модели из способов **записи** . 

Например см. образец [BasicSuspension](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/BasicSuspension) .

## <a name="other-examples-and-resources"></a>Другие примеры и ресурсы

Вот несколько примеров и другие ресурсы для конкретных сценариев.

### <a name="code-example-for-retrying-file-io-example"></a>Пример кода для повторной примере файловый ввод-вывод

Ниже приводится пример псевдокода о том, как повторить попытку записи (C#), при условии, что запись, которую требуется выполнить после пользователь выбирает файл для сохранения:

```csharp
Windows.Storage.Pickers.FileSavePicker savePicker = new Windows.Storage.Pickers.FileSavePicker();
savePicker.FileTypeChoices.Add("Plain Text", new List<string>() { ".txt" });
Windows.Storage.StorageFile file = await savePicker.PickSaveFileAsync();

Int32 retryAttempts = 5;

const Int32 ERROR_ACCESS_DENIED = unchecked((Int32)0x80070005);
const Int32 ERROR_SHARING_VIOLATION = unchecked((Int32)0x80070020);

if (file != null)
{
    // Application now has read/write access to the picked file.
    while (retryAttempts > 0)
    {
        try
        {
            retryAttempts--;
            await Windows.Storage.FileIO.WriteTextAsync(file, "Text to write to file");
            break;
        }
        catch (Exception ex) when ((ex.HResult == ERROR_ACCESS_DENIED) ||
                                   (ex.HResult == ERROR_SHARING_VIOLATION))
        {
            // This might be recovered by retrying, otherwise let the exception be raised.
            // The app can decide to wait before retrying.
        }
    }
}
else
{
    // The operation was cancelled in the picker dialog.
}
```

### <a name="synchronize-access-to-the-file"></a>Синхронизировать доступ к файлу

[Параллельного программирования с .NET блога](https://blogs.msdn.microsoft.com/pfxteam/) — это отличный ресурс рекомендации по параллельного программирования. В частности, [блога о AsyncReaderWriterLock](https://blogs.msdn.microsoft.com/pfxteam/2012/02/12/building-async-coordination-primitives-part-7-asyncreaderwriterlock/) описывается, как поддерживать монопольный доступ к файлу для записи разрешая параллельный доступ для чтения. Имейте в виду, сериализации, которые влияют на ввод-вывод производительности.

## <a name="see-also"></a>См. также

* [Создание, запись и чтение файла](quickstart-reading-and-writing-files.md)
