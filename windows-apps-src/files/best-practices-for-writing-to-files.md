---
title: Рекомендации по записи в файлы
description: Ознакомьтесь с рекомендациями по использованию различных файлов, написание методов классов файловый ввод-вывод и PathIO.
ms.date: 02/06/2019
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: f8bed97e060015f92ff95c9f7d797bbcb83db431
ms.sourcegitcommit: b034650b684a767274d5d88746faeea373c8e34f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2019
ms.locfileid: "57605839"
---
# <a name="best-practices-for-writing-to-files"></a>Рекомендации по записи в файлы

**Важные API**

* [**Класс файловый ввод-вывод**](https://docs.microsoft.com/uwp/api/Windows.Storage.FileIO)
* [**Класс PathIO**](https://docs.microsoft.com/uwp/api/windows.storage.pathio)

Разработчики, возникать ряд распространенных проблем при использовании **записи** методы [ **FileIO** ](https://docs.microsoft.com/uwp/api/Windows.Storage.FileIO) и [ **PathIO** ](https://docs.microsoft.com/uwp/api/windows.storage.pathio) классы для выполнения операций файловой системы ввода-вывода. Например распространенных проблем включают:

• Приложение получает исключение при вызове одного из методов частично записываются • файл. • Оставляет операций. TMP-файлы с именем файла, аналогичную имя конечного файла.

**Записи** методы [ **FileIO** ](https://docs.microsoft.com/uwp/api/Windows.Storage.FileIO) и [ **PathIO** ](https://docs.microsoft.com/uwp/api/windows.storage.pathio) классам относятся следующие:

* **WriteBufferAsync**
* **WriteBytesAsync**
* **WriteLinesAsync**
* **WriteTextAsync**

 Эта статья содержит сведения о том, как эти методы работают, поэтому разработчики лучше понять, когда и как их использовать. В этой статье представлены рекомендации и не пытается предоставить решение для всех возможных файл ввода-вывода проблем. 

> [!NOTE]
> Эта статья посвящена **FileIO** методы в примерах и обсуждения. Тем не менее **PathIO** методы следуют схеме, и большинство рекомендаций и инструкций в этой статье также применяется к этим методам. 

## <a name="conveience-vs-control"></a>Conveience и управления

Объект [ **StorageFile** ](https://docs.microsoft.com/uwp/api/windows.storage.storagefile) объект не является дескриптор файла, как и собственная модель программирования Win32. Вместо этого [ **StorageFile** ](https://docs.microsoft.com/uwp/api/windows.storage.storagefile) является представлением файла с помощью методов для управления содержимым.

Основные сведения об этой концепции полезна при выполнении операций ввода-вывода с **StorageFile**. Например [записи в файл](quickstart-reading-and-writing-files.md#writing-to-a-file) разделе представлены три способа записи в файл:

* С помощью [ **FileIO.WriteTextAsync** ](https://docs.microsoft.com/uwp/api/windows.storage.fileio.writetextasync) метод.
* Путем создания буфер и затем вызова [ **FileIO.WriteBufferAsync** ](https://docs.microsoft.com/en-us/uwp/api/windows.storage.fileio.writebufferasync) метод.
* Модель четыре шага, с помощью потока:
  1. [Откройте](https://docs.microsoft.com/uwp/api/windows.storage.storagefile.openasync) файл для получения потока.
  2. [Получить](https://docs.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.getoutputstreamat) поток вывода.
  3. Создание [ **DataWriter** ](https://docs.microsoft.com/uwp/api/windows.storage.streams.datawriter) объекта и вызовите соответствующий **записи** метод.
  4. [Зафиксировать](https://docs.microsoft.com/uwp/api/windows.storage.streams.datawriter.storeasync) данные в модуль записи данных и [flush](https://docs.microsoft.com/uwp/api/windows.storage.streams.ioutputstream.flushasync) в выходной поток.

Первые два сценария, они чаще всего используется в приложениях. Запись в файл, в рамках одной операции проще и поддержка кода, и приложение отвечает за удаляются из освободили многие сложности файлового ввода-вывода. Тем не менее Данное преимущество имеет свою цену: потери контроля над всей операции и возможность обнаружения ошибок, возникающих в определенные моменты.

## <a name="the-transactional-model"></a>Модели транзакций

**Записи** методы [ **FileIO** ](https://docs.microsoft.com/uwp/api/Windows.Storage.FileIO) и [ **PathIO** ](https://docs.microsoft.com/uwp/api/windows.storage.pathio) классы заключают в себе приведенные на третьей записи модель, описанную выше, с дополнительным уровнем. Этот уровень инкапсулирован в транзакции хранилища.

Для защиты целостности исходного файла, в случае, если что-то пойдет не так при записи данных, **записи** методы используют модель транзакций, открыв файл с помощью [ **OpenTransactedWriteAsync** ](https://docs.microsoft.com/uwp/api/windows.storage.storagefile.opentransactedwriteasync). Этот процесс создает [ **StorageStreamTransaction** ](https://docs.microsoft.com/uwp/api/windows.storage.storagestreamtransaction) объекта. После создания этот объект транзакции, API-интерфейсы записи данных после аналогично [доступ к файлам](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/FileAccess) выборки или в примере кода в [ **StorageStreamTransaction** ](https://docs.microsoft.com/uwp/api/windows.storage.storagestreamtransaction) статьи.

На следующей схеме показаны базовые задачи, выполняемые **WriteTextAsync** метод в операции успешной записи. На этом рисунке показано упрощенное представление операции. Например она пропускает действия, такие как кодирование и async завершение текста на различных потоках.

![Диаграмма последовательности вызовов API универсальной платформы Windows для записи в файл](images/file-write-call-sequence.svg)

Преимущества использования **записи** методы [ **FileIO** ](https://docs.microsoft.com/uwp/api/Windows.Storage.FileIO) и [ **PathIO** ](https://docs.microsoft.com/uwp/api/windows.storage.pathio) вместо него классы более сложная модель четыре шага, с помощью потока являются:

* Один вызов API для обработки всех промежуточных шагов, включая ошибки.
* Исходный файл остается в том случае, если что-то пойдет не так.
* Состояние системы будет пытаться хранить максимально чиста.

Однако так много возможных промежуточные точки сбоя, есть шанс сбоя. При возникновении ошибки может быть сложно понять, где процессу не удалось. В следующих разделах представлены некоторые сбои могут возникнуть при использовании **записи** методов и могут оказаться полезными.

## <a name="common-error-codes-for-write-methods-of-the-fileio-and-pathio-classes"></a>Распространенные коды ошибок для записи методы классов файловый ввод-вывод и PathIO

В этой таблице представлены распространенные коды ошибок, которые разработчики приложений могут возникнуть при использовании **записи** методы. Действия, описанные в таблице соответствуют действия, описанные в предыдущей диаграмме.

|  Имя ошибки (значение)  |  Действия  |  Причины  |  Решения  |
|----------------------|---------|----------|-------------|
|  ERROR_ACCESS_DENIED (0X80070005)  |  5  |  Исходный файл может быть помечено для удаления, возможно, из предыдущей операции.  |  Попробуйте повторить операцию.</br>Обеспечить синхронизацию доступа к файлу.  |
|  ERROR_SHARING_VIOLATION (0X80070020)  |  5  |  Исходный файл открыт в другой Монопольная запись.   |  Попробуйте повторить операцию.</br>Обеспечить синхронизацию доступа к файлу.  |
|  ERROR_UNABLE_TO_REMOVE_REPLACED (0X80070497)  |  19 – 20  |  Исходный файл (file.txt) не может быть заменен, так как он используется. Другой процесс или операция запрошенные доступ к файлу, прежде чем он может быть заменен.  |  Попробуйте повторить операцию.</br>Обеспечить синхронизацию доступа к файлу.  |
|  ERROR_DISK_FULL (0X80070070)  |  7, 14, 16, 20  |  Транзакционные модель создает дополнительный файл, и это требует дополнительного места на диске.  |    |
|  ERROR_OUTOFMEMORY (0X8007000E)  |  14, 16  |  Это может произойти из-за нескольких незавершенных операций ввода-вывода или файлы больших размеров.  |  Более детальный подход, контролируя поток может устранить эту ошибку.  |
|  E_FAIL (0X80004005) |  Любой  |  Прочее  |  Попробуйте повторить операцию. Если проблема не исчезла, возможно, ошибка платформы, и приложение должно быть прекращено, так как он находится в несогласованном состоянии. |

## <a name="other-considerations-for-file-states-that-might-lead-to-errors"></a>Дополнительные рекомендации для состояния файлов, которые могут привести к ошибкам

Помимо ошибок, возвращаемых **записи** методы, ниже приведены некоторые рекомендации, на что приложения могут ожидать при записи в файл.

### <a name="data-was-written-to-the-file-if-and-only-if-operation-completed"></a>Данные были записаны в файл только в том случае, если операция завершена

Приложения не следует вносить любые предположения о данных в файле, операции записи во время выполнения. При доступе к файлу до завершения операции может привести к несогласованности данных. Ваше приложение будет отвечать отслеживания необработанных операций ввода-вывода.

### <a name="readers"></a>Устройства чтения

Если файл, который выполняется запись в также используется средством чтения мягкое (то есть, открытом с [ **FileAccessMode.Read**](https://docs.microsoft.com/uwp/api/Windows.Storage.FileAccessMode), последующие операции чтения будут завершаться ошибкой ERROR_OPLOCK_HANDLE_CLOSED (0x80070323). Иногда приложения повторите при открытии файла для чтения снова при **записи** операция. Это может привести к условие конкуренции, на котором **записи** в итоге происходит сбой при попытке перезаписать исходный файл, так как он не может быть заменен.

### <a name="files-from-knownfolders"></a>Файлы из KnownFolders

Приложение может быть только приложение, которое пытается получить доступ к файлу, расположенному на любой из [ **KnownFolders**](https://docs.microsoft.com/uwp/api/Windows.Storage.KnownFolders). Нет никакой гарантии, что если операция выполнена успешно, содержимое, которое приложение выполнена запись в файл остается постоянным следующий раз, он пытается прочитать файл. Кроме того совместного использования или отказе ошибок, которые стали более распространенными в этом сценарии.

### <a name="conflicting-io"></a>Конфликтующие ввода-вывода

Вероятность ошибок параллелизма может снизиться, если использует наше приложение **записи** методы для файлов в свои локальные данные, но осторожно по-прежнему требуется. При наличии нескольких **записи** операции отправляются параллельно в файл, нет никакой гарантии, о заканчивается какие данные в файле. Чтобы избежать этого, мы рекомендуем, что ваше приложение сериализует **записи** операции в файл.

### <a name="tmp-files"></a>~ TMP-файлы

Время от времени Если операция отменяется, принудительно (например, если приложение было приостановлено или прервано операционной системы), транзакция не зафиксирована или закрытия соответствующим образом. Это можно оставить за файлов с помощью (. ~ TMP) расширение. Рассмотрите возможность удаления эти временные файлы (если они существуют в локальные данные приложения) при обработке активации приложения.

## <a name="considerations-based-on-file-types"></a>Вопросы, на основе типов файлов

Некоторые ошибки можно получить более широкое распространение, в зависимости от типа файлов, частоты, на котором они доступны и их размера. Как правило делятся на три категории файлов, которые приложение может обращаться к:

* Файлы создан и изменен пользователем в папке локальных данных вашего приложения. Они создаются и изменяются только при использовании вашего приложения и существуют только в приложении.
* Метаданные приложения. Приложение использует эти файлы для отслеживания собственное состояние.
* Другие файлы в расположения файловой системы, где приложение объявило возможности получить доступ к. Чаще всего они находятся в одном из [ **KnownFolders**](https://docs.microsoft.com/uwp/api/Windows.Storage.KnownFolders).

Приложение имеет полный доступ на первых двух категорий файлов, так как они являются частью файлы пакета приложения и осуществляется исключительно с вашего приложения. Для файлов в последняя категория приложения необходимо иметь в виду, что другим приложениям и службам ОС может обращаться к файлам одновременно.

В зависимости от приложения доступ к файлам могут различаться на интервале.

* Очень низкий. Обычно это файлы, открытые после при запусков приложений и являются сохранения при приостановке действия приложения.
* Низкий. Это файлы, которые пользователь специально выполняет действия от (такие как сохранение и загрузка).
* Средний или высокий. Это файлы, в которых приложения постоянно необходимо обновить данные (например, автосохранения функций или констант метаданных отслеживания).

Для размера файла, с учетом данных производительности на следующей диаграмме для **WriteBytesAsync** метод. На этой диаграмме сравниваются длительность размер файла vs операции над средней производительностью 10 000 операций на размер файла в управляемой среде.

![WriteBytesAsync производительности](images/writebytesasync-performance.png)

Значения времени на оси y исключены из этой диаграммы намеренно, так как другое оборудование и конфигурации даст разных абсолютных значений времени. Тем не менее мы постоянно рассмотрели эти тенденции в наших тестах:

* Для небольших файлов (< = 1 МБ): Время для завершения операций является постоянно высокую скорость.
* Для более крупных файлов (> 1 МБ): Время для завершения операций начинает увеличиваться экспоненциально.

## <a name="io-during-app-suspension"></a>Операций ввода-вывода во время приостановки приложения

Приложения должны предназначены для обработки приостановки, если вы хотите сохранить сведения о состоянии или метаданных для использования в последующих сеансов. Справочные сведения о Приостановка приложения, см. в разделе [жизненный цикл приложения](../launch-resume/app-lifecycle.md) и [этой записи блога](https://blogs.windows.com/buildingapps/2016/04/28/the-lifecycle-of-a-uwp-app/#qLwdmV5zfkAPMEco.97).

Если операционная система предоставляет расширенного выполнения в приложение при приостановке приложения имеет 5 секунд, чтобы освободить все ресурсы и сохранить свои данные. Надежность и пользователя столкнуться, всегда думаете, что время, необходимо обрабатывать приостановки задачи ограничено. Учитывайте следующие рекомендации во время 5-секундный интервал времени для обработки задач приостановки.

* Попытайтесь свести к минимуму во избежание конкуренции, из-за операции очистки и освобождения ввода-вывода.
* Избегайте написания файлов, которые требуются сотен миллисекунд или несколько для записи.
* Если приложение использует **записи** методы, имейте в виду все промежуточные шаги, эти методы требуют.

Если приложение работает на небольшой объем данных о состоянии во время приостановки выполнения, в большинстве случаев можно использовать **записи** методы очистки данных. Тем не менее если приложение использует большой объем данных о состоянии, рассмотрите возможность использования потоков для непосредственно хранения данных. Это может помочь снизить задержки, связанные с моделью транзакций **записи** методы. 

Например, см. в разделе [BasicSuspension](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/BasicSuspension) образца.

## <a name="other-examples-and-resources"></a>Другие примеры и ресурсы

Ниже приведены несколько примеров и другие ресурсы для конкретных сценариев.

### <a name="code-example-for-retrying-file-io-example"></a>Пример кода для повтора пример файлового ввода-вывода

Ниже приведен пример псевдокода по повтору записи (C#), при условии, что записи, которую требуется выполнить после пользователь выбирает файл для сохранения:

```csharp
Windows.Storage.Pickers.FileSavePicker savePicker = new Windows.Storage.Pickers.FileSavePicker();
savePicker.FileTypeChoices.Add("Plain Text", new List<string>() { ".txt" });
Windows.Storage.StorageFile file = await savePicker.PickSaveFileAsync();

Int32 retryAttempts = 5;

const Int32 ERROR_ACCESS_DENIED = unchecked((Int32)0x80070005);
const Int32 ERROR_SHARING_VIOLATION = unchecked((Int32)0x80070020);

if (file != null)
{
    // Application now has read/write access to the picked file.
    while (retryAttempts > 0)
    {
        try
        {
            retryAttempts--;
            await Windows.Storage.FileIO.WriteTextAsync(file, "Text to write to file");
            break;
        }
        catch (Exception ex) when ((ex.HResult == ERROR_ACCESS_DENIED) ||
                                   (ex.HResult == ERROR_SHARING_VIOLATION))
        {
            // This might be recovered by retrying, otherwise let the exception be raised.
            // The app can decide to wait before retrying.
        }
    }
}
else
{
    // The operation was cancelled in the picker dialog.
}
```

### <a name="synchronize-access-to-the-file"></a>Синхронизировать доступ к файлу

[Параллельному программированию в блоге .NET](https://blogs.msdn.microsoft.com/pfxteam/) является превосходным ресурсом для рекомендации, касающиеся параллельного программирования. В частности [блога о AsyncReaderWriterLock](https://blogs.msdn.microsoft.com/pfxteam/2012/02/12/building-async-coordination-primitives-part-7-asyncreaderwriterlock/) описывается Ведение монопольный доступ к файлу для записи, предоставляя параллельный доступ для чтения. Следует помнить, что при сериализации, операций ввода-вывода будет влиять на производительность.

## <a name="see-also"></a>См. также

* [Создание, запись и чтение файла](quickstart-reading-and-writing-files.md)
