---
title: Рекомендации по записи в файлы
description: Ознакомьтесь с рекомендациями по использованию различных методов записи в файлы, доступных в классах FileIO и PathIO.
ms.date: 02/06/2019
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: dcbeffc7e3db8f3df9c197e8c388f30faf7ad03d
ms.sourcegitcommit: 26bb75084b9d2d2b4a76d4aa131066e8da716679
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2020
ms.locfileid: "75685239"
---
# <a name="best-practices-for-writing-to-files"></a>Рекомендации по записи в файлы

**Важные API**

* [**Класс FileIO**](https://docs.microsoft.com/uwp/api/Windows.Storage.FileIO)
* [**Класс PathIO**](https://docs.microsoft.com/uwp/api/windows.storage.pathio)

Иногда разработчики сталкиваются с рядом распространенных проблем, когда используют методы **Write** классов [**FileIO**](https://docs.microsoft.com/uwp/api/Windows.Storage.FileIO) и [**PathIO**](https://docs.microsoft.com/uwp/api/windows.storage.pathio) для выполнения операций ввода-вывода с файловой системой. Например, распространены следующие проблемы.

* Файл записан частично.
* Приложение получает исключение при вызове одного из методов.
* После выполнения операций остаются TMP-файлы с именем, аналогичным имени конечного файла.

К методам **Write** классов [**FileIO**](https://docs.microsoft.com/uwp/api/Windows.Storage.FileIO) и [**PathIO**](https://docs.microsoft.com/uwp/api/windows.storage.pathio) относятся следующие:

* **WriteBufferAsync**
* **WriteBytesAsync**
* **WriteLinesAsync**
* **WriteTextAsync**

 В этой статье описывается, как работают эти методы, чтобы разработчикам было понятнее, когда и как их использовать. В статье представлены рекомендации. Она не является решением для всех возможных проблем с файловым вводом-выводом. 

> [!NOTE]
> В этой статье рассматриваются методы **FileIO**, для которых приводятся примеры. Тем не менее, методы **PathIO** следуют аналогичной схеме, и большинство рекомендаций и инструкций в этой статье также применимы к ним. 

## <a name="convenience-vs-control"></a>Удобство и управление

Объект [**StorageFile**](https://docs.microsoft.com/uwp/api/windows.storage.storagefile) не является дескриптором файла, как в собственной модели программирования Win32. Вместо этого [**StorageFile**](https://docs.microsoft.com/uwp/api/windows.storage.storagefile) является представлением файла с методами для управления его содержимым.

Понимание этой концепции пригодится при выполнении операций ввода-вывода с **StorageFile**. Например, в разделе [Запись в файл](quickstart-reading-and-writing-files.md#writing-to-a-file) представлены три способа записи в файл:

* с помощью метода [**FileIO.WriteTextAsync**](https://docs.microsoft.com/uwp/api/windows.storage.fileio.writetextasync);
* путем создания буфера и последующего вызова метода [**FileIO.WriteBufferAsync**](https://docs.microsoft.com/uwp/api/windows.storage.fileio.writebufferasync);
* посредством модели из четырех шагов с помощью потока:
  1. [открытие](https://docs.microsoft.com/uwp/api/windows.storage.storagefile.openasync) файла для получения потока;
  2. [получение](https://docs.microsoft.com/uwp/api/windows.storage.streams.irandomaccessstream.getoutputstreamat) потока вывода;
  3. создание объекта [**DataWriter**](https://docs.microsoft.com/uwp/api/windows.storage.streams.datawriter) и вызов соответствующего метода **Write**;
  4. [фиксация](https://docs.microsoft.com/uwp/api/windows.storage.streams.datawriter.storeasync) данных в модуле записи данных и [запись на диск](https://docs.microsoft.com/uwp/api/windows.storage.streams.ioutputstream.flushasync) выходного потока.

Первые два сценария чаще всего используются в приложениях. Запись в файл одной операцией проще программировать и поддерживать. Кроме того, это снимает с приложения ответственность за множество сложностей файлового ввода-вывода. Тем не менее это удобство имеет свою цену: потеря контроля над всей операцией и возможности обнаруживать ошибки в определенных точках.

## <a name="the-transactional-model"></a>Транзакционная модель

Методы **Write** классов [**FileIO**](https://docs.microsoft.com/uwp/api/Windows.Storage.FileIO) и [**PathIO**](https://docs.microsoft.com/uwp/api/windows.storage.pathio) охватывают шаги третьей модели записи, описанной выше, с добавлением уровня. Этот уровень инкапсулирован в транзакции хранилища.

Чтобы защитить целостность исходного файла в случае сбоя при записи данных, методы **Write** используют транзакционную модель, открывая файл с помощью метода [**OpenTransactedWriteAsync**](https://docs.microsoft.com/uwp/api/windows.storage.storagefile.opentransactedwriteasync). В этом процессе создается объект [**StorageStreamTransaction**](https://docs.microsoft.com/uwp/api/windows.storage.storagestreamtransaction). После создания этого объекта транзакции интерфейсы API записывают данные, как это реализовано в примере [доступа к файлам](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/FileAccess) или в примере кода в статье [**StorageStreamTransaction**](https://docs.microsoft.com/uwp/api/windows.storage.storagestreamtransaction).

На следующей схеме показаны базовые задачи, выполняемые методом **WriteTextAsync** в успешной операции записи. На этом рисунке показано упрощенное представление операции. Например, на нем пропущены такие действия, как кодирование и асинхронное завершение разных потоков.

![Схема последовательности вызовов API UWP для записи в файл](images/file-write-call-sequence.svg)

Преимущества использования методов **Write** классов [**FileIO**](https://docs.microsoft.com/uwp/api/Windows.Storage.FileIO) и [**PathIO**](https://docs.microsoft.com/uwp/api/windows.storage.pathio) вместо более сложной модели из четырех шагов с использованием потока следующие:

* Один вызов API для обработки всех промежуточных шагов, включая ошибки.
* В случае сбоя исходный файл сохраняется.
* Состояние системы сохраняется как можно более чистым.

Однако ввиду множества возможных промежуточных точек сбоя существует повышенная вероятность ошибки. При возникновении ошибки может быть сложно понять, где произошел сбой процесса. В следующих разделах рассматриваются некоторые сбои, которые могут возникнуть при использовании методов **Write**, и предлагаются возможные решения.

## <a name="common-error-codes-for-write-methods-of-the-fileio-and-pathio-classes"></a>Распространенные коды ошибок при использовании методов Write классов FileIO и PathIO

В этой таблице представлены распространенные коды ошибок, с которыми разработчики приложений могут столкнуться при использовании методов **Write**. Шаги, описанные в таблице, соответствуют шагам на предыдущей схеме.

|  Имя ошибки (значение)  |  Действия  |  Причины  |  Решения  |
|----------------------|---------|----------|-------------|
|  ERROR_ACCESS_DENIED (0X80070005)  |  5  |  Возможно, исходный файл помечен для удаления предыдущей операцией.  |  Попробуйте повторить операцию.</br>Обеспечьте синхронизацию доступа к файлу.  |
|  ERROR_SHARING_VIOLATION (0x80070020)  |  5  |  Исходный файл открыт другим сеансом монопольной записи.   |  Попробуйте повторить операцию.</br>Обеспечьте синхронизацию доступа к файлу.  |
|  ERROR_UNABLE_TO_REMOVE_REPLACED (0x80070497)  |  19–20  |  Исходный файл (file.txt) не может быть заменен, так как он используется. Другой процесс или операция получила доступ к файлу, прежде чем его удалось заменить.  |  Попробуйте повторить операцию.</br>Обеспечьте синхронизацию доступа к файлу.  |
|  ERROR_DISK_FULL (0x80070070)  |  7, 14, 16, 20  |  Транзакционная модель создает дополнительный файл, и это требует дополнительного места на диске.  |    |
|  ERROR_OUTOFMEMORY (0x8007000E)  |  14, 16  |  Это может произойти из-за нескольких незавершенных операций ввода-вывода или большого размера файлов.  |  Более детальный подход с контролем потока может устранить эту ошибку.  |
|  E_FAIL (0x80004005) |  Любые  |  Прочее  |  Попробуйте повторить операцию. Если проблема не исчезла, возможно, это ошибка платформы, и приложение должно быть завершено, так как оно находится в несогласованном состоянии. |

## <a name="other-considerations-for-file-states-that-might-lead-to-errors"></a>Дополнительные рекомендации по состояниям файлов, которые могут привести к ошибкам

Помимо ошибок, возвращаемых методами **Write**, ознакомьтесь с некоторыми рекомендациями по реагированию приложения на запись в файл.

### <a name="data-was-written-to-the-file-if-and-only-if-operation-completed"></a>Данные записываются в файл только в том случае, если операция завершена

Приложение не должно делать какие-либо предположения о данных в файле, пока выполняется операция записи. Попытка обращения к файлу до завершения операции может привести к несогласованности данных. Ваше приложение должно отвечать за отслеживание незавершенных операций ввода-вывода.

### <a name="readers"></a>Устройства чтения

Если файл, в который выполняется запись, также используется "мягким" средством чтения (то есть открыт с помощью [**FileAccessMode.Read**](https://docs.microsoft.com/uwp/api/Windows.Storage.FileAccessMode)), то последующие операции чтения будут завершаться ошибкой ERROR_OPLOCK_HANDLE_CLOSED (0x80070323). Иногда приложения пытаются повторно открыть файл для чтения, пока выполняется операция **Write**. Это может привести к состязанию за доступ, и операция **Write** в итоге завершится сбоем, пытаясь перезаписать исходный файл, так как он не сможет быть заменен.

### <a name="files-from-knownfolders"></a>Файлы из KnownFolders

Ваше приложение может быть не единственным приложением, которое пытается получить доступ к файлу, расположенному в любой из папок [**KnownFolders**](https://docs.microsoft.com/uwp/api/Windows.Storage.KnownFolders). Нет никакой гарантии, что после успешного выполнения операции содержимое, которое приложение записало в файл, останется без изменений при следующей попытке считать этот файл. Кроме того, в этом сценарии распространены ошибки совместного использования и отказа в доступе.

### <a name="conflicting-io"></a>Конфликты при операциях ввода-вывода

Вероятность ошибок параллельной обработки можно снизить, если ваше приложение использует методы **Write** для файлов в своих локальных данных, но по-прежнему следует проявлять осторожность. Если одновременно отправляется несколько операций **Write** с файлом, нет никакой гарантии того, какие данные в итоге окажутся в этом файле. Чтобы избежать этого, мы рекомендуем, чтобы ваше приложение сериализовало операции **Write** с файлом.

### <a name="tmp-files"></a>~TMP-файлы

Иногда, если операция принудительно отменяется (например, когда приложение приостановлено или завершено операционной системой), транзакция не фиксируется или не закрывается соответствующим образом. После этого могут остаться файлы с расширением ~TMP. Рассмотрите возможность удаления этих временных файлов (если они существуют в локальных данных приложения) при обработке активации приложения.

## <a name="considerations-based-on-file-types"></a>Рекомендации по типам файлов

Некоторые ошибки могут преобладать в зависимости от типа файлов, частоты обращения к ним и их размера. Как правило, приложению доступны три категории файлов:

* Файлы, созданные и измененные пользователем в папке локальных данных вашего приложения. Они создаются и изменяются только при использовании вашего приложения и существуют только в нем.
* Метаданные приложения. Ваше приложение использует эти файлы для отслеживания собственного состояния.
* Другие файлы в расположениях файловой системы, для которых ваше приложение объявило возможность доступа. Чаще всего они находятся в одной из папок [**KnownFolders**](https://docs.microsoft.com/uwp/api/Windows.Storage.KnownFolders).

Ваше приложение имеет полный контроль над первыми двумя категориями файлов, так как они являются частью файлов пакета приложения и используются исключительно вашим приложением. Что касается файлов из последней категории, ваше приложение должно читывать, что к ним могут одновременно обращаться другие приложения и службы ОС.

В зависимости от приложения, частота обращения к файлам может быть разной:

* Очень низкая. Обычно это файлы, открываемые сразу после запуска приложения и сохраняемые при приостановке работы приложения.
* Низкая. Это файлы, с которыми пользователь специально выполняет действия (такие как сохранение или загрузка).
* Средняя или высокая. Это файлы, в которых приложению требуется постоянно обновлять данные (например, для автосохранения или постоянного отслеживания метаданных).

Данные по размеру файлов и производительности можно изучить на следующей диаграмме для метода **WriteBytesAsync**. На этой диаграмме сравниваются длительность операции и размер файла. На ней отображается средняя производительность 10 000 операций для размера файла в управляемой среде.

![Производительность WriteBytesAsync](images/writebytesasync-performance.png)

На этой диаграмме намеренно пропущены значения времени на оси y, так как разное оборудование и конфигурации дадут разные абсолютные значения времени. Тем не менее мы наблюдали следующие устойчивые тенденции в тестах.

* Небольшие файлы (не более 1 МБ): время выполнения операций устойчиво небольшое.
* Более крупные файлы (более 1 МБ): время выполнения операций начинает увеличиваться экспоненциально.

## <a name="io-during-app-suspension"></a>Операции ввода-вывода во время приостановки приложения

Приложение должно обрабатывать приостановку, если вы хотите сохранить сведения о состоянии или метаданные для использования в последующих сеансах. Общие сведения о приостановке приложений доступны в разделе [Жизненный цикл приложения](../launch-resume/app-lifecycle.md) и в [этой записи блога](https://blogs.windows.com/buildingapps/2016/04/28/the-lifecycle-of-a-uwp-app/#qLwdmV5zfkAPMEco.97).

Если только операционная система не предоставляет приложению режим расширенного выполнения, при приостановке у приложения есть 5 секунд на то, чтобы освободить все свои ресурсы и сохранить данные. Чтобы обеспечить наилучшую надежность и взаимодействие, всегда учитывайте, что время, выделяемое на обработку задач приостановки, ограничено. Используйте приведенные ниже рекомендации во время 5-секундного интервала времени, выделяемого для обработки задач приостановки.

* Пытайтесь свести к минимуму операции ввода-вывода, чтобы избежать состязания за доступ из-за операций записи на диск и освобождения.
* Избегайте операций записи в файлы, требующих сотен миллисекунд или больше для выполнения.
* Если приложение использует методы **Write**, учитывайте все промежуточные шаги, обязательные для этих методов.

Если приложение работает с небольшим объемом данных о состоянии во время приостановки, в большинстве случаев можно использовать методы **Write** для записи данных на диск. Тем не менее, если приложение использует большой объем данных о состоянии, рассмотрите возможность использования потоков для непосредственного сохранения данных. Это может снизить задержки, связанные с транзакционной моделью методов **Write**. 

Вы можете ознакомиться с примером [BasicSuspension](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/BasicSuspension).

## <a name="other-examples-and-resources"></a>Другие примеры и ресурсы

Ниже приведено несколько примеров и другие ресурсы для конкретных сценариев.

### <a name="code-example-for-retrying-file-io-example"></a>Пример кода для повтора файлового ввода-вывода

Ниже приведен пример псевдокода для повтора записи (C#) при условии, что запись требуется выполнить после того, как пользователь выберет файл для сохранения.

```csharp
Windows.Storage.Pickers.FileSavePicker savePicker = new Windows.Storage.Pickers.FileSavePicker();
savePicker.FileTypeChoices.Add("Plain Text", new List<string>() { ".txt" });
Windows.Storage.StorageFile file = await savePicker.PickSaveFileAsync();

Int32 retryAttempts = 5;

const Int32 ERROR_ACCESS_DENIED = unchecked((Int32)0x80070005);
const Int32 ERROR_SHARING_VIOLATION = unchecked((Int32)0x80070020);

if (file != null)
{
    // Application now has read/write access to the picked file.
    while (retryAttempts > 0)
    {
        try
        {
            retryAttempts--;
            await Windows.Storage.FileIO.WriteTextAsync(file, "Text to write to file");
            break;
        }
        catch (Exception ex) when ((ex.HResult == ERROR_ACCESS_DENIED) ||
                                   (ex.HResult == ERROR_SHARING_VIOLATION))
        {
            // This might be recovered by retrying, otherwise let the exception be raised.
            // The app can decide to wait before retrying.
        }
    }
}
else
{
    // The operation was cancelled in the picker dialog.
}
```

### <a name="synchronize-access-to-the-file"></a>Синхронизация доступа к файлу

[Блог по параллельному программированию для .NET](https://devblogs.microsoft.com/pfxteam/) является превосходным источником рекомендаций по параллельному программированию. В частности, в [записи блога о AsyncReaderWriterLock](https://devblogs.microsoft.com/pfxteam/building-async-coordination-primitives-part-7-asyncreaderwriterlock/) описывается, как обеспечить монопольный доступ к файлу для записи, предоставляя параллельный доступ для чтения. Следует помнить, что сериализация операций ввода-вывода будет влиять на производительность.

## <a name="see-also"></a>См. также статью

* [Создание, запись и чтение файла](quickstart-reading-and-writing-files.md)
