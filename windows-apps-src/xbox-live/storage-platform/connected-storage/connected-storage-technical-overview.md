---
title: Технический обзор подключенного хранилища
description: Близкое знакомство с внутренней работе подключения хранилища.
ms.assetid: a0bacf59-120a-4ffc-85e1-fbeec5db1308
ms.date: 02/27/2018
ms.topic: article
keywords: Xbox live, xbox, игры, универсальной платформы Windows, windows 10 для настольных ПК, xbox, подключенные устройства хранения
ms.localizationpriority: medium
ms.openlocfilehash: 6eddd11a370b8dcadc5108fe00539c2c6d1d9d1a
ms.sourcegitcommit: b034650b684a767274d5d88746faeea373c8e34f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2019
ms.locfileid: "57624059"
---
# <a name="connected-storage"></a>Подключенное хранилище

> [!NOTE]
> Этот документ первоначально был написан для разработчиков управляемых партнера Xbox One.  Некоторые Xbox One определенного содержимого, таким как локальный и заголовок хранилище может игнорироваться для универсальной платформы Windows на Windows.  Концептуальное содержимое и API в этом документе по-прежнему актуальны.  Обратитесь к своему представителю корпорации Майкрософт (если применимо) с любыми вопросами.

Хранилище и сохранения модели в службе Xbox One значительно отличаются от разрешений для Xbox 360; Xbox One имеет более гибкую модель приложения, поддерживающий ускоренного восстановления приложений, переключение, несколько приложений одновременно, и быстрый приостановить и возобновить приложений. Хранить данные с помощью API службы хранилища подключены автоматически перемещается для пользователей в нескольких консолей Xbox One, а также доступна для автономного использования.

Содержание раздела

-   С помощью подключения API службы хранилища хранить сохраненные игры и данные приложения в службе Xbox One.
-   Рекомендации по проектированию приложения сохраните систем, таким образом, чтобы они хорошо интегрируются с преимуществ возможности пользователя, предоставляемых моделью приложения Xbox One.
-   Как система подключенного хранилища повышает скорость, с помощью которого приложение может сохранить данные
-   Как система обрабатывает конфликты данных синхронизации и данные из нескольких консолей, не требуя пользовательского интерфейса приложения.
-   Подключенные устойчивости модели хранения, который разработан таким образом, чтобы приложение всегда имеет самосогласованным представление данных, которые хранятся в отдельных контейнерах даже в случае потери подключения или power прерванного сети.

> [!NOTE]
> Термин *приложения*, так как в этой статье, относятся к любое приложение, запущенное на консоли, включая игры.

## <a name="overview"></a>Обзор

Модель приложения Xbox One пользователи могут использовать несколько приложений одновременно, это означает, что приложения нельзя использовать запрос пользователя может ожидать данных сохраняется до выключения консоли или перейти к другим приложением. Xbox One пользователей также будет приятно, так как данные, их можно было использовать автоматически на консоли, чтобы каждый консоли Xbox One вспомнив собственные консоли. Xbox One платформа предоставляет подключение API службы хранилища для выполнения этих требований приложения.

Подключенные устройства хранения система позволяет приложениям хранить данные как один или несколько *большие двоичные объекты* в *контейнеры*. Когда приложение сохраняет данные, он быстро копируется из эксклюзивные секции в общего раздела, чтобы задачи хранения данных на диске и отправить его в хранилище-Title Xbox Live, которые могут обрабатываться за пределами жизненного цикла приложения.

Если приложение запрашивает данные определенного пользователя из системы подключенные устройства хранения, система автоматически проверяет с облаком обновленных данных и уведомляет пользователей, если они понадобиться получить данные для загрузки. Система также запрашивает пользователю выбирать между конфликтующие данные в некоторых случаях, например когда пользователь воспроизведения в автономном режиме на более чем одной консоли, или когда отправки еще одна консоль сохраненные данные для этого пользователя.

Приложение также имеет выделенную, но с определенными, объем Облачное хранилище для каждого пользователя, поэтому пользователям не придется сделать жестких Выбор об окончательном удалении данных из одного приложения, чтобы освободить место для другого приложения сохраняет. Тем не менее, есть ограниченный объем дискового пространства на Xbox One жестком диске для кэширования сохраняет локально, поэтому система предоставляет пользовательский интерфейс для освобождение места в локальном кэше. Пользователи контролируете кэшируются в локальном компьютере. они никогда не потерять доступ к данным, они важную информацию, когда они Играем в автономном режиме. Подключенные устройства хранения система также позволяет небольшой объем данных пользователя для локального хранения для приложения. Эти данные на уровне компьютера не перемещаются и не был передан в облако.

Xbox One, подключенного хранилища берет на себя управление питанием системы таким образом, чтобы ожидающие операции записи на жесткий диск или отправки в облако, обрабатываются автоматически, нет необходимости для наименований для отображения пользовательского интерфейса сказать «сохранить в состоянии выполнения, не отключите консоли.»

### <a name="the-xbox-one-app-model-and-app-navigation"></a>Модели и приложение навигации приложения Xbox One

Xbox One позволяет пользователям быстро переключаться между несколькими приложениями. Грамотно сконструированные приложения пользователи могут выбрать он остановился во время свое последнее действие с соответствующий контекст загрузки быстро, даже если приложение завершил работу с момента последнего обращения пользователя его.

Консолей Xbox One можно запускать только одно приложение в эксклюзивное секции одновременно. Представления в пользовательском интерфейсе переключение fast требует запущенного эксклюзивные приложение, чтобы завершить работу быстро когда пользователь хочет выполнить еще один. Когда пользователь пытается получить перейдите в другое приложение, система отправляет активного приложения уведомление suspend. В течение этого времени приложение следует сохранить соответствующего региона и возврат из функции его приостановки. Система применяет максимальное ограничение времени в 1 секунду для этой операции. Если приложение не вернулся в течение 1 секунды, система принудительно завершает работу приложения. Приложения не может запретить пользователям переход отсюда, как и в случае с моделью навигации на современные смартфоны и планшеты.

Кроме того, существуют также другие случаи, в которых приостановлена эксклюзивные приложения, такие как системы ввода в состояние простоя или низкой power, когда пользователь нажимает кнопку питания на консоли. Когда приложение приостановлено, его можно возобновить без повторной выгрузки системой. Это позволяет функции быстрого возобновления. Важно понимать — что приостановленных приложений также может завершено или возобновлено. Приложение всегда необходимо сохранить состояние, в случае, если его выполнение завершается.

Для работы с моделью приложения Xbox One, приложения должны быть готовы сериализации состояния в буфер памяти быстро, чтобы соответствующего региона могут быть сохранены в 1 секунду приостанавливать временные рамки.

Обратите внимание, что разница между сохраненные данные о пользователя игровой процесс и данные о состоянии приложения, такие как расположение в меню. Дополнительно к скидке игровой процесс, когда приложение приостановлено, рассмотрите возможность сохранения состояния меню, если пользователь находится в середине настроив параметры или Настройка символа за пределами основной игровое ядро.

Пользователи могут покидать игры приостановлена для очень много времени. Рассмотрите возможность предлагает разные возможности, когда игра возобновляется после приостановки long. Удаление пользователя обратно в тушить из их кампании может быть резать глаз и непредвиденных качества, если пользователь еще не двух недель, тогда как разрыв один час будет чаще будут и гарантировать быстро вернуть в игровой процесс.

Дополнительные сведения о модели приложения Xbox One см. следующие ресурсы:

-   [Современные переключения между приложениями для гостиной](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Documents/Xfest%202012/Xfest%202012%20-%20Modern%20Application%20Switching%20for%20the%20Living%20Room.pptx), презентации на Xfest 2012
-   [Возможности оболочки](https://developer.xboxlive.com/_layouts/xna/download.ashx?file=PROD-D_Experience.pptx&folder=platform/xfest2013), презентации на Xfest 2013
-   [Процесс управления жизненным циклом для Xbox One](https://developer.xboxlive.com/en-us/platform/development/education/Documents/PLM%20for%20Xbox%20One.aspx), технический документ на GDN

> [!NOTE]
> Некоторые презентации были проведены в [Xfest 2012](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Pages/Xfest2012.aspx) и [Xfest 2013](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Pages/Xfest2013.aspx) содержат сведения, которые устарели из-за объявления, что Xbox One поддерживает воспроизведение в автономном режиме.


### <a name="storage-options-on-xbox-one"></a>Параметры хранилища в службе Xbox One

Xbox One предоставляет несколько вариантов хранения, каждая из которых имеет собственные преимущества и ограничения. Приложения может потребоваться использовать сочетание параметров в зависимости от требований приложения.


<a name="connected-storage"></a>Подключенные устройства хранения
-----------------
Подключенные устройства хранения призван помочь сэкономить Xbox One игровой процесс данных и другие соответствующие приложения состояний данные, которые должны перемещаться между консолями приложений. Подключение API службы хранилища, относящиеся к службе Xbox One, поможет с сохранением и отправкой данных. API работает в сочетании с моделью приложения Xbox One.

Подключение API службы хранилища предоставляет следующие возможности:

-   Приложения можно быстро сохранить до 16 МБ данных за раз в буфер памяти в системный раздел, который затем кэшируется локально жесткого диска в системе и отправлять в облако.
- Для управляемых партнеров и ID@Xbox разработчиков:
  - 256 МБ в пользователя или приложения для облачного хранилища.
- Для разработчиков Xbox Live Creators Program:
  - 64 МБ в пользователя или приложения облачного хранилища.
-   Надежный ответ сбоев питания — приложений отпадает необходимость иметь дело с частичной сохраняемые данные.
-   Данные автоматически передаются в облаке, даже в том случае, если приложение не запущено.
-   Данные будут доступны на консолях Xbox One, подключенных к Xbox Live.
-   Xbox Live обрабатывает управление синхронизацией и конфликтов между устройствами без необходимости участия в приложении.

Дополнительные сведения о подключенных API службы хранилища см. соответствующий раздел в xblesdk.chm (который Документирует Xbox Live расширения пакета SDK для API-интерфейсы) в Xbox Live SDK.


<a name="xbox-live-title-storage"></a>Xbox Live Title хранилища
-----------------------
Служба хранилища Title предоставляет кросс платформенных REST API для хранения данных со следующими возможностями:

-   Предоставляет данные, совместное использование несколькими пользователями, приложений и различных платформ
-   Поддерживает двоичные данные, JSON и файлы конфигурации
-   Для управляемых партнеров и ID@Xbox разработчиков:
    - 256 МБ в пользователя или приложения для облачного хранилища
    - 256 МБ в глобальном хранилище title
- Для разработчиков Xbox Live Creators Program:
  -   64 МБ в пользователя или приложения облачного хранилища
  -   256 МБ в глобальном хранилище title

Требования для использования службы:

-   Консоль Xbox One, необходимо подключиться к Интернету для доступа к службе
-   Все взаимодействия службы должны выполняться во время выполнения приложения; Передача данных не заполняется автоматически в фоновом режиме.

Дополнительные сведения см. в разделе *хранения-Title Xbox Live*, в документации по XDK.


<a name="local-temporary-storage"></a>Локальным временным хранилищем
-----------------------
В консоли приложения имеет доступ к локальным временным хранилищем со следующими характеристиками:

-   2 ГБ, выделенный жесткий диск хранилища, доступного по пути/T:\\.
-   Содержимое этого хранилища могут быть удалены, когда приложение не выполняется.

Дополнительные сведения о локальном хранилище см. в разделе локального хранилища в документации по XDK.


<a name="configuring-your-app-for-connected-storage"></a>Настройка приложения для подключенного хранилища
------------------------------------------
При использовании API службы хранилища подключены все считывания и записи операций связаны с Xbox Live основной службы конфигурации идентификатор (SCID), определенные в файле манифеста приложения, AppXManifest.xml:

```xml
      <Extensions>
        <mx:Extension Category="xbox.live">
        <mx:XboxLive TitleId="<your title ID>" PrimaryServiceConfigId="<your SCID>"
        RequireXboxLive="<boolean indicating Live requirement>" />
        </mx:Extension>
      </Extensions>
```

Дополнительные сведения о получении заголовок идентификатора и SCID для вашего приложения, см. в разделе *параметр вверх "песочницы" для Xbox Live Development*, в документации по XDK.



## <a name="connected-storage-system-concepts"></a>Подключенного хранилища: основные понятия о системных

В этом разделе описываются компоненты системы подключенные устройства хранения, их связи и их правильное использование.

### <a name="connected-storage-space"></a>Подключенные дискового пространства

На высоком уровне все данные в системе подключенные устройства хранения, связанный с пользователя или компьютера (например, отдельные Xbox One консоль). Все данные, сохраненные с помощью приложения для конкретного пользователя или компьютера хранится в подключенном дисковом пространстве.

Каждый пользователь приложения получает подключенных дисковом пространстве с ограничение в 256 МБ общего хранилища. Важно отметить, что это хранилище выделяется в приложение только — не используется совместно с другими приложениями.

Приложение также имеет 64 МБ места в локальный подключенных дискового пространства для машины. Это дисковое пространство не зависит от пользователей и может осуществляться, даже если пользователи не вошли в систему.

Для получения подключенного дисковое пространство, приложение вызывает *метод ConnectedStorageSpace.GetForUserAsync* или *ConnectedStorageSpace.GetForMachineAsync метод*. Это потенциально длительная операция, особенно в том случае, если пользователь сохраненные данные на одном устройстве и возобновляет работу игровой процесс, в первый раз на другом устройстве. Дополнительные сведения об этом процессе и условия возможной ошибки, которые может выполняться, пока приложение ожидает получения подключенного дискового пространства см. в разделе *синхронизации подключенных дисковое пространство*далее в этом документе.

После приложение получает **ConnectedStorageSpace** объекта, вызовов ко всем методам в разделе *пространства имен Windows.Storage* которых используют, объекта или других объектов, производных от него, не зависящих от ответа из веб-служб для завершения. Тем не менее так как доступ к Xbox одного жесткого диска не является уникальной для активного приложения, строгие границы на производительность этих методов не гарантируется.


### <a name="connected-storage-containers-and-blobs"></a>Подключенного хранилища: контейнеры и большие двоичные объекты

*Контейнер подключенного хранилища*, или *контейнера* для краткости, является основной единицей хранения. Каждый подключенный дисковое пространство может содержать множество контейнеров, как показано на следующей схеме.

**Рис. 1.  Подключенные дисковое пространство (title/компьютера или title/пользователя)**

![](../../images/connected_storage/connected_storage_space_containers.png) Данные хранятся в контейнерах, как один или несколько буферы называются *большие двоичные объекты*. На следующей схеме показано представление внутренней системы контейнеров на диске. Для каждого контейнера имеется файл контейнера, который содержит ссылки на файл данных для каждого большого двоичного объекта в контейнере.

**Рис. 2.  Схема контейнера**

![](../../images/connected_storage/container_storage_blobs.png)

Для сохранения данных в контейнере, вызвать *ConnectedStorageContainer.SubmitUpdatesAsync метод*, предоставляя карту имена и большие двоичные объекты (буфер объектов). Все изменения, описанные в **SubmitUpdatesAsync** вызов применяются атомарным образом, то есть либо все большие двоичные объекты обновляются по запросу, или вся операция завершается и контейнер остается в состоянии до вызова метода.

Отдельные операции, использующие сохранения **SubmitUpdatesAsync** — 16 МБ данных за раз.


### <a name="submitupdatesasync-behavior"></a>Поведение SubmitUpdatesAsync

Когда **SubmitUpdatesAsync** является именем, буферы, предоставленные для вызова быстро копируются из раздела приложения в выделенной памяти в системном разделе. После памяти успешно скопирован в системном разделе, обработчик завершения предоставлены в **SubmitUpdatesAsync** вызов реализуется в приложении, указывающий на наличие приложению безопасно освободить выделенную ему память локально для данных.

Затем система сохраняет большие двоичные объекты в консоли жесткого диска и завершает операцию с обновлением конечный контейнер, который обязывает всей операции на этом контейнере.

Есть максимальный 16 МБ памяти в общий раздел для получения **SubmitUpdatesAsync** данных. Если в вызове **SubmitUpdatesAsync** не могут быть обработаны немедленно системой из-за достаточный объем памяти, свободного в выделенный буфер 16 МБ, вызов помещается в очередь для обслуживания. Система постоянно передает данные из буфера 16 МБ на жестком диске, а в очереди обновления обрабатываются в порядке, в котором они были запрошены по мере появления в буфере 16 МБ места.

**Рис. 3.  Поведение SubmitUpdatesAsync**

![](../../images/connected_storage/submitupdatesasync_behavior.png) Отправка в облаке происходит так же, как: Отдельные большие двоичные объекты передаются в службу и операции обновления фиксируется путем последнее обновление в контейнер файл, который ссылается на все другие отправленных BLOB-объектов. В отправки в облако, такое объединение в единый и последнее обновление гарантирует, что ссылки на все данные в **SubmitUpdatesAsync** вызова либо фиксируется в полном объеме или контейнер остается без изменений. Таким образом даже в том случае, если система переходит в автономный режим или отключения питания во время операции передачи, пользователь может перейти в другой консоли Xbox One, скачать данные из облака и продолжить воспроизведение с помощью согласованное представление всех контейнеров.

> [!IMPORTANT]
> Данные зависимостей в контейнеры не являются безопасными.  Результаты отдельных *SubmitUpdatesAsync* вызовы будут гарантированно применяться полностью, или вообще не.

**SubmitUpdatesAsync** вызовы не должен предполагать, что будущее **SubmitUpdatesAsync** вызов будет успешно завершена чтобы покидать контейнер в недопустимом состоянии. Другими словами, приложения не следует полагаться на более чем один **SubmitUpdatesAsync** вызов, чтобы сохранить все необходимые данные в контейнер. Каждый **SubmitUpdatesAsync** вызова необходимо оставить содержимое указанного контейнера в недопустимом состоянии для приложения для чтения в более поздней версии.

Чтобы продемонстрировать это, рассмотрим сценарий, где контейнер отслеживает объем gold и качества пищевых продуктов, удерживаемые знак с именем Боб. Заголовок можно хранить два больших двоичных объектов, с именем *food* и *gold*. Боб начинается с 100 gold и не качества пищевых продуктов в его данных инвентаризации.

**Рис. 4.  Пример сценария. Боб начинается со 100 gold.**

![](../../images/connected_storage/submitupdatesasync_example_scenario1.png)

Теперь Боб тратит 50 gold. Подготавливает заголовок **SubmitUpdatesAsync** вызов, который обновляет значение gold большого двоичного объекта значение 50.

Система захватывает обновленный большой двоичный объект и сведения об обновлении контейнера в буфере обновления. Затем система копирует значение новый большой двоичный объект на жестком диске.

**Рис. 5.  Система записывает обновленную информацию и копирует значения на жестком диске.**

![](../../images/connected_storage/submitupdatesasync_example_scenario2.png)

Наконец система обновляет файл контейнера жесткого диска для ссылки на новый большой двоичный объект. В конечном счете система удаляет неиспользуемые большого двоичного объекта в сборки мусора.

**Рис. 6.  Система обновляет файл контейнера жесткого диска и удаляет неиспользуемые большого двоичного объекта.**

![](../../images/connected_storage/submitupdatesasync_example_scenario3.png)

Обратите внимание, что большие двоичные объекты, использовать на **SubmitUpdatesAsync** вызов, тем больше времени требуется для выполнения необходимых атомарных операций из операции файловой системы, чтобы надежно хранить данные. Гранулярность хранения данных в предыдущем примере слишком мал, но он предназначен для демонстрации поведения атомарные обновления нескольких больших двоичных объектов в одном контейнере.


### <a name="updating-multiple-blobs--the-wrong-way"></a>Обновление нескольких больших двоичных объектов — неправильный способ

Рассмотрим сценарий, в котором Боб хочет купить продукты питания. Для простоты мы скажем: 1 единица gold покупает 1 единицу качества пищевых продуктов, что Боб хочет купить 25 единиц качества пищевых продуктов. Приложение может выдать один **SubmitUpdatesAsync** вызов для добавления 25 единиц качества пищевых продуктов, а затем другое для вычитания 25 единиц gold из Боб\_инвентаризации контейнера. Но даже если завершенного обработчики для обоих **SubmitUpdatesAsync** вызовы были вызваны, существует вероятность возникновения неверные результаты из-за событий, например отключения питания, который может предотвратить данных предотвращает запись на жесткий диск, или синхронизация не завершена в облако. Ниже приведены схемы объяснить последовательность шагов, выполняемых системой, и результат отключения питания в один из шагов.

Предполагается, что данные из обоих **SubmitUpdatesAsync** вызовы уже находится в буфере обновления системы, и после вызова обработчиков завершения title для обоих вызовов.

Сначала система записывает данные для нового значения большого двоичного объекта качества пищевых продуктов на диск.

**Рис. 7.  Система записывает значение качества пищевых продуктов большого двоичного объекта на диск.**

![](../../images/connected_storage/update_method_wrong_way_1.png) Затем система обновляет контейнер для ссылки на записываемые значение. Как на следующей схеме показано, если power были удалены после выполнения этого шага и перед следующим, Боб получим по себе весьма ценно, получение 25 нектара без необходимости соответствующий gold, вычитается из его инвентаризации.

**Рис. 8.  Система обновляет контейнер для ссылки на записываемые значение.**

![](../../images/connected_storage/update_method_wrong_way_2.png)

Затем система записывает данные для нового значения gold большого двоичного объекта на диск. Значение для gold ссылается Боб\_инвентаризации контейнер по-прежнему не была изменена, и Боб имеет 25 gold, чем он должен, но процесс еще один шаг ближе к желаемому результату.

**Рис. 9.  Система записывает данные для нового значения gold большого двоичного объекта на диск.**

![](../../images/connected_storage/update_method_wrong_way_3.png)

Наконец, система обновляет файл контейнера для ссылки на записываемые BLOB-объектов, золотой — предполагался другой результат.

**Рис. 10.  Система обновляет файл контейнера для ссылки на записываемые gold большого двоичного объекта.**

![](../../images/connected_storage/update_method_wrong_way_4.png)

### <a name="updating-multiple-blobs--the-right-way"></a>Обновление нескольких больших двоичных объектов — лучший способ

Правильный способ гарантировать объем gold и качества пищевых продуктов на складе Боба атомарным образом обновление, без возможности неверные промежуточное состояние, из-за отключения питания, является обновление обоих больших двоичных объектах в одном **SubmitUpdatesAsync** вызова. Система будет затем выполните следующие действия.

Сначала система записывает данные для нового значения большого двоичного объекта качества пищевых продуктов на диск.

**Рис. 11.  Система записывает данные для нового значения большого двоичного объекта качества пищевых продуктов.**

![](../../images/connected_storage/update_method_right_way_1.png) Затем система записывает данные для нового значения gold большого двоичного объекта на диск.

**Рис. 12.  Система записывает данные для нового значения gold большого двоичного объекта.**

![](../../images/connected_storage/update_method_right_way_2.png) Наконец система обновляет файл контейнера для ссылки на несколько новых больших двоичных объектов.

**Рис. 13.  Система обновляет файл контейнера для ссылки на обоих новых больших двоичных объектов.**

![](../../images/connected_storage/update_method_right_way_3.png) Хотя этот пример является очень простой, он иллюстрирует важность принятия все изменения в данные в контейнер, который должен применяться атомарным образом, выполнив один **SubmitUpdatesAsync** вызывать все нужные обновления. Таким образом в случае приобретения качества пищевых продуктов с gold, приложение позволяет избежать возможного состояния гонки, неправильно может обновить только одно из значений и оставьте символ с слишком много gold.

### <a name="performance-characteristics-and-considerations"></a>Характеристики производительности и рекомендации

Этот буфер обновления 16 МБ в разделе общих нужен ограниченный набор операций обновления выполняться очень быстро. Скорость, с которой система может сохранить данные на диск зависит от объема данных в буфере и больших двоичных объектов. Так как каждый большой двоичный объект записывается на диск с устойчивостью, большее количество больших двоичных объектов в буфере, тем больше времени, требуемое для сохранения их на диск.

Рис. 13 показан пример времени обработки для **SubmitUpdatesAsync** операции, каждые 2 секунды с обновлениями двух 512 k BLOB-объектов и один 1024 КБ BLOB-объектов обновления, когда не выполняет никаких других действий жесткого диска в системе. Система может работать в стабильном состоянии, обработки каждого обновления в 14 — 18ms.

**Рис. 14.  Время обработки для операции SubmitUpdatesAsync каждые 2 секунды с обновлениями двух 512 k BLOB-объектов и один BLOB-объектов 1024 КБ, обновление и никакие другие действия на жестком диске.**

![](../../images/connected_storage/submitupdatesasync_proc_time_mixed_size_fixed_interval.png) Рис. 14 показано время обработки для трех 1024 КБ, большие двоичные объекты через разные промежутки времени.

Система может обрабатывать эти обновления каждые 3 секунды на 87ms устойчивого состояния. Повышение частоты для каждые 2 секунды, система может по-прежнему обрабатывать обновления в 87ms устойчивого состояния.

Уменьшение интервала до 1 секунды между обновлениями изменяет поведение устойчивого состояния. Система может обрабатывать обновления 60 на 87ms каждого обновления, но каждое обновление, чем тот, занимает значительно больше времени, достижение устойчивого состояния обработки времени 500 миллисекунд, во-вторых каждого обновления, с помощью значительные колебания. Это обусловлено буфер памяти 16 МБ, заполняется быстрее, чем его можно записать данные на диск; обновления будут вынуждены ожидать предыдущие обновления для записи.

Эффект, значительно увеличивается при обновлении интервал до одного обновления каждые 0,5 секунд. Система может обрабатывать только 7 обновлений с интервалом, еще раз за 87ms каждого обновления, до достижения им устойчивого состояния, в котором каждое обновление имеет более чем 1 секунду, обрабатываемых с очень высокой вариациями.

**Рис. 15.  Время обработки из трех 1024 КБ, большие двоичные объекты через разные промежутки времени.**

![](../../images/connected_storage/submitupdatesasync_proc_time_fixed_size_various_intervals.png) Это только наглядные примеры. Приложения обычно не должно быть сохранение данных это часто, но он также не обычно работать в среде без дискового ввода-вывода.

Очень важно понять характеристики системы, на основе этих примеров — для измерения приложения в различных условиях работы, чтобы гарантировать, что сохранения завершения операций может менее 1 секунды во время приложения приостановить обработчика.


## <a name="synchronizing-a-connected-storage-space"></a>Синхронизация подключенных дискового пространства

-   Проверка подключения
-   Получение блокировки
-   Список, сравнения и слияния логики контейнера
-   Загрузки контейнера

Когда приложение запрашивает доступ к подключенной дискового пространства, система выполняет процесс синхронизации обеспечить сохраненные данные пользователя в согласованном состоянии с различными консолей Xbox One и сделать его данные доступными для автономного воспроизведения. Так как синхронизация может занять Разное количество времени и может потребоваться пользователь для принятия решений, система может отображать пользовательский Интерфейс для пользователя на различных этапах процесса.

Пользователь может перейти от приложения нажатием кнопки «Xbox» в любое время, даже если синхронизации пользовательского интерфейса активен. Система скрывает пользовательский Интерфейс и продолжается синхронизация, насколько это возможно без участия пользователя. Когда пользователь переходит обратно к приложению, снова отобразится пользовательский Интерфейс, если не выполнена синхронизация. Система не делает предположения о выбора пользователя при скрытии пользовательского интерфейса.

Так как система отображает без синхронизации пользовательского интерфейса, когда пользователь на начальном экране и, используемого в приложении по-прежнему отображается в больших плитку приложения, важно то, что приложение отображаться используемому визуальных элементов при **GetForUserAsync** завершения вызова. Продолжение отрисовку указывается, что приложение будет интерактивным и ожидает данные для загрузки.

На следующей схеме показана последовательность высокого уровня, в которой следует система, когда приложение запрашивает подключенных дискового пространства. Если последовательность целиком занимает несколько секунд, рисуемых системой синхронизации пользовательского интерфейса отображается.

**Рис. 16.  Последовательность, следуют в системе, когда приложение запрашивает подключенных дисковое пространство.**

![](../../images/connected_storage/app_requests_connected_storage_space.png) Система проходит через следующие этапы, при его служб **GetForUserAsync** запроса:

-   Проверка подключения
-   Получение блокировки
-   Список, сравнения и слияния логики контейнера
-   Загрузки контейнера

### <a name="connectivity-check"></a>Проверка подключения

Будет запущена для обслуживания **GetForUserAsync** запроса, система проверяет возможность подключения. Если консоль находится в автономном режиме, пропускается процесс всей синхронизации и подключенных дискового пространства для указанного пользователя помечается как отключенный в текущем сеансе. Все измененные данные будут согласованы с облачным хранилищем следующий раз, если приложение обращается к тем же пользователем подключенных дисковое пространство и система может подключиться к службе хранилища Title. Когда-либо пользовательский Интерфейс не отображается для этого случая.

Дополнительные сведения об автономной обработке вне контекста подключенного хранилища см. в разделе *устойчивости прерывания работы службы для названия одного Xbox*.

### <a name="lock-acquisition"></a>Получение блокировки

После проверки подключения, система пытается получить монопольный доступ к Облачное хранилище, связанные с приложением и текущего пользователя. Это достигается путем размещения файла блокировки в области подключенных хранения хранилища Title. Если консоль находится в сети, можно подключиться к службе, а также может получить блокировку за короткий период времени, ни один пользовательский Интерфейс и не продолжается процесс синхронизации.

Когда система будет получил блокировку для определенной подключенной дискового пространства и возвращается экземпляром подключенный дисковое пространство в приложение, ни один из вашего приложения API вызывает, работе с данными, в, на что подключенных дисковое пространство будет блокировать успешно веб-запросов. Блокировка предоставляет необходимый уровень защиты, чтобы вызовы API, даже если пользователь отключите сетевой кабель из системы после, как приложение получило подключенных дискового пространства, будет работать на основе данных, доступны локально.

Существует несколько сценариев возможна ошибка во время выполнения шага приобретения блокировки:

 **Синхронизация пользовательского интерфейса** Если консоль находится в сети, но не получил блокировку из службы за короткое время, отображается «Синхронизация» пользовательского интерфейса.

 **Прерывание блокировки** Если пользователь сыграла приложения в другой консоли, так как он или она последнего воспроизведения текущего, то, возможно, что другие консоли имеет монопольный доступ в дисковом пространстве и находится в процессе передачи данных. Это также возможно, что еще одна консоль запущена передача данных, но потерял его подключения или питания перед завершением работы.

Обоих этих случаях называются *конфликт блокировки*, и в любом случае система представляет пользовательский Интерфейс, чтобы объяснить, что еще одна консоль передача данных. Пользователь может ожидать этот процесс для завершения или работы с данными, доступных в облаке. Если пользователь выбирает для работы с данными в облаке, система использует блокировку самого (нарушает работу блокировки), получение монопольного доступа в Облачное хранилище для пользователя и приложения. Отправка из других консоли отменяется, и продолжает процесс синхронизации.

### <a name="container-listing-comparison-and-merger-logic"></a>Список, сравнения и слияния логики контейнера

После получения блокировки, система запрашивает список всех контейнеров в облаке для указанного приложения и пользователя. Затем он сравнивает содержимое локальный жесткий диск с данными в облаке и выполняется в соответствии с результатами сравнения:

 **Локальные данные соответствует облаке** Если были внесены изменения, не из других консолей, и данные в облаке и на локальном жестком диске совпадает, то синхронизация завершена, обработчика завершения **GetForUserAsync**вызов реализуется в данный момент, и приложения можно продолжить загрузку и сохранение.

 **Нет локальных данных** локальной консоли нет ни одного облака содержит данные, данные из облака, загружаемого локально. Это может произойти, например, при воспроизведении дома друга в первый раз.

 **Изменен локально и в облаке же контейнеры** невозможно, если пользователь изменил контейнеры в облаке с помощью воспроизведения на другой консоли и изменил тех же контейнеров, при использовании текущей консоли в автономном режиме, автоматически объединить данные. Пользователю будет предложено выбрать, какие данные следует сохранить. В случае конфликтов пользователь может выбрать политику замены: Всегда отображается на локальных данных или данных в облаке, либо пользователь может выбрать **отменить** и отложить выбор. Если пользователь нажимает в облаке или локальных данных, как политика замены, контейнеры с одинаковым именем —, но с отличается от содержимого, будут разрешаться соответствующим образом.

Если пользователь выбирает **отменить**, название будет иметь доступ к сохранения системы в состоянии не разрешен, как если бы пользователь воспроизведения в автономном режиме. В этом случае разрешение конфликтов пользовательского интерфейса представлены повторно при следующем запуске, приложение запрашивает доступ к подключенной дисковое пространство, если консоль подключен к сети.

### <a name="container-download"></a>Загрузки контейнера

После разрешения конфликтов в системе предусмотрен всю информацию, необходимую для определения, какие контейнеры необходимо загрузить из облака. Все необходимые контейнеры будут загружены, обработчика завершения *ConnectedStorageSpace.GetForUserAsync метод* будет вызываться в данный момент, и приложения можно продолжить загрузку и сохранение.

Некоторые возможные ошибки во время выполнения этого шага:

**Недостаточно дискового пространства**  
В случае локальном жестком диске недостаточно места для необходимые контейнеры пользователям предоставляется пользовательский Интерфейс запрашиваются для освобождения места на диске, удалив локально сохраненные данные. Чтобы помочь избежать окончательным удалением важных данных, не архивируются в облаке, пользовательский Интерфейс четко показывает данные являются просто локальный кэш и данные, уникальные для текущей консоли.

Когда пользователю представлен интерфейс пользователя:

-   Если пользователь позволяет освободить достаточно места, синхронизации продолжает и завершения.
-   Если пользователь не выполнит пользовательского интерфейса без освобождения памяти достаточно места, обработчика завершения **GetForUserAsync** вызов возвращает **OutOfLocalStorage**— см. в разделе *ConnectedStorageErrorStatus Перечисление*. Приложения следует убедиться, что пользователь планирует воспроизведение не может сохранить данные. Если пользователь соглашается, приложение должно продолжить без сохранения данных для этого пользователя. Если пользователь указывает, хочет сохранить данные при воспроизведении, приложение должно повторяться **GetForUserAsync** вызов, который затем будет отображать пользовательский Интерфейс, чтобы освободить место.

**Пользователь отменяет синхронизации**  
Если пользователь не хочет дождитесь завершения синхронизации и отменить выбор, пользователю сообщат, что не все сохраненные данные будут доступны. Обработчика завершения **GetForUserAsync** вызов направляется в данный момент, и приложение может продолжить загрузку и сохранение.

**Время ожидания сети истекло**  
Если время ожидания из-за проблемы с сетевым подключением или доступность службы по загрузке данных, пользователю предоставляется возможность повторить синхронизацию. Если он решил не, пользователю сообщат, что не все сохраненные данные будут доступны. Обработчика завершения **GetForUserAsync** вызов направляется в данный момент, и приложение может продолжить загрузку и сохранение.

## <a name="development-tools"></a>Средства разработки

Два средства помогут вам в разработке приложения использование подключенного хранилища: XbStorage и Fiddler.

### <a name="managing-connected-storage-with-xbstorage"></a>Управление хранилищами, подключенных с помощью XbStorage

XbStorage является средством разработки, которое позволит управлять данных локального хранилища, подключенных на Xbox One пакета средств разработки из Компьютере разработки.

Эта программа позволяет Очистка локального подключенных дисковых пространств с жесткого диска, а также импорт и экспорт отдельного пользователя или компьютера подключаемых дисковых пространств с помощью XML-файлов.

При выполнении операции над локальной подключенных дискового пространства, система действует так, будто этой операции с самого приложения. Копировать данные из подключенных дисковое пространство в локальном файле приводит к синхронизации с облаком перед копированием.

Аналогичным образом при копировании данных из XML-файл на Компьютере разработки контейнер подключенного хранилища на Xbox One dev kit приводит к консоли начать отправку данных в облако. Есть одно исключение: Если пакет средств разработки не удается получить блокировку или если возникает конфликт между контейнерами на консоль и в облаке. В этом случае консоль действует так, будто пользователь решили не для разрешения конфликта-например, выбирая одну версию контейнера, чтобы сохранить- и консоль действует так, будто он воспроизведение вне сети до следующего запуска заголовок.

Команда сброса XbStorage очищает все SCIDs и пользователи сохраненные данные в локальном хранилище, но не изменяет данные, хранящиеся в облаке. Это полезно для установки консоли состояние, которое было бы в, если пользователь роуминг на консоль и загрузка данных из облака на воспроизведение заголовок.

Дополнительные сведения о XbStorage, см. в разделе *Управление хранилищем подключен (xbstorage.exe)*, в документации по XDK.

### <a name="monitoring-connected-storage-network-activity-using-fiddler"></a>Наблюдение за активностью сети подключенные устройства хранения с помощью Fiddler

Может быть полезным для определения ли консоль взаимодействует со службой при выполнении операций хранилища в облаке. С помощью Fiddler может помочь определить консоль успешно выполняет вызовы к службе или если возникли ошибки авторизации. Сведения о настройке Fiddler в службе Xbox One, см. в разделе *использование Fiddler с Xbox One*, в этой документации XDK.

## <a name="resources"></a>Ресурсы

А также материалы, предлагаемые выше ниже можно использовать при разработке приложения или заголовок:

-   Подключенные Общие сведения о хранилище, в документации по XDK
-   [Управление жизненным циклом обработки](https://developer.xboxlive.com/_layouts/xna/download.ashx?file=ProcessLifetimeManagement_08_2013_qfe5.zip&folder=platform/aug2013xdk_qfe5/samples), примера из примеров в сети разработчиков игр (GDN)
-   [«Процесс управления временем существования (PLM) для Xbox One»](https://developer.xboxlive.com/en-us/platform/development/education/Documents/PLM%20for%20Xbox%20One.aspx), доступных из документов по GDN Технический документ
