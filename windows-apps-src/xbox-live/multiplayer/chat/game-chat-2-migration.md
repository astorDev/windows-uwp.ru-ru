---
title: Перенос игр чата 2
description: Сведения о переносе существующего кода Chat игры с помощью 2-чат игры.
ms.date: 05/02/2018
ms.topic: article
keywords: Xbox live, xbox, игры, универсальной платформы Windows, windows 10, xbox, один, игр чата 2, чат, игры, голосовой связи
ms.localizationpriority: medium
ms.openlocfilehash: e963210091694a07114f10d5a3dc531a353621df
ms.sourcegitcommit: b034650b684a767274d5d88746faeea373c8e34f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2019
ms.locfileid: "57653589"
---
# <a name="migration-from-game-chat-to-game-chat-2"></a>Миграция с игр чата игр чата 2

В этом документе описаны сходства Chat игры и игры Chat 2, а также способы перехода с Chat игра 2 Chat игры. Таким образом это для названия, использовать существующую реализацию Chat игры, которые хотите перенести в 2-чат игры. Если у вас еще нет реализацию игры-чат, рекомендуемая отправная точка является [с использованием 2 Chat игры](using-game-chat-2.md). 

## <a name="preface"></a>Префикс

Исходный API чата игр — это API WinRT, предоставляемого понятие чата пользователей и голосовых каналов для помощи в реализации Xbox Live в игре голосовой чат сценариев. API чата игры создан на основе чата API, который сам является API WinRT, предоставляемого концепцию пользователей чата и голосовых каналов при этом не низкого уровня управления звуковых устройств. Игры чата 2 является преемником исходные игры и API-интерфейсы чата — она может быть более простой API для разговора основные сценарии, такие как взаимодействие членов группы, одновременно обеспечивая большую гибкость для сценариев расширенной чата, таких как стиле вещательных обмен данными и обработки в реальном времени аудио. Чат, игры и игры 2 чата заполнения же нишу: API-интерфейсы каждой предоставляют удобный метод для интеграции, Xbox Live с поддержкой, игровых разговора, хотя заголовок содержит транспортный уровень для передачи пакетов данных в и из удаленных экземпляров игр чат или игры Чат 2.

Игра Chat 2 API имеет множество преимуществ перед исходные Chat игры и чат API-интерфейсы. Некоторые особенности:
* Гибкий ориентированных на пользователя API, который не привязана к модели «канал».
* Повышение пропускной способности из-за фильтрация пакетов по источникам данных и приемники данных.
* Внутренняя ограниченного использования программ для 2 потоков продолжительного со сходством можно настроить приложение.
* Интерфейс API в C++ и WinRT форм.
* Модель упрощенного потребления, выравнивание по шаблону «рабочая».
* Обработчики памяти для выделения 2-чат игры через пользовательский распределитель перенаправления.
* Идентичные UWP + заголовки эксклюзивные ресурсов приложения (ЭРА) для более удобным разработку кросс Платформенная.

В этом документе описаны сходства Chat игры и игры Chat 2, а также способы перехода с Chat игры в игре Chat 2 C++ API. Если вы заинтересованы в миграции с Chat игры в игре Chat 2 WinRT API, рекомендуется ознакомиться с этим документом, чтобы понять, как сопоставить Chat игры понятия 2 Chat игры, а затем см. в разделе [с помощью игры Chat 2 WinRT проекций](using-game-chat-2-winrt.md) для закономерностей, специфичных для WinRT. Пример кода для исходного Chat игры в этом документе будет использовать C + +/ CX.

## <a name="prerequisites"></a>Предварительные условия

Прежде чем приступить к созданию кода с помощью 2-чат игры, необходимо настроить AppXManifest приложения для объявления возможность устройства «микрофон». AppXManifest возможности описаны более подробно в соответствующих подразделах документации платформы; в следующем фрагменте показан узел возможность устройства «микрофон», должна существовать в узле пакета или возможности, иначе будет заблокировано чата:

```xml
 <?xml version="1.0" encoding="utf-8"?>
 <Package ...>
   <Identity ... />
   ...
   <Capabilities>
     <DeviceCapability Name="microphone" />
   </Capabilities>
 </Package>
```

Компиляция 2 Chat игры требует включения основного GameChat2.h заголовка. Чтобы связать должным образом, проект необходимо также включить GameChat2Impl.h в хотя бы одна единица компиляции (common предкомпилированного заголовка рекомендуется, так как эти функции заглушки являются небольшим и простым для компилятору создавать как «встроенные»).

Интерфейс игры Chat 2 не требует проектом, чтобы выбрать между компиляция с использованием C + +/ CX и традиционного C++. он может использоваться с любым. Реализация также не выдавать исключения как средства отчетности, поэтому их можно использовать без труда из проектов без поддержки исключений при желании Некритическая ошибка. Реализация тем не менее, исключения с точки зрения Неустранимая ошибка reporting (см. в разделе [сбоя модели](#failure-model-and-debugging) для получения дополнительных сведений).

## <a name="initialization"></a>Инициализация

### <a name="game-chat"></a>Чат, игры

Взаимодействие с исходной Chat игры осуществляется с помощью `ChatManager` класса. В следующем примере показано создание `ChatManager` экземпляра, используя параметры по умолчанию:

```cpp
auto chatManager = ref new ChatManager();
```

### <a name="game-chat-2"></a>Игровой чат 2

Все взаимодействие с 2 Chat игры осуществляется с помощью игры Chat 2 `chat_manager` singleton. Одноэлементный экземпляр должен быть инициализирован до возможного все значимые взаимодействия с библиотекой. Одноэлементный экземпляр требуется максимальное количество одновременных чата локальных и удаленных пользователей во время инициализации. Это обусловлено 2 Chat игры заранее выделяет объем памяти, пропорциональный ожидаемому числу пользователей. В следующем примере показано, как для инициализации одноэлементного экземпляра, если максимальное число одновременных чата локальные и удаленные пользователи будут находиться четыре:

```cpp
chat_manager::singleton_instance().initialize(4);
```

Существует несколько необязательных параметров, которые могут быть указаны во время инициализации, такие как значение по умолчанию сделать тома удаленный разговор пользователями и 2 чата игра должна ли выполняться автоматическое преобразование речи в текст. Дополнительные сведения об этих параметрах см. в документации по `chat_manager::initialize()`.

## <a name="configuring-users"></a>Настройки пользователей

### <a name="game-chat"></a>Чат, игры

Добавление локальных пользователей в исходный API Game Chat осуществляется с помощью `ChatManager::AddLocalUserToChatChannelAsync()`. Добавление пользователя нескольким каналам чата требует несколько вызовов каждого указания на другой канал. Приведенный ниже показано, как добавить пользователя с xuid «myXuid» канал 0:

```cpp
auto asyncOperation = chatManager->AddLocalUserToChatChannelAsync(0, L"myXuid");
```

Удаленные пользователи не добавляются к экземпляру напрямую. Когда удаленное устройство появляется в сети title, заголовок создает объект, представляющая удаленное устройство, но и уведомляет игры Chat нового устройства через `ChatManager::HandleNewRemoteConsole()`. Заголовок также необходимо предоставить метод сравнения объекты, представляющие удаленных устройств получить интерактивную игру, реализовав `CompareUniqueConsoleIdentifiersHandler`. Приведенный ниже показано, как предоставить этот делегат в чате игры, при условии, что `Platform::String` объекты используются для представления удаленных устройств и новое устройство, представленное строкой `L"1"` присоединено к сети title:

```cpp
auto token = chatManager->OnCompareUniqueConsoleIdentifiers +=
    ref new CompareUniqueConsoleIdentifiersHandler(
        [this](Platform::Object^ obj1, Platform::Object^ obj2)
    {
        return (static_cast<Platform::String^>(obj1)->Equals(static_cast<Platform::String^>(obj2)));
    });

...

Platform::String^ newDeviceIdentifier = ref new Platform::String(L"1");
chatManager->HandleNewRemoteConsole(newDeviceIdentifier);
```

После этого устройства уведомлен Chat игры, он формирования пакетов, содержащих сведения о всех локальных пользователей и предоставляет такие пакеты к заголовку для передачи данных к экземпляру Chat игры на удаленном устройстве. Аналогичным образом экземпляр Chat игры на удаленном устройстве приведет к созданию пакетов, содержащих сведения о пользователях на этом устройстве удаленного, заголовок будет передавать в локальный экземпляр Chat игры. Когда локальный экземпляр получает пакеты, содержащие сведения о новых удаленных пользователей, новые удаленные пользователи добавляются локальный экземпляр списка пользователей, доступных через `ChatManager::GetUsers()`.

Идет удаление пользователей из экземпляра Chat игры осуществляется с помощью аналогичные вызовы к `ChatManager::RemoveLocalUserFromChatChannelAsync()` и `ChatManager::RemoveRemoteConsoleAsync()`

### <a name="game-chat-2"></a>Игровой чат 2

Добавление локальных пользователей 2 Chat игры, выполняется синхронно с помощью `chat_manager::add_local_user()`. В этом примере пользователь A будет представлять локального пользователя с идентификатором пользователя, Xbox `L"myLocalXboxUserId"`:

```cpp
chat_user* chatUserA = chat_manager::singleton_instance().add_local_user(L"myLocalXboxUserId");
```

Обратите внимание, что пользователь не добавлен для конкретного канала - 2-чат игра использует концепция «отношений взаимодействия» вместо того, чтобы каналы для управления ли пользователи могут говорить и слышать друг с другом. Метод настройки отношений взаимодействия устранить проблемы позднее в этом разделе.

Аналогичную локальные пользователи, удаленные пользователи добавляются синхронно ответим на локальном игр 2 экземпляра. Удаленных пользователей, одновременно необходимо связать с идентификаторами, которые будут использоваться для представления удаленного устройства. Игры Chat 2 относится к экземпляру приложения, выполняемого на удаленное устройство как «Конечной точкой». В этом примере пользователь Б будет пользователь с идентификатором пользователя, Xbox `L"remoteXboxUserId"` на конечной точке представленный целое число `1`.

```cpp
chat_user* chatUserB = chat_manager::singleton_instance().add_remote_user(L"remoteXboxUserId", 1);
```

После добавления пользователей к экземпляру, необходимо настроить «отношения взаимодействия» между каждого удаленного пользователя и каждый локального пользователя. В этом примере предположим, что пользователь А и Б находятся в той же командой разработчиков и двусторонний обмен сообщениями разрешен. `c_communicationRelationshiSendAndReceiveAll` Константа, определенная в GameChat2.h для представления двунаправленный обмен данными. Связи можно настроить с помощью:

```cpp
chatUserA->local()->set_communication_relationship(chatUserB, c_communicationRelationshipSendAndReceiveAll);
```

Наконец Предположим, что пользователь Б вышел из игры и должны быть удалены из локального экземпляра игр Chat. Выполняется синхронно, вызвав:

```cpp
chat_manager::singleton_instance().remove_user(chatUserD);
```

Ссылаться на [с помощью игры Chat 2 - Настройка пользователей](using-game-chat-2.md#configuring-users) более подробные примеры или ссылку для отдельных методов API, Дополнительные сведения.

## <a name="processing-data"></a>Обработка данных

### <a name="game-chat"></a>Чат, игры

Игры чата не имеет свой собственный транспортном уровне; Это должно быть указано в приложении. Исходящие пакеты обрабатываются, подписавшись на `OnOutgoingChatPacketReady` событий, а также проверять аргументы для определения требований к пакетов назначения и транспорта. Приведенный ниже показано, как подписаться на событие и пересылать аргументы `HandleOutgoingPacket()` метод, реализованный заголовка:

```cpp
auto token = chatManager->OnOutgoingChatPacketReady +=
    ref new Windows::Foundation::EventHandler<Microsoft::Xbox::GameChat::ChatPacketEventArgs^>(
        [this](Platform::Object^, Microsoft::Xbox::GameChat::ChatPacketEventArgs^ args)
    {
        this->HandleOutgoingPacket(args);
    });
```

Входящие пакеты отправляются в чате игры с помощью `ChatManager::ProcessingIncomingChatMessage()`. Необходимо предоставить буфер необработанных пакетов и идентификатор удаленного устройства. В следующем примере показано, как отправить пакет, который хранится в локальной `packetBuffer` и идентификатор удаленного устройства, хранящиеся в локальной переменной `remoteIdentifier`.

```cpp
Platform::String^ remoteIdentifier = /* The identifier associated with the device that generated this packet */
Windows::Storage::Streams::IBuffer^ packetBuffer = /* The incoming chat packet */

chatManager->ProcessIncomingChatMessage(packetBuffer, remoteIdentifier);
```

### <a name="game-chat-2"></a>Игровой чат 2

Аналогичным образом игра Chat 2 имеет свой собственный уровень транспорта; Это должно быть указано в приложении. Исходящие пакеты обрабатываются приложения регулярных частые вызовы `chat_manager::start_processing_data_frames()` и `chat_manager::finish_processing_data_frames()` пару методов. Эти методы являются как игра Chat 2 обеспечивает выходных данных в приложение. Они предназначены для выполняются быстро, таким образом, чтобы они может быть запрошено часто в выделенном потоке сети. Это обеспечивает удобное место для извлечения всех данных в очереди, не беспокоясь о непредсказуемость времени сети и уровня сложности многопоточных обратного вызова.

Когда `chat_manager::start_processing_data_frames()` вызывается, все в очереди данные передаются в массив `game_chat_data_frame` структуры указатели. Приложения должны перебирать массив, проверить целевой объект «конечные точки» и использовать сетевой уровень приложения для доставки данных в экземпляры, соответствующие удаленному приложению. После завершения со всеми `game_chat_data_frame` структуры, массива должны быть переданы обратно 2 Chat игры, чтобы освободить ресурсы путем вызова `chat_manager:finish_processing_data_frames()`. Например:

```cpp
uint32_t dataFrameCount;
game_chat_data_frame_array dataFrames;
chat_manager::singleton_instance().start_processing_data_frames(&dataFrameCount, &dataFrames);
for (uint32_t dataFrameIndex = 0; dataFrameIndex < dataFrameCount; ++dataFrameIndex)
{
    game_chat_data_frame const* dataFrame = dataFrames[dataFrameIndex];
    HandleOutgoingDataFrame(
        dataFrame->packet_byte_count,
        dataFrame->packet_buffer,
        dataFrame->target_endpoint_identifier_count,
        dataFrame->target_endpoint_identifiers,
        dataFrame->transport_requirement
        );
}
chat_manager::singleton_instance().finish_processing_data_frames(dataFrames);
```

Чаще кадров данных, тем ниже аудио задержки, очевидным для конечного пользователя. Звук, объединенных в 40 мс кадры данных; это период предлагаемые опроса.

Входящие данные передаются 2 Chat игры с помощью `chat_manager::processing_incoming_data()`. Буфер данных и идентификатор удаленной конечной точки должно быть указано. В следующем примере показано, как отправить пакет данных, которые хранятся в локальной переменной `dataFrame` и идентификатора удаленной конечной точки, хранящегося в локальной переменной `remoteEndpointIdentifier`:

```cpp
uin64_t remoteEndpointIdentier = /* The identifier associated with the endpoint that generated this packet */
uint32_t dataFrameSize = /* The size of the incoming data frame, in bytes */
uint8_t* dataFrame = /* A pointer to the buffer containing the incoming data */

chatManager::singleton_instance().process_incoming_data(remoteEndpointIdentifier, dataFrameSize, dataFrame);
```

## <a name="processing-events"></a>Обработка событий

### <a name="game-chat"></a>Чат, игры

Чат, игры с помощью модели событий оповещать приложение о возникновении каких-либо интерес - например получение текстового сообщения или изменение настройки специальных возможностей пользователя. Приложение должно подписаться и реализовать обработчик для каждого интересующего события. В этом примере показано, как подписаться на `OnTextMessageReceived` событий и пересылать их аргументы `OnTextChatReceived()` или `OnTranscribedChatReceived()` методов, реализованных приложением:

```cpp
auto token = chatManager->OnTextMessageReceived +=
    ref new Windows::Foundation::EventHandler<Microsoft::Xbox::GameChat::TextMessageReceivedEventArgs^>(
        [this](Platform::Object^, Microsoft::Xbox::GameChat::TextMessageReceivedEventArgs^ args)
    {
        if (args->ChatTextMessageType != ChatTextMessageType::TranscribedSpeechMessage)
        {
            this->OnTextChatReceived(args);
        }
        else
        {
            this->OnTranscribedChatReceived(args);
        }
    });
```

### <a name="game-chat-2"></a>Игровой чат 2

Игры Chat 2 предоставляет обновления для него, например полученных текстовых сообщений, через приложение регулярных и своевременные вызовы `chat_manager::start_processing_state_changes()` и `chat_manager::finish_processing_state_changes()` пару методов. Они предназначены для выполняются быстро, таким образом, что они могут вызываться каждый кадр графики в цикле отрисовки пользовательского интерфейса. Это обеспечивает удобное место для получения всех изменений в очереди, не беспокоясь о непредсказуемость времени сети и уровня сложности многопоточных обратного вызова.

При `chat_manager::start_processing_state_changes()` является именем, все обновления в очереди, передаются в массив `game_chat_state_change` структуры указатели. Приложения должны перебирать массив, проверки базовой структуры для его более конкретный тип, приведение основной структуры, соответствующему более подробно введите, а затем обработать это обновление соответствующим образом. После завершения со всеми `game_chat_state_change` объектов в настоящее время недоступно, этот массив должны быть переданы обратно 2 Chat игры, чтобы освободить ресурсы путем вызова `chat_manager::finish_processing_state_changes()`. Например:

```cpp
uint32_t stateChangeCount;
game_chat_state_change_array gameChatStateChanges;
chat_manager::singleton_instance().start_processing_state_changes(&stateChangeCount, &gameChatStateChanges);

for (uint32_t stateChangeIndex = 0; stateChangeIndex < stateChangeCount; ++stateChangeIndex)
{
    switch (gameChatStateChanges[stateChangeIndex]->state_change_type)
    {
        case game_chat_state_change_type::text_chat_received:
        {
            HandleTextChatReceived(static_cast<const game_chat_text_chat_received_state_change*>(gameChatStateChanges[stateChangeIndex]));
            break;
        }

        case Xs::game_chat_2::game_chat_state_change_type::transcribed_chat_received:
        {
            HandleTranscribedChatReceived(static_cast<const Xs::game_chat_2::game_chat_transcribed_chat_received_state_change*>(gameChatStateChanges[stateChangeIndex]));
            break;
        }

        ...
    }
}
chat_manager::singleton_instance().finish_processing_state_changes(gameChatStateChanges);
```

Так как `chat_manager::remove_user()` сразу же делает недействительным в памяти, связанной с объектом пользователя и изменения состояния может содержать указатели на объекты пользователя `chat_manager::remove_user()` не должен вызываться при обработке изменений состояния.

## <a name="text-chat"></a>Текст чата

### <a name="game-chat"></a>Чат, игры

Чтобы отправить текст разговор с чат игры, `GameChatUser::GenerateTextMessage()` может использоваться. В следующем примере показано, как отправить текстовое сообщение разговор с чат локального пользователя, представленного `chatUser` переменной:

```cpp
chatUser->GenerateTextMessage(L"Hello", false);
```

Второй параметр типа boolean определяет преобразование текста в речь. Дополнительные сведения см. в разделе [специальных возможностей](#accessibility). Игры чата создает чата пакета, содержащего это сообщение. Удаленные экземпляры служб Chat игра будут уведомлены о текстовое сообщение с помощью `OnTextMessageReceived` событий.

### <a name="game-chat-2"></a>Игровой чат 2

Чтобы отправить чат текст с 2 чата игры, используйте `chat_user::chat_user_local::send_chat_text()`. В следующем примере показано, как отправить SMS разговор с чат локального пользователя, представленного `chatUser` переменной:

```cpp
chatUser->local()->send_chat_text(L"Hello");
```

Игры Chat 2 создает кадр данных, содержащий это сообщение; целевые конечные точки для кадров данных будет элементами, связанными с пользователями, которые были настроены для получения текста из локального пользователя. При обработке данных с удаленных конечных точек, сообщение будет предоставлен через `game_chat_text_chat_received_state_change`. Как и в случае с разговора, для текста соблюдаются ограничения прав доступа и конфиденциальности. Если пара пользователей были настроены для разрешить чат текста, но ограничения прав доступа или конфиденциальности запретить обмен данными, текстовое сообщение, будут автоматически удалены.

Поддержка отображения и ввода текста чат является обязательным для объекта специальных возможностей (см. в разделе [специальных возможностей](#accessibility) подробности).

## <a name="accessibility"></a>Специальные возможности

Поддержка текста чат ввода и отображения является обязательным для игры и игры чата 2. Текстовое поле является обязательным, поскольку даже на платформах или игр жанров, которые Исторически не были использовать широко физическую клавишу клавиатуры, пользователи могут настроить систему для использования преобразования текста в речь вспомогательных технологий. Аналогичным образом отображения текста не требуется, поскольку пользователи могут настроить систему для использования распознавания речи в текст. Чат игры и игры Chat 2 предоставляют методы обнаружения и соблюдение настройки специальных возможностей пользователя; Вы можете условно включить механизмы текст, на основании этих параметров.

### <a name="text-to-speech---game-chat"></a>Преобразование текста в речь — игры чата

Если для пользователя включен, текст в речь `GameChatUser::HasRequestedSynthesizedAudio()` возвратит значение true. При обнаружении этого состояния, `GameChatUser::GenerateTextMessage()` Кроме того будет создавать преобразования текста в речь звуковой файл, который вставляется в потоке звука, связанном с локального пользователя. В следующем примере показано, как отправлять текстовые сообщения чата с локального пользователя, представленного `chatUser` переменной:

```cpp
chatUser->GenerateTextMessage(L"Hello", true);
```

Второй логический параметр позволяет приложению переопределить настройки распознавания речи в текст - «true» указывает, что игра Chat генерирования преобразования текста в речь аудио при преобразования текста в речь предпочтениями пользователя была включена, а «false» указывает, что игра Чат никогда не следует создавать преобразования текста в речь аудио из сообщения.

### <a name="text-to-speech---game-chat-2"></a>Преобразование текста в речь — игры чата 2

Если для пользователя включен, текст в речь `chat_user::chat_user_local::text_to_speech_conversion_preference_enabled()` возвращает «true». При обнаружении этого состояния, приложению необходимо предоставить метод для ввода текста. После ввода текста, предоставляемые реальном или виртуальном клавиатуры, передайте строку для `chat_user::chat_user_local::synthesize_text_to_speech()` метод. Игры 2 Chat обнаружит и синтезировать звуковых данных, на основе строки и предпочтениями голосовой доступ пользователя. Например:

```cpp
chat_userA->local()->synthesize_text_to_speech(L"Hello");
```

Аудио, созданным в рамках этой операции будет передаваться ко всем пользователям, которые были настроены для получения аудио из этого локального пользователя. Если `chat_user::chat_user_local::synthesize_text_to_speech()` вызывается для пользователя, у которого нет преобразования текста в речь поддержкой будет 2 Chat игры не выполнять никаких действий.

### <a name="speech-to-text---game-chat"></a>Речь текст - чат, игры

При наличии речи в текст включен, `GameChatUser::HasRequestSynthesizedAudio()` возвращает «true». При обнаружении этого состояния, чат игра будет автоматически транскрипция звука аудио каждого удаленного пользователя и предоставить его через `OnTextMessageReceived` событий. Когда `OnTextMessageReceived` вызывает событие из-за получение сообщения транскрипции, `TextMessageReceivedEventArgs` указывает тип сообщений `ChatTextMessageType::TranscribedSpeechMessage`.

### <a name="speech-to-text---game-chat-2"></a>Речь текст - игр чата 2

При наличии речи в текст включен, `chat_user::chat_user_local::speech_to_text_conversion_preference_enabled()` возвратит значение true. При обнаружении этого состояния, приложение должно быть готово для предоставления пользовательского интерфейса, связанный с расшифрованного сообщения. Игры Chat 2 будет автоматически транскрипция аудио каждого удаленного пользователя и предоставить его через `game_chat_transcribed_chat_received_state_change`.

> `Windows::Xbox::UI::Accessibility` Класс Xbox One специально разработан для предоставления простое отображение текста в игре разговора с упором на вспомогательные технологии распознавания речи в текст.

Ссылаться на [2 с помощью чата игры — вопросы производительности речи в текст](using-game-chat-2.md#speech-to-text-performance-considerations) Дополнительные сведения о вопросах производительности речи в текст.

## <a name="ui"></a>Пользовательский интерфейс

Рекомендуется, что в любом игроков отображаются, особенно в список gamertags, например табло также отображать значки так заметны говоря обратной связи для пользователя. Игры Chat 2 представлена объединенное индикатор, который предоставляет простые средства определения соответствующие элементы пользовательского интерфейса для отображения.

### <a name="game-chat"></a>Чат, игры

Объект `GameChatUser` имеет три свойства, которые обычно исследуются при определении соответствующие элементы пользовательского интерфейса — `GameChatUser::TalkingMode`, `GameChatUser::IsMuted`, и `GameChatUser::RestrictionMode`. В следующем примере демонстрируется возможных эвристику для определения определенный значок постоянное значение, присваиваемое `iconToShow` переменной из `GameChatUser` объекта, на который ссылается переменная «chatUser».

```cpp
if (chatUser->RestrictionMode != None)
{
    if (!chatUser->IsMuted)
    {
        if (chatUser->TalkingMode != NotTalking)
        {
            iconToShow = Icon_ActiveSpeaker;
        }
        else
        {
            iconToShow = Icon_InactiveSpeaker;
        }
    }
    else
    {
        iconToShow = Icon_MutedSpeaker;
    }
}
else
{
    iconToShow = Icon_RestrictedSpeaker;
}
```

### <a name="game-chat-2"></a>Игровой чат 2

Игры чата 2 имеет объединенное `game_chat_user_chat_indicator` используется для представления состояния текущего, моментальное разговора для проигрывателя. Это значение получается путем вызова `chat_user::chat_indicator()`. В следующем примере показано получение значения индикатора для `chat_user` объекта, на который ссылается переменная «chatUser», чтобы определить значение константы определенный значок, чтобы присвоить переменной «iconToShow»:

```cpp
switch (chatUser->chat_indicator())
{
   case game_chat_user_chat_indicator::silent:
   {
       iconToShow = Icon_InactiveSpeaker;
       break;
   }

   case game_chat_user_chat_indicator::talking:
   {
       iconToShow = Icon_ActiveSpeaker;
       break;
   }

   case game_chat_user_chat_indicator::local_microphone_muted:
   {
       iconToShow = Icon_MutedSpeaker;
       break;
   }
   ...
}
```

## <a name="muting"></a>Отключение звука

## <a name="game-chat"></a>Чат, игры

Отключение или включение пользователя в разговоре игры выполняется посредством вызова `ChatManager::MuteUserFromAllChannels()` или `ChatManager::UnMuteUIserFromAllChannels()`, соответственно. Состояние отключения пользователя можно получить, проверив `GameChatUser::IsMuted` или `GameChatUser::IsLocalUserMuted`.

## <a name="game-chat-2"></a>Игровой чат 2

`chat_user::chat_user_local::set_microphone_muted()` Метод можно использовать для переключения состояние отключения элемента локального пользователя "микрофон". Когда Микрофон выключен, не содержат звука из этой "микрофон" будут записаны. Если пользователь находится в общего устройства, такие как Kinect, состояние отключения применяется ко всем пользователям.

`chat_user::chat_user_local::microphone_muted()` Метод может использоваться для получения состояние отключения элемента локального пользователя "микрофон". Этот метод только отражает ли микрофон локального пользователя отключен в программном обеспечении через вызов `chat_user::chat_user_local::set_microphone_muted()`; этот метод не отражает выключить оборудования контролируется, например, с помощью кнопки на гарнитура пользователя. Не существует метода для извлечения состояние выключения звука оборудования звуковое устройство пользователя через 2-чат игры.

`chat_user::chat_user_local::set_remote_user_muted()` Метод можно использовать для переключения состояние отключения удаленных пользователей относительно определенного локального пользователя. Когда удаленный пользователь так заметны, локального пользователя не любого звука или получать текст сообщения из удаленного пользователя.

## <a name="bad-reputation-auto-mute"></a>Ухудшают репутацию автоматическое выключение

Как правило удаленные пользователи будут начинаться unmuted. Чат игры и игры Chat 2 имеется функция «ухудшают репутацию автоматическое выключение». Это означает, что пользователи будут начинаться в состояние выключения звука при (1) удаленный пользователь не друзей с локального пользователя и (2) удаленного пользователя имеет флаг ухудшают репутацию. Игры 2 Chat обеспечивает обратную связь, когда пользователь отключен из-за этой функции. Ссылаться на [2 с помощью чата игры — ухудшают репутацию автоматическое выключение](using-game-chat-2.md#bad-reputation-auto-mute) Дополнительные сведения.

## <a name="privilege-and-privacy"></a>Права доступа и конфиденциальности

Чат игры и игры Chat 2 применять Xbox Live права доступа и конфиденциальности ограничения на основе канала или связи отношений, под управлением приложения. Кроме того, игр 2-чат предоставляет диагностические сведения, чтобы определить, точно как ограничение влияет на направление аудио (например ли Однонаправленная или bi звука аудио ограничение).

### <a name="game-chat"></a>Чат, игры

Игры чата предоставляются права доступа и конфиденциальности данных через `RestrictionMode` свойство. Его можно получить, проверив `GameChatUser::RestrictionMode`.

### <a name="game-chat-2"></a>Игровой чат 2

Игры 2 Chat выполняет поиск ограничение прав доступа и конфиденциальности, при первом добавлении пользователя; пользователя `chat_user::chat_indicator()` всегда будет возвращать `game_chat_user_chat_indicator::silent` до завершения этих операций. Если взаимодействие с пользователем зависит от прав доступа или конфиденциальности ограничение, пользователь `chat_user::chat_indicator()` вернет `game_chat_user_chat_indicator::platform_restricted`. Применяются ограничения взаимодействия платформ к разговору голоса и текста; никогда не будет экземпляр, где текст чата блокируется по ограничению платформы, но разговора не, или наоборот.

`chat_user::chat_user_local::get_effective_communication_relationship()` можно использовать для различения, когда пользователи не могут обмениваться данными из-за неполной права доступа и конфиденциальности операций. Он возвращает отношения взаимодействия, обеспечиваемая 2 Chat игры в виде `game_chat_communication_relationship_flags` и причиной связи не может быть равным настроенные связи в виде `game_chat_communication_relationship_adjuster`. Например, если операции поиска, все еще выполняется `game_chat_communication_relationship_adjuster` будет `game_chat_communication_relationship_adjuster::intializing`. Этот метод должен использоваться в разработки и отладки сценариев; он не должен использоваться для изменения пользовательского интерфейса (см. в разделе [пользовательского интерфейса](#UI)).

## <a name="cleanup"></a>Очистка

Исходный игры разговор `ChatManager` — это класс среды выполнения WinRT - интерфейс с подсчетом ссылок. Таким образом, будет освобождена ресурсов памяти. Если последний счетчик ссылок становится равным нулю и очищаются. Взаимодействие с API C++ Game Chat 2 осуществляется с помощью одноэлементный экземпляр; Если приложение больше не нужна связь через 2-чат игру, необходимо вызвать `chat_manager::cleanup()`. Это позволяет 2 Chat игры немедленно освободить все ресурсы, которые были выделены для управления обменом данными. Сведения об игре Chat 2 WinRT API и управление ресурсами, см. в разделе [с помощью игры Chat 2 WinRT проекций](using-game-chat-2-winrt.md#cleanup).

## <a name="failure-model-and-debugging"></a>Сбой модели и отладка

Исходный Chat игры — это API WinRT; Таким образом он сообщила об ошибках через исключения. Некритической ошибки или предупреждения передаются через обратный вызов необязательно отладки. API C++ Game Chat 2 не вызывать исключения, как средства отчетности, поэтому их можно использовать без труда из проектов без поддержки исключений при желании Некритическая ошибка. Игры 2-чат тем не менее, создает исключения для информирования о неустранимых ошибках. Эти ошибки представляют собой результат несанкционированного использования API, например добавление пользователя к экземпляру игры разговор до инициализации экземпляра, или доступа к объекту пользователя после его удаления из экземпляра Chat игры. Эти ошибки должны исключаться на раннем этапе разработки и можно исправить, изменив шаблон, используемый для взаимодействия с 2 Chat игры. При возникновении такой ошибки, указание относительно причины ошибки выводится отладчик до исключения. WinRT API WinRT игр Chat 2 шаблону сообщения об ошибках через исключения.

## <a name="how-to-configure-popular-scenarios"></a>Как настроить популярные сценарии

См. [с помощью игры Chat 2 - Настройка популярные сценарии](using-game-chat-2.md#how-to-configure-popular-scenarios) примеры по настройке популярных сценариев, таких как Push-уведомлений для разговоров, команд и сценариев связи в стиле вещательных передач.

## <a name="pre-encode-and-post-decode-audio-manipulation"></a>Предварительное кодирование и после декодирования аудио манипуляции

Исходный Chat игры допускается для манипуляций с аудио, разрешив доступ к аудио необработанные "микрофон" через `OnPreEncodeAudioBuffer` и `OnPostDecodeAudioBuffers` события. Игры 2-чат предоставляет эту функцию, через модель опроса. Дополнительные сведения см. [в реальном времени аудио манипуляции](real-time-audio-manipulation.md).
