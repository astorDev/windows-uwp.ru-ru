---
title: Формат BC6H
description: Формат BC6H— это формат сжатия текстуры, предназначенный для обеспечения поддержки цветовых пространств HDR в исходных данных.
ms.assetid: 6781D967-9262-4EE7-B354-7A6D0EA0498E
keywords:
- Формат BC6H
author: michaelfromredmond
ms.author: mithom
ms.date: 02/08/2017
ms.topic: article
ms.localizationpriority: medium
ms.openlocfilehash: be88f06cd5893f2f67697a54754826440bdf7d18
ms.sourcegitcommit: cd00bb829306871e5103db481cf224ea7fb613f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/01/2018
ms.locfileid: "5880764"
---
# <a name="bc6h-format"></a>Формат BC6H


Формат BC6H— это формат сжатия текстуры, предназначенный для обеспечения поддержки цветовых пространств HDR в исходных данных.

## <a name="span-idabout-bc6h-dxgi-format-bc6hspanspan-idabout-bc6h-dxgi-format-bc6hspanspan-idabout-bc6h-dxgi-format-bc6hspanabout-bc6hdxgiformatbc6h"></a><span id="About-BC6H-DXGI-FORMAT-BC6H"></span><span id="about-bc6h-dxgi-format-bc6h"></span><span id="ABOUT-BC6H-DXGI-FORMAT-BC6H"></span>Сведения о BC6H/DXGI\_FORMAT\_BC6H


Формат BC6H обеспечивает высококачественное сжатие изображений, использующих три канала цветов HDR с 16-разрядным значением для каждого канала цвета в составе значения (16:16:16). Альфа-канал не поддерживается.

Формат BC6H задается с помощью следующих значений перечисления DXGI\_FORMAT:

-   **DXGI\_FORMAT\_BC6H\_TYPELESS**.
-   **DXGI\_FORMAT\_BC6H\_UF16**. В этом формате BC6H не используется знаковый бит в 16-разрядных значениях канала цвета с плавающей запятой.
-   **DXGI\_FORMAT\_BC6H\_SF16**. В этом формате BC6H используется знаковый бит в 16-разрядных значениях канала цвета с плавающей запятой.

**Примечание**  16-разрядный формат с плавающей запятой для каналов цвета — это часто называют «полуформатом» с плавающей запятой. Формат имеет следующее расположение битов:
|                       |                                                 |
|-----------------------|-------------------------------------------------|
| UF16 (без знака с плавающей запятой) | 5 разрядов экспоненты + 11 разрядов мантиссы              |
| SF16 (со знаком с плавающей запятой)   | 1 разряд знака + 5 разрядов экспоненты + 10 разрядов мантиссы |

 

 

Формат BC6H можно использовать для ресурсов текстуры [Texture2D](https://msdn.microsoft.com/library/windows/desktop/bb205277) (включая массивы), Texture3D или TextureCube (включая массивы). Аналогичным образом этот формат применяется к любым поверхностям MIP-карты, связанным с этими ресурсами.

В BC6H используется фиксируемый размер блоков— 16 байтов (128 битов) и фиксированный размер плитки— 4x4 текселя. Как и в случае с предыдущими форматами BC, изображения текстур крупнее, чем поддерживаемый размер плитки (4x4), сжимаются с использованием нескольких блоков. Это же удостоверение адресации также применяется к трехмерным изображениям, MIP-картам, картам кубов и массивам текстуры. Все плитки изображений должны иметь один формат.

Оговорки о формате BC6H:

-   BC6H поддерживает денормализацию чисел с плавающей запятой, но не поддерживает сущности типа INF (бесконечность) и NaN (не число). Исключение составляет режим BC6H со знаком (DXGI\_FORMAT\_BC6H\_SF16), который поддерживает -INF (отрицательную бесконечность). Такая поддержка сущности -INF является, по сути, артефактом самого формата и не поддерживается кодировщиками для этого формата. В общем, когда кодировщик встречает входные данные INF (положительной или отрицательной бесконечности) или NaN, кодировщик должен преобразовать эти данные в максимальное допустимое значение представления, отличное от INF, и сопоставить NaN нулю, прежде чем выполнять компрессию.
-   Формат BC6H не поддерживает альфа-канал.
-   Декодер BC6H выполняет распаковку до того, как приступит к фильтрации текстур.
-   Распаковка BC6H должна быть точной на уровне битов, то есть оборудование должно возвращать результаты, идентичные декодеру, который описан в этой документации.

## <a name="span-idbc6h-implementationspanspan-idbc6h-implementationspanspan-idbc6h-implementationspanbc6h-implementation"></a><span id="BC6H-implementation"></span><span id="bc6h-implementation"></span><span id="BC6H-IMPLEMENTATION"></span>Реализация BC6H


Блок BC6H состоит из битов режима, сжатых конечных точек, сжатых индексов и дополнительного индекса раздела. Этот формат задает 14 разных режимов.

Цвет конечной точки хранится в виде RGB-триады. BC6H определяет цветовую палитру по приблизительной линии, проходящей через несколько определенных конечных точек цвета. Кроме того, в зависимости от режима плитка может быть разделена на два региона или обрабатываться как один регион, где плитка с двумя регионами имеет отдельный набор конечных точек цвета для каждого региона. BC6H сохраняет один индекс палитры на тексель.

Если вы работаете с двумя регионами, число возможных разделов равно 32.

## <a name="span-iddecoding-the-bc6h-formatspanspan-iddecoding-the-bc6h-formatspanspan-iddecoding-the-bc6h-formatspandecoding-the-bc6h-format"></a><span id="Decoding-the-BC6H-format"></span><span id="decoding-the-bc6h-format"></span><span id="DECODING-THE-BC6H-FORMAT"></span>Декодирование формата BC6H


В псевдокоде ниже изображены действия по распаковке пикселя в точке (x,y) при наличии 16-байтового блока BC6H.

``` syntax
decompress_bc6h(x, y, block)
{
    mode = extract_mode(block);
    endpoints;
    index;
    
    if(mode.type == ONE)
    {
        endpoints = extract_compressed_endpoints(mode, block);
        index = extract_index_ONE(x, y, block);
    }
    else //mode.type == TWO
    {
        partition = extract_partition(block);
        region = get_region(partition, x, y);
        endpoints = extract_compressed_endpoints(mode, region, block);
        index = extract_index_TWO(x, y, partition, block);
    }
    
    unquantize(endpoints);
    color = interpolate(index, endpoints);
    finish_unquantize(color);
}
```

В таблице ниже указано число битов и значения для каждого из 14 возможных форматов для блоков BC6H.

| Режим | Индексы разделов | Раздел | Конечные точки цвета                  | Биты режима      |
|------|-------------------|-----------|----------------------------------|----------------|
| 1    | 46 битов           | 5 битов    | 75 битов (10,555, 10,555, 10,555) | 2 бита (00)    |
| 2    | 46 битов           | 5 битов    | 75 битов (7666, 7666, 7666)       | 2 бита (01)    |
| 3    | 46 битов           | 5 битов    | 72 бита (11,555, 11,444, 11,444) | 5 битов (00010) |
| 4    | 46 битов           | 5 битов    | 72 бита (11,444, 11,555, 11,444) | 5 битов (00110) |
| 5    | 46 битов           | 5 битов    | 72 бита (11,444, 11,444, 11,555) | 5 битов (01010) |
| 6    | 46 битов           | 5 битов    | 72 бита (9555, 9555, 9555)       | 5 битов (01110) |
| 7    | 46 битов           | 5 битов    | 72 бита (8666, 8555, 8555)       | 5 битов (10010) |
| 8    | 46 битов           | 5 битов    | 72 бита (8555, 8666, 8555)       | 5 битов (10110) |
| 9    | 46 битов           | 5 битов    | 72 бита (8555, 8555, 8666)       | 5 битов (11010) |
| 10   | 46 битов           | 5 битов    | 72 бита (6666, 6666, 6666)       | 5 битов (11110) |
| 11   | 63 бита           | 0 битов    | 60 битов (10,10, 10,10, 10,10)    | 5 битов (00011) |
| 12   | 63 бита           | 0 битов    | 60 битов (11,9, 11,9, 11,9)       | 5 битов (00111) |
| 13   | 63 бита           | 0 битов    | 60 битов (12,8, 12,8, 12,8)       | 5 битов (01011) |
| 14   | 63 бита           | 0 битов    | 60 битов (16,4, 16,4, 16,4)       | 5 битов (01111) |

 

Каждый формат в этой таблице можно уникально идентифицировать битами режима. Первые десять режимов используются для плиток с двумя регионами, а поле бита режима может иметь длину два бита или пять битов. Эти блоки также имеют поля для конечных точек сжатого цвета (72 или 75 битов), раздела (5 битов) и индексов раздела (46 битов).

Для конечных точек сжатого цвета значения в предыдущей таблице обозначают точность сохраненных конечных точек RGB и число битов, используемых для каждого значения цвета. Например, режим 3 указывает на 11 уровень точности конечной точки цвета, а число битов, используемых для хранения дельта-значений преобразованных конечных точек для красного, синего и зеленого цветов (5, 4 и 4 соответственно). В режиме 10 не используется дельта-сжатие. Вместо этого все четыре конечные точки цвета сохраняются явно.

Последние четыре режима блока используются для плиток с одним регионом, где поле режима равно 5 битам. Эти блоки имеют поля для конечных точек (60 битов) и сжатых индексов (63 бита), В режиме 11 (как и в режиме 10) не используется дельта-сжатие. Вместо этого конечные точки цвета сохраняются явно.

Режимы 10011, 10111, 11011 и 11111 (не показан) зарезервированы. Не используйте их в своем кодировщике. Если оборудование представляет собой переданные блоки и задан один из этих режимов, полученный распакованный блок должен содержать все нули во всех каналах, кроме альфа-канала.

Для BC6H альфа-канал должен всегда возвращать 1,0 независимо от режима.

### <a name="span-idbc6h-partition-setspanspan-idbc6h-partition-setspanspan-idbc6h-partition-setspanbc6h-partition-set"></a><span id="BC6H-partition-set"></span><span id="bc6h-partition-set"></span><span id="BC6H-PARTITION-SET"></span>Набор разделов BC6H

Существует 32 возможных набора разделов для плитки с двумя регионами, которые определены в таблице ниже. Каждый блок 4x4 представляет одну фигуру.

![таблица наборов разделов bc6h](images/bc6h-partition-sets.png)

В этой таблице наборов разделов выделенная полужирным шрифтом и подчеркиванием запись является расположением индекса исправления для подмножества 1 (которое задается с количеством битов на 1 меньше). Индекс исправления для подмножества 0— это всегда нулевой индекс, поскольку разделение на разделы всегда организовано так, чтобы нулевой индекс находился в нулевом подмножестве. Порядок разделения на разделы: из верхнего левого угла до нижнего правого, перемещаясь слева направо и сверху вниз.

## <a name="span-idbc6h-compressed-endpoint-formatspanspan-idbc6h-compressed-endpoint-formatspanspan-idbc6h-compressed-endpoint-formatspanbc6h-compressed-endpoint-format"></a><span id="BC6H-compressed-endpoint-format"></span><span id="bc6h-compressed-endpoint-format"></span><span id="BC6H-COMPRESSED-ENDPOINT-FORMAT"></span>Формат BC6H сжатой конечной точки


![битовые поля для форматов bc6h сжатой конечной точки](images/bc6h-headers-med.png)

В этой таблице показаны битовые поля для сжатых конечных точек в качестве функции формата конечной точки, при этом каждый столбец задает кодировку, а каждая строка— битовое поле. В рамках этого подхода число битов для плиток с двумя регионами составляет 82, а для плиток с одним регионом— 65. Например, первые 5 битов для кодировки с одним регионом \[16 4\] выше (а именно крайний правый столбец)— это биты m\ [4:0\], следующие 10 битов— биты rw\ [9:0\] и так далее, а последние 6 битов содержат bw\ [10:15\].

Имена полей в таблице выше определяются следующим образом:

| Поле | Переменная          |
|-------|-------------------|
| m     | режим              |
| d     | индекс фигуры       |
| rw    | endpt\[0\].A\[0\] |
| rx    | endpt\[0\].B\[0\] |
| ry    | endpt\[1\].A\[0\] |
| rz    | endpt\[1\].B\[0\] |
| gw    | endpt\[0\].A\[1\] |
| gx    | endpt\[0\].B\[1\] |
| gy    | endpt\[1\].A\[1\] |
| gz    | endpt\[1\].B\[1\] |
| bw    | endpt\[0\].A\[2\] |
| bx    | endpt\[0\].B\[2\] |
| by    | endpt\[1\].A\[2\] |
| bz    | endpt\[1\].B\[2\] |

 

Endpt\[i\], где i— это 0 или 1, относится к нулевому или первому набору конечных точек соответственно.
## <a name="span-idsign-extension-for-endpoint-valuesspanspan-idsign-extension-for-endpoint-valuesspanspan-idsign-extension-for-endpoint-valuesspansign-extension-for-endpoint-values"></a><span id="Sign-extension-for-endpoint-values"></span><span id="sign-extension-for-endpoint-values"></span><span id="SIGN-EXTENSION-FOR-ENDPOINT-VALUES"></span>Расширение знака для значений конечных точек


Для плиток с двумя регионами существует четыре значения конечных точек, для которых можно расширить знак. Значение Endpt\[0\].A имеет знак, только если формат имеет знак; другие конечные точки имеют знак, только если конечная точка была преобразована или если формат имеет знак. Приведенный ниже код демонстрирует алгоритм расширения знака значений конечной точки с двумя регионами.

``` syntax
static void sign_extend_two_region(Pattern &p, IntEndpts endpts[NREGIONS_TWO])
{
    for (int i=0; i<NCHANNELS; ++i)
    {
      if (BC6H::FORMAT == SIGNED_F16)
        endpts[0].A[i] = SIGN_EXTEND(endpts[0].A[i], p.chan[i].prec);
      if (p.transformed || BC6H::FORMAT == SIGNED_F16)
      {
        endpts[0].B[i] = SIGN_EXTEND(endpts[0].B[i], p.chan[i].delta[0]);
        endpts[1].A[i] = SIGN_EXTEND(endpts[1].A[i], p.chan[i].delta[1]);
        endpts[1].B[i] = SIGN_EXTEND(endpts[1].B[i], p.chan[i].delta[2]);
      }
    }
}
```

Для плиток с одним регионом поведение аналогичное, однако endpt\[1\] удален.

``` syntax
static void sign_extend_one_region(Pattern &p, IntEndpts endpts[NREGIONS_ONE])
{
    for (int i=0; i<NCHANNELS; ++i)
    {
    if (BC6H::FORMAT == SIGNED_F16)
        endpts[0].A[i] = SIGN_EXTEND(endpts[0].A[i], p.chan[i].prec);
    if (p.transformed || BC6H::FORMAT == SIGNED_F16) 
        endpts[0].B[i] = SIGN_EXTEND(endpts[0].B[i], p.chan[i].delta[0]);
    }
}
```

## <a name="span-idtransform-inversion-for-endpoint-valuesspanspan-idtransform-inversion-for-endpoint-valuesspanspan-idtransform-inversion-for-endpoint-valuesspantransform-inversion-for-endpoint-values"></a><span id="Transform-inversion-for-endpoint-values"></span><span id="transform-inversion-for-endpoint-values"></span><span id="TRANSFORM-INVERSION-FOR-ENDPOINT-VALUES"></span>Преобразование инверсии для значений конечных точек


Для плиток с двумя регионами преобразование применяет инверсию кодировки разницы, добавляя базовое значение в endpt\[0\].A к трем другим записям. Всего получается 9 операций добавления. На следующем рисунке базовое значение представляется в виде "A0" и имеет наивысшую точность плавающей точки. "A1" "B0" и "B1"— это дельты, вычисленные на основе значения привязки, и эти значения привязки представлены с более низкой точностью. (A0 соответствует endpt\[0\].A, B0 соответствует endpt\[0\].B, A1 соответствует endpt\[1\].A, а B1 соответствует endpt\[1\].B.)

![расчет значений конечных точек инверсии преобразования](images/bc6h-transform-inverse.png)

Для плиток с одним регионом существует только одно дельта-смещение и, следовательно, только три операции добавления.

Распаковщик должен убедиться, что результаты обратного преобразования не переполнят точность endpt\[0\].a. В случае переполнения значения, которые являются результатом обратного преобразования, должны быть заключены в оболочку из того же числа битов. Если точность A0— "p" битов, алгоритм преобразования выглядит следующим образом:

`B0 = (B0 + A0) & ((1 << p) - 1)`

Для форматов со знаком результаты вычисления дельты также должны иметь расширение со знаком. Если в ходе операции расширение знака рассматривается расширение обоих знаков, где 0— положительное, а 1— отрицательное, расширение знака 0 обработает фиксацию выше. Аналогично, после фиксации выше необходимо расширять знаком только значение 1 (отрицательное).

## <a name="span-idunquantization-of-color-endpointsspanspan-idunquantization-of-color-endpointsspanspan-idunquantization-of-color-endpointsspanunquantization-of-color-endpoints"></a><span id="Unquantization-of-color-endpoints"></span><span id="unquantization-of-color-endpoints"></span><span id="UNQUANTIZATION-OF-COLOR-ENDPOINTS"></span>Расквантование конечных точек цвета


Учитывая, что конечные точки не сжаты, следующий шаг— выполнить исходное расквантование конечных точек цвета. Это включает три шага:

-   Расквантование цветовых палитр
-   Интерполяция палитр
-   Завершение расквантования

Разделение процесса расквантования на две части (расквантование цветовой палитры перед интерполяцией и окончательное расквантование после интерполяции) уменьшает число необходимых операций умножения по сравнению с полным расквантованием перед интерполяцией палитры.

Код ниже иллюстрирует процесс извлечения оценок исходных 16-разрядных значений цвета с последующим использованием предоставленных значений веса для добавления в палитру 6 дополнительных значений цвета. Та же операция выполняется в каждом канале.

``` syntax
int aWeight3[] = {0, 9, 18, 27, 37, 46, 55, 64};
int aWeight4[] = {0, 4, 9, 13, 17, 21, 26, 30, 34, 38, 43, 47, 51, 55, 60, 64};

// c1, c2: endpoints of a component
void generate_palette_unquantized(UINT8 uNumIndices, int c1, int c2, int prec, UINT16 palette[NINDICES])
{
    int* aWeights;
    if(uNumIndices == 8)
        aWeights = aWeight3;
    else  // uNumIndices == 16
        aWeights = aWeight4;

    int a = unquantize(c1, prec); 
    int b = unquantize(c2, prec);

    // interpolate
    for(int i = 0; i < uNumIndices; ++i)
        palette[i] = finish_unquantize((a * (64 - aWeights[i]) + b * aWeights[i] + 32) >> 6);
}
```

В следующем примере кода показан процесс интерполяции с учетом следующих соображений:

-   Поскольку полный диапазон значений цвета для функции **unquantize** (ниже)— с -32768 до 65535, средство интерполяции реализуется с использованием 17-разрядного арифметического со знаком.
-   После интерполяции значения передаются в функцию **finish\_unquantize** (описанную в третьем примере в этом разделе), которая применяет окончательное масштабирование.
-   Все аппаратные распаковщики должны возвращать из этих функций результаты с точными значениями разрядов.

``` syntax
int unquantize(int comp, int uBitsPerComp)
{
    int unq, s = 0;
    switch(BC6H::FORMAT)
    {
    case UNSIGNED_F16:
        if(uBitsPerComp >= 15)
            unq = comp;
        else if(comp == 0)
            unq = 0;
        else if(comp == ((1 << uBitsPerComp) - 1))
            unq = 0xFFFF;
        else
            unq = ((comp << 16) + 0x8000) >> uBitsPerComp;
        break;

    case SIGNED_F16:
        if(uBitsPerComp >= 16)
            unq = comp;
        else
        {
            if(comp < 0)
            {
                s = 1;
                comp = -comp;
            }

            if(comp == 0)
                unq = 0;
            else if(comp >= ((1 << (uBitsPerComp - 1)) - 1))
                unq = 0x7FFF;
            else
                unq = ((comp << 15) + 0x4000) >> (uBitsPerComp-1);

            if(s)
                unq = -unq;
        }
        break;
    }
    return unq;
}
```

**finish\_unquantize** вызывается после интерполяции палитры. Функция **unquantize** откладывает масштабирование на 31/32 для значений со знаком и на 31/64 для значений без знака. Это поведение необходимо, чтобы окончательное значение находилось в допустимом полудиапазоне (-0x7BFF–0x7BFF) по окончании интерполяции палитры с целью уменьшения общего количества необходимых умножений. **finish\_unquantize** применяет окончательное масштабирование и возвращает значение **unsigned short**, которое затем повторно интерпретируется в **half**.

``` syntax
unsigned short finish_unquantize(int comp)
{
    if(BC6H::FORMAT == UNSIGNED_F16)
    {
        comp = (comp * 31) >> 6;                                         // scale the magnitude by 31/64
        return (unsigned short) comp;
    }
    else // (BC6H::FORMAT == SIGNED_F16)
    {
        comp = (comp < 0) ? -(((-comp) * 31) >> 5) : (comp * 31) >> 5;   // scale the magnitude by 31/32
        int s = 0;
        if(comp < 0)
        {
            s = 0x8000;
            comp = -comp;
        }
        return (unsigned short) (s | comp);
    }
}
```

## <a name="span-idrelated-topicsspanrelated-topics"></a><span id="related-topics"></span>Связанные статьи


[Сжатие блоков текстур](texture-block-compression.md)

 

 




