---
title: Сжатие блоков
description: Сжатие блоков — это метод сжатия текстур с потерями с целью уменьшения размера текстуры и нагрузки на память и, соответственно, повышения производительности. Текстура, сжатая по блокам, может быть меньше, чем текстура с 32 битами на цвет.
ms.assetid: 2FAD6BE8-C6E4-4112-AF97-419CD27F7C73
keywords:
- Сжатие блоков
author: michaelfromredmond
ms.author: mithom
ms.date: 02/08/2017
ms.topic: article
ms.localizationpriority: medium
ms.openlocfilehash: 4c959ced5ada9145ca494dd023c9aa802d7dccc2
ms.sourcegitcommit: 6cc275f2151f78db40c11ace381ee2d35f0155f9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/25/2018
ms.locfileid: "5544587"
---
# <a name="block-compression"></a>Сжатие блоков


Сжатие блоков — это метод сжатия текстур с потерями с целью уменьшения размера текстуры и нагрузки на память и, соответственно, повышения производительности. Текстура, сжатая по блокам, может быть меньше, чем текстура с 32 битами на цвет.

Сжатие блока — это метод сжатия текстур для уменьшения их размера. По сравнению с текстурой с 32 битами на цвет текстура со сжатыми блоками может быть до 75% меньше. Как правило, приложения начинают работать быстрее при использовании сжатия блоков, поскольку нагрузка на память снижается.

Сжатие блоков выполняется с потерями, однако работает хорошо и рекомендуется для всех текстур, преобразуемых и фильтруемых конвейером. Текстуры, которые напрямую сопоставляются экрану (элементы пользовательского интерфейса, такие как значки и текст), не очень подходят для сжатия, поскольку артефакты более заметны.

Текстура со сжатыми блоками должна создаваться как кратная размеру 4 во всех измерениях, ее невозможно использовать в качестве выходных данных конвейера.

## <a name="span-idbasicsspanspan-idbasicsspanspan-idbasicsspanhow-block-compression-works"></a><span id="Basics"></span><span id="basics"></span><span id="BASICS"></span>Как работает сжатие блоков


Сжатие блоков — это метод уменьшения объема памяти, необходимой для хранения данных цвета. Сохраняя некоторые цвета в первоначальном размере, а другие— с использованием схемы кодирования, можно существенно уменьшить объем памяти, необходимый для хранения изображения. Поскольку оборудование автоматически декодирует сжатые данные, использование сжатых текстур не приводит к снижению производительности.

Чтобы узнать, как работает сжатие, рассмотрите следующие два примера. В первом примере описывается объем памяти, используемой при хранении несжатых данных; а второй— объем памяти при хранении сжатых данных.

-   [Хранение несжатых данных](#storing-uncompressed-data)
-   [Хранение сжатых данных](#storing-compressed-data)

### <a name="span-idstoringuncompresseddataspanspan-idstoringuncompresseddataspanspan-idstoringuncompresseddataspanspan-idstoring-uncompressed-dataspanstoring-uncompressed-data"></a><span id="Storing_Uncompressed_Data"></span><span id="storing_uncompressed_data"></span><span id="STORING_UNCOMPRESSED_DATA"></span><span id="storing-uncompressed-data"></span>Хранение несжатых данных

На следующем рисунке показана текстура 4×4 без сжатия. Допустим, каждый цвет имеет один компонент цвета (например, красный) и хранится в одном байте памяти.

![текстура 4x4 без сжатия](images/d3d10-block-compress-1.png)

Несжатые данные располагаются в памяти последовательно и требуют 16 байтов для хранения, как показано на следующем рисунке.

![несжатые данные в последовательной памяти](images/d3d10-block-compress-2.png)

### <a name="span-idstoringcompresseddataspanspan-idstoringcompresseddataspanspan-idstoringcompresseddataspanspan-idstoring-compressed-dataspanstoring-compressed-data"></a><span id="Storing_Compressed_Data"></span><span id="storing_compressed_data"></span><span id="STORING_COMPRESSED_DATA"></span><span id="storing-compressed-data"></span>Хранение сжатых данных

Вы увидели, сколько памяти требуется для хранения несжатого изображения. А теперь посмотрим, сколько памяти экономит сжатое изображение. Формат сжатия [BC1](#bc1) сохраняет 2 цвета (по 1 байту каждый) и 16 3-битовых индексов (48 битов или 6 байтов), которые используются для интерполяции первоначальных цветов в текстуре, как показано на следующем рисунке.

![Формат сжатия bc1](images/d3d10-block-compress-3.png)

Совокупное пространство, необходимое для хранения сжатых данных, равно 8 байтов, то есть экономия памяти составляет 50% по сравнению с примером без сжатия. Экономия увеличивается, если используется несколько компонентов цвета.

Значительная экономия памяти, обеспечиваемая сжатием блоков, позволяет существенно повысить производительность. Это повышение производительности происходит за счет снижения качества изображения (из-за интерполяции цвета); однако более низкое качество не всегда заметно.

В следующем разделе показано, как Direct3D обеспечивает использование сжатия блоков в приложении.

## <a name="span-idusingblockcompressionspanspan-idusingblockcompressionspanspan-idusingblockcompressionspanusing-block-compression"></a><span id="Using_Block_Compression"></span><span id="using_block_compression"></span><span id="USING_BLOCK_COMPRESSION"></span>Использование сжатия блоков


Создайте текстуру со сжатыми блоками точно так же, как несжатую текстуру, с той лишь разницей, что необходимо указать формат со сжатием блоков.

Затем создайте представления, чтобы привязать текстуру к конвейеру. Поскольку текстура со сжатием блоков может использоваться только в качестве входных данных на этапе шейдера, необходимо создать представление ресурса шейдера.

Используйте текстуру со сжатыми блоками так же, как вы бы использовали текстуру без сжатия. Если ваше приложение будет использовать указатель памяти на данные со сжатием блоков, потребуется учетная запись для заполнения памяти в MIP-карте, из-за чего объявленный размер может отличаться от фактического.

-   [Виртуальный размер и физический размер](#virtual-size-versus-physical-size)

### <a name="span-idvirtualsizespanspan-idvirtualsizespanspan-idvirtualsizespanspan-idvirtual-size-versus-physical-sizespanvirtual-size-versus-physical-size"></a><span id="Virtual_Size"></span><span id="virtual_size"></span><span id="VIRTUAL_SIZE"></span><span id="virtual-size-versus-physical-size"></span>Виртуальный размер и физический размер

Если у вас есть код приложения, который использует указатель памяти для прохода памяти текстуры со сжатием блоков, существует один важный аспект, который может потребовать изменения кода приложения. Текстура со сжатием блоков должна быть кратна 4 во всех измерениях, поскольку алгоритмы сжатия блоков работают с блоками текселей 4x4. Это может представлять проблему для MIP-карты, первоначальные габариты которой кратны 4, а подразделенные уровни— нет. На следующей схеме показаны различия областей между виртуальным (объявленным) и физическим (фактическим) размером каждого уровня MIP-карты.

![несжатые и сжатые уровни MIP-карты](images/d3d10-block-compress-pad.png)

В левой части схемы показаны размеры уровня MIP-карты, создаваемые для несжатой текстуры 60×40. Размер верхнего уровня взят из вызова API, создающего текстуру; размер каждого последующего уровня равен половине размера предыдущего уровня. Для несжатой текстуры нет различия между виртуальным (объявленным) и физическим (фактическим) размером.

В правой части схемы показаны размеры уровня MIP-карты, которые создаются для той же текстуры 60×40 со сжатием. Обратите внимание, что на втором и третьем уровнях используется заполнение памяти, чтобы сделать размеры кратными 4 на каждом уровне. Это необходимо, чтобы эти алгоритмы могли работать с блоками текселей 4×4. Это особенно очевидно, если вы рассматриваете уровни MIP-карт менее 4×4; размеры этих очень маленьких MIP-карт при выделении памяти текстуры будут округляться до ближайшего кратного 4 числа.

Оборудование для выборки использует виртуальный размер; при выборке текстуры заполнение памяти игнорируется. Для уровней MIP-карт менее 4×4 только первые четыре текселя будут использоваться для карты 2×2 и только первый тексель будет использоваться для блока 1×1. Однако нет структуры API, которая предоставляет физический размер (включая заполнение памяти).

Необходимо с большой осторожностью пользоваться выровненными блоками памяти при копировании регионов, которые содержат данные со сжатием блоков. Чтобы сделать это в приложении с указателем памяти, убедитесь, что указатель использует шаг поверхности для учета размера физической памяти.

## <a name="span-idcompressionalgorithmsspanspan-idcompressionalgorithmsspanspan-idcompressionalgorithmsspancompression-algorithms"></a><span id="Compression_Algorithms"></span><span id="compression_algorithms"></span><span id="COMPRESSION_ALGORITHMS"></span>Алгоритмы сжатия


Техника сжатия блоков в Direct3D подразумевает разделение данных несжатой текстуры в блоки 4×4, сжатие каждого блока и последующее сохранение файлов. По этой причине сжимаемые текстуры должны иметь габариты, кратные 4.

![сжатие блоков](images/d3d10-compression-1.png)

На предыдущей схеме показана текстура, разделенная на блоки текселей. Первый блок показывает структуру 16 текселей, помеченных с a до p, однако во всех блоках данные организованы одинаково.

Direct3D реализует несколько схем сжатия, каждая из которых представляет собой разные компромиссы между количеством хранимых компонентов, количеством битов на компонент и объемом потребляемой памяти. Воспользуйтесь этой таблицей, чтобы выбрать формат, который больше всего подходит для вашего типа и разрешения данных в приложении.

| Исходные данные                     | Разрешение сжатия данных (в битах) | Выберите этот формат сжатия |
|---------------------------------|---------------------------------------|--------------------------------|
| Трех-компонентный цвет и альфа | Цвет (5:6:5), альфа (1) или без альфа  | [BC1](#bc1)                    |
| Трех-компонентный цвет и альфа | Цвет (5:6:5), альфа (4)              | [BC2](#bc2)                    |
| Трех-компонентный цвет и альфа | Цвет (5:6:5), альфа (8)              | [BC3](#bc3)                    |
| Однокомпонентный цвет             | Один компонент (8)                     | [BC4](#bc4)                    |
| Двухкомпонентный цвет             | Два компонента (8:8)                  | [BC5](#bc5)                    |

 

-   [BC1](#bc1)
-   [BC2](#bc2)
-   [BC3](#bc3)
-   [BC4](#bc4)
-   [BC5](#bc5)

### <a name="span-idbc1spanspan-idbc1spanbc1"></a><span id="BC1"></span><span id="bc1"></span>BC1

Используйте первый формат сжатия блоков (BC1) (DXGI\_FORMAT\_BC1\_TYPELESS, DXGI\_FORMAT\_BC1\_UNORM или DXGI\_BC1\_UNORM\_SRGB) для хранения данных о трехкомпонентном цвете с использованием цвета 5:6:5 (5 битов красного, 6 битов зеленого, 5 битов синего). Это актуально, даже если данные также содержат 1-битовый альфа-канал. Допустим, текстура 4×4 использует самый крупный из возможных форматов данных. В этом случае формат BC1 уменьшает объем необходимой памяти с 48 байтов (16 цветов × 3 компонента/цвет × 1 байт/компонент) до 8 байтов.

Этот алгоритм работает в блоках текселей 4×4. Вместо хранения 16 цветов алгоритм сохраняет 2 эталонных цвета (color\_0 и color\_1) и 16 2-битовых индекса цвета (блоки a–p), как показано на следующей схеме.

![структура для сжатия bc1](images/d3d10-compression-bc1.png)

Индексы цвета (a–p) используются для поиска первоначальных цветов в таблице цветов. Таблица цветов содержит 4 цвета. Первые два цвета — color\_0 и color\_1 — минимальный и максимальный цвета. Другие два цвета— color\_2 и color\_3— являются промежуточными цветами, которые вычисляются с использованием линейной интерполяции.

```
color_2 = 2/3*color_0 + 1/3*color_1
color_3 = 1/3*color_0 + 2/3*color_1
```

Четырем цветам назначаются 2-битовые значения индекса, которые сохраняются в блоках a–p.

```
color_0 = 00
color_1 = 01
color_2 = 10
color_3 = 11
```

Наконец, все цвета в блоках a–p сравниваются с четырьмя цветами в таблице цветов, и индекс ближайшего цвета сохраняется в 2-битовых блоках.

Этот алгоритм пригоден для данных, которые также содержит 1-битовый альфа-канал. Единственное различие в том, что color\_3 задан равным 0 (прозрачный цвет), а color\_2 представляет собой линейное слияние color\_0 и color\_1.

```
color_2 = 1/2*color_0 + 1/2*color_1;
color_3 = 0;
```

### <a name="span-idbc2spanspan-idbc2spanbc2"></a><span id="BC2"></span><span id="bc2"></span>BC2

Используйте формат BC2 (DXGI\_FORMAT\_BC2\_TYPELESS, DXGI\_FORMAT\_BC2\_UNORM или DXGI\_BC2\_UNORM\_SRGB) для хранения данных, содержащих данные о цвете и альфа низкой согласованности (используйте [BC3](#bc3) для альфа-данных высокой согласованности). Формат BC2 хранит данные RGB как цвет 5:6:5 (5 битов на красный, 6 битов на зеленый, 5 битов на синий), а альфа-канал— как отдельное 4-битовое значение. Допустим, текстура 4×4 использует самый крупный из возможных форматов данных. В этом случае эта техника сжатия уменьшает объем необходимой памяти с 64 байтов (16 цветов × 4 компонента/цвет × 1 байт/компонент) до 16 байтов памяти.

Формат BC2 сохраняет цвета с тем же количеством битов и той же структурой данных, что и формат [BC1](#bc1); однако формату BC2 требуются дополнительно 64 бита памяти для хранения альфа-данных, как показано на следующей схеме.

![структура для сжатия bc2](images/d3d10-compression-bc2.png)

### <a name="span-idbc3spanspan-idbc3spanbc3"></a><span id="BC3"></span><span id="bc3"></span>BC3

Используйте формат BC3 (DXGI\_FORMAT\_BC3\_TYPELESS, DXGI\_FORMAT\_BC3\_UNORM или DXGI\_BC3\_UNORM\_SRGB) для хранения данных о цвете высокой согласованности (используйте [BC2](#bc2) для хранения альфа-данных более низкой согласованности). Формат BC3 сохраняет данные цвета с использованием цвета 5:6:5 (5 битов красного, 6 битов зеленого, 5 битов синего) и альфа-данные с использованием одного байта. Допустим, текстура 4×4 использует самый крупный из возможных форматов данных. В этом случае эта техника сжатия уменьшает объем необходимой памяти с 64 байтов (16 цветов × 4 компонента/цвет × 1 байт/компонент) до 16 байтов памяти.

Формат BC3 сохраняет цвета с тем же количеством битов и той же структурой данных, что и формат [BC1](#bc1); однако формату BC3 требуются дополнительно 64 бита памяти для хранения альфа-данных. Формат BC3 обрабатывает альфа-канал, сохраняя два эталонных значения и выполняя интерполяцию между ними (аналогично сохранению цвета RGB в формате BC1).

Этот алгоритм работает в блоках текселей 4×4. Вместо того чтобы хранить 16 альфа-значений, алгоритм сохраняет 2 эталонных альфа-значения (alpha\_0 и alpha\_1) и 16 3-битовых индекса цвета (с alpha a по alpha p), как показано на следующей схеме.

![структура для сжатия bc3](images/d3d10-compression-bc3.png)

Формат BC3 использует альфа-индексы (a–p) для поиска первоначальных цветов в таблице поиска, которая содержит 8 значений. Первые два значения— alpha\_0 и alpha\_1 — являются минимальным и максимальным значениями; другие шесть промежуточных значений вычисляются с использованием линейной интерполяции.

Алгоритм определяет количество интерполированных альфа-значений, анализируя два эталонных альфа-значения. Если alpha\_0 больше alpha\_1, то BC3 интерполирует 6 альфа-значений; в противном случае интерполируется только 4 значения. Если BC3 интерполирует только 4 альфа-значения, он задает два дополнительных альфа-значения (0 для полностью прозрачного и 255 для полностью непрозрачного). BC3 сжимает альфа-значения в области текселей 4×4, сохраняя битовый код, соответствующий интерполированным альфа-значениям, которые наиболее полно соответствуют исходному альфа-значению для заданного текселя.

```
if( alpha_0 > alpha_1 )
{
  // 6 interpolated alpha values.
  alpha_2 = 6/7*alpha_0 + 1/7*alpha_1; // bit code 010
  alpha_3 = 5/7*alpha_0 + 2/7*alpha_1; // bit code 011
  alpha_4 = 4/7*alpha_0 + 3/7*alpha_1; // bit code 100
  alpha_5 = 3/7*alpha_0 + 4/7*alpha_1; // bit code 101
  alpha_6 = 2/7*alpha_0 + 5/7*alpha_1; // bit code 110
  alpha_7 = 1/7*alpha_0 + 6/7*alpha_1; // bit code 111
}
else
{
  // 4 interpolated alpha values.
  alpha_2 = 4/5*alpha_0 + 1/5*alpha_1; // bit code 010
  alpha_3 = 3/5*alpha_0 + 2/5*alpha_1; // bit code 011
  alpha_4 = 2/5*alpha_0 + 3/5*alpha_1; // bit code 100
  alpha_5 = 1/5*alpha_0 + 4/5*alpha_1; // bit code 101
  alpha_6 = 0;                         // bit code 110
  alpha_7 = 255;                       // bit code 111
}
```

### <a name="span-idbc4spanspan-idbc4spanbc4"></a><span id="BC4"></span><span id="bc4"></span>BC4

Используйте формат BC4 для хранения данных об однокомпонентном цвете с использованием 8 битов каждого цвета. В результате повышенной точности (по сравнению с [BC1](#bc1)) BC4 становится идеальным средством для хранения данных с плавающей запятой в диапазоне \[0 до 1\] с использованием формата DXGI\_FORMAT\_BC4\_UNORM и в диапазоне \[-1 до +1\] с использованием формата DXGI\_FORMAT\_BC4\_SNORM. Допустим, текстура 4×4 использует самый крупный из возможных форматов данных. В этом случае эта техника сжатия уменьшает объем необходимой памяти с 16 байтов (16 цветов × 1 компонент/цвет × 1 байт/компонент) до 8 байтов.

Этот алгоритм работает в блоках текселей 4×4. Вместо хранения 16 цветов алгоритм сохраняет 2 эталонных цвета (red\_0 и red\_1) и 16 3-битовых индекса цвета (с red a по red p), как показано на следующей схеме.

![структура для сжатия bc4](images/d3d10-compression-bc4.png)

Алгоритм использует 3-битовые индексы для поиска цветов в таблице цветов, которая содержит 8 элементов. Первые два цвета — red\_0 и red\_1 — минимальный и максимальный цвета. Этот алгоритм вычисляет оставшиеся цвета с использованием линейной интерполяции.

Алгоритм определяет количество интерполированных значений цвета, анализируя два эталонных значения. Если red\_0 больше red\_1, то BC4 интерполирует 6 значений цвета; в противном случае интерполируется 4 значения. Если BC4 интерполирует только 4 значения цвета, задается два дополнительных значения цвета (0.0f для полностью прозрачного и 1.0f для полностью непрозрачного). BC4 сжимает альфа-значения в области текселей 4×4, сохраняя битовый код, соответствующий интерполированным альфа-значениям, которые наиболее полно соответствуют исходному альфа-значению для заданного текселя.

-   [BC4\_UNORM](#bc4-unorm)
-   [BC4\_SNORM](#bc4-snorm)

### <a name="span-idbc4unormspanspan-idbc4unormspanspan-idbc4-unormspanbc4unorm"></a><span id="BC4_UNORM"></span><span id="bc4_unorm"></span><span id="bc4-unorm"></span>BC4\_UNORM

Следующий пример кода показывает, как выполняется интерполяция однокомпонентных данных.

```
unsigned word red_0, red_1;

if( red_0 > red_1 )
{
  // 6 interpolated color values
  red_2 = (6*red_0 + 1*red_1)/7.0f; // bit code 010
  red_3 = (5*red_0 + 2*red_1)/7.0f; // bit code 011
  red_4 = (4*red_0 + 3*red_1)/7.0f; // bit code 100
  red_5 = (3*red_0 + 4*red_1)/7.0f; // bit code 101
  red_6 = (2*red_0 + 5*red_1)/7.0f; // bit code 110
  red_7 = (1*red_0 + 6*red_1)/7.0f; // bit code 111
}
else
{
  // 4 interpolated color values
  red_2 = (4*red_0 + 1*red_1)/5.0f; // bit code 010
  red_3 = (3*red_0 + 2*red_1)/5.0f; // bit code 011
  red_4 = (2*red_0 + 3*red_1)/5.0f; // bit code 100
  red_5 = (1*red_0 + 4*red_1)/5.0f; // bit code 101
  red_6 = 0.0f;                     // bit code 110
  red_7 = 1.0f;                     // bit code 111
}
```

Эталонным цветам назначаются 3-битовые индексы (000–111, поскольку значений 8), которые сохраняются в блоках с red a до red p во время сжатия.

### <a name="span-idbc4snormspanspan-idbc4snormspanspan-idbc4-snormspanbc4snorm"></a><span id="BC4_SNORM"></span><span id="bc4_snorm"></span><span id="bc4-snorm"></span>BC4\_SNORM

DXGI\_FORMAT\_BC4\_SNORM работает так же с той разницей, что данные кодируются в диапазоне SNORM и когда 4 значения цвета интерполируются. Следующий пример кода показывает, как выполняется интерполяция однокомпонентных данных.

```
signed word red_0, red_1;

if( red_0 > red_1 )
{
  // 6 interpolated color values
  red_2 = (6*red_0 + 1*red_1)/7.0f; // bit code 010
  red_3 = (5*red_0 + 2*red_1)/7.0f; // bit code 011
  red_4 = (4*red_0 + 3*red_1)/7.0f; // bit code 100
  red_5 = (3*red_0 + 4*red_1)/7.0f; // bit code 101
  red_6 = (2*red_0 + 5*red_1)/7.0f; // bit code 110
  red_7 = (1*red_0 + 6*red_1)/7.0f; // bit code 111
}
else
{
  // 4 interpolated color values
  red_2 = (4*red_0 + 1*red_1)/5.0f; // bit code 010
  red_3 = (3*red_0 + 2*red_1)/5.0f; // bit code 011
  red_4 = (2*red_0 + 3*red_1)/5.0f; // bit code 100
  red_5 = (1*red_0 + 4*red_1)/5.0f; // bit code 101
  red_6 = -1.0f;                     // bit code 110
  red_7 =  1.0f;                     // bit code 111
}
```

Эталонным цветам назначаются 3-битовые индексы (000–111, поскольку значений 8), которые сохраняются в блоках с red a до red p во время сжатия.

### <a name="span-idbc5spanspan-idbc5spanbc5"></a><span id="BC5"></span><span id="bc5"></span>BC5

Используйте формат BC5 для хранения данных о двухкомпонентном цвете с использованием 8 битов каждого цвета. В результате повышенной точности (по сравнению с [BC1](#bc1)) BC5 становится идеальным средством для хранения данных с плавающей запятой в диапазоне \[0 до 1\] с использованием формата DXGI\_FORMAT\_BC5\_UNORM и в диапазоне \[-1 до +1\] с использованием формата DXGI\_FORMAT\_BC5\_SNORM. Допустим, текстура 4×4 использует самый крупный из возможных форматов данных. В этом случае эта техника сжатия уменьшает объем необходимой памяти с 32 байтов (16 цветов × 2 компонента/цвет × 1 байт/компонент) до 16 байтов.

-   [BC5\_UNORM](#bc5-unorm)
-   [BC5\_SNORM](#bc5-snorm)

Этот алгоритм работает в блоках текселей 4×4. Вместо хранения 16 цветов для обоих компонентов алгоритм хранит 2 эталонных цвета для каждого компонента (red\_0, red\_1, green\_0 и green\_1) и 16 3-битовых индексов для каждого компонента (с red a по red p и с green a по green p), как показано на следующей схеме.

![структура для сжатия bc5](images/d3d10-compression-bc5.png)

Алгоритм использует 3-битовые индексы для поиска цветов в таблице цветов, которая содержит 8 элементов. Первые два цвета — red\_0 и red\_1 (или green\_0 и green\_1) — минимальный и максимальный цвета. Этот алгоритм вычисляет оставшиеся цвета с использованием линейной интерполяции.

Алгоритм определяет количество интерполированных значений цвета, анализируя два эталонных значения. Если red\_0 больше red\_1, то BC5 интерполирует 6 значений цвета; в противном случае интерполируется 4 значения. Если BC5 интерполирует только 4 значения цвета, он задает остальные два значения цвета равными 0.0f и 1.0f.

### <a name="span-idbc5unormspanspan-idbc5unormspanspan-idbc5-unormspanbc5unorm"></a><span id="BC5_UNORM"></span><span id="bc5_unorm"></span><span id="bc5-unorm"></span>BC5\_UNORM

Следующий пример кода показывает, как выполняется интерполяция однокомпонентных данных. Вычисления для зеленых компонентов похожи.

```
unsigned word red_0, red_1;

if( red_0 > red_1 )
{
  // 6 interpolated color values
  red_2 = (6*red_0 + 1*red_1)/7.0f; // bit code 010
  red_3 = (5*red_0 + 2*red_1)/7.0f; // bit code 011
  red_4 = (4*red_0 + 3*red_1)/7.0f; // bit code 100
  red_5 = (3*red_0 + 4*red_1)/7.0f; // bit code 101
  red_6 = (2*red_0 + 5*red_1)/7.0f; // bit code 110
  red_7 = (1*red_0 + 6*red_1)/7.0f; // bit code 111
}
else
{
  // 4 interpolated color values
  red_2 = (4*red_0 + 1*red_1)/5.0f; // bit code 010
  red_3 = (3*red_0 + 2*red_1)/5.0f; // bit code 011
  red_4 = (2*red_0 + 3*red_1)/5.0f; // bit code 100
  red_5 = (1*red_0 + 4*red_1)/5.0f; // bit code 101
  red_6 = 0.0f;                     // bit code 110
  red_7 = 1.0f;                     // bit code 111
}
```

Эталонным цветам назначаются 3-битовые индексы (000–111, поскольку значений 8), которые сохраняются в блоках с red a до red p во время сжатия.

### <a name="span-idbc5snormspanspan-idbc5snormspanspan-idbc5-snormspanbc5snorm"></a><span id="BC5_SNORM"></span><span id="bc5_snorm"></span><span id="bc5-snorm"></span>BC5\_SNORM

DXGI\_FORMAT\_BC5\_SNORM работает так же, с той разницей, что данные кодируются в диапазоне SNORM, и когда 4 значения данных интерполируются, мы получаем два дополнительных значения: -1.0f и 1.0f. Следующий пример кода показывает, как выполняется интерполяция однокомпонентных данных. Вычисления для зеленых компонентов похожи.

```
signed word red_0, red_1;

if( red_0 > red_1 )
{
  // 6 interpolated color values
  red_2 = (6*red_0 + 1*red_1)/7.0f; // bit code 010
  red_3 = (5*red_0 + 2*red_1)/7.0f; // bit code 011
  red_4 = (4*red_0 + 3*red_1)/7.0f; // bit code 100
  red_5 = (3*red_0 + 4*red_1)/7.0f; // bit code 101
  red_6 = (2*red_0 + 5*red_1)/7.0f; // bit code 110
  red_7 = (1*red_0 + 6*red_1)/7.0f; // bit code 111
}
else
{
  // 4 interpolated color values
  red_2 = (4*red_0 + 1*red_1)/5.0f; // bit code 010
  red_3 = (3*red_0 + 2*red_1)/5.0f; // bit code 011
  red_4 = (2*red_0 + 3*red_1)/5.0f; // bit code 100
  red_5 = (1*red_0 + 4*red_1)/5.0f; // bit code 101
  red_6 = -1.0f;                    // bit code 110
  red_7 =  1.0f;                    // bit code 111
}
```

Эталонным цветам назначаются 3-битовые индексы (000–111, поскольку значений 8), которые сохраняются в блоках с red a до red p во время сжатия.

## <a name="span-iddifferencesspanspan-iddifferencesspanspan-iddifferencesspanformat-conversion"></a><span id="Differences"></span><span id="differences"></span><span id="DIFFERENCES"></span>Преобразование формата


Direct3D позволяет копировать текстуры предварительно структурированных типов и текстуры со сжатием блоков одинаковой битовой ширины.

Можно копировать ресурсы нескольких типов формата. Этот тип операции копирования выполняет тип преобразования формата, который интерпретирует исходные данные как другой тип формата. Рассмотрите этот пример, в котором показана разница между повторной интерпретацией данных с поведением более стандартного типа преобразования.

```
FLOAT32 f = 1.0f;
UINT32 u;
```

Чтобы повторно интерпретировать f как тип u, используйте функцию [memcpy](http://msdn.microsoft.com/library/dswaw1wk.aspx):

```
memcpy( &u, &f, sizeof( f ) ); // 'u' becomes equal to 0x3F800000.
```

В предыдущем примере повторной интерпретации базовое значение данных не меняется; [memcpy](http://msdn.microsoft.com/library/dswaw1wk.aspx) повторно интерпретирует число с плавающей запятой как целое число без знака.

Для выполнения более стандартного преобразования используйте следующее назначение:

```
u = f; // 'u' becomes 1.
```

В предыдущем преобразовании базовое значение изменений данных.

В следующей таблице перечислены допустимые форматы исходного объекта и объекта назначения, которые можно использовать в данном типе повторной интерпретации преобразования формата. Необходимо кодировать значения надлежащим образом, чтобы повторная интерпретация работала правильно.

<table>
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Ширина бита</th>
<th align="left">Несжатый ресурс</th>
<th align="left">Ресурс со сжатием блоков</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">32</td>
<td align="left"><p>DXGI_FORMAT_R32_UINT</p>
<p>DXGI_FORMAT_R32_SINT</p></td>
<td align="left">DXGI_FORMAT_R9G9B9E5_SHAREDEXP</td>
</tr>
<tr class="even">
<td align="left">64</td>
<td align="left"><p>DXGI_FORMAT_R16G16B16A16_UINT</p>
<p>DXGI_FORMAT_R16G16B16A16_SINT</p>
<p>DXGI_FORMAT_R32G32_UINT</p>
<p>DXGI_FORMAT_R32G32_SINT</p></td>
<td align="left"><p>DXGI_FORMAT_BC1_UNORM[_SRGB]</p>
<p>DXGI_FORMAT_BC4_UNORM</p>
<p>DXGI_FORMAT_BC4_SNORM</p></td>
</tr>
<tr class="odd">
<td align="left">128</td>
<td align="left"><p>DXGI_FORMAT_R32G32B32A32_UINT</p>
<p>DXGI_FORMAT_R32G32B32A32_SINT</p></td>
<td align="left"><p>DXGI_FORMAT_BC2_UNORM[_SRGB]</p>
<p>DXGI_FORMAT_BC3_UNORM[_SRGB]</p>
<p>DXGI_FORMAT_BC5_UNORM</p>
<p>DXGI_FORMAT_BC5_SNORM</p></td>
</tr>
</tbody>
</table>

 

## <a name="span-idrelated-topicsspanrelated-topics"></a><span id="related-topics"></span>Статьи по теме


[Ресурсы сжатых текстур](compressed-texture-resources.md)
