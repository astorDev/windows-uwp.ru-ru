---
title: Копирование данных ресурса и доступ к ним
description: Флаги использования показывают, как приложение собирается использовать данные ресурсов для размещения ресурсов в самой производительной области памяти. Данные ресурса копируются из разных ресурсов, чтобы ЦП или графический процессор мог осуществлять к ним доступ без ущерба для производительности.
ms.assetid: 6A09702D-0FF2-4EA6-A353-0F95A3EE34E2
keywords:
- Копирование данных ресурса и доступ к ним
author: michaelfromredmond
ms.author: mithom
ms.date: 02/08/2017
ms.topic: article
ms.localizationpriority: medium
ms.openlocfilehash: e7b0f06711b4a908f8990dfb16968400c685c15f
ms.sourcegitcommit: 6cc275f2151f78db40c11ace381ee2d35f0155f9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/25/2018
ms.locfileid: "5542381"
---
# <a name="copying-and-accessing-resource-data"></a>Копирование данных ресурса и доступ к ним


Флаги использования показывают, как приложение собирается использовать данные ресурсов для размещения ресурсов в самой производительной области памяти. Данные ресурса копируются из разных ресурсов, чтобы ЦП или графический процессор мог осуществлять к ним доступ без ущерба для производительности.

Не обязательно рассматривать ресурсы как создаваемые в видеопамяти или системной памяти либо решать, должна ли среда выполнения управлять памятью. При использовании архитектуры WDDM (Windows Display Driver Model) приложения создают ресурсы Direct3D с разными флагами использования, чтобы указать, как приложение планирует использовать данные ресурсов. Модель драйвера виртуализирует память, используемую ресурсами; в обязанности операционной системы/драйвера/диспетчера памяти входит размещение ресурсов в наиболее производительной области памяти с учетом ожидаемого использования.

Сценарий по умолчанию подразумевает доступность ресурсов графическому процессору. Существуют моменты, когда данные ресурсов должны быть доступны ЦП. Чтобы копировать данные ресурсов из разных расположений, чтобы соответствующий процессор мог осуществлять к ним доступ, не влияя на производительность, требует определенных знаний о принципах работы методов API.

## <a name="span-idcopyingspanspan-idcopyingspanspan-idcopyingspancopying-resource-data"></a><span id="Copying"></span><span id="copying"></span><span id="COPYING"></span>Копирование данных ресурсов


Ресурсы создаются в памяти, когда Direct3D вызывает метод Create. Они могут создаваться в видеопамяти, системной памяти и любой другой памяти. Поскольку модель драйвера WDDM виртуализирует эту память, приложениям больше не нужно отслеживать, в какой памяти создаются ресурсы.

В идеале все ресурсы должны быть размещены в видеопамяти и быть мгновенно доступны для графического процессора. Однако иногда нужно, чтобы ЦП считал данные ресурсов или графический процессор осуществил доступ к данным ресурсов, в которые был записан ЦП. Direct3D обрабатывает эти разные сценарии, отправляя в приложение запрос на указание использования, а затем предлагает несколько методов копирования данных ресурсов на случай необходимости.

В зависимости от того как был создан ресурс, не всегда возможно осуществить прямой доступ к базовым данным. Это может подразумевать необходимость копирования данных ресурса из исходного ресурса в другой, доступный соответствующему процессору. В терминах Direct3D доступ к ресурсам по умолчанию можно осуществлять графическим процессором напрямую, а динамические и промежуточные ресурсы напрямую доступны для ЦП.

Изменить использование ресурса после создания невозможно. Вместо этого необходимо копировать содержимое одного ресурса в другой, созданный с другим использованием. Вы копируете данные ресурса из одного ресурса в другой или копируете данные из памяти в ресурс.

Существует два основных типа ресурсов: сопоставляемые и несопоставляемые. Ресурсы, созданные с динамическим или промежуточным использованием, сопоставимы, в то время как ресурсы, созданные с использованием по умолчанию или неизменяемым использованием, не сопоставляются.

Копирование данных между несопоставляемыми ресурсами выполняется очень быстро, потому что это наиболее распространенный сценарий, выполнение которого максимально оптимизировано. Так как эти ресурсы недоступны непосредственно ЦП, они оптимизированы таким образом, чтобы графический процессор мог быстро выполнять с ними различные операции.

Копирование данных среди сопоставляемых ресурсов является более проблематичным, поскольку производительность будет зависеть от использования, назначенного ресурсу при создании. Например, графический процессор может считывать динамический ресурс относительно быстро, но не может выполнять в него запись. Кроме того, графический процессор не может выполнять запись напрямую в промежуточные ресурсы или чтение из них.

Приложения, которым требуется копировать данные из ресурса с использованием по умолчанию в ресурс с промежуточным использованием (чтобы разрешить ЦП считывать данные, то есть решить проблему обратного считывания графическим процессором), делать это нужно с осторожностью. См. раздел [Доступ к данным ресурсов](#accessing) ниже.

## <a name="span-idaccessingspanspan-idaccessingspanspan-idaccessingspanaccessing-resource-data"></a><span id="Accessing"></span><span id="accessing"></span><span id="ACCESSING"></span>Доступ к данным ресурсов


Доступ к ресурсу требует сопоставления ресурса; по сути, сопоставление означает, что приложение пытается предоставить ЦП доступ к памяти. Сопоставление ресурса с тем, чтобы ЦП мог осуществлять доступ к базовой памяти, может вызывать "узкие места" производительности. По этой причине эту задачу нужно выполнять с большой осторожностью и тщательно выбирать время.

Производительность может упасть до нуля, если приложение попытается сопоставить ресурс в неподходящее время. Если приложение пытается осуществить доступ к результатам операции до того, как она будет завершена, произойдет зависание конвейера.

Выполнение операции сопоставления в неподходящее время может вызвать серьезное падение производительности, поскольку графический процессор и ЦП будут вынуждены синхронизироваться друг с другом. Синхронизация произойдет, если приложение хочет осуществлять доступ к ресурсу до того, как графический процессор завершит копирование ресурса в ресурс, доступный для сопоставления ЦП.

### <a name="span-idperformanceconsiderationsspanspan-idperformanceconsiderationsspanspan-idperformanceconsiderationsspanperformance-considerations"></a><span id="Performance_Considerations"></span><span id="performance_considerations"></span><span id="PERFORMANCE_CONSIDERATIONS"></span>Вопросы производительности

Лучше всего воспринимать ПК как устройство, функционирующее в виде параллельной архитектуры с двумя основными типами процессоров: один или несколько ЦП и один или несколько графических процессоров. Как и в любой параллельной архитектуре, оптимальная производительность достигается, если для каждого процессора запланировано достаточно задач, чтобы не дать ему простаивать, и когда работе одного процессора не приходится ждать завершения работы другого.

В самом худшем сценарии параллелизма графического процессора и ЦП один процессор вынужден ждать результаты работы другого. Direct3D позволяет решить эту проблему, делая методы копирования асинхронными; копирование не обязательно должно быть завершено до возвращения метода.

Преимущество такого подхода в том, что производительность приложения не снижается из-за фактического копирования данных до тех пор, пока ЦП не осуществит доступ к данным, то есть во время вызова метода Map. Если метод Map вызывается после фактического копирования данных, потерь производительности не происходит. С другой стороны, если метод Map вызывается до копирования данных, произойдет зависание конвейера.

Асинхронные вызовы в Direct3D (то есть подавляющее большинство методов, и в особенности вызовы отрисовки) хранятся в так называемом *буфере команд*. Этот буфер является внутренним по отношению к графическому драйверу и используется для объединения в пакеты вызовов, адресованных базовому оборудованию, чтобы затратное переключение из режима пользователя в режим ядра в Microsoft Windows осуществлялось как можно реже.

Буфер команд очищается, вызывая переключение между режимом пользователя и режимом ядра, в одной из следующих четырех ситуаций.

1.  Вызывается метод Present.
2.  Вызывается метод Flush.
3.  Буфер команд заполнен; его размер является динамичным и контролируется операционной системой и графическим драйвером.
4.  ЦП требует доступа к результатам команды, дожидаясь выполнения в буфере команд.

Из четырех ситуаций последняя является наиболее неблагоприятной для производительности. Если приложение выполняет вызов, чтобы копировать ресурс или вложенный ресурс, вызов помещается в очередь в буфере команд.

Если приложение затем пытается сопоставить промежуточный ресурс, который был целевым объектом вызова метода копирования, перед очисткой буфера команд, произойдет зависание конвейера, поскольку должен выполняться не только вызов метода Copy, но и все остальные буферизованные команды в буфере команд. Это вызовет синхронизацию графического процессора и ЦП, поскольку ЦП будет ждать доступа к промежуточному ресурсу, пока графический процессор очищает буфер команд и, наконец, заполняет необходимый ЦП ресурс. После того как графический процессор завершит копирование, ЦП начнет осуществлять доступ к промежуточному ресурсу, однако в это время графический процессор будет находиться в состоянии простоя.

Если делать так часто во время выполнения, производительность существенно снизится. По этой причине сопоставление ресурсов, созданных с использованием по умолчанию, должно выполняться осторожно. Приложению придется достаточно долго ожидать очищения буфера команд и завершения выполнения всех этих команд, прежде чем приложение попытается сопоставить соответствующий промежуточный ресурс.

Сколько должно ждать приложение? По меньшей мере два кадра, поскольку это позволит максимально эффективно использовать параллелизм между ЦП и графическим процессором. Как работает графический процессор: в то время как приложение обрабатывает кадр N, отправляя вызовы в буфер команд, графический процессор выполняет вызовы из предыдущего кадра, N-1.

Поэтому если приложению требуется сопоставить ресурс, источником которого является видеопамять и который копирует ресурс в кадре N, этот вызов фактически начнет выполняться в кадре N+1, когда приложение будет отправлять вызовы для следующего кадра. Копирование необходимо завершить, когда приложение обрабатывает кадр N+2.

<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Кадр</th>
<th align="left">Состояние графического процессора/ЦП</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">N</td>
<td align="left"><ul>
<li>ЦП создает вызовы отрисовки для текущего кадра.</li>
</ul></td>
</tr>
<tr class="even">
<td align="left">N+1</td>
<td align="left"><ul>
<li>Графический процессор выполняет вызовы, отправленные из ЦП во время кадра N.</li>
<li>ЦП создает вызовы отрисовки для текущего кадра.</li>
</ul></td>
</tr>
<tr class="odd">
<td align="left">N+2</td>
<td align="left"><ul>
<li>Графический процессор завершает выполнение вызовов, отправленных из ЦП во время кадра N. Результаты готовы.</li>
<li>Графический процессор выполняет вызовы, отправленные из ЦП во время кадра N+1.</li>
<li>ЦП создает вызовы отрисовки для текущего кадра.</li>
</ul></td>
</tr>
<tr class="even">
<td align="left">N+3</td>
<td align="left"><ul>
<li>Графический процессор завершает выполнение вызовов, отправленных из ЦП во время кадра N+1. Результаты готовы.</li>
<li>Графический процессор выполняет вызовы, отправленные из ЦП во время кадра N+2.</li>
<li>ЦП создает вызовы отрисовки для текущего кадра.</li>
</ul></td>
</tr>
<tr class="odd">
<td align="left">N+4</td>
<td align="left">...</td>
</tr>
</tbody>
</table>

 

## <a name="span-idrelated-topicsspanrelated-topics"></a><span id="related-topics"></span>Статьи по теме


[Ресурсы](resources.md)

 

 




