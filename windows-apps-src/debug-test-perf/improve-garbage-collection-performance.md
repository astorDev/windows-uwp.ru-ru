---
ms.assetid: F912161D-3767-4F35-88C0-E1ECDED692A2
title: Улучшение производительности сборки мусора
description: Приложения универсальной платформы Windows (UWP) на C# и Visual Basic получают функции автоматического управления памятью от сборщика мусора .NET. В этой статье приведены основные рекомендации по настройке поведения и производительности сборщика мусора .NET в приложениях UWP.
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 6d3940f519706fba6d795d60344cbd83337ae482
ms.sourcegitcommit: c01c29cd97f1cbf050950526e18e15823b6a12a0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/05/2018
ms.locfileid: "8710471"
---
# <a name="improve-garbage-collection-performance"></a>Улучшение производительности сборки мусора


Приложения универсальной платформы Windows (UWP) на C# и Visual Basic получают функции автоматического управления памятью от сборщика мусора .NET. В этой статье приведены основные рекомендации по настройке поведения и производительности сборщика мусора .NET в приложениях UWP. Подробнее о принципах работы сборщика мусора .NET и средствах его отладки и анализа производительности см. в статье [Сборка мусора](https://msdn.microsoft.com/library/windows/apps/xaml/0xy59wtx.aspx).

**Примечание**необходимость изменить поведение по умолчанию сборщика мусора, свидетельствует о наличии проблем общего характера памятью с вашим приложением. Дополнительные сведения об этом см. в статье [Средство использования памяти при отладке в Visual Studio2015](http://blogs.msdn.com/b/visualstudioalm/archive/2014/11/13/memory-usage-tool-while-debugging-in-visual-studio-2015.aspx). Эта статья касается только языков C# и Visual Basic.

 

Сборщик мусора определяет, когда ему следует запускаться, путем установления баланса между памятью, потребляемой управляемой кучей, и объемом работы, который уйдет на сборку мусора. Один из способов достичь этого баланса — разделить кучу на поколения и большую часть времени собирать только часть кучи. В управляемой куче существует три поколения.

-   Поколение 0. Это поколение содержит только новые выделенные объекты объемом не более 85КБ (более крупные объекты входят в кучу больших объектов). Объекты из кучи больших объектов собираются вместе с поколением 2. Сборка мусора в поколении 0 выполняется наиболее часто. При этом уничтожаются короткоживущие объекты, такие как локальные переменные.
-   Поколение 1. Это поколение содержит объекты, которые пережили сборки мусора в поколении 0. Оно служит буфером между поколениями 0 и 2. Сборка мусора в поколении 1 выполняется реже, чем в поколении 0. При этом уничтожаются временные объекты, которые были активны во время предыдущих сборок мусора в поколении 0. При сборке мусора в поколении 1 также выполняется сборка объектов в поколении 0.
-   Поколение 2. Это поколение содержит долгоживущие объекты, пережившие сборки в поколениях 0 и 1. Сборка мусора в поколении 2 выполняется реже всего. При этом собирается вся управляемая куча, включая кучу больших объектов, которая содержит объекты, объем которых превышает 85КБ.

Производительность сборщика мусора можно оценить по двум показателям: продолжительности сборки мусора и объему памяти, который потребляет управляемая куча. Если у вас небольшое приложение с размером кучи менее 100МБ, сосредоточьтесь на сокращении потребления ресурсов памяти. Если приложение с управляемой кучей имеет размер более 100МБ, обратите внимание только на сокращение времени сборки мусора. Ниже описано, как повысить производительность сборщика мусора .NET.

## <a name="reduce-memory-consumption"></a>Сокращение потребления памяти

### <a name="release-references"></a>Освобождение ссылок

Ссылка на объект в приложении исключает из сборки этот объект и все объекты, на которые он ссылается. Компилятор .NET выполняет полезную функцию, определяя, когда переменная больше не используется и, следовательно, связанные с ней объекты можно будет собрать. Но в отдельных случаях ссылки одних объектов на другие могут быть неочевидными из-за того, что часть графа объекта принадлежит библиотекам, которые используют ваше приложение. Инструменты и методики обнаружения объектов, которые переживут сборку мусора, см. в [Сборка мусора и производительность](https://msdn.microsoft.com/library/windows/apps/xaml/ee851764.aspx).

### <a name="induce-a-garbage-collection-if-its-useful"></a>Инициирование сборки мусора, если она необходима

Инициируйте сборку мусора только после оценки производительности своего приложения, по результатам которой установлено, что сборка мусора позволит повысить производительность.

Инициировать сборку мусора определенного поколения можно при помощи метода [**GC.Collect(n)**](https://msdn.microsoft.com/library/windows/apps/xaml/y46kxc5e.aspx), где n — номер поколения (0, 1 или 2).

**Примечание**мы рекомендуем, что вы не принудительную сборку мусора в вашем приложении, поскольку сборщик использует множество эвристических алгоритмов для определения оптимальное время для выполнения сбора и ненужному во многих случаях расходованию ресурсов процессора. Однако если вам известно, что в приложении есть множество неиспользуемых объектов, и вы хотите восстановить занимаемую ими память, то, возможно, стоит выполнить принудительную сборку мусора. Например, можно инициировать сборку мусора по окончании процедуры загрузки в игре, чтобы освободить память до начала игры.
 
Чтобы случайно не запустить слишком много процессов сборки мусора, можно задать для параметра [**GCCollectionMode**](https://msdn.microsoft.com/library/windows/apps/xaml/bb495757.aspx) значение **Optimized**. Это дает указание сборщику мусора начинать сборку, только если он определяет, что улучшение производительности будет оправданным.

## <a name="reduce-garbage-collection-time"></a>Сокращение продолжительности сборки мусора

Этот раздел применим, если вы проанализировали приложение и обнаружили продолжительную сборку мусора. Продолжительность паузы в работе приложения из-за сборки мусора включает время выполнения одного цикла сборки и общее время, которое приложение затрачивает на сборку мусора. Продолжительность сборки зависит от объема оперативных данных, которые нужно проанализировать сборщику. Поколения 0 и 1 ограничены по размеру, но поколение 2 растет по мере увеличения количества активных долгоживущих объектов в приложении. Следовательно, продолжительность сборки мусора для поколений 0 и 1 ограничена, а сборка мусора для поколения 2 может занимать больше времени. Частота сборки мусора зависит главным образом от объема выделенной памяти, так как в процессе сборки память освобождается для выполнения запросов на выделение ресурсов.

Сборщик мусора время от времени приостанавливает работу вашего приложения для выполнения своей функции, но это не значит, что пауза будет длиться в течение всего времени сборки мусора. Пользователь обычно не замечает такие паузы в работе приложения, особенно при выполнении сборки мусора для поколений 0 и 1. Функция [сборки мусора в фоновом режиме](https://msdn.microsoft.com/library/windows/apps/xaml/ee787088.aspx#background-garbage-collection) сборщика мусора .NET позволяет проводить сборку для поколения 2, не прерывая работу приложения и приостанавливая его только на короткое время. Но выполнять сборку мусора для поколения 2 в фоновом режиме не всегда возможно. В этом случае пользователь может заметить паузу, если размер кучи достаточно большой (больше 100 МБ).

Частый запуск сборки мусора может дополнительно увеличивать потребление ресурсов процессора (а следовательно, и электроэнергии) и время загрузки или снижать частоту кадров в вашем приложении. Ниже приведены некоторые приемы, при помощи которых можно ускорить сборку мусора и сократить связанные с ней паузы в работе приложения UWP.

### <a name="reduce-memory-allocations"></a>Сокращение выделения памяти

Если вы не выделяете никакие объекты, то сборщик мусора не запускается, пока в системе не возникнет нехватка памяти. Сокращение объема выделенных ресурсов памяти напрямую приводит к уменьшению частоты проведения сборки мусора.

Если в некоторых компонентах вашего приложения паузы абсолютно недопустимы, то можно заранее выделить необходимые объекты в периоды с менее критичными требованиями к производительности. Например, в игре можно выделить все необходимые объекты во время загрузки уровня и не выделять никакие объекты в ходе игры. Это позволит избежать пауз во время игры и может помочь добиться более высокой и согласованной частоты кадров.

### <a name="reduce-generation-2-collections-by-avoiding-objects-with-a-medium-length-lifetime"></a>Сокращение сборок в поколении 2 за счет пропуска объектов со средним временем существования

Производительность сборки мусора по поколениям дает наилучшие результаты, только если в приложении используются действительно короткоживущие и/или действительно долгоживущие объекты. Сборка короткоживущих объектов выполняется в менее затратных поколениях 0 и 1, а долгоживущие объекты переводятся в поколение 2, для которого сборки проводятся редко. К долгоживущим относятся объекты, которые используются на протяжении всего цикла приложения или в течение значительной его части, например во время загрузки определенной страницы или выполнения уровня игры.

Если вы часто создаете временные объекты, время существования которых достаточно велико, чтобы отнести их к поколению2, то выполняется больше дорогостоящих сборок мусора в поколении2. Можно сократить сборки для поколения 2, повторно используя существующие объекты или быстрее освобождая ненужные объекты.

Распространенный пример объектов со средним временем существования — объекты, которые используются для отображения элементов списка, прокручиваемого пользователем. Если объекты создаются во время прокрутки и отображения элементов списка и не используются после того, как в ходе прокрутки элементы списка скрываются из поля зрения пользователя, то обычно в приложении выполняется множество сборок мусора для поколения 2. В подобных случаях можно заранее выделить и повторно использовать набор объектов для активных данных, которые просматривает пользователь, а короткоживущие объекты применять для загрузки информации во время отображения элементов списка.

### <a name="reduce-generation-2-collections-by-avoiding-large-sized-objects-with-short-lifetimes"></a>Сокращение сборок в поколении 2 за счет пропуска короткоживущих крупных объектов

Любой объект объемом более 85КБ попадает в кучу больших объектов и в сборку поколения 2. Если имеются временные переменные, такие как буферы, размером более 85КБ, то в ходе сборки для поколения2 они будут удалены. Ограничение размеров временных переменных до значений меньше 85КБ сокращает количество коллекций поколения 2 в приложении. Распространенный прием — создать буферный пул и повторно использовать объекты из пула, чтобы не выделять больших временных ресурсов.

### <a name="avoid-reference-rich-objects"></a>Неиспользование объектов, содержащих множество ссылок

Сборщик мусора определяет активные объекты, прослеживая ссылки между объектами, начиная с корня приложения. Дополнительные сведения: [Что происходит во время сборки мусора](https://msdn.microsoft.com/library/windows/apps/xaml/ee787088.aspx#what-happens-during-a-garbage-collection). Если объект содержит много ссылок, то объем работы сборщика мусора увеличивается. Распространенный прием (особенно для больших объектов) — преобразовать объекты со множеством ссылок в объекты без ссылок (например, вместо хранения ссылки хранить индекс). Конечно, такой способ можно использовать, только если он логически допустим.

Замена ссылок на объекты индексами может нарушить работу вашего приложения и усложнить его. Этот прием наиболее эффективен для больших объектов, содержащих много ссылок. Используйте его, только если вы определили, что с такими объектами связана большая продолжительность сборки мусора в вашем приложении.

 

 




