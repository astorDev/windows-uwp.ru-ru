---
author: jwmsft
title: Анализ приложений
description: Проанализируйте свое приложение на проблемы производительности.
ms.author: jimwalk
ms.date: 02/08/2017
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: Windows10, UWP
ms.openlocfilehash: bedd4ce683622935488f9cc210d71f568a167f51
ms.sourcegitcommit: 63c815f8c6665872987b5410cabf324f2b7e3c7c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/10/2017
ms.locfileid: "887954"
---
# <a name="app-analysis-overview"></a>Обзор средства анализа приложений

Средство анализа приложений уведомляет разработчиков о проблемах с производительностью. Во время анализа код приложения проверяется на соответствие ряду рекомендаций для обеспечения производительности.

Анализ приложений выявляет проблемы из набора правил распространенных проблем, которые возникают в приложениях. При необходимости анализ приложений указывает на средство временной шкалы Visual Studio, информацию об исходном коде и документацию, чтобы вы могли подробно изучить проблему.

Правила в средстве анализа приложений — это рекомендации, на соответствие которым проверяется ваше приложение.

## <a name="decoded-image-size-larger-than-render-size"></a>Размер декодированного изображения больше размера отрисовки

Изображения захватываются в очень высоких разрешениях, что может привести к потреблению приложениями большего количества ресурсов ЦП при декодировании данных изображения и большего объема памяти после загрузки изображений с диска. Декодирование и сохранение в памяти изображения с высоким разрешением не имеет смысла, если это изображение будет показано в меньшем размере, чем оригинал. Вместо этого создайте версию изображения размера, который будет отображаться на экране, при помощи свойств DecodePixelWidth и DecodePixelHeight.

### <a name="impact"></a>Влияние

Показ изображений в исходном размере может отрицательно повлиять на время ЦП (из-за декодирования в нужный размер и скачивания), и память.

### <a name="causes-and-solutions"></a>Причины и решения

#### <a name="image-is-not-being-set-asynchronously"></a>Изображение не устанавливается асинхронно

Приложение использует SetSource() вместо SetSourceAsync(). Старайтесь как можно меньше использовать [**SetSource**](https://msdn.microsoft.com/library/windows/apps/BR243255) и вместо этого использовать [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) при задании потока для асинхронного декодирования изображений. 

#### <a name="image-is-being-called-when-the-imagesource-is-not-in-the-live-tree"></a>Изображение вызывается, если ImageSource нет в динамическом дереве

Класс BitmapImage подключен к дереву XAML в режиме реального времени после настройки содержимого с помощью SetSourceAsync или UriSource. Обязательно подключайте [**BitmapImage**](https://msdn.microsoft.com/library/windows/apps/BR243235) к дереву в режиме реального времени до задания источника. Это необходимо делать каждый раз, когда элемент изображения или кисть задается в разметке. Примеры приведены ниже. 

**Примеры дерева в режиме реального времени**

Пример 1 (как надо) — универсальный код ресурса (URI) задан в разметке.

```xml
<Image x:Name="myImage" UriSource="Assets/cool-image.png"/>
```

Пример 2, разметка — URI задан в коде программной части.

```xml
<Image x:Name="myImage"/>
```

Пример 2, код программной части (как надо) — подключение BitmapImage к дереву до задания его UriSource.

```vb
var bitmapImage = new BitmapImage();
myImage.Source = bitmapImage;
bitmapImage.UriSource = new URI("ms-appx:///Assets/cool-image.png", UriKind.RelativeOrAbsolute);
```

Пример 2, код программной части (как не надо) — задание UriSource для BitmapImage до его подключения к дереву.

```vb
var bitmapImage = new BitmapImage();
bitmapImage.UriSource = new URI("ms-appx:///Assets/cool-image.png", UriKind.RelativeOrAbsolute);
myImage.Source = bitmapImage;
```

#### <a name="image-brush-is-non-rectangular"></a>Кисть изображения не прямоугольная 

Если изображение используется для непрямоугольной кисти, изображение будет использовать программный путь растеризации, который вообще не масштабирует изображения. Кроме того, приложение должно сохранить копию изображения как в программной, так и в аппаратной памяти. Например, если изображение используется в качестве эллиптической кисти, то потенциально большое полное изображение будет сохранено внутренне дважды. При использовании непрямоугольной кисти ваше приложение должно предварительно масштабировать изображения примерно соответственно размеру, в котором они будут отрисованы.

Кроме того, можно задать явный размер декодирования, чтобы создать версию изображения с тем размером, с которым оно будет отрисовано на экране, с помощью свойств [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) и [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241).

```xml
<Image>
    <Image.Source>
    <BitmapImage UriSource="ms-appx:///Assets/highresCar.jpg" 
                 DecodePixelWidth="300" DecodePixelHeight="200"/>
    </Image.Source>
</Image>
```

По умолчанию единицы измерения [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) и [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) — физические пиксели. Свойство [**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545) можно использовать, чтобы изменить такое поведение: если задать для параметра **DecodePixelType** значение **Logical**, размер декодирования автоматически будет учитывать текущий коэффициент масштабирования системы, аналогично другому содержимому XAML. Таким образом, в общем случае стоит задать для параметра **DecodePixelType** значение **Logical**, например, если вы хотите, чтобы **DecodePixelWidth** и **DecodePixelHeight** соответствовали свойствам Height и Width элемента управления Image, в котором будет показано изображение. Поскольку по умолчанию используются физические пиксели, вы должны самостоятельно учитывать текущий коэффициент масштабирования системы; необходимо ожидать уведомления об изменении масштаба на случай, если пользователь изменит настройки экрана.

В некоторых случаях, если определить нужный размер декодирования заранее нельзя, необходимо положиться на функцию автоматического определения нужного размера декодирования XAML, которая попытается декодировать изображение в нужном размере, если DecodePixelWidth или DecodePixelHeight не заданы явным образом.

Если вы знаете размер содержимого изображения заранее, необходимо задать размер декодирования явным образом. Вы также должны параллельно задать для параметра [**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545) значение **Logical**, если предоставленный размер декодирования задан относительно размеров других элементов XAML. Например, если вы в явном виде задали размер содержимого с помощью Image.Width и Image.Height, вы можете задать для параметра DecodePixelType значение DecodePixelType.Logical, обеспечив использование тех же размеров в логических пикселях, что и для элемента управления «Изображение», а затем в явном виде использовать BitmapImage.DecodePixelWidth или BitmapImage.DecodePixelHeight, чтобы контролировать размер изображения для потенциально большей экономии памяти.

Обратите внимание на необходимость учета Image.Stretch при определении размера декодированного содержимого.

#### <a name="images-used-inside-of-bitmapicons-fall-back-to-decoding-to-natural-size"></a>Изображения, используемые в BitmapIcons, возвращаются к декодированию в естественному размере 

Вы можете задать явный размер декодирования, чтобы создать версию изображения с тем размером, с которым оно будет отрисовано на экране, с помощью свойств [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) и [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241).

#### <a name="images-that-appear-extremely-large-on-screen-fall-back-to-decoding-to-natural-size"></a>Изображения, которые кажутся очень большими на экране, возвращаются к декодирование в естественном размере 

Изображения, которые кажутся очень большими на экране, возвращаются к декодирование в естественном размере. Вы можете задать явный размер декодирования, чтобы создать версию изображения с тем размером, с которым оно будет отрисовано на экране, с помощью свойств [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) и [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241).

#### <a name="image-is-hidden"></a>Изображение скрыто

Изображение скрыто, т. к. для параметра Opacity установлено значение 0 или для параметра Visibility — значение Collapsed на элементе основного изображения, или кисти, или любого родительского элемента. Изображения, не показанные на экране из-за обрезки или прозрачности, могут декодироваться в естественном размере. 

#### <a name="image-is-using-ninegrid-property"></a>Изображение использует свойство NineGrid

Если изображение используется для [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756), оно будет применять программный путь растеризации, который вообще не масштабирует изображения. Кроме того, приложение должно сохранить копию изображения как в программной, так и в аппаратной памяти. При использовании **NineGrid** ваше приложение должно предварительно масштабировать изображения примерно соответственно размеру, в котором они будут отрисованы.

Изображения, которые используют свойство NineGrid, возвращаются к декодированию в естественном размере. Рекомендуется добавить эффект ninegrid к первоначальному изображению.

#### <a name="decodepixelwidth-or-decodepixelheight-are-set-to-a-size-thats-larger-than-the-image-will-appear-on-screen"></a>Для DecodePixelWidth или DecodePixelHeight установлен размер, который больше размера изображения на экране 

Если DecodePixelWidth или DecodePixelHeight явным образом заданы больше, чем ширина и высота изображения, которое будет показано на экране, то приложение без необходимости будет использовать дополнительный объем памяти до 4 байтов на пиксель, что быстро станет слишком затратным для больших изображений. Кроме того, изображение будет уменьшено с помощью билинейного масштабирования, отчего может выглядеть расплывчатым при больших коэффициентах масштабирования.

#### <a name="image-is-decoded-as-part-of-producing-a-drag-and-drop-image"></a>Изображение декодируется в рамках создания изображения перетаскивания

Вы можете задать явный размер декодирования, чтобы создать версию изображения с тем размером, с которым оно будет отрисовано на экране, с помощью свойств [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) и [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241).

## <a name="collapsed-elements-at-load-time"></a>Свернутые элементы во время загрузки

Обычно в приложениях элементы пользовательского интерфейса изначально скрываются, а затем отображаются. В большинстве случаев эти элементы следует отложить с помощью x:Load или x:DeferLoadStrategy, чтобы не создавать их во время загрузки.

Сюда относится и преобразование Boolean в Visibility, используемое для скрытия элементов до какого-то момента.

### <a name="impact"></a>Влияние

Свернутые элементы загружаются вместе с другими элементами и увеличивают время загрузки.

### <a name="cause"></a>Причина

Это правило было активировано, так как элемент был свернут во время загрузки. Сворачивание элемента или установка его непрозрачности равной 0 не предотвратят создание этого элемента. Это правило может быть активировано приложением, которое использует преобразование Boolean в Visibility, которое по умолчанию имеет значение false.

### <a name="solution"></a>Решение

С помощью [атрибута x:Load](../xaml-platform/x-load-attribute.md) или [x:DeferLoadStrategy](https://msdn.microsoft.com/library/windows/apps/Mt204785) можно отложить загрузку элемента пользовательского интерфейса и загрузить его, когда это потребуется. Это хороший способ задержать обработку элементов пользовательского интерфейса, которые не видны в первом кадре. Вы можете загружать элемент, когда он необходим, или в рамках задержанной логики. Чтобы начать загрузку, вызовите метод findName для нужного элемента. Атрибут x:Load расширяет возможности атрибута x:DeferLoadStrategy, включая элементы для выгрузки и для состояния загрузки для управления через x:Bind.

В некоторых случаях использование findName для отображения элемента пользовательского интерфейса не является выходом из положения. Это так если вы хотите реализовать большую часть пользовательского интерфейса при нажатии кнопки с очень низкой задержкой. В таком случае можно обменять более быструю задержку пользовательского интерфейса за счет дополнительного объема памяти, при этом следует использовать x:DeferLoadStrategy и установить для свойства Visibility значение Collapsed для элемента, который требуется реализовать. После загрузки страницы и освобождения потока пользовательского интерфейса вы можете вызвать findName, когда потребуется загрузить элементы. Элементы не будут видны пользователю, пока не задать свойству Visibility значение Visible.

## <a name="listview-is-not-virtualized"></a>ListView не виртуализирован

Виртуализация пользовательского интерфейса — это самое важное улучшение производительности коллекций. Это означает, что элементы пользовательского интерфейса, представляющие элементы, создаются по запросу. Для элемента управления элементами, привязанного к коллекции из 1000 элементов, создание пользовательского интерфейса одновременно для всех элементов было бы напрасной тратой ресурсов, поскольку они не могут отображаться одновременно. ListView и GridView (и другие стандартные элементы управления, производные от ItemsControl) выполняют виртуализацию пользовательского интерфейса за вас. Если элементы близки к появлению на экране (за несколько страниц), платформа создает пользовательский интерфейс для таких элементов и помещает их в кэш. Если повторное появление элементов маловероятно, платформа освобождает память.

Виртуализация пользовательского интерфейса — это только один из нескольких ключевых факторов для улучшения производительности коллекции. Упрощение элементов коллекции и виртуализация данных — также два других важных аспекта для улучшения производительности коллекций. Дополнительные сведения об улучшении производительности коллекций в элементах ListViews и GridViews см. в статьях [Оптимизация пользовательского интерфейса ListView и GridView](https://msdn.microsoft.com/windows/uwp/debug-test-perf/optimize-gridview-and-listview) и [Виртуализация данных ListView и GridView](https://msdn.microsoft.com/windows/uwp/debug-test-perf/listview-and-gridview-data-optimization).

### <a name="impact"></a>Влияние

Неиртуализированный ItemsControl увеличивает время загрузки и использование ресурсов из-за загрузки большего числа дочерних элементов, чем необходимо.

### <a name="cause"></a>Причина

Концепция окна просмотра очень важна для виртуализации пользовательского интерфейса, так как среда разработки должна создавать элементы с высокой вероятностью отображения. Как правило, окно просмотра ItemsControl того же размера, что и логический элемент управления. Например, окно просмотра элемента управления ListView имеет те же ширину и высоту, что и элемент ListView. Некоторые панели предоставляют дочерним элементам неограниченное пространство (например, ScrollViewer и Grid) с автоматически устанавливаемым размером строк и столбцов. Когда виртуализированный элемент управления ItemsControl помещается на такую панель, нужно достаточно места для отображения всех его элементов, что препятствует виртуализации. 

### <a name="solution"></a>Решение

Восстановите виртуализацию, задав ширину и высоту в ItemsControl.

## <a name="ui-thread-blocked-or-idle-during-load"></a>Поток пользовательского интерфейса заблокирован или бездействует во время загрузки

Блокировка потока пользовательского интерфейса — это синхронные вызовы функций, выполняющихся вне потока, которые блокируют поток пользовательского интерфейса.  

Полный список рекомендаций для улучшения производительности приложения при запуске см. в статьях [Рекомендации по повышению производительности запуска приложения](https://msdn.microsoft.com/windows/uwp/debug-test-perf/best-practices-for-your-app-s-startup-performance) и [Обеспечение быстрого отклика потока пользовательского интерфейса](https://msdn.microsoft.com/windows/uwp/debug-test-perf/keep-the-ui-thread-responsive).

### <a name="impact"></a>Влияние

Блокированный или бездействующий поток пользовательского интерфейса во время загрузки не допускает обработку макета и другие операции с пользовательским интерфейсом, что увеличивает время запуска.

### <a name="cause"></a>Причина

Код платформы для пользовательского интерфейса и код вашего приложения для пользовательского интерфейса выполняются в одном потоке пользовательского интерфейса. В этом потоке одновременно может выполняться только одна инструкция, поэтому если код приложения обрабатывает событие слишком долго, то платформа не может выполнить макет или создать новые события, представляющие взаимодействие с пользователем. Скорость отклика приложения зависит от доступности потока пользовательского интерфейса для обработки заданий.

### <a name="solution"></a>Решение

Приложение может реагировать на действия пользователя, даже если не все его части полностью функциональны. Например, если приложение отображает данные, на получение которых требуется время, вы можете сделать выполнение этого кода независимым от выполнения кода запуска приложения за счет асинхронного получения данных. Как только данные будут доступны, заполните ими пользовательский интерфейс приложения. Для поддержания нормальной скорости отклика вашего приложения платформа предоставляет асинхронные версии многих API. Асинхронный API гарантирует, что активный поток выполнения никогда не будет заблокирован в течение продолжительного времени. При вызове API из потока пользовательского интерфейса используйте по возможности асинхронную версию.

## <a name="binding-is-being-used-instead-of-xbind"></a>{Binding} используется вместо {x:Bind}

Это правило активируется, если приложение использует оператор {Binding}. Чтобы повысить производительность приложения, следует использовать {x:Bind}.

### <a name="impact"></a>Влияние

{Binding} выполняется дольше и потребляет больше памяти, чем {x:Bind}.

### <a name="cause"></a>Причина

Приложение использует {Binding} вместо {x:Bind}. {Binding} требует наличия нестандартного рабочего набора и вызывает перегрузку ЦП. Для создания привязки ({Binding}) требуется выделение памяти, а обновление целевого объекта привязки может вызвать отражение и упаковку-преобразование.

### <a name="solution"></a>Решение

Используйте расширение разметки {x:Bind}, которое компилирует привязки на этапе сборки. В результате привязки {x:Bind} (часто именуемые компилированными привязками) имеют большую производительность, обеспечивают проверку ваших выражений привязки и поддерживают отладку, позволяя задавать точки останова в файлах кода, которые создаются как разделяемый класс для вашей страницы. 

Обратите внимание, что x:Bind подходит не для всех ситуаций, например не для сценариев поздней привязки. Полный список случаев, не охватываемых {x:Bind}, см. в документации {x:Bind}.

## <a name="xname-is-being-used-instead-of-xkey"></a>x:Name используется вместо x:Key

ResourceDictionaries обычно используются для хранения ресурсов на глобальном уровне, то есть ресурсов, на которые приложение собирается сослаться в нескольких местах, например стили, кисти, шаблоны и т. д. В целом мы оптимизировали ResourceDictionaries так, чтобы экземпляр ресурса не создавался без соответствующего запроса. Однако в некоторых случаях необходимо проявлять осторожность.

### <a name="impact"></a>Влияние

Для любого ресурса с x:Name будет создан экземпляр сразу после создания ResourceDictionary. Это происходит потому, что атрибут x:Name показывает платформе, что приложению требуется местный доступ к этому ресурсу. Поэтому платформе необходимо создать объект, на который можно создать ссылку.

### <a name="cause"></a>Причина

Приложение устанавливает x:Name для ресурса.

### <a name="solution"></a>Решение

Используйте x:Key вместо x:Name, если вы не ссылаетесь на ресурсы из кода программной части.

## <a name="collections-control-is-using-a-non-virtualizing-panel"></a>Элемент управления коллекциями используют невиртуализованную панель

Если вы задали пользовательский шаблон панели элементов (см. ItemsPanel), следует использовать панель виртуализации, например ItemsWrapGrid или ItemsStackPanel. Если вы используете VariableSizedWrapGrid, WrapGrid или StackPanel, то виртуализация не будет выполнена. Кроме того, следующие события ListView вызываются только при использовании элементов ItemsWrapGrid или ItemsStackPanel: ChoosingGroupHeaderContainer, ChoosingItemContainer и ContainerContentChanging.

Виртуализация пользовательского интерфейса — это самое важное улучшение производительности коллекций. Это означает, что элементы пользовательского интерфейса, представляющие элементы, создаются по запросу. Для элемента управления элементами, привязанного к коллекции из 1000 элементов, создание пользовательского интерфейса одновременно для всех элементов было бы напрасной тратой ресурсов, поскольку они не могут отображаться одновременно. ListView и GridView (и другие стандартные элементы управления, производные от ItemsControl) выполняют виртуализацию пользовательского интерфейса за вас. Если элементы близки к появлению на экране (за несколько страниц), платформа создает пользовательский интерфейс для таких элементов и помещает их в кэш. Если повторное появление элементов маловероятно, платформа освобождает память.

Виртуализация пользовательского интерфейса — это только один из нескольких ключевых факторов для улучшения производительности коллекции. Упрощение элементов коллекции и виртуализация данных — также два других важных аспекта для улучшения производительности коллекций. Дополнительные сведения об улучшении производительности коллекций в элементах ListViews и GridViews см. в статьях [Оптимизация пользовательского интерфейса ListView и GridView](https://msdn.microsoft.com/windows/uwp/debug-test-perf/optimize-gridview-and-listview) и [Виртуализация данных ListView и GridView](https://msdn.microsoft.com/windows/uwp/debug-test-perf/listview-and-gridview-data-optimization).

### <a name="impact"></a>Влияние

Неиртуализированный ItemsControl увеличивает время загрузки и использование ресурсов из-за загрузки большего числа дочерних элементов, чем необходимо.

### <a name="cause"></a>Причина

Вы используете панель, не поддерживающей виртуализацию.

### <a name="solution"></a>Решение

Используйте панель виртуализации, например ItemsWrapGrid или ItemsStackPanel.

## <a name="accessibility-uia-elements-with-no-name"></a>Специальные возможности: элементы автоматизации пользовательского интерфейса без имени

В XAML вы можете указать имя, задав значение AutomationProperties.Name. Многие одноранговые классы автоматизации предоставляют имя по умолчанию, если свойство AutomationProperties.Name не задано. 

### <a name="impact"></a>Влияние

Если пользователи достигают элемента без имени, они часто не будут знать, с чем он связан. 

### <a name="cause"></a>Причина

Имя UIA имеет значение NULL или пустое. Это правило проверяет, что видит модель автоматизации пользовательского интерфейса, не значение AutomationProperties.Name.

### <a name="solution"></a>Решение

Задайте в свойстве AutomationProperties.Name в XAML элемента управления соответствующую локализованную строку.

Иногда нужно не указать имя, а удалить элемент модели автоматизации пользовательского интерфейса из всех деревьев, кроме необработанных. Это можно сделать в XAML, задав свойству AutomationProperties.AccessibilityView значение "Raw".

## <a name="accessibility-uia-elements-with-the-same-controltype-should-not-have-the-same-name"></a>Специальные возможности: имена элементов модели автоматизации пользовательского интерфейса с одинаковым Controltype не должны совпадать

Свойства Name и ControlType двух элементов модели автоматизации пользовательского интерфейса с одним родительским элементом не должны совпадать. У двух элементов может быть одинаковое свойство Name, если ControlType различаются. 

Это правило не проверяет дублирование имен с различными родительскими элементами. Однако в большинстве случаев не следует дублировать свойства Name и ControlType во всем окне даже с разными родительскими элементами. Дублирующиеся имена в окне допустимы, если это два списка с идентичными элементами. В этом случае у элементов списка должны быть одинаковые свойства Name и ControlType.

### <a name="impact"></a>Влияние

Если пользователи достигают элемент с такими же свойствами Name и ControlType, как и другого элемента с тем же родительским элементом UIA, они не смогут понять различия между элементами.

### <a name="cause"></a>Причина

Свойства Name и ControlType элементов модели автоматизации пользовательского интерфейса с одним родительским элементом совпадают.

### <a name="solution"></a>Решение

Задайте имя в XAML с помощью AutomationProperties.Name. В списках, где это обычно возникает, используйте привязку, чтобы связать значение AutomationProperties.Name с источником данных.


