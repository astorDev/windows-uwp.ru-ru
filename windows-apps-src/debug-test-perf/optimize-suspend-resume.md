---
author: jwmsft
ms.assetid: E1943DCE-833F-48AE-8402-CD48765B24FC
title: Оптимизация времени приостановки и возобновления работы
description: Создавайте приложения универсальной платформы Windows (UWP), которые упростят использование системы жизненных циклов процессов для эффективного восстановления после приостановки или завершения.
ms.author: jimwalk
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 4cbaa56f9c25c0e4ea1f10c79b4f7d1100748532
ms.sourcegitcommit: 93c0a60cf531c7d9fe7b00e7cf78df86906f9d6e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2018
ms.locfileid: "7565711"
---
# <a name="optimize-suspendresume"></a>Оптимизация времени приостановки и возобновления работы


Создавайте приложения универсальной платформы Windows (UWP), которые упростят использование системы жизненных циклов процессов для эффективного восстановления после приостановки или завершения.

## <a name="launch"></a>Запуск

При повторной активации приложения после приостановки или завершения проверьте, прошел ли длительный период времени. Если да, рассмотрите вариант возвращения на главную целевую страницу приложения вместо отображения устаревших данных. Это также приведет к ускорению запуска.

При активации всегда проверяйте атрибут PreviousExecutionState параметра аргументов события (например, для запущенных активаций проверяйте LaunchActivatedEventArgs.PreviousExecutionState). Если он имеет значение ClosedByUser или NotRunning, то не стоит тратить время на восстановление ранее сохраненного состояния. В этом случае следует начать взаимодействие сначала. Это позволит ускорить запуск.

Вместо восстановления ранее сохраненного состояния можно отслеживать его и восстанавливать его только по запросу. Например, рассмотрим ситуацию, в которой приложение было приостановлено, сохранило состояние 3-х страниц, а затем было завершено. При повторном запуске и возвращении пользователя на 3-ю страницу не обязательно восстанавливать состояние первых 2-х страниц. Вместо этого можно сохранить это состояние и использовать его только тогда, когда оно необходимо.

## <a name="while-running"></a>Во время выполнения

Настоятельно рекомендуется не ждать событие приостановки для сохранения большого объема состояний. Вместо этого приложение должно постепенно сохранять небольшие объемы состояний по мере работы. Это особенно важно для больших приложений, для которых при приостановке существует риск истечения времени ожидания в случае сохранения всех данных за один раз.

При этом необходимо поддерживать баланс между постепенным сохранением и обеспечением производительности приложения при работе. Разумным компромиссом является постепенное отслеживание данных, которые были изменены (и поэтому должны быть сохранены), и использование события приостановки для фактического сохранения этих данных (на это требуется меньше времени, чем на сохранение всех данных или проверку состояния всего приложения при определения подлежащих сохранению данных).

Не используйте события окна Activated или VisibilityChanged для определения данных, подлежащих сохранению. Когда пользователь выходит из приложения, окно деактивируется, но система ожидает некоторое время (примерно 10 секунд), прежде чем приостановить приложение. Это обеспечивает более быстрое взаимодействие в том случае, если пользователь быстро возвращается к приложению. Для выполнения логики приостановки следует дождаться события приостановки.

## <a name="suspend"></a>Приостановка

Во время приостановки следует уменьшить используемый приложением объем памяти. Если во время приостановки приложение использует меньше памяти, увеличивается быстродействие всей системы и меньше приостановленных приложений (включая ваше) подвергается завершению. Однако следует предусмотреть возможность быстрого возобновления работы. Не уменьшайте объем используемой памяти слишком сильно — это значительно замедлит процесс возобновления, так как приложению потребуется перезагружать в память слишком много данных.

При использовании управляемых приложений система выполняет сбор мусора после завершения работы обработчиков приостановки приложений. Используйте эту возможность, освобождая ссылки на объекты. Это позволит сократить объем памяти, используемой приложением во время приостановки.

В идеале приложение выполняет логику приостановки менее чем за 1 секунду. Чем быстрее вы сможете выполнить приостановку, тем лучше. Это позволяет улучшить взаимодействие с пользователем для других приложений и компонентов системы. Если необходимо, выполнение логики приостановки может занимать до 5 секунд на настольных и до 10 секунд на мобильных устройствах. При превышении этих значений работа приложения будет сразу же завершена. Такой исход нежелателен, поскольку в этом случае при повторном обращении к приложению будет запускаться новый процесс. Скорость взаимодействия в этом случае будет ниже, чем при возобновлении приостановленного приложения.

## <a name="resume"></a>Возобновление

Большинство приложений не выполняет каких-либо особых действий при возобновлении, поэтому обычно данное событие не нуждается в обработке. Некоторые приложения используют возобновление для восстановления подключений, закрытых во время приостановки, а также для обновления данных, которые могли устареть. Вместо автоматического выполнения этих действий спроектируйте приложение так, чтобы они выполнялись по требованию. В результате при последующем включении приостановленного приложения скорость взаимодействие будет выше. Кроме того, будут выполняться только те задачи, которые действительно необходимы пользователю.

## <a name="avoid-unnecessary-termination"></a>Избегайте ненужного завершения работы

Система жизненных циклов процессов UWP может приостановить или завершить выполнение приложения по ряду причин. Данный процесс предназначен для возврата приложения в то состояние, в котором оно находилось перед приостановкой или завершением его выполнения. Если данный процесс работает хорошо, то пользователь даже не будет знать, что работа приложения вообще была остановлена. Вот несколько приемов, которые могут использоваться вашим приложением UWP для упрощения переходных процессов системы в жизненном цикле приложения.

Приложение может быть приостановлено, если пользователь переводит его в фоновый режим или если система переходит в режим пониженного энергопотребления. Если работа приложения приостанавливается, в нем возникает соответствующее событие, и у приложения есть до пяти секунд, чтобы сохранить данные. Если за эти пять секунд работа обработчика события приостановки не завершилась, система считает приложение зависшим и принудительно завершает его. Завершенное приложение должно пройти через длительный процесс запуска заново вместо того, чтобы, когда пользователь переключается на него, загрузиться в память немедленно.

### <a name="serialize-only-when-necessary"></a>Выполняйте сериализацию только в случае необходимости

Во время приостановки многие приложения выполняют сериализацию всех своих данных. Однако если вам нужно сохранить только небольшой объем параметров приложения, лучше всего использовать для этого хранилище [**LocalSettings**](https://msdn.microsoft.com/library/windows/apps/BR241622), а не выполнять сериализацию данных. Используйте сериализацию для больших объемов данных и данных, не являющихся параметрами приложения.

Если вы выполняете сериализацию данных, следует избегать повторной сериализации, если они не изменились. В этом случае приложение тратит дополнительное время на сериализацию и сохранение данных, плюс дополнительное время при возобновлении работы — на их чтение и десериализацию. Поэтому рекомендуется, чтобы приложение проверяло, изменились ли данные, и проводило сериализацию и десериализацию только измененных данных. Хорошим способом организовать этот процесс является периодическая фоновая сериализация данных после их изменения. При использовании этой методики все, что требует сериализации во время приостановки, уже сохранено, поэтому приостановка приложения выполняется быстро.

### <a name="serializing-data-in-c-and-visual-basic"></a>Сериализация данных в C# и Visual Basic

Для приложений .NET существуют следующие классы, реализующие технологии сериализации: [**System.Xml.Serialization.XmlSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.xml.serialization.xmlserializer.aspx), [**System.Runtime.Serialization.DataContractSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.datacontractserializer.aspx) и [**System.Runtime.Serialization.Json.DataContractJsonSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.json.datacontractjsonserializer.aspx).

С точки зрения производительности рекомендуется использование класса [**XmlSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.xml.serialization.xmlserializer.aspx). **XmlSerializer** требует минимальных времени сериализации и десериализации и используемого объема памяти. **XmlSerializer** мало зависит от .NET Framework. Это означает, что для использования **XmlSerializer** потребуется загружать меньшее (по сравнению с другими технологиями сериализации) количество модулей в ваше приложение.

[**DataContractSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.datacontractserializer.aspx) легко выполнять сериализацию пользовательских классов, хотя он менее эффективен в плане производительности, чем класс **XmlSerializer**. Перейти на использование последнего класса стоит, если вам нужна оптимальная производительность. Вообще не стоит использовать больше одного класса сериализации и лучше всего использовать класс **XmlSerializer**, если вам не нужны возможности других классов сериализации.

### <a name="reduce-memory-footprint"></a>Уменьшение используемого объема памяти

Система старается хранить в памяти как можно больше приостановленных приложений, чтобы пользователь мог быстро и без проблем переключаться между ними. Приостановленное приложение, хранящееся в памяти системы, может быть быстро выведено пользователем на передний план; при этом не надо отображать экран-заставку или выполнять продолжительные действия по загрузке. Если ресурсов для сохранения приложения в памяти недостаточно, приложение завершается. Это придает важность управлению памятью по следующим двум причинам:

-   Высвобождение как можно большего объема памяти при приостановке минимизирует шансы, что работа вашего приложения будет завершена из-за недостатка ресурсов в ходе приостановки.
-   Снижение общего объема памяти, который использует ваше приложение, уменьшает шансы на то, что работа других приложений будет завершена во время их приостановки.

### <a name="release-resources"></a>Высвобождение ресурсов

Некоторые объекты, такие как файлы и устройства, занимают большой объем памяти. Рекомендуется во время приостановки приложения освободить дескрипторы этих объектов и повторно создать их впоследствии при необходимости. Приостановка приложения также является подходящим моментом для очистки всех видов кэшей, которые окажутся неприменимы после возобновления работы приложения. Дополнительно при необходимости инфраструктура XAML запускает на приложениях, созданных на языках C# и Visual Basic, сборку мусора. Это обеспечивает высвобождение любых объектов, на которые отсутствуют ссылки в коде приложения.

## <a name="resume-quickly"></a>Быстрое возобновление работы

Работа приостановленного приложения может быть продолжена, если пользователь выводит его окно на передний план или система выходит из состояния пониженного энергопотребления. Когда работа приложения возобновляется из состояния "приостановлено", возобновление происходит с момента приостановки. Даже если выполнение приложения было приостановлено на продолжительный период, данные приложения не теряются, поскольку они были сохранены в памяти.

Большинству приложений не требуется обрабатывать событие [**Resuming**](https://msdn.microsoft.com/library/windows/apps/BR205859). После возобновления работы переменные и объекты приложения будут находиться в том же самом состоянии, в котором они были во время приостановки приложения. Обрабатывайте событие **Resuming**, только если необходимо обновить данные или объекты, которые могли измениться за время приостановки и возобновления работы приложения: содержимое (например, обновление данных канала), сетевые подключения, которые могли потерять актуальность, или если необходимо произвести переподключение к устройству (например, к веб-камере).

## <a name="related-topics"></a>Ссылки по теме

* [Руководство по приостановке и возобновлению работы приложения](https://msdn.microsoft.com/library/windows/apps/Hh465088)
 

 




