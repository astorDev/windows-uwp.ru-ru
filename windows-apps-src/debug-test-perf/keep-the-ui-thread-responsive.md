---
author: mcleblanc
ms.assetid: FA25562A-FE62-4DFC-9084-6BD6EAD73636
title: Обеспечение быстрого отклика потока пользовательского интерфейса
description: Пользователи, независимо от типа компьютера, ожидают от приложений быстрого отклика во время вычислений.
---
# Обеспечение быстрого отклика потока пользовательского интерфейса

\[ Обновлено для приложений UWP в Windows 10. Статьи, касающиеся Windows 8.x, см. в разделе [Архив](http://go.microsoft.com/fwlink/p/?linkid=619132) \]

Пользователи, независимо от типа компьютера, ожидают от приложений быстрого отклика во время вычислений. Для разных приложений это подразумевает разные вещи. Это может означать предоставление более реалистичной физики, более быструю загрузку данных с диска или из Интернета, мгновенное представление сложных сцен и навигацию по страницам, быстрый поиск направлений или быструю обработку данных. Независимо от типа вычислений пользователи хотят, чтобы приложение реагировало на ввод данных, и удаляют экземпляры, которые престают отвечать во время вычислений.

Ваше приложение событийное — это означает, что ваш код выполняет действия в ответ на событие, а затем будет неактивен до следующего. Код платформы для пользовательского интерфейса (макета, ввода данных, создания событий и т. д.) и код вашего приложения для пользовательского интерфейса выполняются в одном потоке пользовательского интерфейса. В этом потоке одновременно может выполняться только одна инструкция, поэтому если код приложения обрабатывает событие слишком долго, то платформа не может выполнить макет или создать новые события, представляющие взаимодействие с пользователем. Скорость отклика приложения зависит от доступности потока пользовательского интерфейса для обработки заданий.

Чтобы внести изменения в поток пользовательского интерфейса, включая создание типов пользовательского интерфейса и получение доступа к их членам, необходимо использовать поток пользовательского интерфейса. Невозможно обновить интерфейс из фонового потока, но можно создать сообщение с помощью [**CoreDispatcher.RunAsync**](https://msdn.microsoft.com/library/windows/apps/Hh750317), чтобы вызвать код для выполнения.

> **Примечание.** Единственным исключением является отдельный обрабатывающий поток, который может применять изменения пользовательского интерфейса, не затрагивающие способ обработки ввода или базовый макет. Например, многие анимации и переходы, которые не влияют на макет, могут выполняться в этом потоке обработки.

## Создание экземпляра элемента задержки

Некоторые наиболее медленные этапы в приложении могут включать запуск и переключение между представлениями. Не выполняйте лишнюю работу при выводе на экран пользовательского интерфейса, который изначально виден пользователю. Например, не создавайте пользовательский интерфейс для открывающегося по порядку пользовательского интерфейса и содержимого всплывающих окон.

-   Для создания экземпляров элементов задержки используйте [x:DeferLoadStrategy](https://msdn.microsoft.com/library/windows/apps/Mt204785).
-   Вставьте программным путем элементы в дерево по запросу.

Очереди [
              **CoreDispatcher.RunIdleAsync**
            ](https://msdn.microsoft.com/library/windows/apps/Hh967918) работают для обработки потока пользовательского интерфейса, когда он не занят.

## Использование асинхронных API

Для поддержания нормальной скорости отклика вашего приложения платформа предоставляет асинхронные версии многих API. Асинхронный API гарантирует, что активный поток выполнения никогда не будет заблокирован в течение продолжительного времени. При вызове API из потока пользовательского интерфейса используйте по возможности асинхронную версию. Дополнительную информацию о программировании с использованием шаблонов **async** см. в разделе [Асинхронное программирование](https://msdn.microsoft.com/library/windows/apps/Mt187335) или [Вызов асинхронных API в C# и Visual Basic](https://msdn.microsoft.com/library/windows/apps/Mt187337).

## Разгрузка выполнения в фоновые потоки

Напишите код для обработчика событий, чтобы он быстро возвращался. В случаях, когда необходимо выполнить нестандартный объем работы, запланируйте выполнение в фоновом потоке и его возвращение.

Запланировать задание можно асинхронно с помощью оператора **await** в C#, оператора **Await** в Visual Basic или делегатов в C++. Но это не гарантирует, что запланированное задание будет выполняться в фоновом потоке. Многие API универсальной платформы Windows (UWP) планируют выполнение в фоновом потоке, но если код приложения вызывается только с помощью **await** или делегата, этот делегат или метод будет выполнен в потоке пользовательского интерфейса. Необходимо явным образом указать, что требуется выполнение кода приложения в фоновом потоке. В C# и Visual Basic это можно сделать, передав код в метод [**Task.Run**](https://msdn.microsoft.com/library/windows/apps/xaml/system.threading.tasks.task.run.aspx).

Помните, что доступ к элементам пользовательского интерфейса можно получить только из потока. Используйте поток пользовательского интерфейса для получения доступа к элементам пользовательского интерфейса, прежде чем запустить фоновую работу и/или использовать [**CoreDispatcher.RunAsync**](https://msdn.microsoft.com/library/windows/apps/Hh750317) или [**CoreDispatcher.RunIdleAsync**](https://msdn.microsoft.com/library/windows/apps/Hh967918) в фоновом потоке.

В качестве примера кода, который можно выполнить в фоновом потоке, возьмем вычисление искусственного интеллекта компьютера в игре. На выполнение кода, вычисляющего следующий ход компьютера, может потребоваться достаточно много времени.

```csharp
public class AsyncExample
{
    private async void NextMove-Click(object sender, RoutedEventArgs e)
    {
        // The await causes the handler to return immediately.
        await System.Threading.Tasks.Task.Run(() => ComputeNextMove());
        // Now update the UI with the results.
        // ...
    }

    private async System.Threading.Tasks.Task ComputeNextMove()
    {
        // Perform background work here.
        // Don't directly access UI elements from this method.
    }
}
```

> [!div class="tabbedCodeSnippets"]
> ```csharp
> public class Example
> {
>     // ...
>     private async void NextMove-Click(object sender, RoutedEventArgs e)
>     {
>         await Task.Run(() => ComputeNextMove());
>         // Update the UI with results
>     }
> 
>     private async Task ComputeNextMove()
>     {
>         // ...
>     }
>     // ...
> }
> ```
> ```vb
> Public Class Example
>     ' ...
>     Private Async Sub NextMove-Click(ByVal sender As Object, ByVal e As RoutedEventArgs)
>         Await Task.Run(Function() ComputeNextMove())
>         ' update the UI with results
>     End Sub
> 
>     Private Async Function ComputeNextMove() As Task
>         ' ...
>     End Function
>     ' ...
> End Class
> ```

В этом примере обработчик `NextMove-Click` возвращается в **await**, чтобы обеспечить быстроту отклика потока пользовательского интерфейса. Однако выполнение снова обращается к этому обработчику после завершения `ComputeNextMove` (которое выполняется в фоновом потоке). Оставшийся код в обработчике обновляет пользовательский интерфейс с учетом результатов.

> **Примечание.** Для UWP существуют также API [**ThreadPool**](https://msdn.microsoft.com/library/windows/apps/BR229621) и [**ThreadPoolTimer**](https://msdn.microsoft.com/library/windows/apps/windows.system.threading.threadpooltimer.aspx) , которые можно использовать для аналогичных сценариев. Дополнительную информацию см. в разделе [Потоки и асинхронное программирование](https://msdn.microsoft.com/library/windows/apps/Mt187340).

## Связанные темы

* [Настраиваемые взаимодействия с пользователем](https://msdn.microsoft.com/library/windows/apps/Mt185599)



<!--HONumber=May16_HO2-->


