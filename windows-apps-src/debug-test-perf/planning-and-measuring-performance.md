---
author: jwmsft
ms.assetid: A37ADD4A-2187-4767-9C7D-EDE8A90AA215
title: Планирование производительности
description: Пользователи ожидают от приложений постоянного отклика и естественной реакции без расходования заряда батареи.
ms.author: jimwalk
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: e62e724cceb458ba922143e61058dffa8d16a0b8
ms.sourcegitcommit: e814a13978f33654d8e995584f4b047cb53e0aef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/05/2018
ms.locfileid: "6023787"
---
# <a name="planning-for-performance"></a>Планирование производительности



Пользователи ожидают от приложений постоянного отклика и естественной реакции без расходования заряда батареи. Формально производительность — нефункциональное требование, однако отношение к производительности приложения как к одной из его возможностей поможет вам оправдать ожидания пользователей. Определение целей и измерений являются ключевыми факторами. Определите сценарии, критические для производительности, а также уровень достаточной производительности. Затем измеряйте ее на ранних этапах и достаточно часто в течение всего жизненного цикла проекта, чтобы убедиться в возможности достижения поставленных целей.

## <a name="specifying-goals"></a>Определение целей

Важнейшим способом определения производительности приложения является его взаимодействие с пользователем. Время запуска приложения может повлиять на мнение пользователя о его производительности. Пользователь может считать время запуска приложения менее одной секунды очень хорошим результатом, менее 5 секунд — хорошим, а более 5 секунд — плохим.

Другие параметры (например, память) имеют менее заметное влияние на взаимодействие с пользователем. Вероятность прерывания работы приостановленного или неактивного приложения растет вместе с объемом памяти, используемой активным приложением. Как правило, использование большого объема памяти ухудшает производительность всех приложений системы, поэтому стремитесь разумно ограничивать потребление памяти. Следует учитывать приблизительный размер приложения, как его воспринимают пользователи: небольшое, среднее или крупное. Ожидания, связанные с производительностью, соотносятся с этим восприятием. Например, вы создаете небольшое приложение, которое не занимает много места на диске и потребляет менее 100 МБ памяти.

Лучше задать начальную цель и пересмотреть ее позже, чем не иметь никакой цели. Цели, связанные с производительностью вашего приложения, должны быть конкретными и измеримыми. Они делятся на три категории: сколько времени уходит у пользователей или у приложения на выполнение задач (время); частота и непрерывность, с которой приложение перерисовывается в ответ на взаимодействие с пользователем (динамичность); и насколько экономно они расходуют системные ресурсы, в том числе заряд батареи (эффективность).

## <a name="time"></a>Время

Оцените допустимые диапазоны затраченного времени (*классы взаимодействия*), необходимое пользователям для выполнения своих задач в приложении. Присвойте каждому классу взаимодействия метку, данные о восприятии пользователем, а также идеальную и максимальную продолжительность. Ниже приведены некоторые предположения.

| Метка класса взаимодействия | Восприятие пользователя                 | Идеальное            | Максимальное          | Примеры                                                                     |
|-------------------------|---------------------------------|------------------|------------------|------------------------------------------------------------------------------|
| Быстрое                    | Минимально заметная задержка      | 100 миллисекунд | 200 миллисекунд | Вывод панели приложения; нажатие кнопки (первая реакция)                        |
| Обычное                 | Не очень быстрое             | 300 миллисекунд | 500 миллисекунд | Изменение размера; контекстное масштабирование                                                        |
| Хорошая скорость отклика              | Не быстро, но скорость отклика кажется хорошей | 500 миллисекунд | 1 секунда         | Переход на другую страницу; возобновление работы приложения после приостановки          |
| Запуск                  | Приемлемое взаимодействие          | 1 секунда         | 3 секунды        | Запуск приложения в первый раз или после прерывания работы ранее |
| С задержкой              | Отклик более не кажется хорошим      | 500 миллисекунд | 5 секунд        | Скачивание файла из Интернета                                            |
| Затянуто                 | Слишком долго; пользователь может переключиться на что-то еще    | 500 миллисекунд | 10 секунд       | Установка нескольких приложений из Магазина                                         |

 

Теперь вы можете назначать классы взаимодействия для сценариев производительности вашего приложения. Для каждого сценария можно назначить ссылку на момент во времени работы приложения, часть взаимодействия с пользователем и класс взаимодействия. Ниже приведены некоторые предположения, например, для кулинарного приложения.


<!-- DHALE: used HTML table here b/c WDCML src used rowspans -->
<table>
<tr><th>Сценарий</th><th>Момент во времени</th><th>Взаимодействие с пользователем</th><th>Класс взаимодействия</th></tr>
<tr><td rowspan="3">Переход на страницу рецепта </td><td>Первая реакция</td><td>Начало анимации перехода страницы</td><td>Быстро (100–200 миллисекунд)</td></tr>
<tr><td>Хорошая скорость отклика</td><td>Список ингредиентов загружен; без изображений</td><td>Хорошая скорость отклика (от 500 миллисекунд до 1 секунды)</td></tr>
<tr><td>Все стало видимым</td><td>Все содержимое загружено; изображения показаны</td><td>С задержкой (500 миллисекунд — 5 секунд)</td></tr>
<tr><td rowspan="2">Поиск рецепта</td><td>Первая реакция</td><td>Кнопка "Поиск" нажата</td><td>Быстро (100–200 миллисекунд)</td></tr>
<tr><td>Все стало видимым</td><td>Локальный список названий рецептов показан</td><td>Обычно (300–500 миллисекунд)</td></tr>
</table>

При отображении обновляющегося содержимого рекомендуется также рассмотреть цели, связанные с актуальностью содержимого. Стоит ли цель обновлять содержимое каждые несколько секунд? Или вполне достаточно обновлять содержимое каждые несколько минут, каждые несколько часов либо даже раз в день?

Определение целей улучшает возможности по тестированию, анализу и оптимизации вашего приложения.

## <a name="fluidity"></a>Простота

Конкретные измеримые цели, связанные с простотой приложения, могут включать следующие.

-   Отсутствие видимых прекращений и возобновлений обновления экрана (сбоев).
-   Отрисовка анимаций с частотой 60 кадров в секунду.
-   Когда пользователь пролистывает или прокручивает страницы в приложении, отображается от 3 до 6 страниц содержимого в секунду.

## <a name="efficiency"></a>Эффективность

Конкретные измеримые цели, связанные с эффективностью приложения, могут включать следующие.

-   Для процесса приложения процент ресурсов ЦП не может превышать *N*, а потребление памяти в мегабайтах — *M*.
-   Если приложение неактивно, *N* и *M* имеют нулевое значение для процесса приложения.
-   Ваше приложение может активно использоваться *X* часов от батареи; если приложение неактивно, устройство сохраняет заряд в течение *Y* часов.

## <a name="design-your-app-for-performance"></a>Учитывайте производительность при разработке приложения

Теперь вы можете использовать цели, связанные с производительностью, как ориентиры при разработке приложения. Рассмотрим в качестве примера кулинарное приложение. После того как пользователь перейдет на страницу рецептов, вы можете выбрать [добавочное обновление элементов](optimize-gridview-and-listview.md#update-items-incrementally), чтобы сначала отображалось название рецепта, отображение ингредиентов откладывалось, а отображение изображений — откладывалось еще дальше. Это обеспечивает отклик и плавный пользовательский интерфейс во время сдвига или прокрутки при отрисовке с максимальным качеством после замедления взаимодействия до скорости, позволяющей потоку пользовательского интерфейса не отставать. Вот некоторые аспекты, которые стоит принять во внимание.

**Пользовательский интерфейс**

-   Максимально увеличьте время анализа и загрузки и повысьте эффективность работы всех страниц пользовательского интерфейса приложения (особенно начальной страницы) с памятью путем [оптимизации разметки XAML](optimize-xaml-loading.md). Одним словом, отложите загрузку пользовательского интерфейса и кода, пока они не понадобятся.
-   Создайте элементы одинакового размера для [**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878) и [**GridView**](https://msdn.microsoft.com/library/windows/apps/BR242705) и используйте как можно больше [методов оптимизации ListView и GridView](optimize-gridview-and-listview.md).
-   Объявите пользовательский интерфейс в форме разметки, которую сможет загружать и повторно использовать по частям платформа, вместо того, чтобы создать императивно в коде.
-   Отложите создание элементов пользовательского интерфейса до тех пор, пока они не понадобятся пользователю. См. атрибут [**x:Load**](../xaml-platform/x-load-attribute.md).
-   По возможности используйте переходы и анимации темы вместо раскадрованных анимаций. Дополнительные сведения см. в разделе [Обзор анимаций](https://msdn.microsoft.com/library/windows/apps/Mt187350). Помните, что для раскадрованных анимаций требуются постоянные обновления экрана, и сохраняйте ЦП и графический конвейер в активном состоянии. Для экономии батареи не воспроизводите анимации, если пользователь не взаимодействует с приложением.
-   Изображения должны загружаться такого размера, который подходит для отображения в том представлении, в котором вы их выводите, с помощью метода [**GetThumbnailAsync**](https://msdn.microsoft.com/library/windows/apps/BR227210).

**ЦП, память и питание**

-   Запланируйте работы с низким приоритетом на соответствующих потоках и/или ядрах. См. раздел [Асинхронное программирование](https://msdn.microsoft.com/library/windows/apps/Mt187335), свойство [**Dispatcher**](https://msdn.microsoft.com/library/windows/apps/BR209054) и класс [**CoreDispatcher**](https://msdn.microsoft.com/library/windows/apps/BR208211).
-   Сведите к минимуму используемый приложением объем памяти, освободив объемные ресурсы (такие как файлы мультимедиа) при приостановке работы.
-   Сведите к минимуму рабочий набор кода.
-   Избегайте утечек памяти за счет отмены регистрации обработчиков событий и снятия ссылок на элементы пользовательского интерфейса, где это только возможно.
-   В целях сохранения заряда батареи используйте традиционный подход к частоте запроса данных или датчика, а также планированию работы ЦП, когда он неактивен.

**Доступ к данным**

-   По возможности выполняйте предварительную загрузку содержимого. Об автоматической предварительной загрузке см. в описании класса [**ContentPrefetcher**](https://msdn.microsoft.com/library/windows/apps/Dn279042). О предварительной загрузке вручную см. в описании пространства имен [**Windows.ApplicationModel.Background**](https://msdn.microsoft.com/library/windows/apps/BR224847) и класса [**MaintenanceTrigger**](https://msdn.microsoft.com/library/windows/apps/Hh700517).
-   По возможности поместите в кэш содержимое, доступ к которому является ресурсоемким. См. свойства [**LocalFolder**](https://msdn.microsoft.com/library/windows/apps/BR241621) и [**LocalSettings**](https://msdn.microsoft.com/library/windows/apps/BR241622).
-   Для промахов в кэше как можно быстрее отобразите замещающий пользовательский интерфейс, указывающий на то, что приложение все еще загружает содержимое. Переход от заполнителя к динамическому содержимому должен выполняться способом, который не мешает работе пользователя. Например, не следует изменять позицию содержимого при движении пальцем или указателем мыши, когда загружается динамическое содержимое.

**Запуск и возобновление приложения**

-   Откладывание экрана-заставки приложения и предотвращение его ненужного расширения. Дополнительные сведения см. в разделе [Создание быстрого и гибкого взаимодействия при запуске приложения](http://go.microsoft.com/fwlink/p/?LinkId=317595) и [Более продолжительное отображение экрана-заставки](https://msdn.microsoft.com/library/windows/apps/Mt187309).
-   Отключайте анимации, которые срабатывают сразу после закрытия экрана-заставки, поскольку во время запуска приложения они вызывают ощущение задержки.

**Адаптивный пользовательский интерфейс и ориентация**

-   Используйте класс [**VisualStateManager**](https://msdn.microsoft.com/library/windows/apps/BR209021).
-   Немедленное завершение только необходимой работы. Операции, для которых требуется интенсивная работа приложения, можно отложить. У вашего приложения будет от 200 до 800 миллисекунд для завершения работы, прежде чем пользователь увидит пользовательский интерфейс приложения в состоянии обрезки.

После того как планирование обеспечения производительности завершено, можно приступать к написанию кода приложения.

## <a name="instrument-for-performance"></a>Средства для обеспечения производительности

По ходу написания кода приложения вы можете добавить код для записи сообщений и событий в определенных точках исполнения приложения. Затем при тестировании приложения можно использовать такие средства профилирования, как Windows Performance Recorder и Windows Performance Analyzer (оба входят в [набор средств для оценки производительности Windows](https://msdn.microsoft.com/library/windows/apps/xaml/hh162945.aspx)), для создания и просмотра отчетов о производительности приложения. В таком отчете можно искать сообщения и события, упрощающие анализ результатов отчета.

Универсальная платформа для Windows (UWP) предоставляет API ведения журналов, подкрепляемые [трассировкой событий Windows (ETW)](https://msdn.microsoft.com/library/windows/desktop/Bb968803). Вместе они предлагают широкие возможности по ведению журналов и трассировке событий. Эти API, входящие в пространство имен [**Windows.Foundation.Diagnostics**](https://msdn.microsoft.com/library/windows/apps/BR206677), включают классы [**FileLoggingSession**](https://msdn.microsoft.com/library/windows/apps/Dn264138), [**LoggingActivity**](https://msdn.microsoft.com/library/windows/apps/Dn264195), [**LoggingChannel**](https://msdn.microsoft.com/library/windows/apps/Dn264202) и [**LoggingSession**](https://msdn.microsoft.com/library/windows/apps/Dn264217).

Чтобы записать сообщение в определенную точку отчета, когда приложение работает, создайте объект **LoggingChannel** и затем вызовите метод [**LogMessage**](https://msdn.microsoft.com/library/windows/apps/windows.foundation.diagnostics.loggingchannel.logmessage.aspx) этого объекта, вот так.

```csharp
// using Windows.Foundation.Diagnostics;
// ...

LoggingChannel myLoggingChannel = new LoggingChannel("MyLoggingChannel");

myLoggingChannel.LogMessage(LoggingLevel.Information, "Here' s my logged message.");

// ...
```

Чтобы записывать события запуска и остановки на протяжении периода времени, когда приложение работает, создайте объект **LoggingActivity** и затем вызовите конструктор [**LoggingActivity**](https://msdn.microsoft.com/library/windows/apps/windows.foundation.diagnostics.loggingactivity.loggingactivity.aspx) этого объекта, вот так.

```csharp
// using Windows.Foundation.Diagnostics;
// ...

LoggingActivity myLoggingActivity;

// myLoggingChannel is defined and initialized in the previous code example.
using (myLoggingActivity = new LoggingActivity("MyLoggingActivity"), myLoggingChannel))
{   // After this logging activity starts, a start event is logged.
    
    // Add code here to do something of interest.
    
}   // After this logging activity ends, an end event is logged.

// ...
```

См. также раздел [Пример ведения журнала](http://go.microsoft.com/fwlink/p/?LinkId=529576).

После того как приложение инструментировано, можно тестировать и измерять его производительность.

## <a name="test-and-measure-against-performance-goals"></a>Тестирование и измерение соответствия целям по производительности

Внесите в ваш план предполагаемые точки измерения производительности. Это служит различным целям в зависимости от того, какие меры предпринимались в ходе создания прототипа, разработки или развертывания проекта. Измерение производительности на ранних этапах создания прототипа может быть значительно полезным, поэтому мы рекомендуем сделать это сразу после написания кода, выполняющего значимые операции. Измерения на столь ранней стадии дают представление о том, что действительно важно в вашем приложении, позволяя принять нужные проектные решения и создать приложение с высокой производительностью и хорошим масштабированием. Обычно дешевле изменить проектирование раньше. Если производительность в цикле работ измерена поздно, это может привести к неожиданным взломам и плохой производительности в итоге.

Используйте эти техники и средства для проверки того, насколько хорошо приложение выполняет исходные цели производительности.

-   Тестирование на широком спектре конфигураций оборудования, включая моноблоки, настольные компьютеры, ноутбуки, ультрабуки, планшеты и другие мобильные устройства.
-   Тестирование на широком спектре размеров экрана. Хотя на более крупных экранах можно показывать гораздо больше содержимого, вывод всего этого содержимого может негативно сказаться на производительности.
-   Устраните как можно большее количество факторов тестирования.
    -   Отключите фоновые приложения на тестируемом устройстве. Для этого в меню "Пуск" ОС Windows выберите **Параметры** &gt; **Персонализация** &gt; **Экран блокировки**. Выберите все активные приложения и установите значение **Нет**.
    -   Выполните компиляцию приложения в машинный код, собрав его в конфигурации выпуска, до развертывания на устройстве тестирования.
    -   Чтобы исключить влияние автоматического обслуживания на производительность устройства тестирования, активируйте его вручную и ожидайте завершения. В меню "Пуск" ОС Windows найдите пункт **Безопасность и обслуживание**. В области **Обслуживание** в разделе **Автоматическое обслуживание** выберите **Начать обслуживание** и ожидайте изменения состояния **Выполняется обслуживание**.
    -   Запустите приложение несколько раз, чтобы устранить случайные факторы тестирования и обеспечить согласованные результаты.
-   Тестирование устройств с малой мощностью. Устройства пользователей могут быть значительно менее мощными, чем компьютер разработки. Windowsбыла разработана с учетом применения на маломощных мобильных устройствах. Приложения, работающие на платформе, должны обеспечить нормальную производительность на этих устройствах. Для правильной постановки задачи лучше сразу принять допущение, что маломощное устройство медленнее настольного компьютера примерно в четырераза.
-   Использование сочетания средств, таких как Microsoft Visual Studio и Windows Performance Analyzer, для измерения производительности приложения. Приложение Visual Studio служит для предоставления анализа, уделяющего основное внимание приложению, такого как анализ привязок исходного кода. Windows Performance Analyzer служит для предоставления анализа, уделяющего основное внимание системе, включая предоставление информации о системе, сведений о событиях сенсорной манипуляции, операциях дискового ввода-вывода и нагрузке на графический процессор. Оба средства предоставляют запись и экспорт трассировок и могут заново открывать общедоступные трассировки и трассировки после окончания.
-   Перед отправкой приложения в магазин для сертификации не забудьте включить в ваши планы тестирования включены связанные с производительностью тестовые случаи, как описано в разделе «Тесты производительности» тестов [Комплект сертификации приложений для Windows](windows-app-certification-kit-tests.md) , а также в «производительность и раздел стабильность» [тестовых случаев приложений UWP](https://msdn.microsoft.com/library/windows/apps/Dn275879).

Дополнительные сведения см. в следующих ресурсах и средствах профилирования.

-   [Windows Performance Analyzer](https://msdn.microsoft.com/library/windows/apps/xaml/hh448170.aspx)
-   [Набор средств для оценки производительности Windows](https://msdn.microsoft.com/library/windows/apps/xaml/hh162945.aspx)
-   [Анализ производительности с помощью средств диагностики Visual Studio](https://msdn.microsoft.com/library/windows/apps/xaml/hh696636.aspx)
-   Мероприятие //build/ [Производительность XAML](https://channel9.msdn.com/Events/Build/2015/3-698)
-   Мероприятие //build/ [Новые средства XAML в Visual Studio 2015](https://channel9.msdn.com/Events/Build/2015/2-697)

## <a name="respond-to-the-performance-test-results"></a>Ответ на результаты тестирования производительности

После анализа результатов тестирования производительности определите, необходимы ли какие-то изменения, например:

-   Следует ли изменить какое-либо из решений проектирования приложений или оптимизировать код?
-   Следует ли добавить, удалить или изменить какой-либо из элементов инструментирования кода?
-   Следует ли изменить какую-либо из целей производительности?

Если требуются изменения, внесите их, а затем продолжите инструментированию или тестированию и повторите действие.

## <a name="optimizing"></a>Оптимизация

Оптимизируйте только пути кода вашего приложения, критические для производительности: те, где затрачивается больше всего времени. Профилирование поможет определить, какие именно. Нередко возникает противоречие между требованиями рекомендаций по созданию приложений и фактическим написанием оптимального кода. Предпочтение следует отдавать продуктивности разработки и качественному проектированию ПО в тех областях, где производительность не является важнейшей задачей.