---
ms.assetid: 159681E4-BF9E-4A57-9FEE-EC7ED0BEFFAD
title: Советы по MVVM и обеспечению производительности языка
description: В этом разделе рассматриваются некоторые вопросы производительности, связанные с выбором шаблонов проектирования программного обеспечения и языка программирования.
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 9027362eccfb8130b181bee26a57f13ce1e1af66
ms.sourcegitcommit: b11f305dbf7649c4b68550b666487c77ea30d98f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/28/2018
ms.locfileid: "7852819"
---
# <a name="mvvm-and-language-performance-tips"></a>Советы по MVVM и обеспечению производительности языка


В этом разделе рассматриваются некоторые вопросы производительности, связанные с выбором шаблонов проектирования программного обеспечения и языка программирования.

## <a name="the-model-view-viewmodel-mvvm-pattern"></a>Шаблон Model-View-ViewModel (MVVM)

Шаблон Model-View-ViewModel (MVVM) является общим для многих приложений XAML. (MVVM очень похож на шаблон Model-View-Presenter, описанный Фаулером (Fowler), отличие лишь в том, что он адаптирован для XAML.) Проблема с шаблоном MVVM заключается в том, что в результате его использования могут появиться приложения, которые имеют слишком много уровней и требуют выделения большого количества памяти. Доводы в пользу MVVM следующие.

-   **Разделение проблем**. Всегда полезно разделить проблему на более мелкие элементы, и шаблон типа MVVM или MVC позволяет разделить приложение (или даже один элемент управления) на более мелкие элементы: фактическое представление (view), логическую модель представления (view-model) и независимую от представления логику приложения (model). В частности, сейчас популярен такой рабочий процесс, в котором дизайнеры разрабатывают представление с помощью одного средства, разработчики разрабатывают модель с помощью другого средства, а интеграторы собирают модель представления, используя оба средства.
-   **Модульное тестирование**. Можно выполнить модульное тестирование модели представления (view-model) (а затем и независимой от представления логики приложения (model)), отдельно от представления (view), и таким образом не заниматься созданием окон, управлением ввода и другими задачами. Сохраняя небольшой размер представления, вы сможете протестировать значительную часть приложения, даже не создавая ни одного окна.
-   **Быстрая адаптация к изменениям процесса взаимодействия с пользователем**. Представление (view) наиболее часто подвергается изменениям, зачастую на поздних этапах, так как взаимодействие с пользователем оптимизируется на основе отзывов пользователей. Если представление содержится отдельно, эти изменения можно вносить быстрее и с меньшим вмешательством в работу приложения.

Шаблон MVVM имеет несколько конкретных определений. Также существуют сторонние платформы, которые помогают реализовывать этот шаблон. Однако строгая реализация какого-то одного из вариантов шаблона может привести к созданию излишне перегруженных приложений.

-   Привязка данных XAML (расширение разметки {Binding}) была разработана в том числе и для создания шаблонов модели/представления. Но {Binding} требует наличие нестандартного рабочего набора и вызывает перегрузку ЦП. Создание привязки ({Binding}) требует выделение памяти, а обновление целевого объекта привязки может вызвать отражение и упаковку-преобразование. Эти проблемы решаются с помощью расширения разметки {x:Bind}, которое компилирует привязки на этапе сборки. **Рекомендация:** используйте {x:Bind}.
-   В MVVM Button.Click часто подключается к модели представления (view-model) с помощью команды ICommand, такой как вспомогательные команды DelegateCommand или RelayCommand. Эти команды требуют выделения дополнительных ресурсов, и поэтому, как и прослушиватель событий CanExecuteChanged, увеличивают рабочий набор и увеличивают время запуска и навигации по странице. **Рекомендация:** вместо использования удобного интерфейса ICommand можно размещать обработчики событий в коде программной части, привязывать их к событиям представления и вызывать команду в модели представления, когда эти события возникают. Вам также потребуется добавить дополнительный код, чтобы отключить кнопку, когда команда будет недоступна.
-   В MVVM разработчики часто создают страницу со всеми возможными конфигурациями пользовательского интерфейса, а затем сворачивают части дерева, привязывая свойство Visibility к свойствам модели представления. Это может без особой необходимости увеличить время запуска и, возможно, рабочий набор (поскольку некоторые части дерева могут никогда не отображаться). **Рекомендации.** Используйте компонент [x:Load attribute](../xaml-platform/x-load-attribute.md) или [x:DeferLoadStrategy attribute](../xaml-platform/x-deferloadstrategy-attribute.md), чтобы исключить ненужные части дерева при запуске. Кроме того, создайте отдельные пользовательские элементы управления для различных режимов страницы и используйте код программной части, чтобы загружать только необходимые элементы управления.

## <a name="ccx-recommendations"></a>Рекомендации по C++/CX

-   **Используйте последнюю версию**. Производительность компилятора C++/CX постоянно улучшается. Убедитесь, что при разработке приложения используется новейший набор средств.
-   **Отключите RTTI (/GR-)**. RTTI включен в компиляторе по умолчанию, поэтому, если ваша среда сборки не выключила его, вы, скорее всего, используете RTTI. RTTI вызывает значительную перегрузку и этот элемент следует отключить, если только ваш код не имеет от него глубокой зависимости. Платформа XAML не требует использования RTTI кодом.
-   **Избегайте чрезмерного использования элементов ppltask**. Элементы ppltask очень удобны при вызове асинхронных API-интерфейсов WinRT, но они значительно увеличивают размер кода. Рабочая группа C++/CX работает над функцией языка await, которая обеспечит значительное улучшение производительности. Одновременно с этим сохраняйте баланс использования элементов ppltask в активно используемых ветвях кода.
-   **Старайтесь не использовать C++/CX в "бизнес-логике" своего приложения**. C++/CX создавался в качестве удобного способа получения доступа к API-интерфейсам WinRT из приложений на C++. Он использует вызывающие перегрузку программы-оболочки. Следует избегать использования C++/CX внутри бизнес-логики/модели класса и использовать его на границах между вашим кодом и WinRT.