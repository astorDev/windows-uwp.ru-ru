---
ms.assetid: 3A477380-EAC5-44E7-8E0F-18346CC0C92F
title: Виртуализация данных ListView и GridView
description: Улучшите производительность и время запуска ListView и GridView с помощью виртуализации данных.
---
# Виртуализация данных ListView и GridView

\[ Обновлено для приложений UWP в Windows 10. Статьи о Windows 8.x см. в [архиве](http://go.microsoft.com/fwlink/p/?linkid=619132) \]

**Примечание.** Для получения дополнительных сведений см. мероприятие //build/ [Резкое повышение производительности при взаимодействии пользователей с большим объемом данных в GridView и ListView](https://channel9.msdn.com/Events/Build/2013/3-158).

Улучшите производительность и время запуска [**ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878) и [**GridView**](https://msdn.microsoft.com/library/windows/apps/BR242705) с помощью виртуализации данных. Подробнее о виртуализации пользовательского интерфейса, сокращении элементов и прогрессивном обновлении элементов см. в разделе [Оптимизация пользовательского интерфейса ListView и GridView](optimize-gridview-and-listview.md).

Для набора данных, который настолько велик, что не может или не должен храниться в памяти одновременно, необходим метод виртуализации данных. Вы загружаете первоначальный объем в память (из локального диска, сети или облака) и применяете виртуализацию пользовательского интерфейса к этой части набора данных. Позже вы можете загрузить дополнительные данные приращениями или по требованию из произвольных мест в наборе основных данных (прямой доступ). Подходит вам виртуализация данных или нет зависит от многих факторов:

-   размера набора данных;
-   размера каждого элемента;
-   источника набора данных (расположение на локальном диске, в сети или облаке);
-   общего потребления памяти вашим приложением.

**Примечание.** Функция включена по умолчанию для ListView и GridView и отображает визуальные элементы временных заполнителей при быстром сдвиге или прокрутке. После загрузки данных эти визуальные элементы-заполнители заменяются вашим шаблоном элементов. Функцию можно отключить, установив для параметра [**ListViewBase.ShowsScrollingPlaceholders**](https://msdn.microsoft.com/library/windows/apps/BR242878base-showsscrollingplaceholders) значение «false», но в таком случае рекомендуется использовать атрибут x:Phase для постепенной обработки элементов в вашем шаблоне элементов. См. раздел [Прогрессивное обновление элементов ListView и GridView](optimize-gridview-and-listview.md#update-items-incrementally).

Ниже приведены подробные сведения о методах добавочной виртуализации данных и виртуализации данных прямого доступа.

## Инкрементная виртуализация данных

Инкрементная виртуализация данных загружает данные последовательно. [
            **ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878), использующий инкрементную виртуализацию данных, можно использовать для просмотра коллекции миллиона элементов, но изначально загружаются только 50 элементов. Следующие 50 загружаются, когда пользователь прокручивает страницу. По мере загрузки элементов бегунок полосы прокрутки уменьшается в размере. Для этого типа виртуализации данных записывается класс источника данных, применяющий эти интерфейсы.

-   [**IList**](T:System.Collections.IList)
-   [**INotifyCollectionChanged**](T:System.Collections.Specialized.INotifyCollectionChanged) (C#/VB) или [**IObservableVector&lt;T&gt;**](https://msdn.microsoft.com/library/windows/apps/BR226052) (C++/CX)
-   [**ISupportIncrementalLoading**](https://msdn.microsoft.com/library/windows/apps/Hh701916)

Подобный источник данных — это хранящийся в памяти список, который можно постоянно расширять. Элемент управления элементами запрашивает элементы, используя стандартный индексатор [**IList**](T:System.Collections.IList) и свойства подсчета. Подсчет должен представлять число элементов локально, а не фактический размер набора данных.

Когда элемент управления элементами подходит к концу существующих данных, он вызывает [**ISupportIncrementalLoading.HasMoreItems**](https://msdn.microsoft.com/library/windows/apps/Hh701916-hasmoreitems). Если возвратить **true**, он вызовет [**ISupportIncrementalLoading.LoadMoreItemsAsync**](https://msdn.microsoft.com/library/windows/apps/Hh701916-loadmoreitemsasync), передавая рекомендованное число элементов для загрузки. В зависимости от того, откуда загружаются данные (из локального диска, сети или облака), можно указать другое число элементов для загрузки, отличающееся от рекомендованного. Например, если ваша служба поддерживает пакеты из 50 элементов, но элемент управления элементами запрашивает только 10, то вы можете загрузить 50. Загрузите данные из серверной части, добавьте их в список и вызовите уведомление об изменениях с помощью [**INotifyCollectionChanged**](T:System.Collections.Specialized.INotifyCollectionChanged) или [**IObservableVector&lt;T&gt;**](https://msdn.microsoft.com/library/windows/apps/BR226052), чтобы элемент управления элементами получил сведения о новых элементах. Следует также возвратить число фактически загруженных элементов. Если вы загружаете меньше элементов, чем рекомендовано, или элемент управления элементами прокручивается дальше на промежуточных этапах, то источник данных вызывается снова для большего числа элементов и цикл продолжается. Дополнительные сведения можно получить, скачав [образец привязки данных в XAML](https://code.msdn.microsoft.com/windowsapps/Data-Binding-7b1d67b5) для Windows 8.1, а затем повторно использовав исходный код в приложении для Windows 10.

## Виртуализация данных прямого доступа

Виртуализация данных прямого доступа позволяет загружать данные из произвольного места в наборе данных. [
            **ListView**](https://msdn.microsoft.com/library/windows/apps/BR242878), использующий виртуализацию данных прямого доступа, применяется для просмотра коллекции из миллиона элементов и может загружать элементы 100 000–100 050. Если пользователь затем перейдет к началу списка, элемент управления загрузит элементы 1–50. Бегунок полосы прокрутки всегда указывает, что **ListView** содержит миллион элементов. Положение бегунка полосы прокрутки зависит от того, где в полном наборе данных коллекции расположены видимые элементы. Этот тип виртуализации данных может значительно сократить требования к памяти и время загрузки для коллекции. Чтобы включить его, необходимо создать класс источника данных, который будет извлекать данные по запросу, управлять локальным кэшем и реализовывать указанные интерфейсы.

-   [**IList**](T:System.Collections.IList)
-   [**INotifyCollectionChanged**](T:System.Collections.Specialized.INotifyCollectionChanged) (C#/VB) или [**IObservableVector&lt;T&gt;**](https://msdn.microsoft.com/library/windows/apps/BR226052) (C++/CX)
-   (Необязательно) [**IItemsRangeInfo**](https://msdn.microsoft.com/library/windows/apps/Dn877070)
-   (Необязательно) [**ISelectionInfo**](https://msdn.microsoft.com/library/windows/apps/Dn877074)

[**IItemsRangeInfo**](https://msdn.microsoft.com/library/windows/apps/Dn877070) предоставляет сведения о том, с какими элементами активно используется элемент управления. Элемент управления элементами вызывает этот метод при каждом изменении представления и включает эти два набора диапазонов.

-   Набор элементов в окне просмотра.
-   Набор элементов без виртуализации, которые используются элементом управления и которых может не быть в окне просмотра.
    -   Буфер элементов вокруг окна просмотра, который используется элементом управления элементами для плавности сенсорного панорамирования.
    -   Элемент с фокусом ввода.
    -   Первый элемент.

Реализуя [**IItemsRangeInfo**](https://msdn.microsoft.com/library/windows/apps/Dn877070), источник данных получает сведения о том, какие элементы необходимо извлечь и поместить в кэш, а также о том, когда вырезать из кэша данные, которые больше не нужны. **IItemsRangeInfo** использует объекты [**ItemIndexRange**](https://msdn.microsoft.com/library/windows/apps/Dn877081), чтобы описать набор элементов на основе их индекса в коллекции. Это необходимо для того, чтобы он не использовал указатели элемента, которые не могут быть неправильными или непостоянными. **IItemsRangeInfo** предназначен для использования только одним экземпляром элемента управления элементами, так как он зависит от сведений о состоянии этого элемента управления элементами. Если нескольким элементам управления элементами требуется доступ к тем же данным, то понадобиться отдельный экземпляр источника данных для каждого из них. Они могут использовать общий кэш, но логика для очистки из кэша будет более сложной.

Ниже приведена основная стратегия для вашего источника данных виртуализации данных прямого доступа.

-   При запросе элемента
    -   Если он доступен в памяти, возвратите его.
    -   Если он отсутствует, возвратите значение null или заполнитель.
    -   Используйте запрос элемента (или сведения о диапазоне из [**IItemsRangeInfo**](https://msdn.microsoft.com/library/windows/apps/Dn877070)), чтобы узнать, какие элементы обязательны, и асинхронно извлечь данные из серверной части. После извлечения данных отправьте уведомление об изменении с помощью [**INotifyCollectionChanged**](T:System.Collections.Specialized.INotifyCollectionChanged) или [**IObservableVector&lt;T&gt;**](https://msdn.microsoft.com/library/windows/apps/BR226052), чтобы элемент управления элементами получил сведения о новых элементах.
-   (Необязательно) По мере изменения окна просмотра элемента управления элементами определите, какие элементы из источника данных необходимы, используя [**IItemsRangeInfo**](https://msdn.microsoft.com/library/windows/apps/Dn877070).

Более того, стратегия того, когда загружать элементы данных, сколько элементов загружать и какие элементы хранить в памяти, зависит от приложения. Несколько общих аспектов, о которых необходимо помнить.

-   Создайте асинхронные запросы данных; не блокируйте поток пользовательского интерфейса.
-   Найдите активную зону в размере пакетов, элементы которых вы извлекаете. Лучше коротко и по-крупному. Не так мало, чтобы создавать слишком много небольших запросов; не слишком много, чтобы их выполнение занимало слишком много времени.
-   Подумайте, сколько запросов должны ожидать выполнения одновременно. Выполнять их по одному проще, но это может быть слишком медленно при увеличении времени выполнения.
-   Можно ли отменить запросы данных?
-   Существует ли плата за транзакцию при использовании размещенных служб?
-   Какие уведомления предоставляются службой при изменении результатов запроса? Получите ли вы уведомление, если элемент будет вставлен с индексом 33? Если ваша служба поддерживает запросы типа ключ-плюс-смещении, это может быть лучше, чем просто использовать индекс.
-   Насколько вы хотите быть осведомлены об элементах, которые будут извлечены? Вы собираетесь испытать и отслеживать направление и скорость прокрутки, чтобы определить, какие элементы необходимы?
-   Насколько вы радикальны в вопросе очистки кэша? Это компромисс памяти и взаимодействия.






<!--HONumber=Mar16_HO1-->


