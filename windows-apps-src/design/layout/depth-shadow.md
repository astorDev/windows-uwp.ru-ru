---
author: serenaz
description: Z-глубины или относительно глубины и тени можно внедрить в приложение, чтобы помочь пользователям сосредоточиться естественного и эффективного глубины двумя способами.
title: Z-глубины и тени для приложений UWP
template: detail.hbs
ms.author: sezhen
ms.date: 02/12/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp
pm-contact: chigy
design-contact: balrayit
ms.localizationpriority: medium
ms.openlocfilehash: a1433b131b994ee2b1323909bc7c195e00f43cde
ms.sourcegitcommit: 63cef0a7805f1594984da4d4ff2f76894f12d942
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/05/2018
ms.locfileid: "4392320"
---
# <a name="z-depth-and-shadow"></a>Z-глубины и тени

![значение true, глубины](images/elevation-shadow/depth.svg)

Fluent глубины система использует физические такие понятия как 3D позиционирования, светлый, и тени для обновления пользовательского интерфейса цифровых могут восприниматься в более физической среде. Z-глубины или относительно глубины и тени можно двумя способами внедрить глубины в приложении UWP.

## <a name="what-is-z-depth"></a>Что такое z-depth?

Глубина Z — это расстояние между двумя поверхности по оси z, и показано, как закрыть объект находится в средстве просмотра.

![глубина z](images/elevation-shadow/elevation.svg)

### <a name="why-use-z-depth"></a>Зачем использовать z-depth?

В реальном мире обычно сосредоточиться на объекты, которые расположены ближе к нам. Можно применить цифровой пользовательского интерфейса, а также этот пространственного очевидным. Например если элемент ближе к пользователю, пользователю будет instinctively сосредоточьтесь на элементе. Перемещение элементов пользовательского интерфейса ближе ось z вы можете установить визуальную иерархию между объектами, помогая пользователям естественного и эффективного выполнения задач в вашем приложении. 

![z-depth в контекстного меню](images/elevation-shadow/whyelevation.svg)

В дополнение к предоставление полезных визуальную иерархию z-depth также для создания единообразного легко от двухмерных в трехмерных средах, масштабирование приложения во всех устройств и форм-факторов. 

![z-depth в 2d-3d](images/elevation-shadow/elevation-2d3d.svg)

### <a name="how-is-z-depth-perceived"></a>Как воспринимается z глубины

В зависимости от как мы чувствовали глубины в реальном мире, Вот несколько методов, которые могут использоваться для отображения близкого взаимодействия в пользовательском Интерфейсе цифровой.

- **Масштаб** Дальше объекты отображаются меньше, чем ближе объекты того же размера. Этот метод является очень сложно эффективно продемонстрировать в двухмерном пространстве, поэтому не рекомендуется. Тем не менее масштабирования и [тени](#what-is-shadow) можно использовать для создания эффективных моделирования перемещение ближе к пользователю в двух объектов.

    ![близкого взаимодействия с помощью масштабирования](images/elevation-shadow/elevation-scale.svg)

- **Атмосфера** Объекты могут отображаться дальше и фокус с «smoky» наложения или других атмосферные эффекта.

    ![близкого взаимодействия с атмосферу](images/elevation-shadow/elevation-atmosphere.svg)

- **Движение** Относительная скорость может использоваться для демонстрации близости: ближе объекты перемещаются быстрее, чем дорогостоящим фоновых объектов. Чтобы узнать, как реализовать этот эффект, см. в разделе [Параллакс](../motion/parallax.md).

    ![близкого взаимодействия с движением](images/elevation-shadow/elevation-motion.svg)

### <a name="recommendations-for-z-depth"></a>Рекомендации по z глубины

Уменьшите число с повышенными привилегиями плоскостей для обеспечения четкого визуального фокуса. Для большинства сценариев создания двух плоскостей достаточно: один для элементов переднего плана (высокой приближения) и другой для элементов фона (низкий приближения). Если у вас есть несколько элементов с повышенными привилегиями, которые не перекрываются, сгруппируйте их одной плоскости (т. е. передний план) для уменьшения числа плоскости.

![z-depth в приложении](images/elevation-shadow/app-depth.svg)

## <a name="what-is-shadow"></a>Что такое тень?

![тени](images/elevation-shadow/shadow.svg)

Тени — это способ видеть повышение прав. Если индикатор над объект с повышенными привилегиями, существует тени на поверхности ниже. Чем больше объектов, чем больше и мягкий становится тени. Обратите внимание, что с повышенными привилегиями объекты не нужно будет тени, но тени указать повышение прав.

В приложениях UWP тени должен быть содержательные, не именно то. Если тени ухудшает фокус и повышения производительности, затем ограничьте использование теней.

Тени можно использовать с API-интерфейсы DropShadow или ThemeShadow.

## <a name="themeshadow"></a>ThemeShadow

ThemeShadow тип может относиться к любому элементу XAML для рисования теней соответствующим образом на основе x, y, z координат. ThemeShadow также автоматически подстраивается под другие требования:

- Адаптируется к изменениям освещения, тема, среде приложения и оболочки.
- Скрывает элементы автоматически в зависимости от их повышение прав.
- Обеспечивает синхронизацию элементов при перемещении и изменить повышение прав.
- Сохраняет теней на протяжении всего и между приложениями.

Ниже приведены примеры ThemeShadow в разных повышение с светлые и темные темы.

![смарт-теней с использованием Светлая тема](images/elevation-shadow/smartshadow-light.svg)

![смарт-тени с темной темой](images/elevation-shadow/smartshadow-dark.svg)

### <a name="themeshadow-in-common-controls"></a>ThemeShadow общих элементов управления

Следующие общие элементы управления будут автоматически использовать ThemeShadow отбрасывать тени:

- [Диалоговые окна и всплывающие элементы](../controls-and-patterns/dialogs.md)
- [NavigationView](../controls-and-patterns/navigationview.md)
- [Элемент управления транспортировкой мультимедиа](../controls-and-patterns/media-playback.md)
- [Контекстное меню](../controls-and-patterns/menus.md)
- [Панель команд](../controls-and-patterns/app-bars.md)
- [Автозаполнение](../controls-and-patterns/auto-suggest-box.md), [поле со списком](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ComboBox), [средства выбора календаря, даты и времени](../controls-and-patterns/date-and-time.md), [подсказки](../controls-and-patterns/tooltips.md)
- [Ключи доступа](../input/access-keys.md)

### <a name="themeshadow-in-popups"></a>ThemeShadow в всплывающих окон

ThemeShadow автоматически приводит тени при применении к любому элементу XAML [всплывающее окно](/uwp/api/windows.ui.xaml.controls.primitives.popup). Он будет отбрасывать тени на содержимое фона приложения за его и любых других открыть всплывающих окон под ним.

Чтобы использовать ThemeShadow с помощью всплывающих окон, используйте `Shadow` для применения ThemeShadow элемент XAML. Затем повысить элемент от других элементов, например с помощью z-компонент `Translation` свойства.
Для большинства всплывающее окно пользовательского интерфейса повышение прав рекомендуется по умолчанию относительно содержимого фона приложения составляет 32 эффективных пикселя.

В этом примере показано прямоугольник во всплывающем окне приведение тени на содержимое фона приложения и другие всплывающие окна за ним:

```xaml
<Popup>
    <Rectangle x:Name="PopupRectangle" Fill="White" Height="48" Width="96">
        <Rectangle.Shadow>
            <ThemeShadow />
        </Rectangle.Shadow>
    </Rectangle>
</Popup>
```

```csharp
// Elevate the rectangle by 32px
PopupRectangle.Translation += new Vector3(0, 0, 32);
```

![тени из примера кода](images/elevation-shadow/smartshadow-example.svg)

### <a name="themeshadow-in-other-elements"></a>ThemeShadow в других элементах

Чтобы отбрасывать тень из элемента XAML, который не является во всплывающем окне, необходимо явно задать другие элементы, которые могут получать теней в `ThemeShadow.Receivers` коллекции.

В этом примере показаны две кнопки, которые отбрасывать тени на сетке за их:

```xaml
<Grid x:Name="BackgroundGrid" Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
    <Grid.Resources>
        <ThemeShadow x:Name="SharedShadow" />
    </Grid.Resources>

    <Button x:Name="Button1" Content="Button 1" Shadow="{StaticResource SharedShadow}" Margin="10" />

    <Button x:Name="Button2" Content="Button 2" Shadow="{StaticResource SharedShadow}" Margin="120" />
</Grid>
```

```csharp
/// Add BackgroundGrid as a shadow receiver and elevate the casting buttons above it
SharedShadow.Receivers.Add(BackgroundGrid);

Button1.Translation += new Vector3(0, 0, 16);
Button2.Translation += new Vector3(0, 0, 32);
```

### <a name="performance-best-practices-for-themeshadow"></a>Рекомендации по производительности для ThemeShadow

1. Ограничьте количество элементов приемника необходимый минимум. 

2. Если несколько элементов получатель находятся на том же повышение прав попробуйте скомбинировать нацеливание вместо одного родительского элемента.

3. Если несколько элементов должен приводить к одному типу тени на те же элементы получатель добавлять тени как общий ресурс и использовать его повторно.

## <a name="drop-shadow"></a>Отбрасывание тени

DropShadow не автоматически реагирует на свою среду и не использует источников света. Примеры реализаций, см. в [Классе DropShadow](https://docs.microsoft.com/uwp/api/windows.ui.composition.dropshadow).

## <a name="which-shadow-should-i-use"></a>Какие теней следует использовать?

| Свойство | ThemeShadow | DropShadow |
| - | - | - | - |
| **Min SDK** | RS5 | 14393 |
| **Адаптируемость** | Да | Нет |
| **Настройка** | Нет | Да |
| **Источник света** | Автоматическое (глобальных по умолчанию, но можно переопределить каждого приложения) | Нет |
| **Поддерживается в трехмерных средах** | Да | Нет |

- Как правило рекомендуется использовать ThemeShadow, которая автоматически адаптируется к своей среды.
- Если более сложных сценариев для пользовательских тени, используйте DropShadow, что обеспечивает более настройки.
- Для обеспечения обратной совместимости, использовать DropShadow.
- Вопросы о производительности ограничить количество тени или использовать DropShadow.
- С помощью ThemeShadow на HMDs в трехмерном пространстве значение true. Так как DropShadow рисует с указанным смещением от визуального объекта, он становится дочерним, на стороне оно будет выглядеть, как он будет где-то в пространстве. С другой стороны ThemeShadow отрисовывается поверх определен как приемники визуальные элементы.
