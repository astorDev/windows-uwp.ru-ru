---
author: knicholasa
description: Использование глубины трехмерной сцены или относительной глубины и тени — это два способа реализовать глубину в приложении, чтобы помочь пользователям сосредоточиться интуитивным и эффективным образом.
title: Глубина трехмерной сцены и тень для приложений UWP
template: detail.hbs
ms.date: 04/19/2019
ms.topic: article
ms.custom: 19H1
keywords: windows 10, uwp
pm-contact: chigy
ms.localizationpriority: medium
ms.openlocfilehash: 216974ba564a192f94473469f3a7a49191ef2192
ms.sourcegitcommit: af4050f69168c15b0afaaa8eea66a5ee38b88fed
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/21/2020
ms.locfileid: "80081389"
---
# <a name="z-depth-and-shadow"></a>Глубина трехмерной сцены и тени

![GIF-файл с изображением четырех серых прямоугольников, расположенных по диагонали, один поверх другого GIF-изображение анимируется таким образом, чтобы тени отображались и исчезали.](images/elevation-shadow/shadow.gif)

Создание визуальной иерархии элементов в пользовательском интерфейсе делает пользовательский интерфейс удобным для просмотра и передает то, на чем важно сконцентрироваться. Эффект возвышенности, действия по выделению элементов пользовательского интерфейса часто используются для достижения такой иерархии в программном обеспечении. В этой статье рассматривается создание возвышенности в приложении UWP с использованием глубины трехмерной сцены и тени.

Глубина трехмерной сцены — это термин, используемый создателями трехмерных приложений для обозначения расстояния между двумя поверхностями вдоль оси Z. Она позволяет понять, насколько близок объект к зрителю. Глубину можно рассматривать как концепцию, аналогичную осям координат X/Y, но в направлении оси Z.

## <a name="why-use-z-depth"></a>Зачем использовать глубину трехмерной сцены?

В физическом мире люди сосредотачиваются на объектах, которые ближе к ним. Мы можем применить этот пространственный инстинкт и к цифровому пользовательскому интерфейсу. Например, если вы приблизите элемент к пользователю, то пользователь инстинктивно сосредоточится на этом элементе. Перемещая элементы пользовательского интерфейса ближе по оси Z, можно установить визуальную иерархию между объектами, что поможет пользователям выполнять задачи интуитивно и эффективно в вашем приложении.

## <a name="what-is-shadow"></a>Что такое тень?

Тень создает для пользователя один из способов восприятия высоты расположения объектов. Освещение над объектом, расположенным вверху, создает тень на поверхности внизу. Чем выше объект, тем больше и мягче становится тень. Элементы, расположенные высоко в вашем пользовательском интерфейсе, не обязательно должны иметь тени, но они помогают создать видимость возвышения.

В приложениях UWP тени следует использовать целенаправленно, а не для эстетики. Избыточное использование теней приведет к уменьшению или исключению способности тени фокусировать на элементе внимание пользователя.

Если вы используете стандартные элементы управления, ThemeShadow будет автоматически включен в ваш пользовательский интерфейс. Но вы можете вручную включить тени в свой пользовательский интерфейс с помощью API-интерфейсов ThemeShadow или DropShadow. 

## <a name="themeshadow"></a>ThemeShadow

Тип [ThemeShadow](/uwp/api/windows.ui.xaml.media.themeshadow) можно применить к любому элементу XAML, чтобы нарисовать тени соответствующим образом на основе координат X, Y и Z. ThemeShadow также автоматически настраивается для других спецификаций среды:

- адаптируется к изменениям в освещении, пользовательской теме, среде приложения и оболочке;
- автоматически применяет тени к элементам на основе глубины трехмерной сцены; 
- обеспечивает синхронизацию элементов при их перемещении и изменении их высоты;
- обеспечивает согласованность теней во всех приложениях и между ними.

В MenuFlyout реализация ThemeShadow выглядит следующим образом: В MenuFlyout есть встроенный интерфейс, в котором основная поверхность повышается на 32 пикселя, а каждое дополнительное каскадное меню располагается на 8 пикселей выше меню, из которого оно открывается.

![Снимок экрана ThemeShadow, примененного к MenuFlyout с тремя открытыми вложенными меню Первое меню повышено на 32 пикселя, а каждое последующее меню, открывающееся из предыдущего меню, повышается еще на 8 пикселей так, что оно оставляет отчетливую тень на заднем фоне.](images/elevation-shadow/themeshadow-menuflyout.png)

### <a name="themeshadow-in-common-controls"></a>ThemeShadow в общих элементах управления

Следующие общие элементы управления автоматически используют ThemeShadow для создания теней с глубиной 32 пикселя, если не указано иное:

- [контекстное меню](../controls-and-patterns/menus.md), [панель команд](../controls-and-patterns/app-bars.md), [всплывающее меню панели команд](../controls-and-patterns/command-bar-flyout.md), [строка меню](../controls-and-patterns/menus.md#create-a-menu-bar);
- [диалоговые окна и всплывающие элементы](../controls-and-patterns/dialogs.md) (диалоговое окно на высоте 64 пикселя);
- [NavigationView](../controls-and-patterns/navigationview.md)
- [ComboBox](../controls-and-patterns/combo-box.md), [DropDownButton, SplitButton, ToggleSplitButton](../controls-and-patterns/buttons.md);
- [TeachingTip](../controls-and-patterns/dialogs-and-flyouts/teaching-tip.md);
- [AutoSuggestBox](../controls-and-patterns/auto-suggest-box.md) 
- [календарь, дата, элементы выбора времени](../controls-and-patterns/date-and-time.md);
- [всплывающая подсказка](../controls-and-patterns/tooltips.md) (16 пикселей);
- [элементы управления транспортировкой мультимедиа](../controls-and-patterns/media-playback.md#media-transport-controls), [InkToolbar](../controls-and-patterns/inking-controls.md);
- [Подключенная анимация](../motion/connected-animation.md)

Примечание. Всплывающие элементы будут применять ThemeShadow только при компиляции с Windows 10 версии 1903 или пакета SDK более поздней версии.

### <a name="themeshadow-in-popups"></a>ThemeShadow во всплывающих окнах

Часто в пользовательском интерфейсе приложения всплывающее окно используется для сценариев, когда нужно привлечь внимание пользователя и быстрое действие. Это отличный пример случая, когда тень следует использовать для создания иерархии в пользовательском интерфейсе вашего приложения.

Класс ThemeShadow автоматически создаст отбрасываемые тени при применении к любому элементу XAML во [всплывающем окне](/uwp/api/windows.ui.xaml.controls.primitives.popup). Этот элемент будет отбрасывать тень на фоновое содержимое приложения позади себя и на любые другие открытые всплывающие окна под ним.

Чтобы использовать ThemeShadow со всплывающими окнами, используйте свойство `Shadow` для применения ThemeShadow к элементу XAML. Затем поднимите элемент над другими элементами позади него, например, используя компонент Z свойства `Translation`.
Для большинства всплывающих элементов интерфейса рекомендуемая высота по умолчанию относительно фонового содержимого приложения составляет 32 эффективных пикселя.

В этом примере показан прямоугольник во всплывающем окне, отбрасывающий тень на фон в приложении и любые другие всплывающие окна позади него:

```xaml
<Popup>
    <Rectangle x:Name="PopupRectangle" Fill="Lavender" Height="48" Width="96">
        <Rectangle.Shadow>
            <ThemeShadow />
        </Rectangle.Shadow>
    </Rectangle>
</Popup>
```

```csharp
// Elevate the rectangle by 32px
PopupRectangle.Translation += new Vector3(0, 0, 32);
```

![Одно прямоугольное всплывающее окно с тенью.](images/elevation-shadow/PopupRectangle.png)

### <a name="disabling-default-themeshadow-on-custom-flyout-controls"></a>Отключение ThemeShadow по умолчанию на пользовательских всплывающих элементах управления

Элементы управления на основе [Flyout](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.flyout), [DatePickerFlyout](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.datepickerflyout), [MenuFlyout](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.menuflyout) или [TimePickerFlyout](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.timepickerflyout) автоматически используют ThemeShadow для создания тени.

Если тень по умолчанию не выглядит корректно в содержимом элемента управления, то ее можно отключить, установив для свойства [IsDefaultShadowEnabled](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.flyoutpresenter.isdefaultshadowenabled) значение `false` в соответствующем FlyoutPresenter:

```xaml
<Flyout>
    <Flyout.FlyoutPresenterStyle>
        <Style TargetType="FlyoutPresenter">
            <Setter Property="IsDefaultShadowEnabled" Value="False" />
        </Style>
    </Flyout.FlyoutPresenterStyle>
</Flyout>
```

### <a name="themeshadow-in-other-elements"></a>ThemeShadow в других элементах

В целом рекомендуется тщательно продумать использование тени и ограничить ее использование случаями, когда она создает осмысленную визуальную иерархию. Тем не менее, мы предоставляем способ создать тень от любого элемента пользовательского интерфейса, если у вас есть расширенные сценарии, в которых это требуется.

Чтобы создать тень от элемента XAML, который не находится во всплывающем окне, необходимо явно указать другие элементы, которые могут получить тень в коллекции `ThemeShadow.Receivers`. Получатель не может быть предком отбрасывающего тень элемента в визуальном дереве.

В этом примере показаны два прямоугольника, которые отбрасывают тени на сетку позади них:

```xaml
<Grid>
    <Grid.Resources>
        <ThemeShadow x:Name="SharedShadow" />
    </Grid.Resources>

    <Grid x:Name="BackgroundGrid" Background="{ThemeResource ApplicationPageBackgroundThemeBrush}" />

    <Rectangle x:Name="Rectangle1" Height="100" Width="100" Fill="Turquoise" Shadow="{StaticResource SharedShadow}" />

    <Rectangle x:Name="Rectangle2" Height="100" Width="100" Fill="Turquoise" Shadow="{StaticResource SharedShadow}" />
</Grid>
```

```csharp
/// Add BackgroundGrid as a shadow receiver and elevate the casting buttons above it
SharedShadow.Receivers.Add(BackgroundGrid);

Rectangle1.Translation += new Vector3(0, 0, 16);
Rectangle2.Translation += new Vector3(120, 0, 32);
```

![Два бирюзовых прямоугольника рядом друг с другом, отбрасывающие тени](images/elevation-shadow/SharedShadow.png)

### <a name="performance-best-practices-for-themeshadow"></a>Рекомендации по повышению производительности для ThemeShadow

1. Система устанавливает ограничение в пять пар отбрасывающих и принимающих тень элементов и отключает тень, если значение превышено. Придерживайтесь установленного системой ограничения в пять пар отбрасывающих и принимающих тень элементов.

2. Ограничьте количество настраиваемых принимающих элементов до необходимого минимума.

3. Если несколько принимающих элементов расположены на одной высоте, попробуйте объединить их, указав вместо этого один родительский элемент.

4. Если несколько элементов будут отбрасывать тени одного и того же типа на одни и те же принимающие элементы, то добавьте тень в качестве общего ресурса и повторно используйте ее.

## <a name="drop-shadow"></a>Отбрасывание тени

DropShadow не реагирует автоматически на окружающую среду и не использует источники освещения. Примеры реализации см. в статье [Класс DropShadow](https://docs.microsoft.com/uwp/api/windows.ui.composition.dropshadow).

## <a name="which-shadow-should-i-use"></a>Какую тень использовать

| Свойство | ThemeShadow | DropShadow |
| - | - | - |
| **Самая ранняя версия пакета SDK** | Windows 10 версии 1903 | 14393 |
| **Адаптируемость** | Да | Нет |
| **Настройка** | Нет | Да |
| **Источники освещения** | Автоматически (глобальное значение по умолчанию, но может переопределяться для каждого приложения) | Нет |
| **Поддержка в трехмерных средах** | Да | Нет |

- Учитывайте, что предназначение тени — обеспечить осмысленную иерархию, а не просто визуальное сопровождение.
- Как правило, мы рекомендуем использовать класс ThemeShadow, который обеспечивает автоматическую адаптацию к окружающей среде.
- Если вас беспокоит производительность, ограничьте количество теней, используйте другое визуальное сопровождение или используйте DropShadow.
- Если у вас есть более расширенные сценарии для реализации визуальной иерархии, используйте другое визуальное сопровождение (например, цвета). Если нужна тень, то используйте DropShadow.
