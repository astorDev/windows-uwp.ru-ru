---
Description: Просмотр различных частей приложения в отдельных окнах.
title: Отображение нескольких представлений для приложения
ms.date: 05/19/2017
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: ee49b5fe5b5956e9069ea196c4d2e029b3a15763
ms.sourcegitcommit: 3cc6eb3bab78f7e68c37226c40410ebca73f82a9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/02/2019
ms.locfileid: "68729518"
---
# <a name="show-multiple-views-for-an-app"></a>Отображение нескольких представлений для приложения

![Модель, показывающая приложение с несколькими окнами](images/multi-view.gif)

Помогите пользователям работать эффективнее, дав им возможность открывать независимые компоненты приложения в отдельных окнах. При создании нескольких окон для приложения панель задач отображает каждое окно отдельно. Пользователи могут перемещать, отображать, скрывать окна приложения и менять их размеры независимо друг от друга, а также переключаться между окнами, как будто это разные приложения.

> **Важные API**: Пространство имен [Windows. UI. виевманажемент](/uwp/api/windows.ui.viewmanagement), [пространство имен Windows. UI. виндовманажемент](/uwp/api/windows.ui.windowmanagement)

## <a name="when-should-an-app-use-multiple-views"></a>Когда приложение должно использовать несколько представлений?

Существует множество сценариев, которые могут использовать преимущества нескольких представлений. Вот несколько примеров.

- Приложение электронной почты, которое позволяет пользователям просматривать список полученных сообщений при составлении нового письма
- Приложение адресной книги, которое позволяет пользователям сравнить контактные данные для нескольких параллельных пользователей
- Приложение проигрывателя музыки, которое позволяет пользователям просматривать информацию о воспроизводимой музыке во время просмотра списка другой доступной музыки
- Приложение заметок, которое позволяет пользователям копировать сведения с одной страницы заметок на другую
- Приложение чтения, которое дает пользователям возможность просматривать все заголовки высокого уровня и позволяет открывать несколько статей для чтения позже

Поскольку каждый макет приложения уникален, мы рекомендуем добавить кнопку «новое окно» в предсказуемые местоположение, например в правый верхний угол содержимого, которое можно открыть в новом окне. Также рекомендуется включить параметр [контекстного меню](../controls-and-patterns/menus.md) , чтобы открыть новое окно.

Сведения о создании отдельных экземпляров приложения (а не отдельных окон для одного экземпляра) см. в статье [Создание приложения](../../launch-resume/multi-instance-uwp.md)универсальной платформы Windows с несколькими экземплярами.

## <a name="windowing-hosts"></a>Узлы с окнами

Существует несколько способов размещения содержимого UWP внутри приложения.

- [CoreWindow](/uwp/api/windows.ui.core.corewindow)/[ApplicationView](/uwp/api/windows.ui.viewmanagement.applicationview)

     Представление приложения — это совокупность 1:1 потока и окна, которая используется приложением для отображения содержимого. Первое представление, создаваемое при запуске приложения, называется *главным*. Каждый CoreWindow/Аппликатионвиев работает в своем собственном потоке. Работа с различными потоками пользовательского интерфейса может усложнить Многооконные приложения.

    Основное представление приложения всегда размещается в Аппликатионвиев. Содержимое во вторичном окне может размещаться в Аппликатионвиев или в Аппвиндов.

    Сведения об использовании Аппликатионвиев для отображения вторичных окон в приложении см. в разделе [Использование аппликатионвиев](application-view.md).
- [AppWindow](/uwp/api/windows.ui.windowmanagement.appwindow)

    Аппвиндов упрощает создание многооконных приложений UWP, поскольку оно работает в том же потоке пользовательского интерфейса, из которого он создается.

    Класс Аппвиндов и другие интерфейсы API в пространстве имен [виндовманажемент](/uwp/api/windows.ui.windowmanagement) доступны начиная с Windows 10, версии 1903 (пакет SDK 18362). Если приложение предназначено для более ранних версий Windows 10, необходимо использовать Аппликатионвиев для создания вторичных Windows.

    Сведения об использовании Аппвиндов для отображения вторичных окон в приложении см. в разделе [Использование аппвиндов](app-window.md).

    > [!NOTE]
    > Аппвиндов сейчас находится на этапе предварительной версии. Это означает, что вы можете отправлять приложения, использующие Аппвиндов, в магазин, но некоторые компоненты платформы и платформы не работают с Аппвиндов (см. раздел [ограничения](/uwp/api/windows.ui.windowmanagement.appwindow#limitations)).
- [Десктопвиндовксамлсаурце](/uwp/api/windows.ui.xaml.hosting.desktopwindowxamlsource) (О-ва XAML)

     Содержимое XAML UWP в приложении Win32 (с помощью HWND), также известное как острова XAML, размещается в Десктопвиндовксамлсаурце.

    Дополнительные сведения о островах XAML см. [в статье Использование API хостинга UWP XAML в классическом приложении](/windows/apps/desktop/modernize/using-the-xaml-hosting-api) .

### <a name="make-code-portable-across-windowing-hosts"></a>Перенос кода в оконные узлы

Когда содержимое XAML отображается в [CoreWindow](/uwp/api/windows.ui.core.corewindow), всегда существует связанное [окно](/uwp/api/windows.ui.xaml.window) [аппликатионвиев](/uwp/api/windows.ui.viewmanagement.applicationview) и XAML. Для получения таких сведений, как границы окна, можно использовать API-интерфейсы для этих классов. Для получения экземпляра этих классов используется статический метод [CoreWindow. жетфоркуррентсреад](/uwp/api/windows.ui.core.corewindow.getforcurrentthread) , метод [аппликатионвиев. Жетфоркуррентвиев](/uwp/api/windows.ui.viewmanagement.applicationview.getforcurrentview) или свойство [Window. Current](/uwp/api/windows.ui.xaml.window.current) . Кроме того `GetForCurrentView` , существует множество классов, использующих шаблон для получения экземпляра класса, например [DisplayInformation. жетфоркуррентвиев](/uwp/api/windows.graphics.display.displayinformation.getforcurrentview).

Эти API работают, поскольку для CoreWindow/Аппликатионвиев существует только одно дерево содержимого XAML, поэтому XAML знает, в каком контексте он размещен, то есть CoreWindow/Аппликатионвиев.

Когда XAML-содержимое выполняется внутри Аппвиндов или Десктопвиндовксамлсаурце, можно одновременно использовать несколько деревьев содержимого XAML в одном и том же потоке. В этом случае эти API-интерфейсы не предоставляют нужных сведений, так как содержимое больше не выполняется в текущем CoreWindow/Аппликатионвиев (и окне XAML).

Чтобы обеспечить правильную работу кода на всех узлах с окнами, необходимо заменить API-интерфейсы, использующие [CoreWindow](/uwp/api/windows.ui.core.corewindow), [аппликатионвиев](/uwp/api/windows.ui.viewmanagement.applicationview)и [Window](/uwp/api/windows.ui.xaml.window) , новыми API, которые получают свой контекст из класса [ксамлрут](/uwp/api/windows.ui.xaml.xamlroot) .
Класс Ксамлрут представляет дерево содержимого XAML и сведения о контексте, в котором он размещен, будь это CoreWindow, Аппвиндов или Десктопвиндовксамлсаурце. Этот уровень абстракции позволяет писать тот же код независимо от того, на каком узле выполняется XAML.

В этой таблице показан код, который не работает правильно в узлах окон, и новый переносимый код, который можно заменить на, а также некоторые API, которые не нужно изменять.

| Если вы использовали... | Заменить на... |
| - | - |
| CoreWindow. Жетфоркуррентсреад (). [Границы](/uwp/api/windows.ui.core.corewindow.bounds) | _UIElement_. Ксамлрут. [Размер](/uwp/api/windows.ui.xaml.xamlroot.size) |
| CoreWindow. Жетфоркуррентсреад (). [SizeChanged](/uwp/api/windows.ui.core.corewindow.sizechanged) | _UIElement_. Ксамлрут. [Изменено](/uwp/api/windows.ui.xaml.xamlroot.changed) |
| CoreWindow. [Видимый](/uwp/api/windows.ui.core.corewindow.visible) | _UIElement_. Ксамлрут. [Ишоствисибле](/uwp/api/windows.ui.xaml.xamlroot.ishostvisible) |
| CoreWindow. [VisibilityChanged](/uwp/api/windows.ui.core.corewindow.visibilitychanged) | _UIElement_. Ксамлрут. [Изменено](/uwp/api/windows.ui.xaml.xamlroot.changed) |
| CoreWindow. Жетфоркуррентсреад (). [Жеткэйстате](/uwp/api/windows.ui.core.corewindow.getkeystate) | Без изменений. Это поддерживается в Аппвиндов и Десктопвиндовксамлсаурце. |
| CoreWindow. Жетфоркуррентсреад (). [Жетасинккэйстате](/uwp/api/windows.ui.core.corewindow.getasynckeystate) | Без изменений. Это поддерживается в Аппвиндов и Десктопвиндовксамлсаурце. |
| Окно. [Текущий](/uwp/api/windows.ui.xaml.window.current) | Возвращает основной объект окна XAML, который тесно привязан к текущему CoreWindow. См. Примечание После этой таблицы. |
| Window. Current. [Границы](/uwp/api/windows.ui.xaml.window.bounds) | _UIElement_. Ксамлрут. [Размер](/uwp/api/windows.ui.xaml.xamlroot.size) |
| Window. Current. [Содержимое](/uwp/api/windows.ui.xaml.window.content) | UIElement root = _UIElement_. Ксамлрут. [Содержимое](/uwp/api/windows.ui.xaml.xamlroot.content) |
| Window. Current. [Компоновщик](/uwp/api/windows.ui.xaml.window.compositor) | Без изменений. Это поддерживается в Аппвиндов и Десктопвиндовксамлсаурце. |
| VisualTreeHelper. [Жетопенпопупс](/uwp/api/windows.ui.xaml.media.visualtreehelper.getopenpopups)<br/>В приложениях с островами XAML это вызовет ошибку. В Аппвиндов приложениях это приведет к возврату открытых всплывающих окон в главном окне. | VisualTreeHelper. [Жетопенпопупсфорксамлрут](/uwp/api/windows.ui.xaml.media.visualtreehelper.getopenpopupsforxamlroot) (_UIElement_. Ксамлрут) |
| FocusManager. [GetFocusedElement](/uwp/api/windows.ui.xaml.input.focusmanager.getfocusedelement) | FocusManager. [GetFocusedElement](/uwp/api/windows.ui.xaml.input.focusmanager.getfocusedelement#Windows_UI_Xaml_Input_FocusManager_GetFocusedElement_Windows_UI_Xaml_XamlRoot_) (_UIElement_. Ксамлрут) |
| Контентдиалог. Шовасинк () | Контентдиалог. [Ксамлрут](/uwp/api/windows.ui.xaml.uielement.xamlroot)  =  _UIElement_. Ксамлрут;<br/>Контентдиалог. Шовасинк (); |
| Менуфлйоут. Шоват (null, Новая точка (10, 10)); | Менуфлйоут. [Ксамлрут](/uwp/api/windows.ui.xaml.controls.primitives.flyoutbase.xamlroot)  =  _UIElement_. Ксамлрут;<br/>Менуфлйоут. Шоват (null, Новая точка (10, 10)); |

> [!NOTE]
> Для содержимого XAML в Десктопвиндовксамлсаурце существует CoreWindow/окно в потоке, но оно всегда невидимо и имеет размер 1x1. Он по-прежнему доступен для приложения, но не возвращает осмысленные границы или видимость.
>
>Для содержимого XAML в Аппвиндов всегда будет существовать ровно один CoreWindow в одном потоке. Если вы вызываете `GetForCurrentView` API `GetForCurrentThread` или, этот API вернет объект, отражающий состояние CoreWindow в потоке, а не аппвиндовс, которые могут выполняться в этом потоке.


## <a name="dos-and-donts"></a>Возможности и ограничения

- Укажите четкую точку входа в дополнительное представление, используя значок «открыть новое окно».
- Обсудите цель предоставления дополнительного представления для пользователей.
- Обеспечьте полную функциональность приложения в одном представлении, и пользователи будут открывать дополнительное представление только для удобства.
- Не полагайтесь на дополнительное представление в плане предоставления уведомлений и других промежуточный визуальных элементов.

## <a name="related-topics"></a>См. также

- [Использование Аппвиндов](app-window.md)
- [Использование Аппликатионвиев](application-view.md)
- [аппликатионвиевсвитчер](https://docs.microsoft.com/uwp/api/Windows.UI.ViewManagement.ApplicationViewSwitcher)
- [креатеневвиев](https://docs.microsoft.com/uwp/api/windows.applicationmodel.core.coreapplication.createnewview)
