---
Description: Разрабатывайте свое приложение таким образом, чтобы оно хорошо выглядело и функционировало на телевизоре.
title: Проектирование для Xbox и телевизора
ms.assetid: 780209cb-3e8a-4cf7-8f80-8b8f449580bf
label: Designing for Xbox and TV
template: detail.hbs
isNew: true
keywords: Xbox, телевизор, просмотр на большом расстоянии, геймпад, пульт дистанционного управления, ввод, взаимодействие
ms.date: 11/13/2018
ms.topic: article
pm-contact: chigy
design-contact: jeffarn
dev-contact: niallm
doc-status: Published
ms.localizationpriority: medium
ms.openlocfilehash: 431b8912e43647bc2678aaab7efc9ec68b866d10
ms.sourcegitcommit: b034650b684a767274d5d88746faeea373c8e34f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2019
ms.locfileid: "57616659"
---
# <a name="designing-for-xbox-and-tv"></a>Проектирование для Xbox и телевизора

Разрабатывайте приложение для универсальной платформы Windows (UWP) таким образом, чтобы оно хорошо выглядело и функционировало на Xbox One и на экране телевизора.

См. в разделе [взаимодействия игровой и удаленное управление](../input/gamepad-and-remote-interactions.md) рекомендации по взаимодействию с действия пользователями в приложениях универсальной платформы Windows в *10 foot* столкнуться.

## <a name="overview"></a>Обзор

Универсальная платформа Windows позволяет создавать отличные приложения для самых разных устройств с Windows 10.
Большинство функциональных возможностей, предоставляемых платформой UWP, позволяет приложениям использовать один и тот же пользовательский интерфейс на всех устройствах без проведения дополнительной работы.
Однако настройка и оптимизация приложения для работы на Xbox One и телевизионных экранах требуют особого подхода.

Взаимодействие с телевизором с дивана на другом конце комнаты с помощью игрового контроллера или пульта ДУ называется **взаимодействием на большом расстоянии**.
Такое название связано прежде всего с тем, что пользователь, как правило, находится на большом (3 м) расстоянии от экрана.
Оно представляет определенные трудности, которые отсутствуют при *взаимодействии на расстоянии 0,5 м* или при работе за компьютером.
Этот фактор следует учитывать, если вы разрабатываете приложение для Xbox One или любого другого устройства, которое выводит изображение на телеэкран, а для ввода использует игровой контроллер.

Не все действия, описанные в этой статье, необходимы для обеспечения работоспособности приложения при просмотре на большом расстоянии. Однако понимание этих принципов и принятие соответствующих решений позволят обеспечить более удобную работу с приложением и принять во внимание его особые требования.
Выпуская приложение, обеспечивающее просмотр на большом расстоянии, следует учитывать следующие принципы проектирования.

### <a name="simple"></a>Simple

Проектирование для обеспечения возможности просмотра на большом расстоянии таит в себе ряд определенных трудностей. Разрешение и расстояние просмотра может затруднить обработку большого объема информации.
Чтобы обеспечить простоту дизайна, сведите его по возможности к самым простым компонентам. Количество информации, отображаемое на телеэкране, должно быть сравнимо с тем, что вы видите на мобильном телефоне, а не на рабочем столе компьютера.

![Главный экран Xbox One](images/designing-for-tv/xbox-home-screen.png)

### <a name="coherent"></a>Ясность

Приложения UWP, предназначенные для просмотра на большом расстоянии, должны быть интуитивно понятными и простыми в использовании. Необходимо четко обозначать фокус, чтобы его невозможно было перепутать ни с чем другим.
Расположите содержимое таким образом, чтобы перемещение по пространству экрана было прогнозируемым и согласованным. Предоставьте пользователям самый короткий путь к необходимым им элементам.

![Приложение "Кино" для Xbox One](images/designing-for-tv/xbox-movies-app.png)

_**На ТВ и видео Microsoft доступны все фильмы, показано на снимке экрана.**_  

### <a name="captivating"></a>Увлечение

Большой экран обеспечивает самый удобный просмотр фильмов с эффектом полного погружения. Полноэкранное изображение, плавные движение, яркие цвета, изысканное оформление выведут ваши приложения на качественно новый уровень. Ваши приложения должны заметными и красивыми.

![Приложение Avatar для Xbox One](images/designing-for-tv/xbox-avatar-app.png)

### <a name="optimizations-for-the-10-foot-experience"></a>Оптимизация для просмотра на большом расстоянии

Итак, теперь вы знаете о принципах качественного проектирования приложений UWP для просмотра на большом расстоянии. Ознакомьтесь со следующим обзором и узнайте, как оптимизировать приложение и обеспечить удобную работу пользователей.

| Функция        | Описание           |
| -------------------------------------------------------------- |--------------------------------|
| [Изменение размера элемента пользовательского интерфейса](#ui-element-sizing)  | Универсальная платформа Windows использует показатели [масштабирования и количества эффективных пикселей](../basics/design-and-ui-intro.md#effective-pixels-and-scaling) для масштабирования пользовательского интерфейса в соответствии с расстоянием до экрана. Понимание принципов масштабирования и применение их ко всему пользовательскому интерфейсу поможет оптимизировать приложение для просмотра на большом расстоянии.  |
|  [Области, TV](#tv-safe-area) | По умолчанию платформа UWP автоматически избегает отображения элементов пользовательского интерфейса в небезопасных областях телевизионного экрана (области вблизи границ экрана). Однако это создает эффект черных полей (эффект экранного каше) вокруг пользовательского интерфейса. Чтобы ваше приложение полностью заполняло экран телевизора, необходимо изменить его таким образом, чтобы оно доходило до краев экрана телевизора, если последний поддерживает такую возможность. |
| [Цвета](#colors)  |  Платформа UWP поддерживает цветовые темы, а в приложении, использующем системную тему, на Xbox One будет по умолчанию применена **темная** схема. Если ваше приложение имеет специальные цветовую тему, необходимо помнить, что определенные цвета не подходят для телевизора, поэтому их следует избегать. |
| [Звук](../style/sound.md)    | Звуки играют ключевую роль при просмотре ТВ на большом расстоянии, позволяя пользователю погрузиться в происходящее на экране и предоставляя обратную связь. UWP поддерживает возможность, которая автоматически включит звуки для стандартных элементов управления, когда приложение работает на Xbox One. Узнайте больше о поддержке звуков, встроенной в UWP, а также о том, как ими пользоваться.    |
| [Рекомендации для элементов управления пользовательского интерфейса](#guidelines-for-ui-controls)  |  Имеется несколько элементов управления пользовательского интерфейса, которые хорошо работают на разных устройствах, но обладают некоторыми особенностями при использовании вместе с телевизором. Ознакомьтесь с рекомендациями по использованию этих элементов управления при разработке приложений, взаимодействие с которыми будет выполняться на большом расстоянии. |
| [Триггер пользовательского визуального состояния для Xbox](#custom-visual-state-trigger-for-xbox) | Чтобы адаптировать приложение UWP для просмотра на большом расстоянии, рекомендуется использовать пользовательский *триггер визуального состояния* для изменения макета, если приложение определяет, что оно было запущено на консоли Xbox. |

В дополнение к предыдущей проектирования и создания макетов, существует ряд [gamepad и удаленное управление взаимодействия](../input/gamepad-and-remote-interactions.md) оптимизации, которые следует учитывать при создании своего приложения.

| Функция        | Описание           |
| -------------------------------------------------------------- |--------------------------------|
| [XY навигации с фокусом и взаимодействие](../input/gamepad-and-remote-interactions.md#xy-focus-navigation-and-interaction) | **Навигации с фокусом XY** позволяет пользователю перемещаться в пользовательском Интерфейсе приложения. Однако это позволяет пользователю перемещаться только вверх, вниз, влево или вправо. Рекомендации по выполнению этих и других требований приведены в этом разделе. |
| [Режим мыши](../input/gamepad-and-remote-interactions.md#mouse-mode)|Навигации с фокусом XY не практические или даже возможно для некоторых типов приложений, таких как карты или и рисования приложений. В этих случаях **режим мыши** позволяет пользователям свободно перейдите с игровой или удаленного управления, так же, как мышь на ПК.|
| [Фокус visual](../input/gamepad-and-remote-interactions.md#focus-visual)  | Задача visual-границу, которая выделяет фокус элемента пользовательского интерфейса. Это помогает пользователю быстро определить пользовательский Интерфейс, их просмотра или взаимодействия с.  |
| [Службы взаимодействия фокус](../input/gamepad-and-remote-interactions.md#focus-engagement) | Фокус engagement требует нажатия пользователем клавиши **A/Выбор** кнопку на игровой или удаленного управления, когда элемент пользовательского интерфейса получает фокус, чтобы взаимодействовать с ним. |
| [Аппаратные кнопки](../input/gamepad-and-remote-interactions.md#hardware-buttons) | Игровой и удаленное управление предоставляют очень разные кнопки и конфигураций. |

> [!NOTE]
> Большинство фрагментов кода в этом разделе написаны на XAML/C#, но принципы и концепции применимы ко всем приложениям UWP. Если вы разрабатываете приложение UWP на HTML/JavaScript для Xbox, ознакомьтесь с великолепной библиотекой [TVHelpers](https://github.com/Microsoft/TVHelpers/wiki) на GitHub.

## <a name="ui-element-sizing"></a>Размер элемента пользовательского интерфейса

Так как при просмотре на большом расстоянии пользователь использует пульт ДУ или геймпад и находится в нескольких метрах от экрана, имеется ряд факторов, связанных с интерфейсом, которые необходимо учесть при проектировании.
Убедитесь, что пользовательский интерфейс имеет необходимую плотность содержимого, а также что он не перегружен и позволяет пользователю без труда перемещаться и выбирать нужные элементы. Помните: простота — это ключевой фактор.

### <a name="scale-factor-and-adaptive-layout"></a>Коэффициент масштабирования и адаптивный макет

**Коэффициент масштабирования** обеспечивает отображение правильного размера элементов пользовательского интерфейса на том устройстве, на котором работает приложение.
На компьютере этот параметр регулируется с помощью ползунка и находится в следующем расположении: **Параметры > Система > Экран**.
Этот же параметр используется и на телефоне, если устройство поддерживает его.

![Изменение размера текста, приложений и прочих элементов](images/designing-for-tv/ui-scaling.png)

На Xbox One такого системного параметра нет, но для правильного отображения размера элементов пользовательского интерфейса UWP на телевизоре по умолчанию используется масштаб **200%** для приложений XAML и **150%** для приложений HTML.
Если элементы пользовательского интерфейса имеют правильные размеры на других устройствах, они будут правильно отображаться и на экране телевизора.
Xbox One отображает приложение в разрешении 1080p (1920 x 1080 пикселей). Поэтому при переносе приложения с других устройств, например компьютеров, убедитесь, что пользовательский интерфейс хорошо выглядит при разрешении 960 x 540 пикселей в масштабе 100% (или 1280 x 720 пикселей в масштабе 100% для приложений HTML), воспользовавшись [специальными возможностями](../layout/screen-sizes-and-breakpoints-for-responsive-design.md).

Проектирование для Xbox несколько отличается от проектирования для компьютера, так как необходимо работать только с одним разрешением — 1920 x 1080.
Неважно, если разрешение телевизора выше&mdash;приложения UWP всегда будут масштабироваться до 1080p.

Правильные размеры ресурсов при значении 200% (или 150% для приложений HTML) также будут использоваться для вашего приложения при работе на Xbox One независимо от разрешения телевизора.

### <a name="content-density"></a>Плотность содержимого

При проектировании приложения помните, что пользователь будет смотреть на пользовательский интерфейс с некоторого расстояния и взаимодействовать с ним с помощью пульта ДУ или геймпада, навигация с помощью которых занимает больше времени, чем навигация с помощью мыши или сенсорного экрана.

#### <a name="sizes-of-ui-controls"></a>Размеры элементов управления пользовательского интерфейса

Интерактивные элементы пользовательского интерфейса должны иметь минимальную высоту 32 эффективных пикселя. Это значение по умолчанию для основных элементов управления UWP. При использовании масштаба 200 % оно обеспечивает видимость элементов пользовательского интерфейса с расстояния и позволяет снизить плотность содержимого.

![Кнопка UWP в масштабе 100 % и 200 %](images/designing-for-tv/button-100-200.png)

#### <a name="number-of-clicks"></a>Количество нажатий

Для упрощения пользовательского интерфейса переход от одного края экрана телевизора до другого должен осуществляться за **шесть нажатий**. Помните, что здесь применим принцип **простоты**. 

![6 значков поперек экрана](images/designing-for-tv/six-clicks.png)

### <a name="text-sizes"></a>Размеры шрифта

Чтобы пользовательский интерфейс был виден с расстояния, следуйте простым правилам, приведенным ниже.

* Основной текст и чтение содержимого: минимум 15 epx
* Некритические текст и дополнительные материалы: минимум 12 epx

При использовании более крупного текста в пользовательском интерфейсе выберите размер, который не слишком ограничивает эффективную область экрана, и не занимает место, которое можно заполнить другим содержимым.

### <a name="opting-out-of-scale-factor"></a>Отказ от коэффициента масштабирования

Мы рекомендуем, чтобы ваше приложение поддерживало коэффициент масштабирования. Это позволит ему работать и корректно отображаться на всех устройствах.
Однако можно отказаться от такого поведение и разработать весь пользовательский интерфейс в масштабе 100 %. Обратите внимание, что вы не можете изменить коэффициент масштабирования на значение, отличное от 100%.

В случае с приложениями XAML вы можете отказаться от коэффициента масштабирования, воспользовавшись следующим фрагментом кода.

```csharp
bool result =
    Windows.UI.ViewManagement.ApplicationViewScaling.TrySetDisableLayoutScaling(true);
```

`result` сообщит вам о том, что вы успешно отказались от этой функции.

Дополнительные сведения, в том числе пример кода для HTML/JavaScript, см. в разделе [Отключение масштабирования](../../xbox-apps/disable-scaling.md).

Обязательно рассчитайте подходящие размеры элементов пользовательского интерфейса, удвоив значения в *эффективных* пикселях, упомянутые в этом разделе, до значений в *фактических* пикселях (или умножив на 1,5 для приложений HTML).

## <a name="tv-safe-area"></a>Безопасная область телевизора

В силу исторических, а также технических обстоятельств, не все телевизоры поддерживают отображение на всем экране. По умолчанию платформа UWP не отображает содержимое пользовательского интерфейса в небезопасных областях телеэкрана, заполняя его только фоновым изображением страницы.

Небезопасная область телевизионного экрана обозначена на следующим изображением синим цветом.

![Небезопасная область телевизионного экрана](images/designing-for-tv/tv-unsafe-area.png)

Вы можете установить в качестве фонового изображения статический цвет, цвет темы или изображение, как показано в следующих фрагментах кода.

### <a name="theme-color"></a>Цвета темы

```xml
<Page x:Class="Sample.MainPage"
      Background="{ThemeResource ApplicationPageBackgroundThemeBrush}"/>
```

### <a name="image"></a>Изображение

```xml
<Page x:Class="Sample.MainPage"
      Background="\Assets\Background.png"/>
```

Вот как будет выглядеть ваше приложение без дополнительной работы.

![Безопасная область телевизора](images/designing-for-tv/tv-safe-area.png)

Это не самый оптимальный вариант, поскольку он приводит к появлению эффекта черных полей в приложении, где части пользовательского интерфейса, например панель навигации и сетка, выглядят обрезанными. Однако с помощью оптимизации можно расширить некоторые части пользовательского интерфейса до краев экрана, чтобы создать более кинематографическое представление.

### <a name="drawing-ui-to-the-edge"></a>Отрисовка пользовательского интерфейса до краев

Мы рекомендуем использовать определенные элементы пользовательского интерфейса для расширения до краев экрана. Это усилит эффект погружения. Сюда входят средства прокрутки [ScrollViewer](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ScrollViewer), [навигационные панели](../controls-and-patterns/navigationview.md) и панели команд [CommandBar](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.CommandBar).

С другой стороны, также важно, чтобы интерактивные элементы и текст никогда не доходили до краев экрана. Это позволит избежать их обрезки на некоторых телевизорах. Мы рекомендуем использовать в 5 % области вдоль краев экрана только некритичное визуальное оформление. Как уже упоминалось в разделе [Размер элементов пользовательского интерфейса](#ui-element-sizing), приложение UWP использующее коэффициент масштабирования Xbox One по умолчанию (200 %), будет использовать область 960 x 540 эффективных пикселей. Поэтому следует избегать размещения критически важных элементов пользовательского интерфейса в следующих областях:

- 27 эффективных пикселей от верхнего и нижнего краев;
- 48 эффективных пикселей от левого и правого краев.

В следующих разделах приведены инструкции по расширению пользовательского интерфейса до краев экрана.

#### <a name="core-window-bounds"></a>Границы основного окна

Для приложений UWP, ориентированных только на взаимодействие на большом расстоянии, использование границ основного окна является самым простым подходом.

В методе `OnLaunched` для `App.xaml.cs` добавьте следующий код.

```csharp
Windows.UI.ViewManagement.ApplicationView.GetForCurrentView().SetDesiredBoundsMode
    (Windows.UI.ViewManagement.ApplicationViewBoundsMode.UseCoreWindow);
```

Благодаря этой строке кода окно приложения будет расширено до границ экрана, поэтому вам придется переместить все интерактивные и важные элементы пользовательского интерфейса в безопасную область телеэкрана, которая была описана выше. Прозрачный пользовательский интерфейс, например контекстные меню, открытые поля со списком [ComboBox](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ComboBox), автоматически будут оставаться в пределах безопасной области телевизионного экрана.

![Границы основного окна](images/designing-for-tv/core-window-bounds.png)

#### <a name="pane-backgrounds"></a>Фоновые изображения панелей

Как правило, панели навигации помещаются вдоль границ экрана, поэтому фоновое изображение должно выходить за границы безопасной области. Это позволит избежать появления странных пропусков. Это можно сделать путем простого изменения цвета фона панели навигации на цвет фона приложения.

Использование границ основного окна, как описано выше, позволяет отрисовывать пользовательский интерфейс до краев экрана, однако после этого следует использовать положительные поля для содержимого [SplitView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.SplitView), чтобы оно оставалось в безопасной области телевизионного экрана.

![Панель навигации, расширенная до краев экрана](images/designing-for-tv/tv-safe-areas-2.png)

Здесь фон панели навигации расширен до краев экрана, а элементы навигации находятся в пределах безопасной области телевизионного экрана.
Содержимое `SplitView` (в данном случае сетка элементов) было расширено до нижней части экрана, поэтому оно отображается непрерывно, тогда как верхняя часть сетки все еще находится в пределах безопасной области телевизионного экрана. (Подробнее о том, как это сделать см. в разделе [Прокрутка концов списков и сеток](#scrolling-ends-of-lists-and-grids)).

Следующий фрагмент кода позволяет достичь этого эффекта.

```xml
<SplitView x:Name="RootSplitView"
           Margin="48,0,48,0">
    <SplitView.Pane>
        <ListView x:Name="NavMenuList"
                  ContainerContentChanging="NavMenuItemContainerContentChanging"
                  ItemContainerStyle="{StaticResource NavMenuItemContainerStyle}"
                  ItemTemplate="{StaticResource NavMenuItemTemplate}"
                  ItemInvoked="NavMenuList_ItemInvoked"
                  ItemsSource="{Binding NavMenuListItems}"/>
    </SplitView.Pane>
    <Frame x:Name="frame"
           Navigating="OnNavigatingToPage"
           Navigated="OnNavigatedToPage"/>
</SplitView>
```

[CommandBar](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.CommandBar) — еще один пример панели, которая, как правило, располагается рядом с одним или несколькими краями приложения, поэтому на телеэкране фон этой панели должен достигать краев экрана. Кроме того, здесь, как правило, имеется кнопка **Дополнительно** в виде многоточия (...), на правой стороне экрана, которая должна оставаться в безопасной области. Ниже приведены несколько различных способов, позволяющих добиться нужного взаимодействия и визуальных эффектов.

**Вариант 1**: Изменение `CommandBar` фоновый цвет, либо прозрачный или цвет фона страницы:

```xml
<CommandBar x:Name="topbar"
            Background="{ThemeResource SystemControlBackgroundAltHighBrush}">
            ...
</CommandBar>
```

Этот приведет к тому, что визуально `CommandBar` будет располагаться на том же фоне, что и вся остальная страница. Таким образом фон будет непрерывно простираться до края экрана.

**Вариант 2**: Добавление заливка которого имеет тот же цвет фона прямоугольника как `CommandBar` фона, который будет находиться ниже `CommandBar` и на остальных узлах страницы:

```xml
<Rectangle VerticalAlignment="Top"
            HorizontalAlignment="Stretch"      
            Fill="{ThemeResource SystemControlBackgroundChromeMediumBrush}"/>
<CommandBar x:Name="topbar"
            VerticalAlignment="Top"
            HorizontalContentAlignment="Stretch">
            ...
</CommandBar>
```

> [!NOTE]
> При использовании такого подхода следует помнить, что кнопка **Дополнительно** меняет при необходимости высоту открытого элемента `CommandBar`, позволяя отобразить подписи `AppBarButton` под соответствующими значками. Рекомендуется переместить подписи *вправо* от соответствующих значков во избежание такого изменения размеров. Дополнительные сведения см. в разделе [Подписи CommandBar](#commandbar-labels).

Оба этих подхода можно также применять к другим типам элементов управления, перечисленным в этом разделе.

#### <a name="scrolling-ends-of-lists-and-grids"></a>Прокрутка концов списков и сеток

Как правило, списки и сетки содержат больше элементов, чем одновременно может уместиться на экране. В этом случае рекомендуется расширить список или сетку до края экрана. Горизонтально прокручиваемые списки и сетки должны доходить до правого края, а вертикально прокручиваемые списки и сетки — до нижнего края экрана.

![Обрезка сетки по безопасной области телевизионного экрана](images/designing-for-tv/tv-safe-area-grid-cutoff.png)

Если список или сетка простираются подобным образом, важно обеспечить положение визуального фокуса и соответствующего элемента в пределах безопасной области телевизионного экрана.

![Фокус прокручиваемой сетки должен оставаться в пределах безопасной области экрана](images/designing-for-tv/scrolling-grid-focus.png)

Функциональные возможности платформы UWP позволяют удерживать визуальный элемент фокуса внутри видимых границ [VisibleBounds](https://docs.microsoft.com/uwp/api/windows.ui.viewmanagement.applicationview.visiblebounds), однако необходимо увеличить расстояние до края, чтобы элементы списка/сетки можно было прокручивать в безопасной области. В частности, следует добавить положительное поле для [ItemsPresenter](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ItemsPresenter) объектов [ListView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ListView) или [GridView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.GridView), как показано в следующем фрагменте кода.

```xml
<Style x:Key="TitleSafeListViewStyle"
       TargetType="ListView">
    <Setter Property="Template">
        <Setter.Value>
            <ControlTemplate TargetType="ListView">
                <Border BorderBrush="{TemplateBinding BorderBrush}"
                        Background="{TemplateBinding Background}"
                        BorderThickness="{TemplateBinding BorderThickness}">
                    <ScrollViewer x:Name="ScrollViewer"
                                  TabNavigation="{TemplateBinding TabNavigation}"
                                  HorizontalScrollMode="{TemplateBinding ScrollViewer.HorizontalScrollMode}"
                                  HorizontalScrollBarVisibility="{TemplateBinding ScrollViewer.HorizontalScrollBarVisibility}"
                                  IsHorizontalScrollChainingEnabled="{TemplateBinding ScrollViewer.IsHorizontalScrollChainingEnabled}"
                                  VerticalScrollMode="{TemplateBinding ScrollViewer.VerticalScrollMode}"
                                  VerticalScrollBarVisibility="{TemplateBinding ScrollViewer.VerticalScrollBarVisibility}"
                                  IsVerticalScrollChainingEnabled="{TemplateBinding ScrollViewer.IsVerticalScrollChainingEnabled}"
                                  IsHorizontalRailEnabled="{TemplateBinding ScrollViewer.IsHorizontalRailEnabled}"
                                  IsVerticalRailEnabled="{TemplateBinding ScrollViewer.IsVerticalRailEnabled}"
                                  ZoomMode="{TemplateBinding ScrollViewer.ZoomMode}"
                                  IsDeferredScrollingEnabled="{TemplateBinding ScrollViewer.IsDeferredScrollingEnabled}"
                                  BringIntoViewOnFocusChange="{TemplateBinding ScrollViewer.BringIntoViewOnFocusChange}"
                                  AutomationProperties.AccessibilityView="Raw">
                        <ItemsPresenter Header="{TemplateBinding Header}"
                                        HeaderTemplate="{TemplateBinding HeaderTemplate}"
                                        HeaderTransitions="{TemplateBinding HeaderTransitions}"
                                        Footer="{TemplateBinding Footer}"
                                        FooterTemplate="{TemplateBinding FooterTemplate}"
                                        FooterTransitions="{TemplateBinding FooterTransitions}"
                                        Padding="{TemplateBinding Padding}"
                                        Margin="0,27,0,27"/>
                    </ScrollViewer>
                </Border>
            </ControlTemplate>
        </Setter.Value>
    </Setter>
</Style>
```

Предыдущий фрагмент кода следует разместить в ресурсах страницы или приложения, а затем получать к нему доступ следующим образом.

```xml
<Page>
    <Grid>
        <ListView Style="{StaticResource TitleSafeListViewStyle}"
                  ... />
```

> [!NOTE]
> Этот фрагмент кода предназначен специально для стиля `ListView`. Для стиля `GridView` задайте атрибут [TargetType](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.controltemplate.targettype) для [ControlTemplate](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ControlTemplate) и [Style](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Style) равным `GridView`.

Для более точного управления как элементы добавлены в представление, если приложение предназначено для версии 1803 или более поздней версии, можно использовать [UIElement.BringIntoViewRequested событий](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.bringintoviewrequested). Вы можете задать для него [ItemsPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemscontrol.itemspanel) для **ListView**/**GridView** перехватить его перед внутренний **ScrollViewer** делает, как показано в следующих фрагментах кода:

```xaml
<GridView x:Name="gridView">
    <GridView.ItemsPanel>
        <ItemsPanelTemplate>
            <ItemsWrapGrid Orientation="Horizontal"
                           BringIntoViewRequested="ItemsWrapGrid_BringIntoViewRequested"/>
        </ItemsPanelTemplate>
    </GridView.ItemsPanel>
</GridView>
```

```cs
// The BringIntoViewRequested event is raised by the framework when items receive keyboard (or Narrator) focus or 
// someone triggers it with a call to UIElement.StartBringIntoView.
private void ItemsWrapGrid_BringIntoViewRequested(UIElement sender, BringIntoViewRequestedEventArgs args)
{
    if (args.VerticalAlignmentRatio != 0.5)  // Guard against our own request
    {
        args.Handled = true;
        // Swallow this request and restart it with a request to center the item.  We could instead have chosen
        // to adjust the TargetRect’s Y and Height values to add a specific amount of padding as it bubbles up, 
        // but if we just want to center it then this is easier.

        // (Optional) Account for sticky headers if they exist
        var headerOffset = 0.0;
        var itemsWrapGrid = sender as ItemsWrapGrid;
        if (gridView.IsGrouping && itemsWrapGrid.AreStickyGroupHeadersEnabled)
        {
            var header = gridView.GroupHeaderContainerFromItemContainer(args.TargetElement as GridViewItem);
            if (header != null)
            {
                headerOffset = ((FrameworkElement)header).ActualHeight;
            }
        }

        // Issue a new request
        args.TargetElement.StartBringIntoView(new BringIntoViewOptions()
        {
            AnimationDesired = true,
            VerticalAlignmentRatio = 0.5, // a normalized alignment position (0 for the top, 1 for the bottom)
            VerticalOffset = headerOffset, // applied after meeting the alignment ratio request
        });
    }
}
```

## <a name="colors"></a>Цвета

По умолчанию универсальная платформа Windows выводит цвета приложения в диапазон, безопасный для телевизионных экранов (подробнее см. в разделе [Безопасные цвета для использования на телевизионных экранах](#tv-safe-colors)), чтобы ваше приложение хорошо выглядело на любом телевизоре. При этом имеется ряд улучшений, которые можно внести в набор цветов, используемый вашим приложением, которые позволят улучшить его отображение на экране телевизора.

### <a name="application-theme"></a>Тема приложения

Вы можете выбрать **тему приложения** (темную или светлую) в соответствии со стилем приложения или вообще отказаться от темы. Дополнительные сведения об общих рекомендациях по темам см. в разделе [Цветовые темы](../style/color.md).

Платформа UWP также позволяет приложениям динамически задавать тему на основе параметров системы, предоставляемых устройствами, на которых они работают.
Несмотря на то, что платформа UWP всегда придерживается параметров темы, указанных пользователем, каждое устройство также предоставляет соответствующую тему по умолчанию.
Вследствие особенностей устройства Xbox One, которое ориентировано больше на работу с *мультимедиа*, чем с *офисными документами*, по умолчанию используется темная системная тема.
Если тема приложения основана на системных параметров, будьте готовы, что на Xbox One будет использоваться темная цветовая схема.

### <a name="accent-color"></a>Цвет элементов

Платформа UWP предоставляет удобный способ отображения **цвета элементов**, выбранного пользователем в системных параметрах.

На Xbox One можно выбрать пользовательский цвет, так же, как на компьютере можно выбрать цвет элементов.
Если ваше приложение вызывает эти цвета элементов с помощью кистей или цветовых ресурсов, будет использоваться цвет, выбранный пользователем в параметрах системы. Обратите внимание, что цвета элементов на устройстве Xbox One применяются на уровне пользователя, а не всей системы.

Кроме того, следует обратить внимание на то, что набор пользовательских цветов на устройстве Xbox One отличается от цветов на ПК, телефонах и других устройствах.

Пока в вашем приложении используется ресурс кисти, например **SystemControlForegroundAccentBrush**, или ресурс цвета (**SystemAccentColor**), или же если цвета элементов вызываются напрямую через API [UIColorType.Accent*](https://docs.microsoft.com/uwp/api/Windows.UI.ViewManagement.UIColorType), эти цвета заменяются на цвета элементов, доступные на Xbox One. Цвета кистей высокой контрастности также берутся из системы, как на ПК и телефоне.

Дополнительные сведения о цветах элементов в целом, см. в разделе [Цвет элементов](../style/color.md#accent-color).

### <a name="color-variance-among-tvs"></a>Различие цветов на разных телевизорах

При проектировании приложений для телевизора следует помнить, что цвета по-разному отображаются на различных телевизорах. Не следует предполагать, что цвета будут выглядеть точно так же, как на вашем мониторе. Если для вашего приложения критичны незначительные отличия в цветах для обозначения частей пользовательского интерфейса, то следует помнить что цвета могут сливаться. Это может ввести пользователей в заблуждение. Попробуйте использовать цвета, которые достаточно различимы, чтобы пользователи могли четко их разделять независимо от используемого телевизора.

### <a name="tv-safe-colors"></a>Безопасные цвета для использования на телевизионных экранах

Цветовые значения RGB обозначают интенсивность красного, зеленого и синего цветов. Телевизоры не могут надлежащим образом отображать предельные значения интенсивности &mdash; на некоторых экранах может возникнуть странный эффект чередования цветов, или же цвета могут выглядеть размытыми. Кроме того, цвета с высокой интенсивностью могут привести к помутнению (соседние пиксели начинают отрисовываться одним цветом). Существуют различные мнения о том, что считать безопасными для телевизионных экранов цветами, однако цвета в пределах значений RGB от 16 до 235 (или от 10 до EB в шестнадцатеричной системе) обычно можно использовать для телеэкранов.

![Диапазон безопасных цветов для телевизионных экранов](images/designing-for-tv/tv-safe-colors-2.png)

В прошлом приложениям для Xbox приходилось адаптировать цвета, чтобы перевести их в "безопасный для телевизионных экранов" диапазон, однако начиная с обновления Fall Creators Update Xbox One автоматически масштабирует содержимое с полным диапазоном в диапазон, безопасный для телевизора. Это означает, что большинству разработчиков приложений больше нужно беспокоиться о цветах для телевизоров.

> [!IMPORTANT]
> Для видеосодержимого, которое уже находится в диапазоне цветов, безопасном для телевизоров, не применяется этот эффект масштабирования цветов при воспроизведении с помощью [Media Foundation](https://docs.microsoft.com/windows/desktop/medfound/microsoft-media-foundation-sdk).

Если вы разрабатываете приложение с использованием DirectX 11 или DirectX 12 и создаете собственную цепочку буферов для отображения пользовательского интерфейса или видео, вы можете указать используемое цветовое пространство путем вызова метода [IDXGISwapChain3::SetColorSpace1](https://docs.microsoft.com/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiswapchain3-setcolorspace1), чтобы сообщить системе, следует ли масштабировать цвета или нет.

## <a name="guidelines-for-ui-controls"></a>Руководство по элементам управления пользовательского интерфейса

Имеется несколько элементов управления пользовательского интерфейса, которые хорошо работают на разных устройствах, но обладают некоторыми особенностями при использовании вместе с телевизором. Ознакомьтесь с рекомендациями по использованию этих элементов управления при разработке приложений, взаимодействие с которыми будет выполняться на большом расстоянии.

### <a name="pivot-control"></a>Элемент управления Pivot

Элемент управления [Pivot](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Pivot) обеспечивает возможность быстрого перемещения между представлениями в приложении путем выбора различных заголовков и вкладок. Элемент управления подчеркивает все заголовки с фокусом, что позволяет проще понять, какой заголовок в данный момент выбран при использовании геймпада/пульта ДУ.

![Подчеркивание с помощью сводки](images/designing-for-tv/pivot-underline.png)

Вы можете задать свойству [Pivot.IsHeaderItemsCarouselEnabled](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.pivot.isheaderitemscarouselenabledproperty) значение `true`, чтобы сводки всегда находились в одном положении, вместо того чтобы заголовок выбранной сводки перемещался на первое место. Это особенно удобно в случае больших экранов, например экранов телевизоров, так как перенос заголовков может отвлекать пользователей. Если все заголовки сводок не помещаются на экране, клиенты смогут просматривать другие заголовки с помощью полосы прокрутки. Но для максимального удобства взаимодействия вам следует убедиться, что они все помещаются на экране. Дополнительные сведения см. в разделе [Вкладки и сводки](/windows/uwp/design/controls-and-patterns/pivot).

### <a name="navigation-pane-a-namenavigation-pane-"></a>Панель навигации <a name="navigation-pane" />

Панель навигации (также называемая *кнопка-гамбургер*) представляет собой элемент управления навигацией, часто используемый в приложениях UWP. Как правило, это панель с несколькими вариантами выбора в меню в виде списка, использующегося для перенаправления пользователя на различные страницы. Обычно эта панель отображается в свернутом состоянии для экономии пространства и пользователь может открыть ее, нажав соответствующую кнопку.

В то время как с навигационными панелями очень удобно взаимодействовать с помощью мыши и сенсорного ввода, работа с ними с помощью геймпада/пульта ДУ несколько затруднена, так как пользователю приходится перемещать указатель к кнопке, чтобы открыть панель. Поэтому для открытия навигационной панели рекомендуется программировать кнопку **Просмотр**, а также реализовывать возможность ее открытия путем перемещения указателя устройства ввода в левую часть страницы. Пример кода со способом реализации этого шаблона можно найти в документе [Перемещение программного фокуса](../input/focus-navigation-programmatic.md#split-view-code-sample). Так пользователь сможет без труда получать доступ к содержимому панели. Дополнительные сведения о том, как ведут себя навигационные панели на экранах различных размеров, а также рекомендации по навигации с помощью геймпада/пульта ДУ см. в разделе [Панели навигации](../controls-and-patterns/navigationview.md).

### <a name="commandbar-labels"></a>Подписи CommandBar

Подписи полезно размещать справа от значков на панели [CommandBar](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.CommandBar) для уменьшения ее высоты и сохранения согласованности ее структуры. Это можно сделать, задав свойству [CommandBar.DefaultLabelPosition](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.commandbar.defaultlabelpositionproperty) значение `CommandBarDefaultLabelPosition.Right`.

![Панель CommandBar с подписями, расположенными справа от значков](images/designing-for-tv/commandbar.png)

Также, когда это свойство задано, подписи будут отображаться постоянно, что хорошо подходит для взаимодействия с экраном на большом расстоянии, так как пользователю приходится делать меньше щелчков для выполнения необходимой операции. Эту модель также можно успешно реализовать и на других типах устройств.

### <a name="tooltip"></a>Всплывающая подсказка

Элемент управления [Tooltip](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ToolTip) предоставляет дополнительные сведения об элементе пользовательского интерфейса при наведении на него указателя мыши или при его нажатии и удержании. При использовании геймпада и пульта ДУ элемент `Tooltip` отображается после получения элементом фокуса, остается на экране в течение краткого времени, а затем исчезает. Это поведение может отвлекать, если используется слишком много элементов `Tooltip`. Пытайтесь избегать использования `Tooltip` при проектировании приложений для телевизора.

### <a name="button-styles"></a>Стили кнопок

Несмотря на то, что стандартные кнопки UWP хорошо подходят для телевизоров, некоторые визуальные стили кнопок привлекают больше внимания к пользовательскому интерфейсу. Поэтому, возможно, их следовало бы использовать на всех платформах, особенно на устройствах, рассчитанных на просмотр на большом расстоянии, для которых четкое указание фокуса особенно удобно. Дополнительные сведения об этих стилях см. в разделе [Кнопки](../controls-and-patterns/buttons.md).

### <a name="nested-ui-elements"></a>Вложенные элементы пользовательского интерфейса

Вложенные элементы пользовательского интерфейса предоставляет вложенные активные элементы, заключенные в контейнерном элементе пользовательского интерфейса. При этом вложенный элемент и контейнер могут принимать фокус независимо друг от друга.

Вложенные элементы пользовательского интерфейса подходят для некоторых методов ввода, но не всегда удобны при использовании геймпада и пульта ДУ, где фокус перемещается по осям X и Y. Следуйте рекомендациям в этой статье, чтобы оптимизировать ваш пользовательский интерфейс для просмотра на большом расстоянии и обеспечить пользователю удобство доступа ко всем активным элементам. Распространенным решением является размещение вложенных элементов пользовательского интерфейса в `ContextFlyout`.

Подробнее о вложенных элементах пользовательского интерфейса см. в разделе [Вложенные элементы пользовательского интерфейса в элементах списка](../controls-and-patterns/nested-ui.md).

### <a name="mediatransportcontrols"></a>MediaTransportControls

Элемент [MediaTransportControls](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaTransportControls) позволяет пользователям работать с файлами мультимедиа, предоставляя им стандартные возможности взаимодействия, к которым относится воспроизведение, приостановка, включение скрытых субтитров и многое другое. Этот элемент управления является свойством [MediaPlayerElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaPlayerElement) и поддерживает 2 варианта макета: *однострочный* и *двухстрочный*. В однострочном макете, ползунок и все кнопки воспроизведения располагаются в ряд, при этом кнопка воспроизведения и паузы находится слева от ползунка. В двухстрочном макете ползунок занимает отдельную строку, а кнопки воспроизведения находятся под ним. При проектировании для взаимодействия на большом расстоянии необходимо использовать двухстрочный макет, поскольку он больше подходит для навигации с помощью геймпада. Чтобы реализовать двухстрочный макет, установите параметр `IsCompact="False"` элемента `MediaTransportControls` в свойстве [TransportControls](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaplayerelement.transportcontrols) элемента управления `MediaPlayerElement`.

```xml
<MediaPlayerElement x:Name="mediaPlayerElement1"  
                    Source="Assets/video.mp4"
                    AreTransportControlsEnabled="True">
    <MediaPlayerElement.TransportControls>
        <MediaTransportControls IsCompact="False"/>
    </MediaPlayerElement.TransportControls>
</MediaPlayerElement>
```  

Дополнительные сведения о добавлении мультимедиа в приложение см. в разделе [Воспроизведение мультимедиа](../controls-and-patterns/media-playback.md).

> ![ПРИМЕЧАНИЕ] Элемент `MediaPlayerElement` доступен только в Windows 10 версии 1607 и более поздних. При разработке приложения для более ранней версии Windows 10 нужно использовать [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement). Приведенные выше рекомендации применяются также к `MediaElement`. Доступ к свойству `TransportControls` осуществляется таким же образом.

### <a name="search-experience"></a>Параметры поиска

Поиск содержимого является одной из наиболее часто используемых на большом расстоянии функций. Если ваше приложение поддерживает возможности поиска, полезно предоставлять пользователю быстрый доступ к этой функции с использованием кнопки **Y** на геймпаде для ускоренного перехода к ней.

Большинство пользователей, скорее всего, уже знают об этой возможности быстрого перехода, но при желании вы можете добавить иконку **Y** в пользовательский интерфейс, чтобы указать, что пользователи могут нажимать эту кнопку для доступа к функции поиска. При добавлении этой подсказки следует использовать символ из шрифта **Segoe Xbox MDL2 Symbol** (`&#xE3CC;` для приложений XAML, `\E426` для приложений HTML) для обеспечения единообразия оболочки Xbox и других приложений.

> [!NOTE]
> Так как шрифт **Segoe Xbox MDL2 Symbol** доступен только на Xbox, этот символ будет неправильно отображаться на компьютере. Но после развертывания на Xbox он будет отображаться на телевизоре.

Поскольку кнопка **Y** доступна только на геймпаде, не забудьте предоставить другие методы доступа к функции поиска, например кнопки в пользовательском интерфейсе. Иначе некоторые пользователи не смогут получать доступ к этой функции.

При работе на большом расстоянии пользователям зачастую удобнее работать с полноэкранным интерфейсом поиска из-за ограниченного места на экране. Независимо от того, применяете ли вы полноэкранную или занимающую часть экрана функцию поиска, рекомендуется сразу же открывать экранную клавиатуру, когда пользователь обращается к поиску, чтобы она была доступна для ввода поисковых запросов.

## <a name="custom-visual-state-trigger-for-xbox"></a>Пользовательский триггер визуального состояния для Xbox

Чтобы адаптировать приложение UWP для просмотра на большом расстоянии, рекомендуется изменять макет, если приложение определяет, что оно было запущено на консоли Xbox. Например, это можно сделать с помощью пользовательского *триггера визуального состояния*. Триггеры визуального состояния полезнее всего использовать при выполнении редактирования в **Blend для Visual Studio**. В следующем фрагменте кода показано, как создать триггер визуального состояния для Xbox.

```xml
<VisualStateManager.VisualStateGroups>
    <VisualStateGroup>
        <VisualState>
            <VisualState.StateTriggers>
                <triggers:DeviceFamilyTrigger DeviceFamily="Windows.Xbox"/>
            </VisualState.StateTriggers>
            <VisualState.Setters>
                <Setter Target="RootSplitView.OpenPaneLength"
                        Value="368"/>
                <Setter Target="RootSplitView.CompactPaneLength"
                        Value="96"/>
                <Setter Target="NavMenuList.Margin"
                        Value="0,75,0,27"/>
                <Setter Target="Frame.Margin"
                        Value="0,27,48,27"/>
                <Setter Target="NavMenuList.ItemContainerStyle"
                        Value="{StaticResource NavMenuItemContainerXboxStyle}"/>
            </VisualState.Setters>
        </VisualState>
    </VisualStateGroup>
</VisualStateManager.VisualStateGroups>
```

Чтобы создать триггер, добавьте в приложение следующий класс. Это класс, на который ранее ссылался код XAML.

```csharp
class DeviceFamilyTrigger : StateTriggerBase
{
    private string _currentDeviceFamily, _queriedDeviceFamily;

    public string DeviceFamily
    {
        get
        {
            return _queriedDeviceFamily;
        }

        set
        {
            _queriedDeviceFamily = value;
            _currentDeviceFamily = AnalyticsInfo.VersionInfo.DeviceFamily;
            SetActive(_queriedDeviceFamily == _currentDeviceFamily);
        }
    }
}
```

После добавления пользовательского триггера ваше приложение автоматически будет изменять макет в соответствии с инструкциями в коде XAML, если оно обнаружит, что было запущено на консоли Xbox One.

Другим способом проверить, выполняется ли ваше приложение на Xbox, является добавление в код соответствующей переменной с последующим внесением необходимых изменений. Для проверки того, выполняется ли ваше приложение на Xbox, можно использовать следующую простую переменную.

```csharp
bool IsTenFoot = (Windows.System.Profile.AnalyticsInfo.VersionInfo.DeviceFamily ==
                    "Windows.Xbox");
```

После выполнения этой проверки в блок кода пользовательского интерфейса можно внести необходимые изменения. 

## <a name="summary"></a>Сводка

Процесс проектирования взаимодействия пользователя с ТВ при просмотре на большом расстоянии имеет свои особенности, которые нужно учитывать, и вследствие наличия которых он отличается от процесса проектирования для других платформ. Несмотря на то, что можно, конечно, осуществить непосредственный перенос приложения UWP на Xbox One и оно будет работать, приложение не будет априори оптимизировано для просмотра на большом расстоянии, что может привести к разочарованию пользователя. Выполнение рекомендаций в этой статье гарантирует, что ваше приложение будет работать на телевизоре так же хорошо, как и на любой другой платформе.

## <a name="related-articles"></a>Связанные статьи

- [Учебник устройств для приложений универсальной платформы Windows (UWP)](index.md)
- [Взаимодействия с игровой и удаленного управления](../input/gamepad-and-remote-interactions.md)
- [Звуковой в приложениях UWP](../style/sound.md)
