---
Description: Описывает концепцию одноранговых элементов автоматизации для автоматизации ПОЛЬЗОВАТЕЛЬСКОГО интерфейса Майкрософт, а также способы обеспечения поддержки автоматизации для собственного пользовательского класса пользовательского интерфейса.
ms.assetid: AA8DA53B-FE6E-40AC-9F0A-CB09637C87B4
title: Пользовательские одноранговые узлы автоматизации
label: Custom automation peers
template: detail.hbs
ms.date: 07/13/2018
ms.topic: article
keywords: Windows 10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: c6bc6996e80aacbd9eec0f37127a1dd24ec0e24e
ms.sourcegitcommit: f561efbda5c1d47b85601d91d70d86c5332bbf8c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/21/2019
ms.locfileid: "72690408"
---
# <a name="custom-automation-peers"></a>Пользовательские одноранговые узлы автоматизации  

Описывает концепцию одноранговых элементов автоматизации для автоматизации ПОЛЬЗОВАТЕЛЬСКОГО интерфейса Майкрософт, а также способы обеспечения поддержки автоматизации для собственного пользовательского класса пользовательского интерфейса.

Модель автоматизации пользовательского интерфейса предоставляет платформу, которую клиенты автоматизации могут использовать для проверки или работы пользовательских интерфейсов различных платформ и сред пользовательского интерфейса. Если вы пишете приложение универсальная платформа Windows (UWP), классы, используемые для пользовательского интерфейса, уже предоставляют поддержку автоматизации пользовательского интерфейса. Можно создать производный от существующих, незапечатанных классов, чтобы определить новый тип элемента управления пользовательского интерфейса или класса поддержки. В этом случае класс может добавить поведение, которое должно иметь поддержку специальных возможностей, но не охватывать стандартную поддержку автоматизации пользовательского интерфейса. В этом случае следует расширить существующую поддержку модели автоматизации пользовательского интерфейса, производной от класса [**AutomationPeer**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.AutomationPeer) , который использовался базовой реализацией, добавив необходимую поддержку в реализацию однорангового узла и выполнив универсальная платформа Windows (UWP). инфраструктура управления, которая должна создавать новый одноранговый узел.

Модель автоматизации пользовательского интерфейса включает не только приложения со специальными возможностями и вспомогательные технологии, такие как средства чтения с экрана, но и код контроля качества (тестирования). В любом сценарии клиенты автоматизации пользовательского интерфейса могут проверять элементы пользовательского интерфейса и имитировать взаимодействие пользователей с приложением из другого кода за пределами приложения. Сведения об автоматизации пользовательского интерфейса на всех платформах и их более широких значениях см. в разделе [Общие сведения о модели автоматизации пользовательского интерфейса](https://docs.microsoft.com/windows/desktop/WinAuto/uiauto-uiautomationoverview).

Существует две разные аудитории, использующие платформу автоматизации пользовательского интерфейса.

* ***Клиенты* автоматизации пользовательского интерфейса** вызывают интерфейсы API автоматизации пользовательского интерфейса, чтобы узнать обо всем пользовательском интерфейсе, отображаемом в данный момент пользователю. Например, такие специальные технологии, как средство чтения с экрана, действуют как клиент автоматизации пользовательского интерфейса. Пользовательский интерфейс представляется в виде дерева связанных элементов автоматизации. Клиент автоматизации пользовательского интерфейса может заинтересовать только одно приложение за раз или во всем дереве. Клиент автоматизации пользовательского интерфейса может использовать интерфейсы API модели автоматизации пользовательского интерфейса для навигации по дереву и чтения или изменения информации в элементах автоматизации.
* ***Поставщики* автоматизации пользовательского интерфейса** вносят сведения в дерево автоматизации пользовательского интерфейса, реализуя интерфейсы API, которые предоставляют элементы в пользовательском интерфейсе, которые они вводили в составе своего приложения. При создании нового элемента управления теперь следует действовать как участник в сценарии поставщика автоматизации пользовательского интерфейса. В качестве поставщика следует убедиться, что все клиенты автоматизации пользовательского интерфейса могут использовать платформу автоматизации пользовательского интерфейса для взаимодействия с элементом управления как в целях обеспечения доступности, так и при тестировании.

Обычно существуют параллельные API-интерфейсы в платформе автоматизации пользовательского интерфейса: один API для клиентов автоматизации пользовательского интерфейса и другой, аналогичный именованный API для поставщиков автоматизации пользовательского интерфейса. В большинстве случаев в этом разделе рассматриваются интерфейсы API для поставщика автоматизации пользовательского интерфейса, а именно классы и интерфейсы, обеспечивающие Расширяемость поставщика в этой инфраструктуре пользовательского интерфейса. Иногда мы упомянули интерфейсы API автоматизации ПОЛЬЗОВАТЕЛЬСКОГО интерфейса, которые используются клиентами автоматизации ИП, для предоставления некоторой перспективы или предоставляют таблицу уточняющих запросов, которая сопоставляет API клиента и поставщика. Дополнительные сведения о перспективе клиента см. в разделе [руководств по программированию клиента автоматизации пользовательского интерфейса](https://docs.microsoft.com/windows/desktop/WinAuto/uiauto-clientportal).

> [!NOTE]
> Клиенты автоматизации пользовательского интерфейса обычно не используют управляемый код и обычно не реализуются как приложение UWP (обычно это классические приложения). Модель автоматизации пользовательского интерфейса основана на стандарте, а не на конкретной реализации или платформе. Многие существующие клиенты автоматизации пользовательского интерфейса, включая вспомогательные технологические продукты, такие как средства чтения с экрана, используют интерфейсы модели COM для взаимодействия с автоматизацией пользовательского интерфейса, системой и приложениями, выполняемыми в дочерних окнах. Дополнительные сведения о COM-интерфейсах и о создании клиента автоматизации пользовательского интерфейса с помощью COM см. в разделе [основы модели автоматизации пользовательского интерфейса](https://docs.microsoft.com/windows/desktop/WinAuto/entry-uiautocore-overview).

<span id="Determining_the_existing_state_of_UI_Automation_support_for_your_custom_UI_class"/>
<span id="determining_the_existing_state_of_ui_automation_support_for_your_custom_ui_class"/>
<span id="DETERMINING_THE_EXISTING_STATE_OF_UI_AUTOMATION_SUPPORT_FOR_YOUR_CUSTOM_UI_CLASS"/>

## <a name="determining-the-existing-state-of-ui-automation-support-for-your-custom-ui-class"></a>Определение существующего состояния поддержки автоматизации ПОЛЬЗОВАТЕЛЬСКОГО интерфейса для пользовательского класса пользовательского интерфейса  
Прежде чем пытаться реализовать одноранговый узел автоматизации для пользовательского элемента управления, необходимо проверить, предоставляет ли базовый класс и его одноранговый узел автоматизации необходимую поддержку доступности или автоматизации. Во многих случаях сочетание реализаций [**фрамеворкелементаутоматионпир**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer) , отдельных одноранговых узлов и шаблонов, которые они реализуют, может обеспечить базовую, но удовлетворительную доступность. Это зависит от того, сколько изменений, внесенных в объектную модель, к элементу управления и его базовому классу. Кроме того, это зависит от того, соответствуют ли ваши дополнения к функциям базового класса новым элементам пользовательского интерфейса в контракте шаблона или к внешнему виду элемента управления. В некоторых случаях изменения могут привести к новым аспектам взаимодействия с пользователем, требующим дополнительной поддержки специальных возможностей.

Даже если использование существующего базового однорангового класса обеспечивает базовую поддержку специальных возможностей, по-прежнему рекомендуется определить одноранговый узел, чтобы вы могли сообщить точную информацию о **className** в модель автоматизации пользовательского интерфейса для сценариев автоматического тестирования. Это особенно важно при написании элемента управления, предназначенного для использования сторонними производителями.

<span id="Automation_peer_classes__"/>
<span id="automation_peer_classes__"/>
<span id="AUTOMATION_PEER_CLASSES__"/>

## <a name="automation-peer-classes"></a>Одноранговые классы автоматизации  
UWP построен на существующих методах автоматизации пользовательского интерфейса и соглашениях, используемых предыдущими платформами пользовательского интерфейса с управляемым кодом, такими как Windows Forms, Windows Presentation Foundation (WPF) и Microsoft Silverlight. У многих классов элементов управления, их функций и целей также есть происхождение в предыдущей платформе пользовательского интерфейса.

По соглашению имена одноранговых классов начинаются с имени класса элемента управления и заканчиваются на "AutomationPeer". Например, [**буттонаутоматионпир**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.ButtonAutomationPeer) является одноранговым классом для класса элемента управления [**Button**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Button) .

> [!NOTE]
> В этом разделе мы будем рассматривать свойства, связанные со специальными возможностями, как более важные при реализации однорангового элемента управления. Но для более общего принципа поддержки автоматизации пользовательского интерфейса следует реализовать одноранговый узел в соответствии с рекомендациями, как описано в разделе рекомендации [программиста поставщика автоматизации пользовательского интерфейса](https://docs.microsoft.com/windows/desktop/WinAuto/uiauto-providerportal) и [основные принципы автоматизации пользовательского интерфейса](https://docs.microsoft.com/windows/desktop/WinAuto/entry-uiautocore-overview). В этих разделах не рассматриваются конкретные API-интерфейсы [**AutomationPeer**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.AutomationPeer) , которые используются для предоставления информации в платформе UWP для автоматизации пользовательского интерфейса, но они описывают свойства, которые определяют класс или предоставляют другую информацию или взаимодействие.

<span id="Peers__patterns_and_control_types"/>
<span id="peers__patterns_and_control_types"/>
<span id="PEERS__PATTERNS_AND_CONTROL_TYPES"/>

## <a name="peers-patterns-and-control-types"></a>Одноранговые, шаблоны и типы элементов управления  
*Шаблон элемента управления* — это реализация интерфейса, которая предоставляет определенный аспект функциональных возможностей элемента управления клиенту автоматизации пользовательского интерфейса. Клиенты автоматизации пользовательского интерфейса используют свойства и методы, предоставляемые через шаблон элемента управления, для получения сведений о возможностях элемента управления или для управления поведением элемента во время выполнения.

Шаблоны элементов управления предоставляют способ категоризации и предоставления функциональных возможностей элемента управления независимо от типа элемента управления или его внешнего вида. Например, элемент управления, представляющий табличный интерфейс, использует шаблон элемента управления **Grid** для представления числа строк и столбцов в таблице, а также для предоставления клиенту автоматизации пользовательского интерфейса возможности извлечения элементов из таблицы. В других примерах клиент автоматизации пользовательского интерфейса может использовать шаблон элемента управления **Invoke** для элементов управления, которые могут быть вызваны, например кнопки, и шаблон элемента управления **Scroll** для элементов управления, имеющих полосы прокрутки, такие как списки, представления списков или поля со списком. Каждый шаблон элемента управления представляет отдельный тип функциональности, и шаблоны элементов управления можно комбинировать для описания полного набора функциональных возможностей, поддерживаемых определенным элементом управления.

Шаблоны элементов управления связаны с интерфейсом пользователя, так как интерфейсы связаны с COM-объектами. В модели COM можно запросить объект, чтобы узнать, какие интерфейсы он поддерживает, а затем использовать эти интерфейсы для доступа к функциональным возможностям. В модели автоматизации ПОЛЬЗОВАТЕЛЬСКОГО интерфейса клиенты автоматизации пользовательского интерфейса могут запрашивать элемент автоматизации ПОЛЬЗОВАТЕЛЬСКОГО интерфейса, чтобы узнать, какие шаблоны элементов управления он поддерживает, а затем взаимодействовать с элементом и его одноранговым элементом управления через свойства, методы, события и структуры, предоставляемые поддерживаемым шаблоны элементов управления.

Одна из главных целей однорангового узла автоматизации — сообщить клиенту автоматизации пользовательского интерфейса, какие шаблоны элементов управления может поддерживать элемент пользовательского интерфейса через его одноранговый узел. Для этого поставщики автоматизации пользовательского интерфейса реализуют новые одноранговые узлы, которые изменяют поведение метода методического [**шаблона**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getpattern) , переопределяя метод [**жетпаттернкоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) . Клиенты автоматизации пользовательского интерфейса выполняют вызовы, которые сопоставлены поставщиком автоматизации пользовательского интерфейса **для вызова метода**"метод". Клиенты автоматизации пользовательского интерфейса запрашивают каждый конкретный шаблон, с которым они хотят взаимодействовать. Если одноранговый узел поддерживает шаблон, он возвращает ссылку на объект для себя; в противном случае возвращается **значение NULL**. Если возвращаемое значение не равно **null**, клиент автоматизации пользовательского интерфейса ждет, что он может вызывать API интерфейса шаблона в качестве клиента для взаимодействия с этим шаблоном элемента управления.

*Тип элемента управления* — это способ широкого определения функциональных возможностей элемента управления, представляемого одноранговым элементом. Это концепция, отличная от шаблона элемента управления, поскольку хотя шаблон информирует модель автоматизации пользовательского интерфейса о том, какие сведения он может получить или какие действия он может выполнять через определенный интерфейс, тип элемента управления существует на одном уровне выше. Каждый тип элемента управления имеет рекомендации по этим аспектам автоматизации пользовательского интерфейса:

* Шаблоны элементов управления модели автоматизации пользовательского интерфейса: тип элемента управления может поддерживать более одного шаблона, каждый из которых представляет другую классификацию сведений или взаимодействия. Каждый тип элемента управления имеет набор шаблонов элементов управления, которые должен поддерживать элемент управления, необязательный набор и набор, который элемент управления не должен поддерживать.
* Значения свойств модели автоматизации пользовательского интерфейса: каждый тип элемента управления имеет набор свойств, которые должен поддерживать элемент управления. Это общие свойства, как описано в разделе [Общие сведения о свойствах модели автоматизации пользовательского интерфейса](https://docs.microsoft.com/windows/desktop/WinAuto/uiauto-propertiesoverview), а не о шаблонах, зависящих от шаблона.
* События модели автоматизации пользовательского интерфейса: каждый тип элемента управления имеет набор событий, которые должен поддерживать элемент управления. Опять же, они являются общими, не зависящими от шаблона, как описано в разделе [Общие сведения о событиях модели автоматизации пользовательского интерфейса](https://docs.microsoft.com/windows/desktop/WinAuto/uiauto-eventsoverview).
* Древовидная структура модели автоматизации пользовательского интерфейса. Каждый тип элемента управления определяет, как элемент управления должен отображаться в древовидной структуре модели автоматизации пользовательского интерфейса.

Независимо от того, как реализуются одноранговые узлы автоматизации для платформы, функциональные возможности клиента модели автоматизации пользовательского интерфейса не привязаны к UWP, и на самом деле вполне вероятно, что существующие клиенты автоматизации пользовательского интерфейса, такие как вспомогательные технологии, будут использовать другие модели программирования, такие как -. В COM клиенты могут выполнять **QueryInterface** для интерфейса шаблона элемента управления COM, который реализует запрошенный шаблон или универсальную платформу автоматизации пользовательского интерфейса для свойств, событий или изучения дерева. Для шаблонов платформа автоматизации пользовательского интерфейса маршалирует код интерфейса в код UWP, работающий с поставщиком автоматизации пользовательского интерфейса приложения и соответствующим одноранговым узлом.

При реализации шаблонов элементов управления для платформы управляемого кода, например приложения UWP с помощью C\# или Microsoft Visual Basic, можно использовать интерфейсы .NET Framework для представления этих шаблонов вместо использования представления интерфейса COM. Например, интерфейс шаблона модели автоматизации пользовательского интерфейса для реализации поставщика Microsoft .NET шаблона **Invoke** — [**IInvokeProvider**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Provider.IInvokeProvider).

Список шаблонов элементов управления, интерфейсов поставщиков и их назначение см. в разделе [шаблоны элементов управления и интерфейсы](control-patterns-and-interfaces.md). Список типов элементов управления см. в разделе [Общие сведения о типах элементов управления модели автоматизации пользовательского интерфейса](https://docs.microsoft.com/windows/desktop/WinAuto/uiauto-controltypesoverview).

<span id="Guidance_for_how_to_implement_control_patterns"/>
<span id="guidance_for_how_to_implement_control_patterns"/>
<span id="GUIDANCE_FOR_HOW_TO_IMPLEMENT_CONTROL_PATTERNS"/>

### <a name="guidance-for-how-to-implement-control-patterns"></a>Руководство по реализации шаблонов элементов управления  
Шаблоны элементов управления и то, для чего они предназначены, являются частью более крупного определения платформы автоматизации пользовательского интерфейса и не относятся к поддержке специальных возможностей для приложения UWP. При реализации шаблона элемента управления следует убедиться, что он реализуется таким образом, который соответствует руководству, как описано в этих документах, а также в спецификации автоматизации пользовательского интерфейса. Если вы ищете рекомендации, вы можете использовать документацию Майкрософт и не обязательно ссылаться на спецификацию. Рекомендации по каждому шаблону описаны здесь: [реализация шаблонов элементов управления модели автоматизации пользовательского интерфейса](https://docs.microsoft.com/windows/desktop/WinAuto/uiauto-implementinguiautocontrolpatterns). Обратите внимание, что в каждом разделе этой области есть раздел "руководства по реализации и соглашения" и раздел "необходимые элементы". Руководство обычно относится к конкретным интерфейсам API соответствующего интерфейса шаблона элемента управления в [интерфейсах шаблонов элементов управления для Справочника по поставщикам](https://docs.microsoft.com/windows/desktop/WinAuto/uiauto-cpinterfaces) . Эти интерфейсы являются интерфейсами машинного или COM (а их API-интерфейсы используют синтаксис в стиле COM). Но все, что вы видите, имеет эквивалент в пространстве имен [**Windows. UI. XAML. Automation. Provider**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Provider) .

Если вы используете одноранговые узлы автоматизации по умолчанию и разрабатываете их поведение, эти узлы уже были написаны на соответствие рекомендациям модели автоматизации пользовательского интерфейса. Если они поддерживают шаблоны элементов управления, вы можете полагаться на эту поддержку шаблонов, которая соответствует рекомендациям по [реализации шаблонов элементов управления модели автоматизации пользовательского интерфейса](https://docs.microsoft.com/windows/desktop/WinAuto/uiauto-implementinguiautocontrolpatterns). Если одноранговый элемент управления сообщает о том, что он имеет тип элемента управления, определенный в модели автоматизации пользовательского интерфейса, за ним последует руководство, которое описано в статье [Поддержка типов элементов управления модели автоматизации пользовательского интерфейса](https://docs.microsoft.com/windows/desktop/WinAuto/uiauto-supportinguiautocontroltypes) .

Тем не менее может потребоваться дополнительное руководство по шаблонам элементов управления или типам элементов управления, чтобы следовать рекомендациям по автоматизации пользовательского интерфейса в реализации одноранговых узлов. Это было бы особенно верно при реализации шаблона или поддержки типов элементов управления, которая еще не существует как реализация по умолчанию в элементе управления UWP. Например, шаблон для заметок не реализован ни в одном из элементов управления XAML по умолчанию. Но у вас может быть приложение, которое широко использует заметки, и поэтому вы хотите сделать эту функцию доступной. В этом сценарии одноранговый узел должен реализовать [**ианнотатионпровидер**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Provider.IAnnotationProvider) и, скорее всего, сообщить о себе как тип элемента управления **документом** с соответствующими свойствами, чтобы указать, что заметки поддерживаются в документах.

Рекомендуется использовать рекомендации, которые отображаются для шаблонов в разделе [реализация шаблонов элементов управления модели автоматизации пользовательского интерфейса](https://docs.microsoft.com/windows/desktop/WinAuto/uiauto-implementinguiautocontrolpatterns) или типов элементов управления в разделе [Поддержка типов элементов управления модели автоматизации пользовательского интерфейса](https://docs.microsoft.com/windows/desktop/WinAuto/uiauto-supportinguiautocontroltypes) в качестве ориентации и общих рекомендаций. Вы можете даже попробовать использовать некоторые из ссылок API для описания и заметок в соответствии с целью API. Но в соответствии с синтаксисом, необходимым для программирования приложений UWP, найдите эквивалентный API в пространстве имен [**Windows. UI. XAML. Automation. Provider**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Provider) и используйте эти справочные страницы для получения дополнительных сведений.

<span id="Built-in_automation_peer_classes"/>
<span id="built-in_automation_peer_classes"/>
<span id="BUILT-IN_AUTOMATION_PEER_CLASSES"/>

## <a name="built-in-automation-peer-classes"></a>Встроенные одноранговые классы автоматизации  
Как правило, элементы реализуют одноранговый класс автоматизации, если они принимают действия пользовательского интерфейса от пользователя или содержат сведения, необходимые пользователям специальных технологий, которые представляют интерактивный или осмысленный пользовательский интерфейс приложений. Не все визуальные элементы UWP имеют одноранговые узлы автоматизации. Примеры классов, реализующих одноранговые классы автоматизации — [**Button**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Button) и [**TextBox**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.TextBox). Примерами классов, которые не реализуют одноранговые узлы автоматизации, являются [**границы**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Border) и классы, основанные на [**панели**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Panel), такие как [**Grid**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Grid) и [**Canvas**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Canvas). **Панель** не имеет однорангового узла, так как она обеспечивает поведение макета только для визуального элемента. Для взаимодействия пользователя с **панелью**нет соответствующего способа. Любые дочерние элементы, содержащиеся в **панели** , передаются в деревья модели автоматизации пользовательского интерфейса как дочерние элементы следующего доступного родителя в дереве, содержащем одноранговый элемент или представление элемента.

<span id="UI_Automation_and_UWP_process_boundaries"/>
<span id="ui_automation_and_uwp_process_boundaries"/>
<span id="UI_AUTOMATION_AND_UWP_PROCESS_BOUNDARIES"/>

## <a name="ui-automation-and-uwp-process-boundaries"></a>Модель автоматизации пользовательского интерфейса и границы процесса UWP  
Как правило, клиентский код автоматизации пользовательского интерфейса, обращающийся к приложению UWP, выполняется вне процесса. Инфраструктура модели автоматизации пользовательского интерфейса позволяет получить данные через границу процесса. Эта концепция более подробно описана в [основах автоматизации пользовательского интерфейса](https://docs.microsoft.com/windows/desktop/WinAuto/entry-uiautocore-overview).

<span id="OnCreateAutomationPeer"/>
<span id="oncreateautomationpeer"/>
<span id="ONCREATEAUTOMATIONPEER"/>

## <a name="oncreateautomationpeer"></a>OnCreateAutomationPeer  
Все классы, производные от [**UIElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.UIElement) , содержат защищенный виртуальный метод [**OnCreateAutomationPeer**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.oncreateautomationpeer). Последовательность инициализации объектов для одноранговых узлов автоматизации вызывает **OnCreateAutomationPeer** , чтобы получить одноранговый объект автоматизации для каждого элемента управления и таким путем создать дерево модели автоматизации пользовательского интерфейса для использования во время выполнения. Код модели автоматизации пользовательского интерфейса может использовать одноранговый узел для получения сведений о характеристиках и функциях элемента управления, а также для имитации интерактивного использования с помощью шаблонов элементов управления. Пользовательский элемент управления, поддерживающий автоматизацию, должен переопределять **OnCreateAutomationPeer** и возвращать экземпляр класса, производного от [**AutomationPeer**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.AutomationPeer). Например, если пользовательский элемент управления является производным от класса [**ButtonBase**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Primitives.ButtonBase) , то объект, возвращаемый **OnCreateAutomationPeer** , должен быть производным от [**буттонбасеаутоматионпир**](https://docs.microsoft.com/en-us/uwp/api/windows.ui.xaml.automation.peers.buttonbaseautomationpeer).

Если вы создаете класс пользовательского элемента управления и планируете также предоставить новый одноранговый узел автоматизации, следует переопределить метод [**OnCreateAutomationPeer**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.oncreateautomationpeer) для пользовательского элемента управления, чтобы он возвращал новый экземпляр вашего однорангового узла. Одноранговый класс должен быть прямо или косвенно производным от [**AutomationPeer**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.AutomationPeer).

Например, следующий код объявляет, что пользовательский элемент управления `NumericUpDown` должен использовать одноранговые `NumericUpDownPeer` в целях автоматизации пользовательского интерфейса.

```csharp
using Windows.UI.Xaml.Automation.Peers;
...
public class NumericUpDown : RangeBase {
    public NumericUpDown() {
    // other initialization; DefaultStyleKey etc.
    }
    ...
    protected override AutomationPeer OnCreateAutomationPeer()
    {
        return new NumericUpDownAutomationPeer(this);
    }
}
```

```vb
Public Class NumericUpDown
    Inherits RangeBase
    ' other initialization; DefaultStyleKey etc.
       Public Sub New()
       End Sub
       Protected Overrides Function OnCreateAutomationPeer() As AutomationPeer
              Return New NumericUpDownAutomationPeer(Me)
       End Function
End Class
```

```cppwinrt
// NumericUpDown.idl
namespace MyNamespace
{
    runtimeclass NumericUpDown : Windows.UI.Xaml.Controls.Primitives.RangeBase
    {
        NumericUpDown();
        Int32 MyProperty;
    }
}

// NumericUpDown.h
...
struct NumericUpDown : NumericUpDownT<NumericUpDown>
{
    ...
    Windows::UI::Xaml::Automation::Peers::AutomationPeer OnCreateAutomationPeer()
    {
        return winrt::make<MyNamespace::implementation::NumericUpDownAutomationPeer>(*this);
    }
};
```

```cpp
//.h
public ref class NumericUpDown sealed : Windows::UI::Xaml::Controls::Primitives::RangeBase
{
// other initialization not shown
protected:
    virtual AutomationPeer^ OnCreateAutomationPeer() override
    {
         return ref new NumericUpDownAutomationPeer(this);
    }
};
```

> [!NOTE]
> Реализация [**OnCreateAutomationPeer**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.oncreateautomationpeer) не должна выполнять ничего больше, чем инициализировать новый экземпляр настраиваемого однорангового узла автоматизации, передавая вызывающий элемент управления в качестве владельца и возвращая этот экземпляр. Не пытайтесь использовать дополнительную логику в этом методе. В частности, любая логика, которая потенциально может привести к уничтожению [**AutomationPeer**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.AutomationPeer) в рамках одного вызова, может привести к непредвиденному поведению во время выполнения.

В типичных реализациях [**OnCreateAutomationPeer**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.oncreateautomationpeer) *владелец* указан как **this** или **Me** , так как переопределение метода находится в той же области, что и остальная часть определения класса элемента управления.

Фактическое определение однорангового класса может выполняться в том же файле кода, что и элемент управления или в отдельном файле кода. Все определения одноранговых узлов существуют в пространстве имен [**Windows. UI. XAML. Automation. пирингs**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers) , которое является отдельным пространством имен из элементов управления, для которых они предоставляют одноранговые узлы. Можно также объявить одноранговые узлы в отдельных пространствах имен при условии, что ссылки на необходимые пространства имен для вызова метода [**OnCreateAutomationPeer**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.oncreateautomationpeer) .

<span id="Choosing_the_correct_peer_base_class"/>
<span id="choosing_the_correct_peer_base_class"/>
<span id="CHOOSING_THE_CORRECT_PEER_BASE_CLASS"/>

### <a name="choosing-the-correct-peer-base-class"></a>Выбор правильного однорангового базового класса  
Убедитесь, что [**AutomationPeer**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.AutomationPeer) является производным от базового класса, который обеспечивает наилучшее соответствие для существующей одноранговой логики класса элемента управления, от которого происходит наследование. В случае предыдущего примера, поскольку `NumericUpDown` является производным от [**RangeBase**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Primitives.RangeBase), существует доступный класс [**ранжебасеаутоматионпир**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer) , на основе которого следует создать одноранговый узел. С помощью ближайшего совпадающего однорангового класса параллельно с тем, как происходит наследование самого элемента управления, можно избежать переопределения по крайней мере некоторых функций [**IRangeValueProvider**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Provider.IRangeValueProvider) , поскольку базовый одноранговый класс уже реализует его.

Базовый класс [**Control**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Control) не имеет соответствующего однорангового класса. Если требуется, чтобы одноранговый класс соответствовал пользовательскому элементу управления, производному от **Control**, необходимо создать класс настраиваемого однорангового узла из [**фрамеворкелементаутоматионпир**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer).

Если вы наследуете от [**ContentControl**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ContentControl) напрямую, этот класс не имеет поведения однорангового узла автоматизации по умолчанию, так как отсутствует реализация [**OnCreateAutomationPeer**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.oncreateautomationpeer) , которая ссылается на одноранговый класс. Поэтому необходимо либо реализовать **OnCreateAutomationPeer** для использования собственного однорангового узла, либо использовать [**фрамеворкелементаутоматионпир**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer) в качестве однорангового, если этот уровень поддержки специальных возможностей подходит для вашего элемента управления.

> [!NOTE]
> Обычно вы не наследуете от [**AutomationPeer**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.AutomationPeer) , а не от [**фрамеворкелементаутоматионпир**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer). Если вы выполнили наследование непосредственно от **AutomationPeer** , вам потребуется дублировать большую часть базовой поддержки специальных возможностей, которая в противном случае поступила бы от **фрамеворкелементаутоматионпир**.

<span id="Initialization_of_a_custom_peer_class"/>
<span id="initialization_of_a_custom_peer_class"/>
<span id="INITIALIZATION_OF_A_CUSTOM_PEER_CLASS"/>

## <a name="initialization-of-a-custom-peer-class"></a>Инициализация пользовательского однорангового класса  
Одноранговый элемент автоматизации должен определять строго типизированный конструктор, использующий экземпляр элемента управления Owner для базовой инициализации. В следующем примере реализация передает значение *владельца* в базу [**ранжебасеаутоматионпир**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer) , а в конечном итоге — [**фрамеворкелементаутоматионпир**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer) , который фактически использует *owner* для установки [ **Фрамеворкелементаутоматионпир. Owner**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.frameworkelementautomationpeer.owner).

```csharp
public NumericUpDownAutomationPeer(NumericUpDown owner): base(owner)
{}
```

```vb
Public Sub New(owner As NumericUpDown)
    MyBase.New(owner)
End Sub
```

```cppwinrt
// NumericUpDownAutomationPeer.idl
import "NumericUpDown.idl";
namespace MyNamespace
{
    runtimeclass NumericUpDownAutomationPeer : Windows.UI.Xaml.Automation.Peers.AutomationPeer
    {
        NumericUpDownAutomationPeer(NumericUpDown owner);
        Int32 MyProperty;
    }
}

// NumericUpDownAutomationPeer.h
...
struct NumericUpDownAutomationPeer : NumericUpDownAutomationPeerT<NumericUpDownAutomationPeer>
{
    ...
    NumericUpDownAutomationPeer(MyNamespace::NumericUpDown const& owner);
};
```

```cpp
//.h
public ref class NumericUpDownAutomationPeer sealed :  Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer
//.cpp
public:    NumericUpDownAutomationPeer(NumericUpDown^ owner);
```

<span id="Core_methods_of_AutomationPeer"/>
<span id="core_methods_of_automationpeer"/>
<span id="CORE_METHODS_OF_AUTOMATIONPEER"/>

## <a name="core-methods-of-automationpeer"></a>Основные методы AutomationPeer  
В целях инфраструктуры UWP переопределяемые методы однорангового узла автоматизации являются частью пары методов: общего метода доступа, который поставщик автоматизации пользовательского интерфейса использует в качестве точки перенаправления для клиентов автоматизации пользовательского интерфейса, и защищенного метода настройки "Core". , что класс UWP может переопределяться, чтобы влиять на поведение. Пара методов по умолчанию взаимодействуют, так что вызов метода доступа всегда вызывает параллельный метод "Core", имеющий реализацию поставщика или в качестве резервного варианта, вызывает реализацию по умолчанию из базовых классов.

При реализации однорангового узла для пользовательского элемента управления Переопределите любой из основных методов базового однорангового класса автоматизации, где требуется предоставить уникальное для пользовательского элемента управления поведение. Код модели автоматизации пользовательского интерфейса получает сведения о вашем элементе управления путем вызова открытых методов однорангового класса. Чтобы предоставить сведения об элементе управления, переопределите каждый метод с именем, заканчивающимся на "Core", если реализация элемента управления и разработка создают сценарии специальных возможностей или другие сценарии автоматизации пользовательского интерфейса, отличающиеся от поддерживаемых базовой автоматизацией. одноранговый класс.

Как минимум, при определении нового однорангового класса реализуйте метод [**жеткласснамекоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getclassnamecore) , как показано в следующем примере.

```csharp
protected override string GetClassNameCore()
{
    return "NumericUpDown";
}
```

> [!NOTE]
> Вы можете хранить строки как константы, а не напрямую в теле метода, но это не так. Для [**жеткласснамекоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getclassnamecore)локализации этой строки не требуется. Свойство **локализедконтролтипе** используется в любой момент, когда для клиента автоматизации пользовательского интерфейса требуется локализованная строка, а не **className**.

### <span id="GetAutomationControlType"/>
<span id="getautomationcontroltype"/>
<span id="GETAUTOMATIONCONTROLTYPE"/>Жетаутоматионконтролтипе

Некоторые вспомогательные технологии используют значение [**жетаутоматионконтролтипе**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getautomationcontroltype) непосредственно при составлении отчета о характеристиках элементов в дереве модели автоматизации пользовательского интерфейса, как и дополнительные сведения, помимо **имени**модели автоматизации пользовательского интерфейса. Если элемент управления значительно отличается от элемента управления, от которого происходит наследование, и требуется сообщить о другом типе элемента управления от того, что сообщается базовым одноранговым классом, используемым элементом управления, необходимо реализовать одноранговый узел и переопределить [**GetAutomationControlTypeCore** ](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getautomationcontroltypecore)в реализации однорангового узла. Это особенно важно, если вы наследуете от обобщенного базового класса, такого как [**ItemsControl**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ItemsControl) или [**ContentControl**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ContentControl), где базовый узел не предоставляет точную информацию о типе элемента управления.

Ваша реализация [**GetAutomationControlTypeCore**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getautomationcontroltypecore) описывает элемент управления, возвращая значение [**аутоматионконтролтипе**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.AutomationControlType) . Несмотря на то, что можно вернуть **аутоматионконтролтипе. Custom**, следует возвращать один из более конкретных типов элементов управления, если он точно описывает основные сценарии элемента управления. Ниже приведен пример.

```csharp
protected override AutomationControlType GetAutomationControlTypeCore()
{
    return AutomationControlType.Spinner;
}
```

> [!NOTE]
> Если не указать [**аутоматионконтролтипе. Custom**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.AutomationControlType), не нужно реализовывать [**жетлокализедконтролтипекоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getlocalizedcontroltypecore) , чтобы предоставить клиентам значение свойства **локализедконтролтипе** . Общая инфраструктура модели автоматизации пользовательского интерфейса предоставляет переведенные строки для каждого возможного значения **аутоматионконтролтипе** , отличного от **аутоматионконтролтипе. Custom**.

<span id="GetPattern_and_GetPatternCore"/>
<span id="getpattern_and_getpatterncore"/>
<span id="GETPATTERN_AND_GETPATTERNCORE"/>

### <a name="getpattern-and-getpatterncore"></a>Pattern и Жетпаттернкоре  
Реализация [**жетпаттернкоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) в одноранговых узлах возвращает объект, который поддерживает шаблон, запрашиваемый во входном параметре. В частности, клиент автоматизации пользовательского интерфейса вызывает метод, который перенаправляется в метод- [**шаблон**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getpattern) поставщика, и задает значение перечисления [**PatternInterface**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.PatternInterface) , которое указывает на запрошенный шаблон. Переопределение **жетпаттернкоре** должно возвращать объект, реализующий указанный шаблон. Этот объект является одноранговым узлом, так как узел должен реализовывать соответствующий интерфейс шаблона каждый раз, когда он сообщает, что поддерживает шаблон. Если у вашего узла нет пользовательской реализации шаблона, но известно, что база однорангового узла реализует шаблон, можно вызвать реализацию базового типа **жетпаттернкоре** из **жетпаттернкоре**. **Жетпаттернкоре** однорангового узла должен возвращать **значение NULL** , если шаблон не поддерживается одноранговым узлом. Однако вместо возврата **значения NULL** непосредственно из реализации вы обычно полагаетесь на вызов базовой реализации, чтобы вернуть **значение NULL** для любого неподдерживаемого шаблона.

Если шаблон поддерживается, реализация [**жетпаттернкоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) может вернуть **этот** или **Me**. Ожидание заключается в том, что клиент автоматизации пользовательского интерфейса будет приводить возвращаемое значение [**шаблона**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getpattern) к запрошенному интерфейсу шаблона каждый раз, когда он не равен **null**.

Если одноранговый класс наследуется от другого узла, и все необходимые отчеты о поддержке и шаблоне уже обрабатываются базовым классом, то реализация [**жетпаттернкоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) не требуется. Например, если реализуется элемент управления диапазона, производный от [**RangeBase**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Primitives.RangeBase), а одноранговый узел является производным от [**ранжебасеаутоматионпир**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer), то этот узел возвращает себя для [**PatternInterface. RangeValue**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.PatternInterface) и работает с реализациями интерфейс [**IRangeValueProvider**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Provider.IRangeValueProvider) , поддерживающий шаблон.

Несмотря на то, что это не код литерала, в этом примере приблизительно реализована реализация [**жетпаттернкоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) , уже присутствующая в [**ранжебасеаутоматионпир**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer).


```csharp
protected override object GetPatternCore(PatternInterface patternInterface)
{
    if (patternInterface == PatternInterface.RangeValue)
    {
        return this;
    }
    return base.GetPattern(patternInterface);
}
```

Если вы реализуете одноранговый узел, где у вас нет необходимой поддержки из базового однорангового класса или вы хотите изменить или добавить набор шаблонов, наследуемых одноранговым элементом, которые может поддерживать одноранговый интерфейс, следует переопределить [**жетпаттернкоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) , чтобы включить автоматизацию пользовательского интерфейса. Клиенты используют шаблоны.

Список шаблонов поставщиков, доступных в реализации модели автоматизации пользовательского интерфейса UWP, см. в разделе [**Windows. UI. XAML. Automation. Provider**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Provider). Каждый такой шаблон имеет соответствующее значение перечисления [**PatternInterface**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.PatternInterface) , в котором клиенты автоматизации пользовательского интерфейса запрашивают шаблон в вызове метода- [**шаблона**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getpattern) .

Одноранговый узел может сообщить о том, что он поддерживает более одного шаблона. В этом случае переопределение должно включать логику пути возврата для каждого поддерживаемого значения [**PatternInterface**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.PatternInterface) и возвращать одноранговый узел в каждом соответствующем регистре. Ожидается, что вызывающий объект будет запрашивать только один интерфейс за раз, и он может быть приведен к ожидаемому интерфейсу.

Ниже приведен пример переопределения [**жетпаттернкоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) для пользовательского однорангового узла. Он содержит сведения о поддержке двух шаблонов: [**IRangeValueProvider**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Provider.IRangeValueProvider) и [**IToggleProvider**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Provider.IToggleProvider). Элемент управления здесь является элементом управления отображением мультимедиа, который может отображаться в полноэкранном режиме (режим переключения) и содержит индикатор выполнения, в котором пользователи могут выбрать положение (элемент управления "диапазон"). Этот код получен из [примера специальных возможностей XAML](https://go.microsoft.com/fwlink/p/?linkid=238570).


```csharp
protected override object GetPatternCore(PatternInterface patternInterface)
{
    if (patternInterface == PatternInterface.RangeValue)
    {
        return this;
    }
    else if (patternInterface == PatternInterface.Toggle)
    {
        return this;
    }
    return null;
}
```

<span id="Forwarding_patterns_from_sub-elements"/>
<span id="forwarding_patterns_from_sub-elements"/>
<span id="FORWARDING_PATTERNS_FROM_sub-elementS"/>

### <a name="forwarding-patterns-from-sub-elements"></a>Пересылка шаблонов из вложенных элементов  
Реализация метода [**жетпаттернкоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) также может указывать вложенный элемент или часть в качестве поставщика шаблона для своего узла. В этом примере имитируется, как [**ItemsControl**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ItemsControl) передает обработку шаблона прокрутки на одноранговый элемент внутреннего элемента управления [**ScrollViewer**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ScrollViewer) . Чтобы указать вложенный элемент для обработки шаблона, этот код получает объект вложенного элемента, создает одноранговый элемент для вложенного элемента с помощью метода [**фрамеворкелементаутоматионпир. креатепирфорелемент**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.frameworkelementautomationpeer.createpeerforelement) и возвращает новый одноранговый узел.


```csharp
protected override object GetPatternCore(PatternInterface patternInterface)
{
    if (patternInterface == PatternInterface.Scroll)
    {
        ItemsControl owner = (ItemsControl) base.Owner;
        UIElement itemsHost = owner.ItemsHost;
        ScrollViewer element = null;
        while (itemsHost != owner)
        {
            itemsHost = VisualTreeHelper.GetParent(itemsHost) as UIElement;
            element = itemsHost as ScrollViewer;
            if (element != null)
            {
                break;
            }
        }
        if (element != null)
        {
            AutomationPeer peer = FrameworkElementAutomationPeer.CreatePeerForElement(element);
            if ((peer != null) && (peer is IScrollProvider))
            {
                return (IScrollProvider) peer;
            }
        }
    }
    return base.GetPatternCore(patternInterface);
}
```

<span id="Other_Core_methods"/>
<span id="other_core_methods"/>
<span id="OTHER_CORE_METHODS"/>

### <a name="other-core-methods"></a>Другие основные методы  
Вашему элементу управления может потребоваться поддержка клавиатурных эквивалентов для основных сценариев. Дополнительные сведения о том, почему это может потребоваться, см. в разделе [Специальные возможности клавиатуры](keyboard-accessibility.md). Реализация поддержки ключа обязательно является частью управляющего кода, а не однорангового кода, так как он является частью логики элемента управления, но класс однорангового класса должен переопределять методы [**жетакцелераторкэйкоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getacceleratorkeycore) и [**жетакцесскэйкоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getaccesskeycore) для передачи отчетов в пользовательский интерфейс. Клиенты автоматизации, используемые ключами. Рассмотрите возможность локализации строк, которые сообщают сведения о ключе, и, следовательно, поступают из ресурсов, не имеющих жестко заданных строк.

Если вы предоставляете одноранговый класс для класса, который поддерживает коллекцию, лучше создать производный от функциональных классов и одноранговых классов, у которых уже есть такая поддержка коллекций. Если этого не сделать, одноранговым элементам управления, которые поддерживают дочерние коллекции, может потребоваться переопределение связанного с коллекцией однорангового метода [**GetChildrenCore**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getchildrencore) для правильного отчета о связях типа «родители-потомки» с деревом модели автоматизации пользовательского интерфейса.

Реализуйте методы [**исконтентелементкоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.iscontentelementcore) и [**IsControlElementCore**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.iscontrolelementcore) , чтобы указать, содержит ли элемент управления содержимое данных, или выполняет интерактивную роль в пользовательском интерфейсе (или в обоих случаях). По умолчанию оба метода возвращают **значение true**. Эти параметры повышают удобство использования вспомогательных технологий, таких как средства чтения с экрана, которые могут использовать эти методы для фильтрации дерева автоматизации. Если метод [**жетпаттернкоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getpatterncore) передает обработку шаблона в одноранговый элемент, то метод **IsControlElementCore** однорангового элемента может вернуть **значение false** , чтобы скрыть элемент однорангового узла из дерева автоматизации.

Некоторые элементы управления могут поддерживать сценарии с метками, в которых часть текстовой метки предоставляет сведения для нетекстовой части, или элемент управления должен быть в известной связи меток с другим элементом управления в пользовательском интерфейсе. Если возможно предоставить полезное поведение на основе классов, можно переопределить [**жетлабеледбикоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getlabeledbycore) , чтобы обеспечить такое поведение.

[**Жетбаундингректанглекоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getboundingrectanglecore) и [**жеткликкаблепоинткоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getclickablepointcore) используются в основном для сценариев автоматического тестирования. Если вы хотите поддерживать автоматическое тестирование для вашего элемента управления, может потребоваться переопределить эти методы. Это может быть необходимо для элементов управления типа Range, где нельзя предложить лишь одну точку, так как при щелчке мышью в пространстве координат другой результат для диапазона. Например, узел автоматизации [**полосы прокрутки**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Primitives.ScrollBar) по умолчанию переопределяет **жеткликкаблепоинткоре** , чтобы вернуть значение [**точки**](https://docs.microsoft.com/uwp/api/Windows.Foundation.Point) "не является числом".

[**Жетливесеттингкоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getlivesettingcore) влияет на значение элемента управления по умолчанию для значения **LiveSetting** для модели автоматизации пользовательского интерфейса. Может потребоваться переопределить этот параметр, если требуется, чтобы элемент управления возвращал значение, отличное от [**аутоматионливесеттинг. Off**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.AutomationLiveSetting). Дополнительные сведения о том, что представляет **LiveSetting** , см. в разделе [**AutomationProperties. LiveSetting**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.automationproperties.livesettingproperty).

Вы можете переопределить [**жеториентатионкоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getorientationcore) , если элемент управления имеет настраиваемое свойство Orientation, которое может сопоставляться с [**аутоматионориентатион**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.AutomationOrientation). Это делают классы [**скроллбараутоматионпир**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.ScrollBarAutomationPeer) и [**слидераутоматионпир**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.SliderAutomationPeer) .

<span id="Base_implementation_in_FrameworkElementAutomationPeer"/>
<span id="base_implementation_in_frameworkelementautomationpeer"/>
<span id="BASE_IMPLEMENTATION_IN_FRAMEWORKELEMENTAUTOMATIONPEER"/>

### <a name="base-implementation-in-frameworkelementautomationpeer"></a>Базовая реализация в Фрамеворкелементаутоматионпир  
Базовая реализация [**фрамеворкелементаутоматионпир**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer) предоставляет некоторые сведения об автоматизации пользовательского интерфейса, которые можно интерпретировать из различных макетов и свойств поведения, определенных на уровне платформы.

* [**Жетбаундингректанглекоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getboundingrectanglecore): Возвращает структуру [**Rect**](https://docs.microsoft.com/uwp/api/Windows.Foundation.Rect) на основе известных характеристик макета. Возвращает значение **Rect** , равное 0, если [**исоффскрин**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.isoffscreen) имеет **значение true**.
* [**Жеткликкаблепоинткоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getclickablepointcore): Возвращает структуру [**точек**](https://docs.microsoft.com/uwp/api/Windows.Foundation.Point) на основе известных характеристик макета при условии, что имеется ненулевой **баундингректангле**.
* [**Жетнамекоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getnamecore): более широкое поведение, чем можно суммировать здесь; см. [**жетнамекоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getnamecore). По сути, он пытается преобразовать строку на любом известном содержимом [**ContentControl**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ContentControl) или связанных классов, имеющих содержимое. Кроме того, если имеется значение для [**лабеледби**](https://docs.microsoft.com/previous-versions/windows/silverlight/dotnet-windows-silverlight/ms591292(v=vs.95)), в качестве **имени**используется значение **имени** этого элемента.
* [**Хаскэйбоардфокускоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.haskeyboardfocuscore): вычисляется на основе свойств [**фокусстате**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.focusstate) и [**Enable**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.isenabled) владельца. Элементы, которые не являются элементами управления, всегда возвращают **значение false**.
* [**Исенабледкоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.isenabledcore): вычисляется на основе свойства, [**включенного**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.isenabled) владельцем, если это [**элемент управления**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Control). Элементы, которые не являются элементами управления, всегда возвращают **значение true**. Это не означает, что владелец включен в стандартном смысле взаимодействия. Это означает, что одноранговый узел включен, несмотря на то, что у владельца нет **включенного** свойства.
* [**Искэйбоардфокусаблекоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.iskeyboardfocusablecore): возвращает **значение true** , если владелец является [**элементом управления**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Control); в противном случае — **false**.
* [**Исоффскринкоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.isoffscreencore): [**видимость**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.visibility) , [**свернутая**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visibility) в элементе owner или любом из его родительских элементов, соответствует значению **true** для [**исоффскрин**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.isoffscreen). Исключение: объект [**Popup**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Primitives.Popup) может быть видимым, даже если его родительские элементы не принадлежат.
* [**Сетфокускоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.setfocuscore): вызывает [**фокус**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.focus).
* " [**Родители**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getparent)": вызывает [**FrameworkElement. Parent**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.parent) из владельца и ищет соответствующий одноранговый узел. Это не переопределение пары с помощью метода "Core", поэтому это поведение изменить нельзя.

> [!NOTE]
> Одноранговые узлы UWP по умолчанию реализуют поведение с помощью внутреннего машинного кода, который реализует UWP, а не обязательно с использованием фактического кода UWP. Вы не сможете увидеть код или логику реализации с помощью отражения среды CLR или других методов. Кроме того, не будут отображаться отдельные справочные страницы для переопределений, зависящих от подкласса, для поведения базового однорангового узла. Например, может быть дополнительным поведением для [**Жетнамекоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getnamecore) [**текстбоксаутоматионпир**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.TextBoxAutomationPeer), которое не будет описано на странице справочника по **AutomationPeer. жетнамекоре** , а справочная страница для  **Текстбоксаутоматионпир. Жетнамекоре**. На странице ссылок **текстбоксаутоматионпир. жетнамекоре** нет даже. Вместо этого прочитайте справочный раздел по наиболее непосредственным одноранговым классам и найдите примечания по реализации в разделе "Примечания".

<span id="Peers_and_AutomationProperties"/>
<span id="peers_and_automationproperties"/>
<span id="PEERS_AND_AUTOMATIONPROPERTIES"/>

## <a name="peers-and-automationproperties"></a>Одноранговые узлы и AutomationProperties  
Одноранговый узел автоматизации должен предоставлять соответствующие значения по умолчанию для сведений, относящихся к специальным возможностям элемента управления. Обратите внимание, что любой код приложения, использующий элемент управления, может переопределять некоторые из этих поведений, включая [**AutomationProperties**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.AutomationProperties) значения вложенных свойств для экземпляров элементов управления. Вызывающие объекты могут сделать это для элементов управления по умолчанию или для пользовательских элементов управления. Например, следующий код XAML создает кнопку с двумя настраиваемыми свойствами модели автоматизации пользовательского интерфейса: `<Button AutomationProperties.Name="Special"      AutomationProperties.HelpText="This is a special button."/>`

Дополнительные сведения о присоединенных свойствах [**AutomationProperties**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.AutomationProperties) см. в разделе [основные данные о специальных возможностях](basic-accessibility-information.md).

Некоторые из методов [**AutomationPeer**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.AutomationPeer) существуют в связи с общим соглашением о том, как поставщики автоматизации пользовательского интерфейса должны сообщать информацию, но эти методы обычно не реализуются в одноранговых элементах управления. Это обусловлено тем, что эти сведения должны предоставляться значениями [**AutomationProperties**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.AutomationProperties) , применяемыми к коду приложения, который использует элементы управления в ОПРЕДЕЛЕННОМ пользовательском интерфейсе. Например, большинство приложений определяют связь меток между двумя различными элементами управления в пользовательском интерфейсе, применяя значение [**AutomationProperties. лабеледби**](https://docs.microsoft.com/previous-versions/windows/silverlight/dotnet-windows-silverlight/ms591292(v=vs.95)) . Однако [**лабеледбикоре**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getlabeledbycore) реализуется в определенных одноранговых отношениях, представляющих связи данных или элементов в элементе управления, например с помощью части заголовка для обозначения части поля данных, пометки элементов с их контейнерами или похожих сценариев.

<span id="Implementing_patterns"/>
<span id="implementing_patterns"/>
<span id="IMPLEMENTING_PATTERNS"/>

## <a name="implementing-patterns"></a>Реализация шаблонов  
Рассмотрим, как написать одноранговый элемент управления, реализующий поведение развертывания и свертывания, путем реализации интерфейса шаблона элемента управления для развертывания и свертывания. Узел должен включить специальные возможности для поведения развертывания и свертывания, [**вернувшись при**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getpattern) вызове метода with со значением [**PatternInterface. ExpandCollapse**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.PatternInterface). Затем узел должен наследовать интерфейс поставщика для этого шаблона ([**иекспандколлапсепровидер**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.provider.iexpandcollapseprovider)) и предоставить реализации для каждого члена этого интерфейса поставщика. В этом случае интерфейс имеет три члена для переопределения: [**expand**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.provider.iexpandcollapseprovider.expand), [**сворачивания**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.provider.iexpandcollapseprovider.collapse), [**ExpandCollapseState**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.provider.iexpandcollapseprovider.expandcollapsestate).

Полезно заранее спланировать специальные возможности в структуре API самого класса. При возникновении поведения, которое потенциально запрашивается в результате типичных взаимодействий с пользователем, работающим в пользовательском интерфейсе или с помощью шаблона поставщика автоматизации, предоставьте один метод, который может быть вызван как ответ пользовательского интерфейса, так и шаблон автоматизации. Например, если у элемента управления есть элементы Button, имеющие обработчики проводных событий, которые могут разворачивать или сворачивать элемент управления и иметь эквиваленты клавиш для этих действий, эти обработчики событий должны вызывать тот же метод, который вызывается из тела [**расширения** ](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.provider.iexpandcollapseprovider.expand)или [**сверните**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.provider.iexpandcollapseprovider.collapse) реализации для [**иекспандколлапсепровидер**](https://docs.microsoft.com/windows/desktop/api/uiautomationcore/nn-uiautomationcore-iexpandcollapseprovider) в одноранговой сети. Использование общего логического метода также может быть полезным способом обеспечить обновление визуальных состояний элемента управления для единообразного отображения логического состояния, независимо от способа вызова поведения.

Типичная реализация заключается в том, что API поставщика сначала вызывают [**владельца**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.frameworkelementautomationpeer.owner) для доступа к экземпляру элемента управления во время выполнения. Затем для этого объекта могут быть вызваны необходимые методы поведения.


```csharp
public class IndexCardAutomationPeer : FrameworkElementAutomationPeer, IExpandCollapseProvider {
    private IndexCard ownerIndexCard;
    public IndexCardAutomationPeer(IndexCard owner) : base(owner)
    {
         ownerIndexCard = owner;
    }
}
```

Альтернативная реализация заключается в том, что сам элемент управления может ссылаться на его одноранговый узел. Это общий шаблон, если вы вызываете события автоматизации из элемента управления, так как метод [**раисеаутоматионевент**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.raiseautomationevent) является однорангым.

<span id="UI_Automation_events"/>
<span id="ui_automation_events"/>
<span id="UI_AUTOMATION_EVENTS"/>

## <a name="ui-automation-events"></a>События модели автоматизации пользовательского интерфейса  

События модели автоматизации пользовательского интерфейса делятся на следующие категории.

| Мероприятие | Описание |
|-------|-------------|
| Изменение свойства | Активируется при изменении свойства элемента модели автоматизации пользовательского интерфейса или шаблона элемента управления. Например, если клиенту необходимо отслеживать элемент управления "флажок" приложения, он может зарегистрироваться для прослушивания события изменения свойства в свойстве [**тогглестате**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.provider.itoggleprovider.togglestate) . Если флажок установлен или снят, поставщик запускает событие, и клиент может выполнить необходимые действия. |
| Действие элемента | Активируется, когда изменение пользовательского интерфейса вызывается пользователем или программным действием; Например, при нажатии кнопки или вызове с помощью шаблона **Invoke** . |
| Изменение структуры | Активируется при изменении структуры дерева автоматизации пользовательского интерфейса. Структура изменяется, когда новые элементы пользовательского интерфейса становятся видимыми, скрытыми или удаляются на рабочем столе. |
| Глобальное изменение | Вызывается, когда выполняются действия глобального интереса для клиента, например, когда фокус перемещается с одного элемента на другой или когда закрывается дочернее окно. Некоторые события не обязательно означают, что изменилось состояние пользовательского интерфейса. Например, если пользователь записал вкладки в поле ввода текста, а затем нажимает кнопку для обновления поля, событие [**TextChanged**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.textbox.textchanged) срабатывает, даже если пользователь не изменил текст. При обработке события может потребоваться, чтобы клиентское приложение могло проверить, не изменилось ли что-либо на самом деле перед выполнением действия. |

<span id="AutomationEvents_identifiers"/>
<span id="automationevents_identifiers"/>
<span id="AUTOMATIONEVENTS_IDENTIFIERS"/>

### <a name="automationevents-identifiers"></a>Идентификаторы Аутоматионевентс  
События модели автоматизации пользовательского интерфейса идентифицируются по значениям [**аутоматионевентс**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.AutomationEvents) . Значения перечисления однозначно определяют тип события.

<span id="Raising_events"/>
<span id="raising_events"/>
<span id="RAISING_EVENTS"/>

### <a name="raising-events"></a>Создание событий  
Клиенты автоматизации пользовательского интерфейса могут подписываться на события автоматизации. В одноранговой модели автоматизации одноранговые элементы настраиваемых элементов управления должны сообщать об изменениях в состоянии управления, которые относятся к специальным возможностям, путем вызова метода [**раисеаутоматионевент**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.raiseautomationevent) . Аналогичным образом, при изменении значения свойства модели автоматизации пользовательского интерфейса, одноранговые узлы пользовательского элемента управления должны вызывать метод [**раисепропертичанжедевент**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.raisepropertychangedevent) .

В следующем примере кода показано, как получить одноранговый объект из кода определения элемента управления и вызвать метод, чтобы запустить событие из этого однорангового узла. В качестве оптимизации код определяет наличие прослушивателей для данного типа событий. Обработка события и создание однорангового объекта только в том случае, если прослушиватели позволяют избежать ненужных затрат и помогают элементу управления оставаться в процессе реагирования.


```csharp
if (AutomationPeer.ListenerExists(AutomationEvents.PropertyChanged))
{
    NumericUpDownAutomationPeer peer =
        FrameworkElementAutomationPeer.FromElement(nudCtrl) as NumericUpDownAutomationPeer;
    if (peer != null)
    {
        peer.RaisePropertyChangedEvent(
            RangeValuePatternIdentifiers.ValueProperty,
            (double)oldValue,
            (double)newValue);
    }
}
```

<span id="Peer_navigation"/>
<span id="peer_navigation"/>
<span id="PEER_NAVIGATION"/>

## <a name="peer-navigation"></a>Одноранговая Навигация  
После нахождения однорангового узла автоматизации клиент автоматизации пользовательского интерфейса может перемещаться по одноранговой структуре приложения, вызывая методы [**дочернего**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getchildren) объекта и метода- [**родителя**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getparent) . Переход между элементами пользовательского интерфейса в элементе управления поддерживается реализацией метода [**GetChildrenCore**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.peers.automationpeer.getchildrencore) в одноранговых узлах. Система автоматизации пользовательского интерфейса вызывает этот метод для создания дерева вложенных элементов, содержащихся в элементе управления. Например, список элементов в поле со списком. Метод **GetChildrenCore** по умолчанию в [**фрамеворкелементаутоматионпир**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer) проходит по визуальному дереву элементов для создания дерева одноранговых узлов автоматизации. Пользовательские элементы управления могут переопределять этот метод, чтобы предоставить клиентам автоматизации другое представление дочерних элементов, возвращая одноранговые узлы автоматизации элементов, которые передают информацию или разрешают взаимодействие с пользователем.

<span id="Native_automation_support_for_text_patterns"/>
<span id="native_automation_support_for_text_patterns"/>
<span id="NATIVE_AUTOMATION_SUPPORT_FOR_TEXT_PATTERNS"/>

## <a name="native-automation-support-for-text-patterns"></a>Поддержка собственной автоматизации для текстовых шаблонов  
Некоторые одноранговые узлы автоматизации приложений UWP по умолчанию предоставляют поддержку шаблона элемента управления для текстового шаблона ([**PatternInterface. Text**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.PatternInterface)). Но они обеспечивают эту поддержку с помощью собственных методов, и участвующие коллеги не заметок о интерфейсе [**итекстпровидер**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Provider.ITextProvider) в наследовании (управляемом). Тем не менее, если управляемый или неуправляемый клиент автоматизации пользовательского интерфейса запрашивает одноранговый узел для шаблонов, он сообщит о поддержке шаблона текста и предложит поведение для частей шаблона при вызове клиентских интерфейсов API.

Если вы планируете создать производную от одного из элементов управления текстом приложения UWP, а также создаете пользовательский одноранговый узел, производный от одного из связанных с текстом узлов, ознакомьтесь с разделом "Примечания" для однорангового узла, чтобы получить дополнительные сведения о поддержке шаблонов на собственном уровне. Вы можете получить доступ к базовому поведению в собственном одноранговом узле, если вы вызываете базовую реализацию из реализаций управляемого интерфейса поставщика, но сложно изменить то, что делает Базовая реализация, так как собственные интерфейсы как на одноранговом, так и в элемент управления "владелец" не предоставляется. Как правило, следует использовать базовые реализации "как есть" (только для базового вызова) или полностью заменить функциональность собственным управляемым кодом и не вызывать базовую реализацию. Второй сценарий является расширенным сценарием, поэтому вам нужно хорошо знакомство с платформой текстовых служб, используемой элементом управления для поддержки требований к специальным возможностям при использовании этой платформы.

<span id="AutomationProperties.AccessibilityView"/>
<span id="automationproperties.accessibilityview"/>
<span id="AUTOMATIONPROPERTIES.ACCESSIBILITYVIEW"/>

## <a name="automationpropertiesaccessibilityview"></a>AutomationProperties. Акцессибилитивиев  
Помимо предоставления пользовательского однорангового узла, можно также настроить представление в виде дерева для любого экземпляра элемента управления, установив [**AutomationProperties. акцессибилитивиев**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.automationproperties.accessibilityview) в XAML. Это не реализуется как часть однорангового класса, но мы будем упомянутся здесь, так как он является немецким по отношению к общей поддержке специальных возможностей для пользовательских элементов управления или настраиваемых шаблонов.

Основной сценарий использования **AutomationProperties. акцессибилитивиев** заключается в намеренном пропуске определенных элементов управления в шаблоне из представлений модели автоматизации пользовательского интерфейса, поскольку они не имеют смысла вносить изменения в представление специальных возможностей всего элемента управления. Чтобы избежать этого, задайте для **AutomationProperties. акцессибилитивиев** значение "RAW".

<span id="Throwing_exceptions_from_automation_peers"/>
<span id="throwing_exceptions_from_automation_peers"/>
<span id="THROWING_EXCEPTIONS_FROM_AUTOMATION_PEERS"/>

## <a name="throwing-exceptions-from-automation-peers"></a>Создание исключений из одноранговых узлов автоматизации  
API-интерфейсы, реализуемые для поддержки одноранговых узлов автоматизации, могут создавать исключения. Предполагается, что все клиенты автоматизации пользовательского интерфейса, которые ожидают прослушивание, достаточно надежны для продолжения работы после возникновения большинства исключений. С другой стороны, прослушиватель просматривает все дерево автоматизации, которое включает в себя приложения, отличные от собственных, и это неприемлемый проект клиента, позволяющий выключать весь клиент только потому, что одна область дерева вызвала исключение однорангового узла, когда клиент вызывает его API.

Для параметров, передаваемых в одноранговый узел, допустимо проверять входные данные и, например, создавать [**ArgumentNullException**](https://docs.microsoft.com/dotnet/api/system.argumentnullexception) , если он передавал **значение NULL** и это не является допустимым значением для вашей реализации. Однако при наличии последующих операций, выполняемых одноранговым узлом, помните, что взаимодействие однорангового элемента управления с ведущим имеет в них какой-либо асинхронный символ. Все, что делает одноранговый элемент, не обязательно блокирует поток пользовательского интерфейса в элементе управления (и, возможно, не должен). Поэтому возможны ситуации, когда объект был доступен или имел определенные свойства при создании однорангового узла или при первом вызове однорангового метода автоматизации, но в то время, пока состояние элемента управления изменилось. В таких случаях существует два отдельных исключения, которые может вызывать поставщик:

* Вызывайте [**ElementNotAvailableException**](https://docs.microsoft.com/dotnet/api/system.windows.automation.elementnotavailableexception) , если не удается получить доступ к владельцу узла или связанному одноранговому элементу на основе исходных сведений, переданных API. Например, у вас может быть одноранговый узел, который пытается выполнить свои методы, но владелец был удален из пользовательского интерфейса, например модальное диалоговое окно, которое было закрыто. Для клиента non-.NET это сопоставляется с [**UIA\_E\_елементнотаваилабле**](https://docs.microsoft.com/windows/desktop/WinAuto/uiauto-error-codes).
* Вызывайте [**елементнотенабледексцептион**](https://docs.microsoft.com/dotnet/api/system.windows.automation.elementnotenabledexception) , если он по-прежнему является владельцем, но этот владелец находится в режиме, например [**включенном**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.isenabled)`=`**false** , блокирующем некоторые из определенных программных изменений, которые пытается выполнить одноранговый узел. Для клиента non-.NET это сопоставляется с [**UIA\_E\_елементнотенаблед**](https://docs.microsoft.com/windows/desktop/WinAuto/uiauto-error-codes).

Помимо этого, одноранговые узлы должны быть относительно консервативными исключениями, которые они создают при поддержке их коллег. Большинство клиентов не смогут обрабатывать исключения от одноранговых узлов и преобразовывать их в действия, которые могут быть доступны пользователям при взаимодействии с клиентом. Таким образом, иногда нет операций и перехват исключений без повторного создания в реализациях одноранговых узлов является лучшей стратегией, чем создание исключений при каждом попытке одноранговой попытки. Также следует учесть, что большинство клиентов автоматизации пользовательского интерфейса не написаны в управляемом коде. Большинство из них написано на языке COM и только проверяет наличие **\_ОК** в **HRESULT** каждый раз, когда они вызывают КЛИЕНТСКИЙ метод автоматизации пользовательского интерфейса, который заканчивает доступ к вашему одноранговому узлу.

<span id="related_topics"/>

## <a name="related-topics"></a>Связанные разделы  
* [Режима](accessibility.md)
* [Пример специальных возможностей XAML](https://go.microsoft.com/fwlink/p/?linkid=238570)
* [**фрамеворкелементаутоматионпир**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer)
* [**AutomationPeer**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.Peers.AutomationPeer)
* [**OnCreateAutomationPeer**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.oncreateautomationpeer)
* [Шаблоны элементов управления и интерфейсы](control-patterns-and-interfaces.md)
