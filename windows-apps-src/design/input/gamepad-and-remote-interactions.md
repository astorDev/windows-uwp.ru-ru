---
Description: Оптимизируйте свое приложение для ввода с игровой планшета Xbox и удаленного управления.
title: Взаимодействие с помощью геймпада и пульта дистанционного управления
ms.assetid: 784a08dc-2736-4bd3-bea0-08da16b1bd47
label: Gamepad and remote interactions
template: detail.hbs
isNew: true
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 440f758e5db8bd77d3f26290eb59d7684e5f87a3
ms.sourcegitcommit: 789bfe3756c5c47f7324b96f482af636d12c0ed3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/09/2019
ms.locfileid: "68867649"
---
# <a name="gamepad-and-remote-control-interactions"></a>Взаимодействие с помощью геймпада и пульта дистанционного управления

![изображение клавиатуры и геймпада](images/keyboard/keyboard-gamepad.jpg)

***Многие взаимодействия между планшетом, удаленным управлением и клавиатурой являются общими.***

Взаимодействие между сборками в приложениях универсальная платформа Windows (UWP), которые гарантируют использование и доступность приложения с помощью традиционных типов входных компьютеров, ноутбуков и планшетов (мыши, клавиатуры, сенсорного экрана и т. д.), а также входных типов типичные возможности ТВ и Xbox *10* , такие как игровой планшет и пульт дистанционного управления.

Общие рекомендации по проектированию приложений UWP в *10-футовом* интерфейсе см. в статье [Разработка для Xbox и телепередач](../devices/designing-for-tv.md) .

## <a name="overview"></a>Обзор

В этом разделе мы обсудим, что следует учитывать при проектировании взаимодействия (или что вы не можете делать, если платформа выглядит после этого), а также предоставляет рекомендации, рекомендации и предложения по созданию приложений UWP, которые лучше использовать независимо от устройство, тип ввода или возможности и предпочтения пользователей.

В конце концов, ваше приложение должно быть интуитивно понятным и простым в использовании в *2-футовом* окружении, так как оно находится в *10-футовой* среде (и наоборот). Поддержка предпочтительных устройств пользователя, обеспечение фокуса пользовательского интерфейса на очистку и унмистакабле, упорядочение содержимого для обеспечения единообразия и прогнозирования, а также предоставление пользователям кратчайшего пути, который нужно сделать.

> [!NOTE]
> Большинство фрагментов кода в этом разделе написаны на XAML/C#, но принципы и концепции применимы ко всем приложениям UWP. Если вы разрабатываете приложение UWP на HTML/JavaScript для Xbox, ознакомьтесь с великолепной библиотекой [TVHelpers](https://github.com/Microsoft/TVHelpers/wiki) на GitHub.


## <a name="optimize-for-both-2-foot-and-10-foot-experiences"></a>Оптимизация для двух и более нижних и 10-футовых возможностей

Как минимум, рекомендуется протестировать приложения, чтобы убедиться в том, что они хорошо работают как в 2-футовом, так и в 10-футовом сценариях, и что все функции доступны для обнаружения и доступа к игровому планшету Xbox [и удаленному управлению](#gamepad-and-remote-control).

Ниже приведены другие способы оптимизации приложения для использования в двух-и 10-футовых режимах, а также все устройства ввода (каждая ссылка на соответствующий раздел в этой статье).

> [!NOTE]
> Так как игровые планшеты и пульт дистанционного управления Xbox поддерживают множество поведений и возможностей клавиатуры UWP, эти рекомендации подходят для обоих типов ввода. Более подробные сведения о клавиатуре см. в разделе [взаимодействие](keyboard-interactions.md) с клавиатурой.

| Компонент        | Описание           |
| -------------------------------------------------------------- |--------------------------------|
| [Навигация по фокусу и взаимодействие с КООРДИНАТами](#xy-focus-navigation-and-interaction) | **Точечная Навигация** по фокусу позволяет пользователю перемещаться по пользовательскому интерфейсу приложения. Однако это позволяет пользователю перемещаться только вверх, вниз, влево или вправо. Рекомендации по выполнению этих и других требований приведены в этом разделе. |
| [Режим мыши](#mouse-mode)|Навигация по фокусу на XY не является практичной или даже возможной для некоторых типов приложений, таких как карты или приложения рисования и рисования. В таких случаях **режим мыши** позволяет пользователям свободно перемещаться по планшету или пульту дистанционного управления, как и мышь на ПК.|
| [Визуальный элемент фокусировки](#focus-visual)  | Визуальный элемент фокуса — это граница, которая выделяет текущий фокус в элементе пользовательского интерфейса. Это помогает пользователю быстро выявить пользовательский интерфейс, с которым осуществляется переход или взаимодействие.  |
| [Участие в фокусе](#focus-engagement) | Для взаимодействия с фокусом пользователь должен нажать кнопку **A/выбрать** на планшете или пульте дистанционного управления, если элемент пользовательского интерфейса имеет фокус, чтобы взаимодействовать с ним. |
| [Аппаратные кнопки](#hardware-buttons) | Игровой планшет и пульт дистанционного управления предоставляют очень разные кнопки и конфигурации. |

## <a name="gamepad-and-remote-control"></a>Геймпад и пульт дистанционного управления

Так же, как клавиатура и мышь на компьютере и сенсорный экран на телефоне и планшете, геймпад и пульт ДУ являются основными устройствами ввода при взаимодействии на большом расстоянии.
В этом разделе описаны аппаратные кнопки и их предназначение.
В разделах [Перемещение фокуса по оси X и Y и взаимодействие](#xy-focus-navigation-and-interaction) и [Режим мыши](#mouse-mode) вы узнаете, как оптимизировать приложение для использования этих устройств ввода.

Качество работы геймпадов и пультов ДУ по умолчанию зависит от того, насколько хорошо ваше приложение поддерживает клавиатуру. Хороший способ реализовать оптимальную поддержку геймпада / пульта ДУ в приложении — обеспечить поддержку клавиатуры на ПК, а затем протестировать его с геймпадом и пультом ДУ и выявить слабые места пользовательского интерфейса.

### <a name="hardware-buttons"></a>Аппаратные кнопки

В этом документе будут использоваться имена кнопок, указанные на следующей схеме.

![Схема расположения кнопок на геймпаде и пульте ДУ](images/designing-for-tv/hardware-buttons-gamepad-remote.png)

Как видно на схеме, имеется ряд кнопок, которые поддерживаются на геймпаде и не поддерживаются на пульте ДУ и наоборот. Хотя для ускорения навигации и можно использовать кнопки, которые поддерживаются только одним устройством ввода, следует помнить, что их использование в критически важных случаях может привести к тому, что пользователь не сможет получить доступ к определенным частям пользовательского интерфейса.

В следующей таблице перечислены все аппаратные кнопки, поддерживаемые приложениями UWP, с указанием соответствующего устройства ввода.

| Кнопка                    | Геймпад   | Пульт ДУ    |
|---------------------------|-----------|-------------------|
| Кнопка A / выбор           | Да       | Да               |
| Кнопка B / назад             | Да       | Да               |
| Крестовина   | Да       | Да               |
| Кнопка меню               | Да       | Да               |
| Кнопка просмотра               | Да       | Да               |
| Кнопки X и Y           | Да       | Нет                |
| Левый джойстик                | Да       | Нет                |
| Правой джойстик               | Да       | Нет                |
| Левый и правый триггеры   | Да       | Нет                |
| Левый и правый бамперы    | Да       | Нет                |
| Кнопка OneGuide           | Нет        | Да               |
| Кнопка громкости             | Нет        | Да               |
| Кнопка канала            | Нет        | Да               |
| Кнопки управления мультимедиа     | Нет        | Да               |
| Кнопка выключения звука               | Нет        | Да               |

### <a name="built-in-button-support"></a>Встроенная поддержка кнопок

UWP автоматически сопоставляет существующее поведение при вводе с помощью клавиатуры с вводом с помощью геймпада и пульта ДУ. В следующей таблице представлены эти встроенные сопоставления.

| Клавиатура              | Геймпад / пульт ДУ                        |
|-----------------------|---------------------------------------|
| Клавиши со стрелками            | Крестовина (также левый джойстик на геймпаде)    |
| ПРОБЕЛ              | Кнопка A / выбор                       |
| ВВОД                 | Кнопка A / выбор                       |
| ESCAPE                | Кнопка B / назад*                        |

\*Если ни события [KeyDown](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.keydown) , ни [KeyUp](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.keyup) для кнопки B не обрабатываются приложением, будет вызвано событие [системнавигатионманажер. unrequest](https://docs.microsoft.com/uwp/api/windows.ui.core.systemnavigationmanager.backrequested) , которое должно привести к переходу в пределах приложения. Однако это необходимо реализовывать самостоятельно, как показано в следующем фрагменте кода.

```csharp
// This code goes in the MainPage class

public MainPage()
{
    this.InitializeComponent();

    // Handling Page Back navigation behaviors
    SystemNavigationManager.GetForCurrentView().BackRequested +=
        SystemNavigationManager_BackRequested;
}

private void SystemNavigationManager_BackRequested(
    object sender,
    BackRequestedEventArgs e)
{
    if (!e.Handled)
    {
        e.Handled = this.BackRequested();
    }
}

public Frame AppFrame { get { return this.Frame; } }

private bool BackRequested()
{
    // Get a hold of the current frame so that we can inspect the app back stack
    if (this.AppFrame == null)
        return false;

    // Check to see if this is the top-most page on the app back stack
    if (this.AppFrame.CanGoBack)
    {
        // If not, set the event to handled and go back to the previous page in the
        // app.
        this.AppFrame.GoBack();
        return true;
    }
    return false;
}
```

> [!NOTE]
> Если кнопка для возврата используется кнопка B, кнопку "Назад" в пользовательском интерфейсе отображать не следует. При использовании [представления навигации](../controls-and-patterns/navigationview.md) кнопка "Назад" скрывается автоматически. Дополнительные сведения о навигации в обратном направлении см. в разделе [Журнал навигации и навигация в обратном направлении для приложений UWP](../basics/navigation-history-and-backwards-navigation.md).

Кроме того, контекстные меню в приложениях UWP на Xbox One можно открывать нажатием кнопки **Меню**. Дополнительные сведения см. в разделе [CommandBar и ContextFlyout](#commandbar-and-contextflyout).

### <a name="accelerator-support"></a>Поддержка горячих клавиш

Горячие клавиши — это те кнопки, которые можно использовать для повышения скорости навигации по пользовательскому интерфейсу. Однако эти кнопки могут быть уникальными для того или иного устройства ввода, поэтому следует помнить, что не все пользователи смогут воспользоваться этими функциями. Фактически геймпад в настоящее время является единственным устройством ввода, которое поддерживает функции ускорения для приложений UWP на устройстве Xbox One.

В следующей таблице указаны встроенные в UWP функции поддержки горячих клавиш, а также возможности, которые вы можете реализовать самостоятельно. Используйте эти возможности в своем пользовательском интерфейсе для обеспечения согласованной и удобной работы пользователей.

| Тип взаимодействия   | Клавиатура и мышь   | Геймпад      | Встроенная функция для  | Рекомендуется для |
|---------------|------------|--------------|----------------|------------------|
| Страница вверх/вниз  | Страница вверх/вниз | Левый и правый триггеры | [CalendarView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.CalendarView), [ListBox](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ListBox), [ListViewBase](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ListViewBase), [ListView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ListView), `ScrollViewer`, [Selector](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Primitives.Selector), [LoopingSelector](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Primitives.LoopingSelector), [ComboBox](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ComboBox), [FlipView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.FlipView) | Представления, поддерживающие вертикальную прокрутку
| Страница влево/вправо | Нет | Левый и правый бамперы | [Pivot](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Pivot), [ListBox](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ListBox), [ListViewBase](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ListViewBase), [ListView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ListView), `ScrollViewer`, [Selector](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Primitives.Selector), [LoopingSelector](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Primitives.LoopingSelector), [FlipView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.FlipView) | Представления, поддерживающие горизонтальную прокрутку
| Увеличение/уменьшение масштаба        | Ctrl +/- | Левый и правый триггеры | Нет | `ScrollViewer`, представления, поддерживающие отображение и уменьшение |
| Открыть/закрыть панель навигации | Нет | Просмотр | Нет | Панели навигации |
| Поиск | Нет | Кнопка Y | Нет | Ярлык для функции основного поиска в приложении |
| [Открыть контекстное меню](#commandbar-and-contextflyout) | Щелкните правой кнопкой мыши | Кнопка меню | [контекстфлйоут](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.UIElement.ContextFlyout) | Контекстные меню |

## <a name="xy-focus-navigation-and-interaction"></a>Перемещение фокуса по осям X и Y и взаимодействие

Если ваше приложение поддерживает корректное перемещение фокуса с помощью клавиатуры, оно будет поддерживать геймпад и пульт ДУ.
Навигация с помощью клавиш со стрелками соответствует использованию **крестовины** (в том числе **левого мини-джойстика** на геймпаде), а взаимодействие с элементами управления пользовательского интерфейса — использованию клавиши **Ввод/Выбор** (см. раздел [Геймпад и пульт ДУ](#gamepad-and-remote-control))

Многие события и свойства используются как клавиатурой, так и геймпадом &mdash; оба устройства применяются для запуска событий `KeyDown` и `KeyUp`. Также оба устройства применяются для перехода только к тем элементам управления, которые обладают свойствами `IsTabStop="True"` и `Visibility="Visible"`. Руководство по проектированию управления с помощью клавиатуры см. в разделе [Взаимодействие с клавиатурой](../input/keyboard-interactions.md).

Если поддержка клавиатуры реализована надлежащим образом, ваше приложение будет работать достаточно стабильно. Однако может понадобиться выполнить ряд дополнительных задач для поддержки всех сценариев. Подумайте об особых требованиях своего приложения, чтобы обеспечить максимально удобную работу пользователя.

> [!IMPORTANT]
> Для приложений UWP, запускаемых на Xbox One, режим мыши включен по умолчанию. Чтобы отключить режим мыши и включить перемещение фокуса по оси X и Y, задайте параметр `Application.RequiresPointerMode=WhenRequested`.

### <a name="debugging-focus-issues"></a>Отладка проблем с фокусировкой

Вызвав метод [FocusManager.GetFocusedElement](https://docs.microsoft.com/uwp/api/windows.ui.xaml.input.focusmanager.getfocusedelement), можно узнать, какой элемент в настоящий момент находится в фокусе. Этот метод полезно использовать, когда местоположение визуального элемента фокуса является неочевидным. Эти сведения можно регистрировать в окне вывода Visual Studio следующим образом:

```csharp
page.GotFocus += (object sender, RoutedEventArgs e) =>
{
    FrameworkElement focus = FocusManager.GetFocusedElement() as FrameworkElement;
    if (focus != null)
    {
        Debug.WriteLine("got focus: " + focus.Name + " (" +
            focus.GetType().ToString() + ")");
    }
};
```

Есть три распространенных причины некорректной работы перемещения фокуса по оси X и Y.

* Неправильно задано свойство [IsTabStop](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.istabstop) или [Visibility](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.visibility).
* Фактический размер элемента управления с фокусом больше, чем вы думаете &mdash; перемещение фокуса по оси X и Y проверяет общий размер элемента управления (свойства [ActualWidth](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.actualwidth) и [ActualHeight](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.actualheight)), а не его часть, на которой отображается нечто заслуживающее внимания.
* Один фокусируемый элемент управления расположен поверх другого &mdash; перемещение фокуса по оси X и Y не поддерживает перекрывающиеся элементы управления.

Если перемещение фокуса по оси X и Y не стало работать ожидаемым образом после устранения этих проблем, можно вручную указать элемент для фокусировки путем вызова метода, описанного в разделе [Переопределение навигации по умолчанию](#overriding-the-default-navigation).

Если перемещение фокуса по оси X и Y работает правильно, но визуальный элемент фокуса не отображается, причиной этого может быть одна из следующих проблем.

* Шаблон элемента управления был изменен и в него не был добавлен визуальный элемент фокуса. Установите значение `UseSystemFocusVisuals="True"` или добавьте визуальный элемент фокуса вручную.
* Фокус был смещен путем вызова `Focus(FocusState.Pointer)`. Параметр [FocusState](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.FocusState) управляет тем, как изменяется визуальный элемент фокуса. Как правило, этому параметру следует задавать значение `FocusState.Programmatic`, что позволит отображаться визуальному элементу фокуса, если он отображался ранее, и оставаться скрытым, если он был до этого скрыт.

В оставшейся части этого раздела содержится описание распространенных проблем проектирования при использовании перемещения фокуса по оси X и Y, а также приведены некоторые способы их устранения.

### <a name="inaccessible-ui"></a>Недоступный пользовательский интерфейс

Поскольку перемещение фокуса по оси X и Y ограничивает пользователя направлениями "Вверх", "Вниз", "Влево" и "Вправо", могут возникнуть случаи, когда части пользовательского интерфейса останутся недоступными.
На следующей схеме приведен пример компоновки пользовательского интерфейса, не поддерживающей перемещения фокуса по оси X и Y.
Обратите внимание, что элемент посередине не доступен при использовании геймпада / пульта ДУ, так как приоритетной является вертикальная и горизонтальная навигация. Средний элемент никогда не получит достаточно высокого приоритета для получения фокуса.

![Элементы в четырех углах и недоступный элемент посередине](images/designing-for-tv/2d-navigation-best-practices-ui-layout-to-avoid.png)

Если по какой-либо причине изменение пользовательского интерфейса невозможно, воспользуйтесь одним из методов, которые обсуждаются в следующем разделе, чтобы переопределить поведение фокуса по умолчанию.

### <a name="overriding-the-default-navigation"></a>Переопределение навигации по умолчанию

Хотя универсальная платформа Windows стремится обеспечить удобство навигации пользователя с помощью крестовины / левого джойстика, невозможно гарантировать поведение, которое было бы оптимизировано под цели вашего приложения.
Лучшим способом оптимизации навигации в приложении является его тестирование с использованием геймпада и проверка доступности каждого элемента пользовательского интерфейса с учетом различных сценариев использования приложения. Если в приложении необходимо реализовать поведение, которого невозможно добиться с помощью имеющихся возможностей перемещения фокуса по оси X и Y, ознакомьтесь с приведенными в следующем разделе рекомендациями, чтобы переопределить поведение и иметь возможность размещать фокус на логическом элементе.

В следующем фрагменте кода показано, как переопределить поведение при перемещении фокуса по оси X и Y по умолчанию.

```xml
<StackPanel>
    <Button x:Name="MyBtnLeft"
            Content="Search" />
    <Button x:Name="MyBtnRight"
            Content="Delete"/>
    <Button x:Name="MyBtnTop"
            Content="Update" />
    <Button x:Name="MyBtnDown"
            Content="Undo" />
    <Button Content="Home"  
            XYFocusLeft="{x:Bind MyBtnLeft}"
            XYFocusRight="{x:Bind MyBtnRight}"
            XYFocusDown="{x:Bind MyBtnDown}"
            XYFocusUp="{x:Bind MyBtnTop}" />
</StackPanel>
```

В этом случае при переходе фокуса к кнопке `Home` и навигации пользователя влево, фокус перемещается к кнопке `MyBtnLeft`. Если пользователь переходит вправо, фокус перемещается к кнопке `MyBtnRight` и т. д.

Чтобы не допустить перемещения фокуса от элемента управления в определенном направлении, используйте свойство `XYFocus*` для указания на тот же самый элемент управления.

```xml
<Button Name="HomeButton"  
        Content="Home"  
        XYFocusLeft ="{x:Bind HomeButton}" />
```

С помощью свойств `XYFocus` родительский элемент управления может обеспечить принудительную навигацию дочерних элементов, когда следующий кандидат на получение фокуса оказывается за пределами его визуального дерева, если дочерний элемент, находящийся в фокусе, не использует то же самое свойство `XYFocus`.

```xml
<StackPanel Orientation="Horizontal" Margin="300,300">
    <UserControl XYFocusRight="{x:Bind ButtonThree}">
        <StackPanel>
            <Button Content="One"/>
            <Button Content="Two"/>
        </StackPanel>
    </UserControl>
    <StackPanel>
        <Button x:Name="ButtonThree" Content="Three"/>
        <Button Content="Four"/>
    </StackPanel>
</StackPanel>
```

Если в примере выше фокус получает `Button` 2 и пользователь переходит вправо, следующим кандидатом на получение фокуса становится `Button` 4. Однако фокус перемещается на `Button` 3, поскольку родительский элемент `UserControl` обеспечивает его принудительный переход при выходе за пределы визуального дерева.

### <a name="path-of-least-clicks"></a>Путь с наименьшим количеством нажатий

Попробуйте свести к минимуму количество нажатий, необходимое для выполнения наиболее распространенных задач. В следующем примере [TextBlock](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.TextBlock) располагается между кнопкой **воспроизведения** (которая изначально имеет фокус) и часто используемым элементом, так что между приоритетными задачами размещается лишний элемент.

![Рекомендации по обеспечению пути навигации с наименьшим количеством нажатий](images/designing-for-tv/2d-navigation-best-practices-provide-path-with-least-clicks.png)

В следующем примере [TextBlock](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.TextBlock) расположен над кнопкой **воспроизведения**.
Простая реорганизация пользовательского интерфейса, при которой ненужные элементы не размещаются между приоритетными задачами, значительно повысит удобство использования приложения.

![TextBlock находится над кнопкой воспроизведения и больше не располагается между приоритетными задачами](images/designing-for-tv/2d-navigation-best-practices-provide-path-with-least-clicks-2.png)

### <a name="commandbar-and-contextflyout"></a>CommandBar и ContextFlyout

При использовании панели [команд](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.CommandBar)помните о проблеме прокрутки списка, как упоминалось в [проблеме. Элементы пользовательского интерфейса, расположенные после длинного списка](#problem-ui-elements-located-after-long-scrolling-list-grid)или сетки с прокруткой. На следующем рисунке показан макет пользовательского интерфейса с `CommandBar` под списком/сеткой. Пользователю нужно полностью прокрутить список/сетку, чтобы достичь `CommandBar`.

![CommandBar под списком/сеткой](images/designing-for-tv/2d-navigation-best-practices-commandbar-and-contextflyout.png)

Что делать, `CommandBar` если вы поместили приведенный *выше* список или сетку? Хотя пользователю, который прокрутил список/сетку, понадобится прокрутить их обратно, чтобы достичь `CommandBar`, это потребует меньше усилий, чем в случае предыдущей конфигурации. Обратите внимание: предполагается, что исходный фокус приложения помещается рядом или над `CommandBar`. Этот подход не будет столь же удобен, если исходный фокус располагается под списком/сеткой. Если эти элементы `CommandBar` являются глобальными элементами действия, которые не нужно использовать слишком часто (например, кнопка **Синхронизировать**), их можно разместить над списком/сеткой.

Несмотря на то, что элементы `CommandBar` невозможно расположить вертикально, их размещение вдоль направления прокрутки (например, слева или справа от вертикально прокручиваемого списка или сверху или снизу от горизонтально прокручиваемого списка) является еще одним вариантом компоновки пользовательского интерфейса, который можно применять.

Если ваше приложение содержит объект `CommandBar`, элементы которого должны быть доступны пользователям, возможно, их стоит разместить внутри [ContextFlyout](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.contextflyout) и удалить их из `CommandBar`. `ContextFlyout`является свойством [UIElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.UIElement) и является контекстным [меню](../controls-and-patterns/dialogs-and-flyouts/index.md) , связанным с этим элементом. При работе на компьютере щелчком правой кнопкой мыши на элементе со свойством `ContextFlyout` выводится соответствующее ему контекстное меню. При работе на Xbox One это происходит при нажатии кнопки **Меню**, когда фокус находится на таком элементе.

### <a name="ui-layout-challenges"></a>Проблемы компоновки пользовательского интерфейса

Использовать некоторые макеты пользовательского интерфейса сложнее вследствие особенностей перемещения фокуса по оси X и Y, поэтому их применение следует оценивать в зависимости от ситуации. Несмотря на отсутствие единственного правильного способа, решение зависит от вас и особых нужд вашего приложения. Однако существует ряд методов, которые можно использовать для упрощения работы с телевизором.

Чтобы лучше понять эти методы, рассмотрим вымышленное приложение, которое продемонстрирует ряд проблем и методов их решения.

> [!NOTE]
> Это вымышленное приложение служит для демонстрации проблем, связанных с пользовательским интерфейсом, и возможных способов их решения и не предназначено для демонстрации возможностей упрощения работы пользователей в каком-либо приложении.

Ниже приведено вымышленное приложение для покупки недвижимости, которое показывает список доступных для продажи домов с картой, описанием объекта и прочими данными. В этом приложении имеется три проблемы, которые можно устранить с помощью следующих методов:

- [Изменение пользовательского интерфейса](#ui-rearrange)
- [Участие в фокусе](#engagement)
- [Режим мыши](#mouse-mode)

![Вымышленное приложение для покупки недвижимости](images/designing-for-tv/2d-focus-navigation-and-interaction-real-estate-app.png)

#### Проблема. Элементы пользовательского интерфейса, расположенные после длинного списка или сетки с прокруткой<a name="problem-ui-elements-located-after-long-scrolling-list-grid"></a>

Объект [ListView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ListView), приведенный на следующем рисунке, является очень длинным списком прокрутки. Если [включение](#focus-engagement)*не* является обязательным для `ListView`, то при переходе пользователя к списку фокус переводится на первый элемент списка. Чтобы пользователь перешел к кнопке **Назад** или **Далее**, ему необходимо перебрать все элементы в списке. В таких случаях, когда пользователю необходимо перебирать все элементы списка (список недостаточно короткий) и когда пользовательский интерфейс становится неудобным, возможно, следует использовать другие варианты.

![Приложение для покупки недвижимости: чтобы добраться до кнопок под списком из 50 элементов, необходимо 51 нажатие](images/designing-for-tv/2d-focus-navigation-and-interaction-real-estate-app-list.png)

#### <a name="solutions"></a>Решения

**Изменение пользовательского интерфейса<a name="ui-rearrange"></a>**

Если исходный фокус не находится в нижней части страницы, элементы пользовательского интерфейса, размещенные над длинным списком прокрутки, станут более доступны, если поместить их под списком.
Если новый макет подходит для других устройств, изменение компоновки для всех семейств устройств вместо внесения специальных изменений в пользовательский интерфейс только для Xbox One может стать менее затратным решением.
Кроме того, размещение элементов пользовательского интерфейса поперек направления прокрутки (то есть горизонтально относительно вертикального списка прокрутки или вертикально относительно горизонтального списка прокрутки) обеспечит более удобный к ним доступ.

![Приложение для покупки недвижимости: размещение кнопок над длинным списком прокрутки](images/designing-for-tv/2d-focus-navigation-and-interaction-ui-rearrange.png)

**Участие в фокусе<a name="engagement"></a>**

Если включение является *обязательным*, весь при фокусировке выделяется весь объект `ListView`. Пользователь сможет перейти к следующему доступному для фокусировки элементу, не переходя к содержимому списка. Дополнительные сведения о том, какие элементы управления поддерживают включение и как их использовать см. в разделе [Включение фокуса](#focus-engagement).

![Приложение для покупки недвижимости: обязательное включение, позволяющее перейти к кнопкам "Назад"/"Далее" с помощью одного нажатия](images/designing-for-tv/2d-focus-navigation-and-interaction-engagement.png)

#### <a name="problem-scrollviewer-without-any-focusable-elements"></a>Проблема. ScrollViewer без элементов с фокусом ввода

Поскольку перемещение фокуса по оси X и Y основано на переходе к одному доступному для фокусировки элементу за раз, объект [ScrollViewer](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ScrollViewer), который не содержит каких-либо доступных элементов (например, объект только с текстом, как в этом примере), может привести к тому, что пользователь не сможет просмотреть все содержимое `ScrollViewer`.
Решения для этого и других похожих сценариев приведены в разделе [Включение фокуса](#focus-engagement).

![Приложение для недвижимости: ScrollViewer только с текстом](images/designing-for-tv/2d-focus-navigation-and-interaction-scrollviewer.png)

#### <a name="problem-free-scrolling-ui"></a>Проблема. Пользовательский интерфейс для прокрутки

Если приложение требует свободной прокрутки пользовательского интерфейса, например в случае поверхности рисования или, как в этом примере, карты, перемещение фокуса по оси X и Y попросту не работает.
В этих случаях можно включить [режим мыши](#mouse-mode), чтобы разрешить пользователю свободно перемещаться внутри элемента пользовательского интерфейса.

![Сопоставление элемента пользовательского интерфейса с использованием режима мыши](images/designing-for-tv/map-mouse-mode.png)

## <a name="mouse-mode"></a>Режим мыши

Как описано в разделе [Перемещение фокуса по оси X и Y и взаимодействие](#xy-focus-navigation-and-interaction), на Xbox One фокус перемещается по оси X и Y, позволяя пользователю переходить от одного элемента управления к другому в обоих направлениях по вертикали и горизонтали.
Однако некоторые элементы управления, такие как [WebView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.WebView) и [MapControl](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Maps.MapControl), требуют взаимодействия, аналогичного работе с мышью, когда пользователи могут свободно перемещать указатель внутри границ элемента управления.
Имеются также приложения, в которых пользователю было бы разумно иметь возможность перемещать указатель по всей странице с помощью геймпада / пульта ДУ, как при работе с мышью на ПК.

В этих сценариях следует обеспечить работу указателя (режим мыши) на всей странице или в границах элемента управления.
Например, ваше приложение может содержать страницу с элементом управления `WebView`, который использует режим мыши только внутри этого элемента и перемещение фокуса по оси X и Y во всех остальных областях экрана.
Чтобы запросить указатель, следует определить, когда его требуется использовать: **при взаимодействии с элементом управления или страницей** либо **при перемещении фокуса на страницу**.

> [!NOTE]
> Запрос указателя при получении элементом управления фокуса не поддерживается.

При выполнении приложений XAML и размещенных веб-приложений на Xbox One режим мыши включается по умолчанию для всего приложения. Настоятельно рекомендуется отключать режим мыши и оптимизировать приложение для работы с перемещением фокуса по оси X и Y. Для этого свойству `Application.RequiresPointerMode` необходимо задать значение `WhenRequested`, чтобы режим мыши активировался только при его вызове элементом управления или страницей.

Чтобы реализовать это в приложении XAML, используйте в классе `App` следующий фрагмент кода.

```csharp
public App()
{
    this.InitializeComponent();
    this.RequiresPointerMode =
        Windows.UI.Xaml.ApplicationRequiresPointerMode.WhenRequested;
    this.Suspending += OnSuspending;
}
```

Дополнительные сведения, в том числе пример кода для HTML/JavaScript, см. в разделе [Отключение режима мыши](../../xbox-apps/how-to-disable-mouse-mode.md).

На следующей схеме показаны сопоставления кнопок для геймпада/пульта ДУ в режиме мыши.

![Сопоставления кнопок для геймпада/пульта ДУ в режиме мыши](images/designing-for-tv/10ft_infographics_mouse-mode.png)

> [!NOTE]
> Режим мыши поддерживается только на консоли Xbox One с геймпадом/пультом ДУ. В случае других семейств устройств и типов ввода он игнорируется без отображения каких-либо сообщений.

Используйте свойство [RequiresPointer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.requirespointer) , чтобы включить режим мыши для элемента управления или страницы. Это свойство поддерживает три значения: `Never` (значение по умолчанию), `WhenEngaged` и `WhenFocused`.

### <a name="activating-mouse-mode-on-a-control"></a>Активация режима мыши для элемента управления

Если пользователь взаимодействует с элементом управления с помощью `RequiresPointer="WhenEngaged"`, режим мыши остается активным на протяжении периода взаимодействия. В следующем фрагменте кода показан простой объект `MapControl`, который активирует режим мыши при начале взаимодействия.

```xml
<Page>
    <Grid>
        <MapControl IsEngagementRequired="true"
                    RequiresPointer="WhenEngaged"/>
    </Grid>
</Page>
```

> [!NOTE]
> Если элемент управления активирует режим мыши при начале взаимодействия, он также должен требовать выполнения условия `IsEngagementRequired="true"`. В противном случае режим мыши активирован не будет.

Если элемент управления работает в режиме мыши, вложенные элементы управления также будут работать в режиме мыши. Запрошенный режим дочерних объектов будет игнорироваться&mdash;так как ситуация, когда родительский объект находится в режиме мыши, а дочерние объекты работают в другом режиме, невозможна.

Кроме того, запрошенный режим элемента управления проверяется только при получении фокуса, поэтому если элемент уже имеет фокус, режим не меняется динамически.

### <a name="activating-mouse-mode-on-a-page"></a>Активация режима мыши на странице

Если на странице имеется свойство `RequiresPointer="WhenFocused"`, режим мыши будет активирован для всей страницы при получении ею фокуса. В следующем фрагменте кода показано предоставление странице этого свойства.

```xml
<Page RequiresPointer="WhenFocused">
    ...
</Page>
```

> [!NOTE]
> Значение `WhenFocused` поддерживается только для объектов [Page](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Page). Если попытаться задать это значение для элемента управления, возникнет исключение.

### <a name="disabling-mouse-mode-for-full-screen-content"></a>Отключение режима мыши для полноэкранного содержимого

Обычно при отображении видео или других типов содержимого в полноэкранном режиме следует скрыть курсор, потому что он может отвлекать пользователя. Этот сценарий применяется, когда приложение использует режим мыши в остальных случаях, но когда необходимо скрыть указатель при отображении полноэкранного содержимого. Для этого полноэкранное содержимое нужно поместить на собственную страницу `Page` и выполнить следующие действия.

1. В объекте `App` установите параметр `RequiresPointerMode="WhenRequested"`.
2. Для каждого объекта `Page`, *за исключением* объекта `Page` для полноэкранного режима, установите параметр `RequiresPointer="WhenFocused"`.
3. Для объекта `Page` для полноэкранного режима установите параметр `RequiresPointer="Never"`.

Таким образом курсор не будет отображаться при отображении полноэкранного содержимого.

## <a name="focus-visual"></a>Визуальный элемент фокуса

Визуальный элемент фокуса — это граница вокруг элемента пользовательского интерфейса, который в настоящее время находится в фокусе. Он позволяет пользователю ориентироваться и без труда перемещаться по пользовательскому интерфейсу.

Благодаря обновлению визуального элемента и различным параметрам его настройки разработчики могут быть уверены, что один и тот же визуальный элемент фокуса будет корректно работать на компьютерах и устройствах Xbox One, а также на любых других устройствах с Windows 10, которые поддерживают клавиатуру и геймпад / пульт ДУ.

Хотя один и тот же визуальный элемент фокуса можно использовать на различных платформах, контекст его использования при просмотре на большом расстоянии несколько отличается. Предполагается, что пользователь не уделяет особого внимания всей площади экрана телевизора, поэтому важно, что текущий выделенный элемент всегда был отчетливо виден. Это позволит избавить пользователя от долгих поисков элемента.

Важно помнить, что визуальный элемент фокуса по умолчанию отображается при использовании геймпада или пульта ДУ, но *не* клавиатуры. Поэтому даже если вы не реализовали его, он будет отображаться при запуске приложения на Xbox One.

### <a name="initial-focus-visual-placement"></a>Исходное положение визуального элемента фокуса

При запуске приложения или перехода к странице поместите фокус на элементе пользовательского интерфейса, который воспринимается как первый элемент, с которым пользователь может выполнить какие-либо действия. Например, в приложении для обработки фотографий фокус можно поместить на первом элементе галереи, а при переходе к подробному представлению композиции в музыкальном приложении — на кнопке воспроизведения. Это позволит упростить воспроизведение музыки.

Попробуйте разместить исходный фокус в левом верхнем углу приложения (или в правом верхнем углу при направлении движения справа налево). Большинство пользователей смотрят сначала в этот угол, так как именно отсюда начинается перемещение по содержимому приложения.

### <a name="making-focus-clearly-visible"></a>Четкое выделение фокуса

Визуальный элемент фокуса всегда должен быть виден на экране, чтобы пользователь без лишних поисков мог продолжить работу с того места, на котором он остановился. Аналогичным образом, элемент, отображаемый на экране, всегда должен быть доступен для фокусировки &mdash; поэтому, например, не следует использовать всплывающие окна, содержащие только текст и не содержащие элементов, которым можно передать фокус.

Исключением из этого правила является взаимодействие пользователя с интерфейсом в полноэкранном режиме, например просмотр видеозаписей или изображений, когда отображение визуального элемента фокуса является неуместным.

### <a name="reveal-focus"></a>Фокус отображения

Фокус отображения — это световой эффект, анимирующий границу элементов (таких как кнопки) для фокусировки, когда пользователь наводит на них фокус с геймпада или клавиатуры. Путем анимированного свечения вокруг границы элементов в фокусе, фокус отображения позволяет пользователям лучше понять, где находится фокус и куда он переходит.

Фокус отображения по умолчанию выключен. Для больших экранов следует включить фокус отображения, задав [свойство Application.FocusVisualKind](https://docs.microsoft.com/uwp/api/windows.ui.xaml.application.FocusVisualKind) в конструкторе приложений.

```csharp
    if(AnalyticsInfo.VersionInfo.DeviceFamily == "Windows.Xbox")
    {
        this.FocusVisualKind = FocusVisualKind.Reveal;
    }
```

Подробнее см. в руководстве по [фокусу отображения](/windows/uwp/design/style/reveal-focus).

### <a name="customizing-the-focus-visual"></a>Настройка визуального элемента фокуса

Если требуется настроить визуальный элемент фокуса, это можно сделать путем изменения свойств, связанных с визуальным элементом фокуса каждого элемента управления. Есть несколько подобных свойств, которые можно использовать для персонализации приложения.

Вы даже можете отказаться от использования системных визуальных элементов фокуса, нарисовав собственные, используя для этого визуальные состояния. Дополнительные сведения см. в разделе [VisualState](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.VisualState).

### <a name="light-dismiss-overlay"></a>Наложение с исчезновением

Чтобы привлечь внимание пользователя к элементам интерфейса, с которыми он работает в настоящее время, используя игровой контроллер или пульт ДУ, при запуске приложения на Xbox One платформа UWP автоматически добавляет "дымку", закрывающую области вне интерфейса всплывающего окна. Для этого не требуется какой-либо дополнительной работы, однако об этом стоит помнить при проектировании пользовательского интерфейса. Чтобы включить или отключить слой дымки, можно задать свойство `LightDismissOverlayMode` для любого объекта `FlyoutBase`. Значением по умолчанию этого свойства является `Auto`. Это значит, что оно активировано на Xbox и отключено в других местах. Дополнительные сведения см. в разделе [Модальность и исчезновение](../controls-and-patterns/menus.md).

## <a name="focus-engagement"></a>Включение фокуса

Включение фокуса призвано упростить использование геймпада или пульта ДУ при взаимодействии с приложением.

> [!NOTE]
> Настройка включения фокуса не влияет на работу клавиатуры и другие устройства ввода.

Если свойство `IsFocusEngagementEnabled` в объекте [FrameworkElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.FrameworkElement) имеет значение `True`, элемент управления помечается как требующий включения фокуса. Это означает, что пользователь должен нажать кнопку **A/выбор**, чтобы включить элемент управления и начать с ним взаимодействовать. После завершения работы можно нажать кнопку **B/Назад**, чтобы отключить элемент управления и перейти к другому.

> [!NOTE]
> `IsFocusEngagementEnabled` — это новый, еще не задокументированный API.

### <a name="focus-trapping"></a>Захват фокуса

Захват фокуса происходит, когда пользователь пытается выполнить переход между элементами интерфейса приложения, но "застревает" на одном из них. При этом перемещение за пределы этого элемента затруднено или невозможно.

В следующем примере показан пользовательский интерфейс, создающий захват фокуса.

![Кнопки слева и справа от горизонтального ползунка](images/designing-for-tv/focus-engagement-focus-trapping.png)

Если пользователь хочет перейти от левой кнопки к правой, логично предположить, что для этого нужно только дважды нажать "Вправо" на крестовине или два раза передвинуть левый джойстик.
Однако если ползунок [Slider](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Slider) не требует включения, произойдет следующее: если пользователь нажмет "Вправо" в первый раз, фокус сместится на `Slider`, а повторное нажатие приведет к перемещению указателя ползунка `Slider`. Пользователь продолжит перемещать маркер вправо и не сможет достичь кнопки.

Данную проблему можно обойти двумя способами. Первый — это создание другого макета, аналогичного примеру приложения для покупки недвижимости в разделе [Перемещение фокуса по оси X и Y и взаимодействие](#xy-focus-navigation-and-interaction), где мы переместили кнопки **Назад** и **Далее** над объектом `ListView`. Размещение элементов управления вертикально, а не горизонтально, как показано на следующем изображении, позволит решить эту проблему.

![Кнопки над и под горизонтальным ползунком](images/designing-for-tv/focus-engagement-focus-trapping-2.png)

Теперь пользователь может переходить к каждому элементу управления, нажимая "Вверх" и "Вниз" на крестовине или левом джойстике. При переходе фокуса к объекту `Slider`, можно нажать "Влево" и "Вправо" для перемещения маркера `Slider` в необходимое положение.

Другой подход к решению этой проблемы — обязательное включение объекта `Slider`. Если задать значение `IsFocusEngagementEnabled="True"`, это приведет к следующему.

![Обязательное включение фокуса на ползунке, которое позволит пользователю перейти к кнопке справа](images/designing-for-tv/focus-engagement-slider.png)

Если объект `Slider` требует включения фокуса, пользователь может перейти к кнопке справа, просто нажав дважды "Вправо" на крестовине / левом джойстике. Это замечательное решение, поскольку оно не требует настройки пользовательского интерфейса и приводит к ожидаемому результату.

### <a name="items-controls"></a>Элементы управления

Помимо элемента управления [Slider](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Slider), существуют другие элементы управления, для которых может потребоваться включения фокуса, например:

- [ListBox](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ListBox)
- [ListView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ListView)
- [GridView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.GridView)
- [FlipView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.FlipView)

В отличие от элемента управления `Slider`, они не захватывают фокус. Однако если они содержат большой объем данных, эти элементы управления могут привести к проблемам, связанным с удобством использования. Ниже приведен пример элемента `ListView`, содержащего большой объем данных.

![ListView с большим объемом данных, а также кнопки, расположенные над и под ним](images/designing-for-tv/focus-engagement-list-and-grid-controls.png)

Как и в примере с элементом `Slider`, давайте попытаемся перейти от кнопки сверху к кнопке снизу, используя геймпад / пульт ДУ.
Фокус находится на верхней кнопке. Нажатие "Вниз" на крестовине или джойстике приведет к перемещению фокуса на первый элемент в `ListView` (Элемент 1).
Когда пользователь снова нажмет "Вниз", фокус перейдет к следующему элементу в списке, а не к кнопке снизу.
Чтобы перейти к кнопке, пользователь должен сначала перебрать все элементы в `ListView`.
Если `ListView` содержит большой объем данных, это может оказаться очень неудобным, что создаст у пользователя плохое впечатление о приложении.

Чтобы устранить эту проблему, установите значение свойства `IsFocusEngagementEnabled="True"` объекта `ListView`. Это позволит сделать включение элемента обязательным.
Это позволит пользователю быстро пропустить `ListView` простым нажатием кнопки "Вниз". Однако, пользователь не сможет прокрутить список или выбрать его элемент, не включив список с помощью кнопки **A/выбор** при получении им фокуса с последующим его отключением с помощью кнопки **B/назад**.

![ListView с обязательным включением](images/designing-for-tv/focus-engagement-list-and-grid-controls-2.png)

#### <a name="scrollviewer"></a>ScrollViewer

От этих элементов управления несколько отличается объект [ScrollViewer](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ScrollViewer). Он так же имеет собственные особенности, которые необходимо учитывать. Если у вас есть `ScrollViewer` с доступным для фокусировки содержимым, по умолчанию переход к `ScrollViewer` приведет к перемещению между его элементами. Как и в случае с `ListView`, необходимо перебрать все элементы `ScrollViewer`, чтобы выйти из этого элемента.

Если `ScrollViewer`*не* имеет содержимого, доступного для фокусировки &mdash; например, содержит только текст &mdash; можно установить значение `IsFocusEngagementEnabled="True"`, чтобы пользователь мог включить объект `ScrollViewer` с помощью кнопки **A/выбор**. После включения элемента пользователь может прокрутить текст с помощью **крестовины / левого джойстика** и нажать кнопку **B/назад**, чтобы отключить фокус элемента.

Другой способ — установить значение `IsTabStop="True"` для `ScrollViewer`. В результате пользователю не придется включать элемент управления &mdash; а только перевести на него фокус и прокрутить с помощью **крестовины/левого джойстика**, если `ScrollViewer` не содержит элементов, доступных для фокусировки.

### <a name="focus-engagement-defaults"></a>Значения по умолчанию для включения фокуса

Некоторые элементы управления достаточно часто захватывают фокус, поэтому настройки по умолчанию должны требовать их обязательного включения. Для других элементов управления включение фокуса не является обязательным по умолчанию, однако оно может принести определенные преимущества. В следующей таблице перечислены эти элементы управления и их поведение по умолчанию при включении фокуса.

| Элемент управления               | Включение фокуса по умолчанию  |
|-----------------------|---------------------------|
| CalendarDatePicker    | Включено                        |
| FlipView.              | Отключено                       |
| GridView;              | Отключено                       |
| ListBox               | Отключено                       |
| ListView              | Отключено                       |
| ScrollViewer          | Отключено                       |
| SemanticZoom          | Отключено                       |
| Slider                | Включено                        |

Для всех прочих элементов управления UWP условие `IsFocusEngagementEnabled="True"` не меняет их поведения или визуального отображения.

## <a name="summary"></a>Сводка

Вы можете создавать приложения UWP, оптимизированные для конкретного устройства или интерфейса, но универсальная платформа Windows также позволяет создавать приложения, которые могут использоваться на разных устройствах, как в 2-футовом, так и в 10-футовом виде, независимо от входных данных. возможность устройства или пользователя. С помощью рекомендаций, приведенных в этой статье, можно убедиться в том, что ваше приложение хорошо работает как на ТЕЛЕВИЗОРе, так и на ПК.

## <a name="related-articles"></a>Связанные статьи

- [Проектирование для Xbox и телевизора](../devices/designing-for-tv.md)
- [Руководство устройства для приложений универсальная платформа Windows (UWP)](index.md)
