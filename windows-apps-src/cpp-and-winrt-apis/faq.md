---
author: stevewhims
description: Ответы на часто возникающие вопросы о разработке и использовании API среды выполнения Windows с помощью C++/WinRT.
title: Ответы на часто задаваемые вопросы о C++/WinRT
ms.author: stwhi
ms.date: 05/07/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: Windows 10, uwp, стандартная, c ++, cpp, winrt, проекция, вопросы и ответы, вопросы и ответы
ms.localizationpriority: medium
ms.openlocfilehash: 5fe355c4ee4ee2dcc9d2e48130773e5632eb4a90
ms.sourcegitcommit: 72835733ec429a5deb6a11da4112336746e5e9cf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/20/2018
ms.locfileid: "5168425"
---
# <a name="frequently-asked-questions-about-cwinrt"></a>Ответы на часто задаваемые вопросы о C++/WinRT
Ответы на вопросы, которые вы, скорее всего имеют о разработке и использовании API среды выполнения Windows с помощью [C + +/ WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt).

> [!NOTE]
> Если ваш вопрос связан с сообщением об ошибке, которое вы увидели, см. также раздел [Устранение неполадок C++/WinRT](troubleshooting.md).

## <a name="how-do-i-retarget-my-cwinrt-project-to-a-later-version-of-the-windows-sdk"></a>Как Перенацелить C + +/ WinRT проекта на более позднюю версию пакета SDK для Windows?

См. в разделе [как Перенацелить C + +/ WinRT проекта на более позднюю версию пакета Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk).

## <a name="why-wont-my-new-project-compile-im-using-visual-studio-2017-version-1580-or-higher-and-sdk-version-17134"></a>Почему не будет скомпилирован, создать новый проект? Я использую Visual Studio 2017 (версии 15.8.0 или более поздней версии) и пакет SDK версии 17134

Если вы используете Visual Studio 2017 (версии 15.8.0 или более поздней версии) и пакет Windows SDK версии 10.0.17134.0 (Windows 10 версии 1803), выберите только что созданный C + +/ WinRT проект может к ошибке при компиляции с ошибкой «ошибка*C3861: «from_abi»: идентификатор не найти*» и другие ошибки, которые происходят *base.h*. Решением является более поздней версии (Дополнительные совместимые) либо целевой версии пакета SDK для Windows, или задать свойство проекта **C/C++** > **язык** > **режим совместимости: нет** (Кроме того, если **/ permissive-** отображается в свойство проекта ** C/C++** > **командной строки** в столбце **Дополнительные параметры**, удалите его).

## <a name="what-are-the-requirements-for-the-cwinrt-visual-studio-extension-vsixhttpsakamscppwinrtvsix"></a>Каковы требования для [расширения Visual Studio (VSIX) C++/WinRT](https://aka.ms/cppwinrt/vsix)?
[VSIX](https://aka.ms/cppwinrt/vsix) требует минимальную целевую версию пакета Windows SDK 10.0.17134.0 (Windows 10, версия 1803). Вам также потребуется Visual Studio 2017 (по крайней мере версия 15.6; рекомендуется версия не младше 15.7). Проект, использующий VSIX, можно определить по наличию `<CppWinRTEnabled>true</CppWinRTEnabled>`в `<PropertyGroup Label="Globals">` в файле `.vcxproj`. Дополнительные сведения см. в разделе [поддержка Visual Studio для C++/WinRT и VSIX ](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).

## <a name="whats-a-runtime-class"></a>Что такое *класс среды выполнения*?
Класс среды выполнения — это тип, который можно активировать и использовать через современные интерфейсы COM, обычно через границы исполняемого файла. Тем не менее, класс среды выполнения может также использоваться в единице компиляции, которая его реализует. Класс среды выполнения объявляется в языке описания интерфейса (IDL) и может реализоваться в стандартной версии C++ с использованием C++/WinRT.

## <a name="what-do-the-projected-type-and-the-implementation-type-mean"></a>Что означают понятия *тип проекции* и *тип реализации*?
Если вы лишь *используете* класс среды выполнения Windows (класс среды выполнения), то вы имеете дело с *типом проекции*. C++/WinRT представляет собой *языковую проекцию*, поэтому типы проекции являются частью среды выполнения Windows, которая *проецируется* в C++ с помощью C++/WinRT. Дополнительные сведения см. в разделе [Использование API-интерфейсов в C++/WinRT](consume-apis.md).

*Тип реализации* содержит реализацию класса среды выполнения, поэтому он доступен только в проекте, который реализует класс среды выполнения. При работе в проекте, который реализует классы среды выполнения (проекте компонента среды выполнения Windows или проекте, использующем пользовательский интерфейс XAML), очень важно понимать различия между вашим типом реализации класса среды выполнения и типом проекции, представляющим класс среды выполнения, проецируемый в C++/WinRT. Дополнительные сведения см. в разделе [Создание API-интерфейсов в C++/WinRT](author-apis.md).

## <a name="do-i-need-to-declare-a-constructor-in-my-runtime-classs-idl"></a>Нужно ли объявлять конструктор в IDL моего класса среды выполнения?
Только в том случае, если класс среды выполнения предназначен для использования извне его единицы компиляции (это компонент среды выполнения Windows, предназначенный для общего использования клиентскими приложениями среды выполнения Windows). Дополнительные сведения о назначении и последствиях объявления конструкторов в IDL см. в разделе [Конструкторы классов среды выполнения](author-apis.md#runtime-class-constructors).

## <a name="why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error"></a>Почему компоновщик отображает сообщение об ошибке "LNK2019: неразрешенный внешний символ"?
Если неразрешенный символ— это API из заголовков пространства имен Windows для проекции C++/WinRT (в пространстве имен **winrt**), то этот API объявляется в заголовке, который вы включили, но его определения находится в заголовке, который еще не включен. Включите заголовок с именем для пространства имен API и повторно выполните сборку. Дополнительные сведения см. в разделе [Заголовки проекции C++/WinRT](consume-apis.md#cwinrt-projection-headers).

Если неразрешенный символ — свободная функция среды выполнения Windows, таких как [RoInitialize](https://msdn.microsoft.com/library/br224650), необходимо явным образом связать библиотеку [WindowsApp.lib](/uwp/win32-and-com/win32-apis) в свой проект. Проекция C++/WinRT зависит от некоторых из этих свободных (не являющихся членами) функций и точек входа. Если вы используете один из шаблонов проектов [расширения Visual Studio для C++/WinRT (VSIX)](https://aka.ms/cppwinrt/vsix) для вашего приложения, `WindowsApp.lib` компонуется автоматически. В противном случае вы можете использовать параметры компоновки проекта, чтобы включить библиотеку, или можете сделать это в исходном коде.

```cppwinrt
#pragma comment(lib, "windowsapp")
```

Рекомендуется устранить все ошибки компоновщика, которые вы можете, привязав его **WindowsApp.lib**. Однако, если вам не нужны ваше приложение могло пройти тесты [Комплект сертификации приложений для Windows](../debug-test-perf/windows-app-certification-kit.md) , используется в Visual Studio и в магазине Майкрософт для проверки отправки (то есть, поэтому будет ваше приложение может быть успешно добавлено в Microsoft Store), а затем вы можете связать альтернативные статическая библиотека вместо. Например если ошибки компоновщика относится к **CoIncrementMTAUsage** (или **WINRT_CoIncrementMTAUsage**), затем можно устранить, связав Ole32.lib случае крайней необходимости (например, если не свою версию **WindowsApp.lib** Экспорт функции).

## <a name="should-i-implement-windowsfoundationiclosableuwpapiwindowsfoundationiclosable-and-if-so-how"></a>Следует ли реализовывать [**Windows::Foundation::IClosable**](/uwp/api/windows.foundation.iclosable) и если да, та каким образом?
Если у вас есть класс среды выполнения, который освобождает ресурсы в своем деструкторе, и этот класс среды предназначен для использования извне его единицы компиляции (это компонент среды выполнения Windows, предназначенный для общего использования клиентскими приложениями среды выполнения Windows), рекомендуется также реализовать **IClosable** для поддержки использования вашего класса среды выполнения языками, в которых отсутствует детерминированная финализация. Убедитесь, что ресурсы освобождаются при вызове деструктора, [**IClosable::Close**](/uwp/api/windows.foundation.iclosable.Close) или и того, и другого сразу. **IClosable::Close** можно вызывать произвольное число раз.

## <a name="do-i-need-to-call-iclosablecloseuwpapiwindowsfoundationiclosablewindowsfoundationiclosableclose-on-runtime-classes-that-i-consume"></a>Нужно ли вызывать [**IClosable::Close**](/uwp/api/windows.foundation.iclosable#Windows_Foundation_IClosable_Close_) для классов среды выполнения, которые я использую?
**IClosable** существует для поддержки языков, в которых отсутствует детерминированная финализация. Таким образом, не следует вызывать метод **IClosable::Close** из C++/WinRT, за исключением очень редких случаев полувзаимной блокировки. К примеру, если вы используете типы **Windows.UI.Composition**, может возникнуть ситуация, в которой вам понадобится удалить объекты в установленной последовательности, а не оставлять задачу их уничтожения программе-оболочке C++/WinRT.

## <a name="can-i-use-llvmclang-to-compile-with-cwinrt"></a>Можно ли использовать LLVM/Clang для компиляции с C++/WinRT?
Мы не поддерживаем цепочку инструментов LLVM и Clang для C++/WinRT, но мы используем ее для внутренней проверки соответствия стандартам C++/WinRT. Например, если вы хотите имитировать то, что мы делаем внутри, вы можете поэкспериментировать, как описано ниже.

Перейдите на [страницу загрузки LLVM](https://releases.llvm.org/download.html), найдите пункт **Скачать LLVM 6.0.0** > **Стандартные двоичные файлы** и скачайте **Clang для Windows (64-разрядная версия)**. Во время установки добавьте LLVM в системную переменную PATH, чтобы вызывать библиотеку из командной строки. В целях этого эксперимента можно пропустить любые ошибки "Не удалось найти каталог цепочки инструментов MSBuild" и "Не удалось установить интеграцию MSVC", если они отображаются. Существует множество способов вызова LLVM/Clang, в примере ниже показан только один из них.

```
C:\ExperimentWithLLVMClang>type main.cpp
// main.cpp
#pragma comment(lib, "windowsapp")
#pragma comment(lib, "ole32")

#include <winrt/Windows.Foundation.h>
#include <stdio.h>
#include <iostream>

using namespace winrt;

int main()
{
    winrt::init_apartment();
    Windows::Foundation::Uri rssFeedUri{ L"https://blogs.windows.com/feed" };
    std::wcout << rssFeedUri.Domain().c_str() << std::endl;
}

C:\ExperimentWithLLVMClang>clang-cl main.cpp /EHsc /I ..\.. -Xclang -std=c++17 -Xclang -Wno-delete-non-virtual-dtor -o app.exe

C:\ExperimentWithLLVMClang>app
windows.com
```

Поскольку C++/WinRT использует функции стандарта C++ 17, вам потребуется использовать все флаги компилятора, необходимые для обеспечения такой поддержки. Эти флаги в разных компиляторах отличаются.

Visual Studio — это средство разработки, которое мы поддерживаем и рекомендуем для C++/WinRT. См. раздел [Поддержка Visual Studio для C++/WinRT и VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).

## <a name="why-doesnt-the-generated-implementation-function-for-a-read-only-property-have-the-const-qualifier"></a>Почему не имеет функции созданных реализации для свойства только для чтения `const` квалификатора?

При объявлении свойства только для чтения в [MIDL 3.0](/uwp/midl-3/)можно было ожидать `cppwinrt.exe` средство для создания в реализации функции для вас, которое соответствует `const`-полное (функции const считает *это* указатель const).

Конечно, рекомендуется использовать константу везде, где это возможно, но `cppwinrt.exe` средству не пытаться причина о том, какую реализацию функции вполне может быть const, и который не может. Вы можете внести какие-либо из вашей реализации функции const, как показано в этом примере.

```cppwinrt
struct MyStringable : winrt::implements<MyStringable, winrt::Windows::Foundation::IStringable>
{
    winrt::hstring ToString() const
    {
        return L"MyStringable";
    }
};
```

Вы можете удалить, `const` квалификатора для **ToString** следует решить, что вам нужно изменить некоторые состояние объекта в своей реализации. Однако следует каждый член функции const или не const, не оба сразу. Другими словами, не перегружать функцию реализации на `const`.

Помимо вашей реализации функции, другой других разместить где const вступает в изображен в проекции функции среды выполнения Windows. Рассмотрим этот код.

```cppwinrt
int main()
{
    winrt::Windows::Foundation::IStringable s{ winrt::make<MyStringable>() };
    auto result{ s.ToString() };
}
```

Для вызова **ToString** выше, команда **Перейти к объявлению** в Visual Studio показывает, что проекцию **IStringable::ToString** среды выполнения Windows в C + +/ WinRT выглядит следующим образом.

```
winrt::hstring ToString() const;
```

Функции в проекции являются const независимо от способа квалификация реализацию их. Рендеринг проекции вызывает двоичный интерфейс приложения (ABI), какие суммы для вызова с помощью указатель COM-интерфейса. Единственное состояние, которое проецируемого **ToString** взаимодействует с является этот указатель COM-интерфейса; и не поддерживает определенно не нужно изменить этот указатель таким образом, чтобы функция const. Это дает ссылка Software assurance, оно не изменит никаких сведений о **IStringable** ссылку, которую вы вызова через, что это гарантирует, что можно вызвать **ToString** даже при использовании const **IStringable**.

Понимать, что эти примеры `const` — подробные сведения о реализации C + +/ WinRT проекции и реализации; они составляют санации кода для справки. Такие понятия как не существует `const` на COM, ни ABI среды выполнения Windows (для функций-членов).

## <a name="do-you-have-any-recommendations-for-decreasing-the-code-size-for-cwinrt-binaries"></a>У вас есть все рекомендации для уменьшения размера кода C + +/ WinRT двоичные файлы?

При работе с объектами среды выполнения Windows, следует избегать показано ниже, поскольку он может иметь отрицательное влияние на работу приложения, вызывая двоичного кода излишнее создается шаблон кодирования.

```cppwinrt
anobject.b().c().d();
anobject.b().c().e();
anobject.b().c().f();
```

В мире среды выполнения Windows, компилятор не может кэшировать либо значение `c()` или интерфейсы для каждого метода, который будет вызываться через косвенного обращения ('. '). Если необходимо изменить, приводит к дополнительные виртуальные вызовы и служебных данных подсчета ссылок. Выше шаблон может легко создавать два раза больше кода, как строго. Вместо этого предпочитают приведенный ниже там, где вы можете шаблон. Он создает намного меньше кода, а также значительно повышает производительность время выполнения.

```cppwinrt
auto a{ anobject.b().c() };
a.d();
a.e();
a.f();
```

Рекомендуемые приведенный выше шаблон применяется не только к C + +/ WinRT, но все языковые проекции среды выполнения Windows.

> [!NOTE]
> Если в этом разделе не ответить на вопрос, то может оказаться справки, перейдя к [сообществу разработчиков Visual Studio C++](https://developercommunity.visualstudio.com/spaces/62/index.html)или с помощью [ `c++-winrt` метки на Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).
