---
author: stevewhims
description: В этом разделе описываются различные категории значений, которые существуют в C++. Вы несомненно слышали значениями и rvalues, но существуют другие типы слишком.
title: Значение категории и ссылки на них
ms.author: stwhi
ms.date: 08/11/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: Windows 10, uwp, стандартные, c ++, cpp, winrt, проекции, перемещение, перенаправление, значение категории, семантику перемещения, точная пересылка, lvalue, rvalue, glvalue, prvalue, xvalue
ms.localizationpriority: medium
ms.openlocfilehash: cbccaf78b45d85d93619977d149431c4eec9e10a
ms.sourcegitcommit: 5dda01da4702cbc49c799c750efe0e430b699502
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/21/2018
ms.locfileid: "4119958"
---
# <a name="value-categories-and-references-to-them"></a>Значение категории и ссылки на них
В этом разделе описываются различные категории значения (и ссылки на значения), которые существуют в C++. Вы несомненно слышали *значениями* и *rvalues*, но может не представить их в условия, которые в этом разделе представлены. Также существуют другие типы значений, слишком.

Каждое выражение на языке C++ возвращает значение, которое принадлежит к одной из категорий, описанные в этой статье. Существует аспектов языка C++, facilies и правила, которые требуют правильного понимание этих категорий значение, и ссылки на них. Например получение адреса значения, копирование значение, перемещения значение и переадресации значение на другой функции. В этом разделе не помещаются в все эти аспекты подробно о, но он содержит фундаментальные сведения о четкое понимание из них.

Информация в этом разделе будет заключенных терминах Страуструпа анализ категорий значение свойствами два независимых удостоверения и movability [Страуструпом, 2013].

## <a name="an-lvalue-has-identity"></a>Lvalue у удостоверения
Что означает значение иметь *удостоверение*? Если у вас (или может занять) адрес памяти значение и использовать его безопасно, то значение состоит из удостоверения. Таким образом, можно сделать более сравнение содержимое значения: можно сравнить или отличить их по идентификатору.

*Lvalue* у удостоверения. Теперь это делается путем только истории интерес, что «l» на «lvalue» представляет собой сокращение от «влево» (как показано, левой части присваиваться). В C++ lvalue может отображаться слева *или* справа от назначения. «L» на «значениями», затем не помогают фактически воспринимать, а также определить, какие. Вам нужно только понимать, что так мы называем lvalue является значение, которое имеет удостоверения.

Примеры выражений, которые являются значениями: именованной переменной или константы; или функцию, которая возвращает ссылку. Примеры выражения, которые *не* значениями: временный; или функция, которая возвращает значение.

```cppwinrt
int& get_by_ref() { ... }
int get_by_val() { ... }

int main()
{
    std::vector<byte> vec{ 99, 98, 97 };
    std::vector<byte>* addr1{ &vec }; // ok: vec is an lvalue.
    int* addr2{ &get_by_ref() }; // ok: get_by_ref() is an lvalue.

    int* addr3{ &(get_by_ref() + 1) }; // Error: get_by_ref() + 1 is not an lvalue.
    int* addr4{ &get_by_val() }; // Error: get_by_val() is not an lvalue.
}
```

Теперь пока оно находится оператор значение true, что значениями имеют идентификатор, делать xvalues. Мы будем произведите более какие *xvalue* далее в этой статье. Теперь просто не забывайте, что существует категорию значение с именем glvalue, для «обобщенными lvalue». Расширенный вариант возможности glvalues содержит значениями (также известной как *Классические значениями*) и xvalues. Таким образом, пока «lvalue у удостоверения» имеет значение true, полный набор действий, которые имеют удостоверение — это набор glvalues, как показано на следующем рисунке.

![Lvalue у удостоверения](images/has-identity1.png)

## <a name="an-rvalue-is-movable-an-lvalue-is-not"></a>Rvalue является перемещаемой; не является lvalue
Но есть значения, которые не являются glvalues. Следовательно существует значения, которые *не могут* получить адрес памяти для (или нельзя полагаться на его, чтобы быть действительным). Мы увидели таких значений в приведенном выше примере кода. Это может показаться недостаток. Но на самом деле, преимуществами значение это как можно *переместить* из него (это обычно требовательны), а не скопировать из него (это обычно требуют). Переход с значение означает, что больше не на месте, которое должно быть. Поэтому при попытке доступа к нему в месте, которое должно быть — что-то, чтобы избежать. Описание того, где и *как* переместить значение выходит за рамки данного раздела. В этом разделе мы просто нужно знать, что значение, которое является перемещаемой называется *rvalue* (или *Классические rvalue*).

«R» в «rvalue» представляет собой сокращение от «вправо» (как показано, справа части присваиваться). Однако вы можете использовать rvalues и ссылки на rvalues за пределами назначения. «R» в «rvalues», то, не самое сосредоточиться на. Вам нужно только понять, что мы вызываем метод rvalue — это значение, которое является перемещаемой.

Lvalue, и наоборот, не является перемещаемой, как показано на следующем рисунке. Lvalue, которая движется бы пример изменяет определение *lvalue*и было бы непредвиденная ошибка для кода, который очень некую должен иметь возможность продолжать осуществлять доступ к lvalue.

![Rvalue является перемещаемой; не является lvalue](images/is-movable.png)

Не удается переместить lvalue. Однако существует *—* своего рода glvalue (набор действий с помощью удостоверения), который можно переместить&mdash;Если вы знаете, что вы делаете (в том числе необходимо указать не получить к ним доступ после перемещения)&mdash;это xvalue. Мы будем Пересмотрите Эта идея еще раз ниже, когда мы рассмотрим полную картину значение категорий.

## <a name="rvalue-references-and-reference-binding-rules"></a>Ссылки rvalue и правила привязки ссылки
В этом разделе рассматриваются синтаксис для ссылки на rvalue. Мы будем придется ждать другой раздел произведите существенных принцип перемещения и пересылки, но это и есть проблемы, которые решены с ссылки rvalue. Прежде чем мы рассмотрим ссылки rvalue, тем не менее, сначала необходимо быть более четкими о `T&` &mdash;самое мы ранее вызова просто «ссылки». Это действительно «(без const) ссылки lvalue», который ссылается на значение, к которому можно написать пользователь ссылки.

```cppwinrt
template<typename T> T& get_by_lvalue_ref() { ... } // Get by lvalue (non-const) reference.
template<typename T> void set_by_lvalue_ref(T&) { ... } // Set by lvalue (non-const) reference.
```

Ссылки lvalue можно привязать lvalue, но не rvalue.

То есть lvalue const ссылки (`T const&`), который ссылки на объекты, к которым пользователь ссылку, *не может* записывать (например, константа).

```cppwinrt
template<typename T> T const& get_by_lvalue_cref() { ... } // Get by lvalue const reference.
template<typename T> void set_by_lvalue_cref(T const&) { ... } // Set by lvalue const reference.
```

Const ссылки lvalue можно связать с lvalue или rvalue.

Синтаксис для ссылки на rvalue типа `T` записывается в виде `T&&`. Ссылка rvalue относится к перемещаемой значение&mdash;значение, содержимое которого мы не нужно сохранить после мы использовали его (например, временный). С момента суть перехода от (тем самым меняющимся) значение привязано к ссылка rvalue, `const` и `volatile` квалификаторы (также известной как cv квалификаторы) не относятся к ссылки rvalue.

```cppwinrt
template<typename T> T&& get_by_rvalue_ref() { ... } // Get by rvalue reference.
struct A { A(A&& other) { ... } }; // A move constructor takes an rvalue reference.
```

Ссылка rvalue привязывается к rvalue. На самом деле терминах разрешение перегрузки rvalue *предпочитает* быть привязан к ссылка rvalue чем для ссылки const lvalue. Но ссылка rvalue невозможно привязать к lvalue, поскольку, как говорилось, ссылка rvalue ссылается на значение, содержимое которого предполагается, нам не нужно сохранить (скажем, параметра для конструктора перемещения).

Можно также передать rvalue там, где ожидается аргумент по значению, через при создании копирования (или через при создании перемещения, если rvalue xvalue).

## <a name="a-glvalue-has-identity-a-prvalue-does-not"></a>Glvalue у удостоверения; не prvalue
На этом этапе мы знаем, что у удостоверения. И мы знаем, что является перемещаемой чего нет. Но мы еще не именованный набор значений, *не* имеют удостоверений. Этот набор называют *prvalue*или *чисто rvalue*.

```cppwinrt
int& get_by_ref() { ... }
int get_by_val() { ... }

int main()
{
    int* addr3{ &(get_by_ref() + 1) }; // Error: get_by_ref() + 1 is a prvalue.
    int* addr4{ &get_by_val() }; // Error: get_by_val() is a prvalue.
}
```

![Lvalue есть удостоверение; не prvalue](images/has-identity2.png)

## <a name="the-complete-picture-of-value-categories"></a>Полную картину категорий значение
Он остается только объединить сведения и иллюстрациях выше в единый, большой рисунок.

![Полную картину категорий значение](images/value-categories.png)

### <a name="glvalue-i"></a>glvalue (i)
Glvalue (универсальный lvalue) имеет удостоверения.

### <a name="lvalue-im"></a>lvalue (i\ & \!m)
Lvalue (типа glvalue) имеет удостоверения, но не перемещаемым. Это обычно чтения и записи значений, которые вы передаете вокруг по ссылке или по ссылке const или по значению при копировании не требовательны. Lvalue не могут быть привязаны к ссылка rvalue.

### <a name="xvalue-im"></a>xValue (i\ & m)
Xvalue (своего рода glvalue, но также своего рода rvalue) имеет удостоверения, а также является перемещаемой. Это может быть lvalue командлета, который вы решили для перемещения, так как копирование является затратной, и вы будете внимательны, чтобы не получить к нему доступ позже. Вот как можно приступить к lvalue xvalue.

```cppwinrt
struct A { ... };
A a; // a is an lvalue...
static_cast<A&&>(a); // ...but this expression is an xvalue.
```

В примере выше мы еще не перешли что-либо еще. Мы только что создали xvalue путем преобразования lvalue для ссылка безымянных rvalue. Это по-прежнему можно идентифицировать по имени lvalue; но, как xvalue теперь *поддержкой* перемещения. Это позволит, причины и какие перемещения выглядит на самом деле, придется ждать другой раздел. Однако можно представить себе буква «x» в «xvalue», как значение «эксперта» только если, позволяющая. Путем преобразования lvalue в xvalue (типа rvalue), то это значение становится может уже привязан к ссылка rvalue.

Ниже приведены другие примеры xvalues&mdash;вызова функции, которая возвращает ссылка безымянных rvalue и доступ к членом xvalue.

```cppwinrt
struct A { int m; };
A&& f();
f(); // This expression is an xvalue...
f().m; // ...and so is this.
```

### <a name="prvalue-im"></a>prvalue (\!i\ & m)
Prvalue (чистом rvalue; своего рода rvalue) не имеет удостоверения, но является перемещаемой. Обычно они развертываются временных переменных, результат вызова функции, которая возвращает значение или результат вычисления выражения, который не является glvalue

### <a name="rvalue-m"></a>rvalue (m)
Rvalue является перемещаемой. *Справочник по* rvalue всегда относится к rvalue (значение, содержимое которого предполагается, нам не нужно сохранить).

Но, ссылка rvalue сам rvalue? *Безымянных* ссылка rvalue (например, показанным в приведенных выше примерах кода xvalue) — это xvalue таким образом, Да, это rvalue. Он предпочитает можно привязать к параметр ссылки функции rvalue, например, конструктором перемещения. И наоборот (и возможно counter-intuitively) Если ссылка rvalue имеет имя, то выражением, состоящим из это имя будет lvalue. Поэтому он *не могут* быть привязаны к параметр ссылки rvalue. Но их можно сделать его сделать&mdash;просто приведите его к ссылка безымянных rvalue (xvalue).

```cppwinrt
void foo(A&) { ... }
void foo(A&&) { ... }
void bar(A&& a) // a is a named rvalue reference; it's an lvalue.
{
    foo(a); // Calls foo(A&).
    foo(static_cast<A&&>(a)); // Calls foo(A&&).
}
A&& get_by_rvalue_ref() { ... } // This unnamed rvalue reference is an xvalue.
```

### <a name="im"></a>\!i\ & \!m
Вид значение, которое не имеет удостоверения и не перемещаемой представляет собой один сочетание, мы еще не обсуждали. Но мы его можно проигнорировать, связано с этой категорией полезно идея на языке C++.

## <a name="reference-collapsing-rules"></a>Сворачивание ссылку правила
Несколько like ссылок в выражении (ссылки lvalue для ссылки lvalue или ссылка rvalue к ссылка rvalue) отмените выбор одного другой вне.

- `A& &` Сворачивает в `A&`.
- `A&& &&` Сворачивает в `A&&`.

Несколько в отличие от ссылки в выражении свернуть, чтобы ссылки lvalue.

- `A& &&` Сворачивает в `A&`.
- `A&& &` Сворачивает в `A&`.

## <a name="forwarding-references"></a>Переадресации ссылки
В этом разделе, последний отличается rvalue ссылки на объекты, которые мы уже обсуждали, с помощью различных концепцию *переадресации ссылки*.

```cppwinrt
void foo(A&& a) { ... }
```

- `A&&` как мы выяснили, — это ссылка rvalue. Const и volatile не относятся к ссылки rvalue.
- `foo` принимает только rvalues типа **A**.
- Причина rvalue ссылается (такие как `A&&`) существует — таким образом, вы можете создать перегрузку, которая оптимизирована для в случае временный (или другие rvalue), передаваемых.

```cppwinrt
template <typename _Ty> void bar(_Ty&& ty) { ... }
```

- `_Ty&&` — Это *переадресации ссылки*. В зависимости от того, что вы передаете `bar`, тип **_Ty** может быть const и не const независимо от volatile/энергонезависимой.
- `bar` принимает любой lvalue или rvalue из тип **_Ty**.
- Передача lvalue вызывает ссылку переадресации стать `_Ty& &&`, который сворачивает lvalue справочные материалы по `_Ty&`.
- Передача rvalue вызывает ссылку переадресации стать `_Ty&& &&`, который сворачивает rvalue справочные материалы по `_Ty&&`.
- Причина переадресации ссылки (такие как `_Ty&&`) существует — *не* для оптимизации, но выполнить, что вы передаете для них и переслать на прозрачно и эффективно. Вы, скорее всего возникнуть ссылку переадресации только в том случае, если запись (или внимательно изучить) кода библиотеки&mdash;например, функции фабрики, которая перенаправляет на аргументы конструктора.

## <a name="sources"></a>"Источники"
* \[Stroustrup, 2013\] Страуструп б.: язык программирования C++, четвертого выпуск. Addison по разработке. 2013.
