---
description: В этом разделе описываются различные категории значений, которые существуют в C++. Вы наверняка уже слышали о значениях lvalue и rvalue, но существуют и другие типы.
title: Значение категории и ссылки на них
ms.date: 08/11/2018
ms.topic: article
keywords: Windows 10, uwp, standard, c ++, cpp, winrt, проекции, перемещение, переадресации, значение категории, семантику перемещения, точная пересылка, lvalue, rvalue, glvalue, prvalue, xvalue
ms.localizationpriority: medium
ms.custom: RS5
ms.openlocfilehash: 1860f562233ceefa6d9ebb3741378b3265b4c3a9
ms.sourcegitcommit: b034650b684a767274d5d88746faeea373c8e34f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2019
ms.locfileid: "57593019"
---
# <a name="value-categories-and-references-to-them"></a>Значение категории и ссылки на них
В этом разделе описываются различные категории значений (и ссылки на значения), которые существуют в C++. Вы несомненно слышали о *значения lvalue* и *rvalues*, но могут не подумать об их в термины, которые представлены в этом разделе. И другие виды значений, слишком.

Каждое выражение в C++ возвращает значение, которое принадлежит к одной из категорий, описанных в этом разделе. Есть аспекты языка C++, facilies и правила, которым требуется должное понимание этих категорий значения и ссылки на них. Например получение адреса значения, копирование значения, значение переносится и пересылки значение на другую функцию. В этом разделе не в все эти аспекты подробно, но он предоставляет базовые сведения для ясное понимание того из них.

Сведения в этом разделе обрамлена с точки зрения Страуструпа анализ значение категории два независимых Свойства identity и movability [Страуструпом 2013].

## <a name="an-lvalue-has-identity"></a>Lvalue имеет идентификатор
Что означает для значения, которое имеют *удостоверений*? Если у вас есть (или может занять) адрес памяти значения и использовать его, а затем значение имеет идентификатор. Таким образом, можно сделать более чем сравнить содержимое значения: вы можете сравнить или различать их по идентификатору.

*Lvalue* имеет идентификатор. Теперь это вопрос только исторические интерес, что «l» в «lvalue» представляет собой сокращение от «left» (как, например левой стороны присваивания). В C++, lvalue может отображаться слева *или* в правой части назначения. «L» в «значения lvalue», затем, не помогают фактически воспринимать и определить, что это такое. Необходимо только понимать, что так называемый lvalue является значение, которое имеет удостоверения.

Примеры выражений, которые являются значениями lvalue: именованной переменной или константы; или функция, возвращающая ссылку. Примеры выражений, которые являются *не* включают значения lvalue: временный; или функцию, возвращающую по значению.

```cppwinrt
int& get_by_ref() { ... }
int get_by_val() { ... }

int main()
{
    std::vector<byte> vec{ 99, 98, 97 };
    std::vector<byte>* addr1{ &vec }; // ok: vec is an lvalue.
    int* addr2{ &get_by_ref() }; // ok: get_by_ref() is an lvalue.

    int* addr3{ &(get_by_ref() + 1) }; // Error: get_by_ref() + 1 is not an lvalue.
    int* addr4{ &get_by_val() }; // Error: get_by_val() is not an lvalue.
}
```

Теперь хотя это утверждение верно, что значения lvalue имеют идентификатор, поэтому не xvalues. Здесь будут сведения о том, что *xvalue* — далее в этом разделе. Пока просто Учтите, что имеется значение категорию с именем glvalue, для «обобщить lvalue». Расширенный набор glvalues содержит оба значения lvalue (также известный как *классические значения lvalue*) и xvalues. Таким образом, хотя «lvalue содержит удостоверение» имеет значение true, полный набор то, что удостоверение — это набор glvalues, как показано на этом рисунке.

![Lvalue имеет идентификатор](images/has-identity1.png)

## <a name="an-rvalue-is-movable-an-lvalue-is-not"></a>Rvalue является перемещаемой; не является ссылкой lvalue
Но есть значения, которые не являются glvalues. Следовательно, существуют значения, которые *нельзя* получить адрес памяти для (или нельзя полагаться на все). Мы увидели некоторые такие значения, в приведенном выше примере кода. Это может показаться нехитрой недостаток. Но на самом деле преимущество значения, такие как то есть, вы можете *переместить* игру (что обычно требует больших затрат), а не копировать из него (это обычно требует много ресурсов). Перемещение из значения означает, что он больше не в место, в котором должно быть. Таким образом при попытке доступа к нему в место, в котором должно быть это следует избегать. Когда обсуждение и *как* для перемещения, значение выходит за рамки данного раздела. В этом примере нам нужно знать, что значение, которое может быть перемещена называется *rvalue* (или *классические rvalue*).

«R» в «rvalue» представляет собой сокращение от «right» (как, например правой стороны назначения). Но можно использовать значения rvalue, а также ссылки на значения rvalue, за пределами назначения. «R» в «rvalues», то, будет в первую очередь сосредоточиться на. Необходимо только понимать, что так называемый rvalue — это значение, которое может быть перемещена.

Lvalue, и наоборот, не является перемещаемым, как показано на этом рисунке. Lvalue, в который перемещен бы преодолеть определение *lvalue*, и было бы возникла непредвиденная проблема, для кода, который очень разумно должен иметь возможность продолжать обращаться к lvalue.

![Rvalue является перемещаемой; не является ссылкой lvalue](images/is-movable.png)

Невозможно переместить lvalue. Но есть *—* своего рода glvalue (набор вещи с помощью удостоверения), вы можете переместить&mdash;Если вы знаете, что делаем (включая, стараясь не доступ к нему после перемещения)&mdash;и это xvalue. Мы вернемся к этой идее еще раз ниже, если взглянуть на полную картину значение категории.

## <a name="rvalue-references-and-reference-binding-rules"></a>Ссылки rvalue и правила привязки ссылок
В этом разделе синтаксис для ссылки rvalue. Нам придется подождать для другой раздел, в значительной обработки перемещения и пересылки, но таковы, проблемы, которые решаются путем ссылки rvalue. Прежде чем мы рассмотрим ссылки rvalue, однако необходимо сначала яснее о `T&` &mdash;то, что мы ранее вызов просто «ссылка». Суть — в «(не константный) ссылки lvalue», который ссылается на значение, к которому можно написать пользователем ссылки.

```cppwinrt
template<typename T> T& get_by_lvalue_ref() { ... } // Get by lvalue (non-const) reference.
template<typename T> void set_by_lvalue_ref(T&) { ... } // Set by lvalue (non-const) reference.
```

Ссылки lvalue можно привязать к lvalue, но не на rvalue.

Существуют const ссылки lvalue (`T const&`), которые относятся к объектам, к которому пользователь ссылки на *нельзя* записи (например, константа).

```cppwinrt
template<typename T> T const& get_by_lvalue_cref() { ... } // Get by lvalue const reference.
template<typename T> void set_by_lvalue_cref(T const&) { ... } // Set by lvalue const reference.
```

Const ссылки lvalue можно привязать lvalue или rvalue.

Синтаксис ссылку rvalue типа `T` записывается как `T&&`. Ссылка rvalue ссылается на значение подвижной&mdash;значение, содержимое которой не требуется сохранить после мы использовали их (например, временно). Так как весь смысл для перемещения из (тем самым изменение) значение привязано к ссылке rvalue, `const` и `volatile` квалификаторы (также известный как cv квалификаторы) не применяются к ссылкам rvalue.

```cppwinrt
template<typename T> T&& get_by_rvalue_ref() { ... } // Get by rvalue reference.
struct A { A(A&& other) { ... } }; // A move constructor takes an rvalue reference.
```

Ссылка rvalue привязывает на rvalue. На самом деле, с точки зрения разрешения перегрузки, rvalue *предпочитает* привязываться к ссылке rvalue чем к ссылке на const lvalue. Но ссылка rvalue не удается привязать к lvalue, поскольку, как мы сказали, ссылкой rvalue ссылается на значение, содержимое которой предполагается, нам не нужно сохранять (например, параметр для конструктор перемещения).

Можно также передать rvalue там, где ожидается аргумент по значению, с помощью конструкции копирования (или конструкции перемещения, если rvalue xvalue).

## <a name="a-glvalue-has-identity-a-prvalue-does-not"></a>Glvalue имеет идентификатор; не поддерживает prvalue
На этом этапе мы знаем, что у удостоверения. И мы знаем, что может быть перемещена, и неподдерживаемые сценарии. Но мы еще не еще с именем набор значений, *не* есть удостоверение. Этот набор называется *prvalue*, или *чисто rvalue*.

```cppwinrt
int& get_by_ref() { ... }
int get_by_val() { ... }

int main()
{
    int* addr3{ &(get_by_ref() + 1) }; // Error: get_by_ref() + 1 is a prvalue.
    int* addr4{ &get_by_val() }; // Error: get_by_val() is a prvalue.
}
```

![Lvalue имеет идентификатор; не поддерживает prvalue](images/has-identity2.png)

## <a name="the-complete-picture-of-value-categories"></a>Полную картину значение категории
Он остается только объединить сведения и рисунках выше в единый, большие изображения.

![Полную картину значение категории](images/value-categories.png)

### <a name="glvalue-i"></a>glvalue (i)
Glvalue (обобщенный lvalue) имеет удостоверение.

### <a name="lvalue-im"></a>lvalue (я\&\!m)
Lvalue (тип glvalue) имеет идентификатор, но не перемещаемым. Это обычно чтения и записи значения, переданные вокруг по ссылке или ссылкой константы или по значению, если копирование не требует больших затрат. Невозможно привязать значение lvalue к ссылке rvalue.

### <a name="xvalue-im"></a>xValue (я\&m)
Xvalue (вида glvalue, но также разновидностью rvalue) имеет идентификатор, а также может быть перемещена. Это может быть lvalue командлета, вы решили переместить, так как копирование является ресурсоемким, и вы будете нельзя допустить доступ к нему позже. Вот, как значение lvalue можно превратить в xvalue.

```cppwinrt
struct A { ... };
A a; // a is an lvalue...
static_cast<A&&>(a); // ...but this expression is an xvalue.
```

В приведенном выше примере кода мы еще не перенесли что-то еще. Мы только что создали xvalue путем приведения lvalue к безымянная ссылка rvalue. Он по-прежнему быть идентифицирован по его имени lvalue; но как xvalue стало *поддержкой* для перемещения. Причины таким образом, и какие перемещение выглядит на самом деле, будет нужно ждать, пока другой раздел. Однако можно считать «x» в «xvalue» значение «expert только» если, который позволяет. Путем приведения lvalue в xvalue (тип rvalue), значение затем становится для привязки к ссылке rvalue.

Ниже приведены другие примеры xvalues&mdash;вызова функции, возвращающей безымянную ссылку rvalue и обращение к члену xvalue.

```cppwinrt
struct A { int m; };
A&& f();
f(); // This expression is an xvalue...
f().m; // ...and so is this.
```

### <a name="prvalue-im"></a>prvalue (\!я\&m)
Prvalue, (чисто rvalue; тип rvalue) не имеет удостоверения, но может быть перемещена. — Обычно это временные, результат вызова функции, которая возвращает значение или результат вычисления другого выражения, не glvalue,

### <a name="rvalue-m"></a>rvalue (m)
Rvalue допускает перемещение. Rvalue *ссылку* всегда ссылается на rvalue (значение, содержимое которой предполагается, нам не нужно сохранить).

Но представляет собой ссылку rvalue, сам rvalue? *Неименованные* ссылку rvalue (например, тех, которые показаны в Вышеприведенные примеры кода xvalue) является xvalue таким образом, Да, он представляет собой rvalue. Он предпочитает быть привязан к параметру функции ссылки rvalue, например, конструктор перемещения. И наоборот (и возможно counter-intuitively) Если ссылка rvalue имеет имя, то выражение, состоящее из этого имени является ссылкой lvalue. Поэтому он *нельзя* быть привязан к параметру ссылки rvalue. Но это легко сделать этого&mdash;просто привести его к безымянную ссылку rvalue (xvalue).

```cppwinrt
void foo(A&) { ... }
void foo(A&&) { ... }
void bar(A&& a) // a is a named rvalue reference; it's an lvalue.
{
    foo(a); // Calls foo(A&).
    foo(static_cast<A&&>(a)); // Calls foo(A&&).
}
A&& get_by_rvalue_ref() { ... } // This unnamed rvalue reference is an xvalue.
```

### <a name="im"></a>\!я\&\!m
Тип значения, не имеет удостоверения и подвижной — одно сочетание, которое мы еще не были включены. Но мы его можно проигнорировать, так как этой категории не полезные идеи на языке C++.

## <a name="reference-collapsing-rules"></a>Правила сворачивания ссылок
Несколько like ссылок в выражении (ссылкой lvalue к ссылке на lvalue или ссылку rvalue к ссылке rvalue) отменить один другой out.

- `A& &` Сворачивает в `A&`.
- `A&& &&` Сворачивает в `A&&`.

Несколько, в отличие от ссылок в выражении свернуть со ссылкой lvalue.

- `A& &&` Сворачивает в `A&`.
- `A&& &` Сворачивает в `A&`.

## <a name="forwarding-references"></a>Перенаправление ссылок
В заключительном разделе противопоставляются ссылки rvalue, которые мы уже выяснили, в разные концепции *пересылки ссылку*.

```cppwinrt
void foo(A&& a) { ... }
```

- `A&&` является ссылкой rvalue, как мы уже видели. Const и volatile не применяются к ссылкам rvalue.
- `foo` принимает только значения rvalue типа **объект**.
- Ссылкам rvalue причина (такие как `A&&`) существует для того, можно создать перегрузку, которая оптимизирована для в случае временного (или других rvalue), передаваемые.

```cppwinrt
template <typename _Ty> void bar(_Ty&& ty) { ... }
```

- `_Ty&&` — *пересылки ссылку*. В зависимости от того, что передаваемый `bar`, тип **_Ty** может быть const/неконстантной независимо от volatile/долговременный.
- `bar` принимает любой lvalue или rvalue типа **_Ty**.
- Передача lvalue приводит ссылки перенаправления станет `_Ty& &&`, который сворачивает ссылки lvalue `_Ty&`.
- Передача rvalue приводит ссылки перенаправления станет `_Ty&& &&`, который сворачивает к ссылке rvalue `_Ty&&`.
- Причина, перенаправление ссылок (такие как `_Ty&&`) существует — *не* для оптимизации, но чтобы воспользоваться, что вы передаете для них и переслать его просто и эффективно. Вы будете часто приходится сталкиваться переадресации ссылку только в том случае, если запись (или внимательно изучить) код библиотеки&mdash;к примеру, функция фабрики, которая перенаправляет на аргументы конструктора.

## <a name="sources"></a>Источники
* \[Страуструпом 2013\] Страуструп б: Язык программирования C++, четвертый выпуск. Addison-Wesley. 2013.
