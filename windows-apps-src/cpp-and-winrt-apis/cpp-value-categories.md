---
description: В этом разделе описываются различные категории значений, которые существуют в C++. Вы наверняка уже слышали о значениях lvalue и rvalue, но существуют и другие типы.
title: Категории значений и ссылки на них
ms.date: 08/11/2018
ms.topic: article
keywords: windows 10, uwp, стандартный, c++, cpp, winrt, проекция, перемещение, пересылка, категории значений, семантика перемещения, точная пересылка, lvalue, rvalue, glvalue, prvalue, xvalue
ms.localizationpriority: medium
ms.custom: RS5
ms.openlocfilehash: 1312b84ded26859cd4b83ffbe3e8a75bfdef6950
ms.sourcegitcommit: 20ee991a1cf87ef03c158cd3f38030c7d0e483fa
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2020
ms.locfileid: "77037884"
---
# <a name="value-categories-and-references-to-them"></a>Категории значений и ссылки на них
В этом разделе описываются различные категории значений (и ссылки на значения), которые существуют в C++. Вы, несомненно, слышали о значениях *lvalue* и *rvalue*, но могли не рассматривать их с точки зрения, изложенной в этом разделе. Существуют и другие виды значений.

Каждое выражение в C++ возвращает значение, которое принадлежит к одной из категорий, описанных в этом разделе. Существуют аспекты языка C++, которые они упрощают, и правила, требующие должного понимания этих категорий значений и ссылок на них. Например, получение адреса значения, копирование значения, перенос значения и пересылка значение в другую функцию. В этом разделе не приводится подробное описание всех этих аспектов, но он содержит базовые сведения для ясного понимания принципа их работы.

Сведения в этом разделе представлены с точки зрения анализа категорий значений на основе двух независимых свойств идентификации и перемещаемости, предложенного Бьерном Страуструпом [Stroustrup, 2013].

## <a name="an-lvalue-has-identity"></a>У lvalue есть идентификатор
Что означает, что у значения есть *идентификатор*? Если у вас есть (или его можно выделить) адрес памяти значения и вы можете его безопасно использовать, то у значения есть идентификатор. Таким образом вы не просто сравниваете содержимое значений: вы можете сравнивать или различать их по идентификатору.

У *lvalue* есть идентификатор. Сейчас этот вопрос представляет лишь исторический интерес, но "l" в имени lvalue представляет собой сокращение от "left" (слева) (то есть левая сторона присваивания). В C++ lvalue может отображаться в левой *или* правой части присваивания. То есть "l" в имени lvalue уже не помогает понять, что это за значения. Необходимо только понимать, что lvalue — это значение, которое имеет идентификатор.

Примеры выражений с lvalue: именованная переменная или константа; или функция, возвращающая ссылку. Примеры выражений, которые *не* содержат lvalue: временное значение или функция, возвращающая результат по значению.

```cppwinrt
int& get_by_ref() { ... }
int get_by_val() { ... }

int main()
{
    std::vector<byte> vec{ 99, 98, 97 };
    std::vector<byte>* addr1{ &vec }; // ok: vec is an lvalue.
    int* addr2{ &get_by_ref() }; // ok: get_by_ref() is an lvalue.

    int* addr3{ &(get_by_ref() + 1) }; // Error: get_by_ref() + 1 is not an lvalue.
    int* addr4{ &get_by_val() }; // Error: get_by_val() is not an lvalue.
}
```

Как мы сказали, у значений lvalue имеются идентификаторы, но это верно и для значений xvalue. Мы подробнее остановимся на значениях *xvalue* позже в этом разделе. Пока просто запомните, что существует категория значений glvalue, от "generalized lvalue" (универсальное значение lvalue). Расширенный набор значений glvalue содержит и значения lvalue (также известные как *классические значения lvalue*), и значения xvalue. Поэтому, хотя утверждение, что у lvalue есть идентификатор, и верно, полный набор значений с идентификатором — это набор значений glvalue, как показано на этом рисунке.

![У lvalue есть идентификатор](images/has-identity1.png)

## <a name="an-rvalue-is-movable-an-lvalue-is-not"></a>Значение rvalue является перемещаемым, а lvalue — нет
Но есть значения, которые не относятся к категории glvalue. Следовательно, существуют значения, для которых *невозможно* получить адрес памяти (либо не гарантируется, что он будет действительным). Мы видели несколько таких значений в приведенном выше примере кода. Это может показаться недостатком. Но на самом деле преимущество такого значения заключается в том, что вы можете *переместить* данные из него (что, как правило, не требует больших затрат), а не копировать их (что, как правило, требует несколько больших затрат). Перемещение значения означает, что оно не остается там, где было до этого. Поэтому следует избегать попыток обращения к переменным там, откуда они уже были перемещены. Когда и *как* следует перемещать переменную выходит за рамки данного раздела. Для данного раздела нам достаточно знать, что значение, которое может быть перемещено, называется *rvalue* (или *классическое значение rvalue*).

Буква "r" в rvalue представляет собой сокращение от "right" (справа) (то есть правая сторона присвоения). Но значения rvalue, а также ссылки на rvalue, можно использовать и за пределами присвоений. Значит, на "r" в имени rvalue можно не обращать особого внимания. Необходимо только понимать, что rvalue — это значение, которое можно перемещать.

А значение lvalue не является перемещаемым, как показано на этом рисунке. Перемещенное значение lvalue противоречило бы определению *lvalue*, и возникла бы непредвиденная проблема для кода, который вполне обоснованно по-прежнему должен иметь доступ к lvalue.

![Значение rvalue является перемещаемым, а lvalue — нет](images/is-movable.png)

Невозможно переместить значение lvalue. Но *есть* еще значение типа glvalue (набор значений с идентификатором), которое вы можете переместить &mdash; если, конечно, вы знаете, что делаете (в то числе достаточно внимательны, чтобы не обращаться к нему после перемещения) &mdash; это значение xvalue. Мы вернемся к этой идее позже, когда рассмотрим полную картину категорий значений.

## <a name="rvalue-references-and-reference-binding-rules"></a>Ссылки на rvalue и правила привязки ссылок
В этом разделе описывается синтаксис ссылки на rvalue. Нам придется подождать выпуска другого раздела, чтобы углубиться в суть перемещения и пересылки, но сейчас достаточно будет сказать что для решения этих проблем необходимы ссылки на rvalue. Однако прежде чем мы рассмотрим ссылки на rvalue, необходимо подробнее рассмотреть `T&`&mdash; то, что ранее мы называли просто "ссылкой". Это действительно "ссылка на lvalue" (непостоянная), которая ссылается на значение, которое может записать пользователь ссылки.

```cppwinrt
template<typename T> T& get_by_lvalue_ref() { ... } // Get by lvalue (non-const) reference.
template<typename T> void set_by_lvalue_ref(T&) { ... } // Set by lvalue (non-const) reference.
```

Ссылку на lvalue можно привязать к lvalue, но не к rvalue.

Существуют постоянные ссылки на lvalue (`T const&`), которые ссылаются на объекты, в которые пользователь, использующий ссылку, *не может* записывать данные (например, константа).

```cppwinrt
template<typename T> T const& get_by_lvalue_cref() { ... } // Get by lvalue const reference.
template<typename T> void set_by_lvalue_cref(T const&) { ... } // Set by lvalue const reference.
```

Постоянную ссылку на lvalue можно привязать к lvalue или rvalue.

Синтаксис ссылки на rvalue типа `T` записывается как `T&&`. Ссылка на rvalue указывает на перемещаемое значение &mdash;, содержимое которого не требуется сохранять после использования (например, временное значение). Так как весь смысл состоит в перемещении (то есть изменении) значения, привязанного к ссылке на rvalue, квалификаторы `const` и `volatile` (также известные как CV-квалификаторы) не применяются к ссылкам на rvalue.

```cppwinrt
template<typename T> T&& get_by_rvalue_ref() { ... } // Get by rvalue reference.
struct A { A(A&& other) { ... } }; // A move constructor takes an rvalue reference.
```

Ссылка на rvalue привязывается к rvalue. На самом деле, с точки зрения разрешения перегрузки, rvalue *предпочтительнее* привязывать к ссылке на rvalue, чем к постоянной ссылке на lvalue. Но ссылку на rvalue невозможно привязать к lvalue, ведь, как мы сказали, ссылка на rvalue указывает на значение, содержимое которого не предполагается сохранять (например, параметр для конструктора перемещения).

Можно также передать rvalue, где ожидается аргумент по значению, с помощью конструкции копирования (или конструкции перемещения, если значение rvalue — это xvalue).

## <a name="a-glvalue-has-identity-a-prvalue-does-not"></a>У значения glvalue имеется идентификатор, а у значения prvalue — нет
На этом этапе мы знаем, что такое идентификатор. И мы знаем, что может быть перемещено, а что — нет. Но мы еще не назвали набор значений, у которых *нет* идентификатора. Этот набор называется значениями *prvalue*, или *чистыми значениями rvalue*.

```cppwinrt
int& get_by_ref() { ... }
int get_by_val() { ... }

int main()
{
    int* addr3{ &(get_by_ref() + 1) }; // Error: get_by_ref() + 1 is a prvalue.
    int* addr4{ &get_by_val() }; // Error: get_by_val() is a prvalue.
}
```

![У значения lvalue имеется идентификатор, а у значения prvalue — нет](images/has-identity2.png)

## <a name="the-complete-picture-of-value-categories"></a>Полная картина категорий значений
Остается только объединить сведения и рисунки, приведенные выше, в одно большие изображение.

![Полная картина категорий значений](images/value-categories.png)

### <a name="glvalue-i"></a>glvalue (i)
У glvalue (универсальное значение lvalue) имеется идентификатор.

### <a name="lvalue-im"></a>lvalue (i\&\!m)
У lvalue (относится к типу glvalue) имеется идентификатор, но его невозможно перемещать. Обычно это доступные для чтения и записи значения, передаваемые с помощью ссылки, постоянной ссылки или значения, если копирование не требует больших затрат. Невозможно привязать значение lvalue к ссылке на rvalue.

### <a name="xvalue-im"></a>xvalue (i\&m)
Значение xvalue (относящееся к типу glvalue, но также являющееся разновидностью rvalue) имеет идентификатор и может быть перемещено. Это может быть прежнее значение lvalue, которое вы решили переместить, так как копирование является ресурсоемким, и вы не допустите обращений к нему после этого. Вот как значение lvalue можно превратить в значение xvalue.

```cppwinrt
struct A { ... };
A a; // a is an lvalue...
static_cast<A&&>(a); // ...but this expression is an xvalue.
```

В приведенном выше примере кода мы еще ничего не перемещали. Мы только создали значение xvalue путем приведения lvalue к неименованной ссылке на rvalue. Его по-прежнему можно идентифицировать по имени lvalue. А так как это значение xvalue, его *можно* перемещать. Чтобы узнать причины для этого и изучить подробное описание перемещения, придется дождаться выпуска другого раздела. Однако можно считать, что "x" в имени xvalue означает "expert-only" (только для специалистов), если вам так проще. Приведя значение lvalue к xvalue (относящемуся к типу rvalue), мы делаем возможной его привязку к ссылке на rvalue.

Ниже приведены другие примеры значений xvalue &mdash; вызов функции, возвращающей неименованную ссылку на rvalue, которая обращается к элементу xvalue.

```cppwinrt
struct A { int m; };
A&& f();
f(); // This expression is an xvalue...
f().m; // ...and so is this.
```

### <a name="prvalue-im"></a>prvalue (\!i\&m)
Значение prvalue ("чистое значение rvalue", относится к типу rvalue) не имеет идентификатора, но может быть перемещено. Обычно это временные значения, результат вызова функции, которая возвращает значение, или результат вычисления другого выражения, не являющийся значением glvalue.

### <a name="rvalue-m"></a>rvalue (m)
Значение rvalue допускает перемещение. *Ссылка* на rvalue всегда указывает на rvalue (значение, содержимое которого не предполагается сохранять).

Но является ли ссылка на rvalue самим значением rvalue? *Неименованная* ссылка на rvalue (см. примеры кода с xvalue выше) является значением xvalue, то есть она представляет собой значение rvalue. Ее предпочтительнее привязывать к параметру функции ссылки на rvalue, например, конструктора перемещения. И наоборот (что может противоречить логике), если у ссылки на rvalue есть имя, то выражение, состоящее из этого имени, является значением lvalue. Поэтому его *невозможно* привязать к параметру ссылки на rvalue. Но это легко обеспечить &mdash; нужно просто привести его к неименованной ссылке на rvalue (xvalue).

```cppwinrt
void foo(A&) { ... }
void foo(A&&) { ... }
void bar(A&& a) // a is a named rvalue reference; it's an lvalue.
{
    foo(a); // Calls foo(A&).
    foo(static_cast<A&&>(a)); // Calls foo(A&&).
}
A&& get_by_rvalue_ref() { ... } // This unnamed rvalue reference is an xvalue.
```

### <a name="im"></a>\!i\&\!m
Мы еще не рассмотрели тип значения, у которого нет идентификатора и которое невозможно переместить. Но его можно проигнорировать, так как эта категория ничем не полезна для языка C++.

## <a name="reference-collapsing-rules"></a>Правила сворачивания ссылок
Несколько ссылок & в выражении (ссылка на lvalue на ссылку на lvalue или ссылка на rvalue на ссылку rvalue) отменяют друг друга.

- `A& &` сворачивается в `A&`.
- `A&& &&` сворачивается в `A&&`.

Несколько ссылок && в выражении сворачиваются в ссылку на lvalue.

- `A& &&` сворачивается в `A&`.
- `A&& &` сворачивается в `A&`.

## <a name="forwarding-references"></a>Пересылаемые ссылки
В заключительном разделе ссылки на rvalue, которые мы уже изучили, сравниваются с другим понятием — *пересылаемыми ссылками*.

```cppwinrt
void foo(A&& a) { ... }
```

- `A&&` является ссылкой на rvalue, как было показано ранее. Понятия "постоянный" и "переменный" не применяются к ссылкам на rvalue.
- `foo` принимает только значения rvalue типа **A**.
- Смысл ссылок на rvalue (например, `A&&`) состоит в том, что можно создать перегрузку, которая оптимизирована на случай передачи временного значения (или другого значения rvalue).

```cppwinrt
template <typename _Ty> void bar(_Ty&& ty) { ... }
```

- `_Ty&&` — это *пересылаемая ссылка*. В зависимости от того, что передается в `bar`, типом **_Ty** может быть константа или не константа независимо от того, переменный он или нет.
- `bar` принимает любое значение lvalue или rvalue типа **_Ty**.
- При передаче значения lvalue пересылаемая ссылка принимает вид `_Ty& &&`, который сворачивается в ссылку на lvalue `_Ty&`.
- При передаче значения rvalue пересылаемая ссылка принимает вид `_Ty&& &&`, который сворачивается в ссылку на rvalue `_Ty&&`.
- Пересылаемые ссылки (например, `_Ty&&`) предназначены *не* для оптимизации, а для того, чтобы можно было просто и эффективно переслать передаваемое значение. Вероятно, вы столкнетесь с пересылаемыми ссылками только в том случае, если будете создавать (или внимательно изучать) код библиотеки &mdash; например, стандартную функцию, которая пересылает аргументы конструктора.

## <a name="sources"></a>Источники
* \[Stroustrup, 2013\] Страуструп Б. "The C++ Programming Language, Fourth Edition". Addison-Wesley. 2013.
