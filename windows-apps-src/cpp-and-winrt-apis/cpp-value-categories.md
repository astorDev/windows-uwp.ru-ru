---
author: stevewhims
description: В этом разделе описываются различные категории значения, существующие в C++. Вы несомненно Херд значениями и rvalues, но существуют другие типы слишком.
title: Значение категории и ссылки на них
ms.author: stwhi
ms.date: 08/11/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: Windows 10, uwp, стандартный, c ++, cpp, winrt, проекции, перемещение, пересылки, значение категорий, семантика перемещения, точную пересылку, lvalue, rvalue, glvalue, prvalue, xvalue
ms.localizationpriority: medium
ms.openlocfilehash: cbccaf78b45d85d93619977d149431c4eec9e10a
ms.sourcegitcommit: 9c79fdab9039ff592edf7984732d300a14e81d92
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/23/2018
ms.locfileid: "2814676"
---
# <a name="value-categories-and-references-to-them"></a>Значение категории и ссылки на них
В этом разделе описываются различные категории значения (и справочные материалы, которые значения), существующих в C++. Вы несомненно Херд *значениями* и *rvalues*, но вы думаете их в условия, которые в данном разделе приведено. А также существуют другие виды значений, слишком.

Каждое выражение в C++ возвращает значение, которое принадлежит к одной из категорий, обсуждаемые в этом разделе. Существует аспектов языка C++, facilies и правила, которые требуют правильного общее представление о следующих категорий значение и ссылки на них. Например получение адреса значения, копирование значения, перемещение значение и значение на другой функции переадресации. В этом разделе не в все аспекты подробно, но предоставляет сведения о базовых для представление о из них.

Сведения в этом разделе является рамке с точки зрения анализа Страуструпа значение категорий с двух независимых Свойства identity и movability [Страуструп 2013].

## <a name="an-lvalue-has-identity"></a>Lvalue имеет удостоверение
Что означает для значения для *свойства IDENTITY*? Если у вас есть (или вы можете воспользоваться) адрес памяти значения и используйте его безопасно, имеет значение identity. Таким образом, можно выполнить более одного сравнить содержимое значения: можно сравнить или различить их по идентификатору.

*Lvalue* имеет удостоверения. Теперь это делается путем только исторические интересов, что «l» в «lvalue» — аббревиатура «left» (как и в, левой части присваивания). В C++ lvalue могут появляться, слева *или* справа от назначения. Символ «l» в «значениями», затем щелкните не помогают фактически более понятными и определить, что такое. Необходимо только понимать, что настроенным lvalue значение с идентификатором.

Примеры выражений, которые являются значениями: именованные переменной или константы; или функция, которая возвращает ссылку на. Примеры выражений, которые *не* значениями: временное; или функции, которая возвращает по значению.

```cppwinrt
int& get_by_ref() { ... }
int get_by_val() { ... }

int main()
{
    std::vector<byte> vec{ 99, 98, 97 };
    std::vector<byte>* addr1{ &vec }; // ok: vec is an lvalue.
    int* addr2{ &get_by_ref() }; // ok: get_by_ref() is an lvalue.

    int* addr3{ &(get_by_ref() + 1) }; // Error: get_by_ref() + 1 is not an lvalue.
    int* addr4{ &get_by_val() }; // Error: get_by_val() is not an lvalue.
}
```

Теперь хотя значение true, оператор, что значениями имеют идентификатор, поэтому выполните xvalues. Мы будем более перейдите в какой *xvalue* далее в этом разделе. Сейчас только что следует учитывать, что значение категорию с именем glvalue, для «обобщенный lvalue». Расширенный набор glvalues содержит значениями (также известной как *Классические значениями*) и xvalues. Таким образом, в то время как «lvalue имеет удостоверение» имеет значение true, то, что удостоверение полный набор — это набор glvalues, как показано на этом рисунке.

![Lvalue имеет удостоверение](images/has-identity1.png)

## <a name="an-rvalue-is-movable-an-lvalue-is-not"></a>Rvalue может быть перемещена; не является lvalue
Однако существует значения, которые не являются glvalues. Следовательно являются значения, которые *не могут* получить адрес памяти для (или нельзя полагаться на все). Мы видели такие значения в предыдущем примере кода. Это может показаться недостаток. Но в действительности преимуществами значение, можно *переместить* из нее (который обычно недорогих), а не копировать из нее (который обычно требуют). Перемещение из значение означает, что больше не в том месте, которое должно быть. В результате пытается получить к нему доступ на месте, которое должно быть — это что-то, чтобы исключить. Обсуждение и когда *как* переместить почтовые значение находится вне области действия для этого раздела. Для этого раздела мы только что необходимо знать, что значение, которое может быть перемещена называется *rvalue* (или *Классические rvalue*).

«R» в «rvalue» — аббревиатура «справа» (как и в, справа части назначения). Однако можно использовать rvalues и справочные материалы, которые rvalues за пределами назначений. «R» в «rvalues», затем щелкните не самое уделено. Необходимо только понимать, что настроенным rvalue — это значение, которое может быть перемещена.

Lvalue, с другой стороны, не является перемещаемой, как показано на этом рисунке. Lvalue, перемещены бы пример изменяет определения *lvalue*и он использовался бы для кода, которые ожидаются очень достаточно могли получать lvalue произошла непредвиденная ошибка.

![Rvalue может быть перемещена; не является lvalue](images/is-movable.png)

Невозможно переместить lvalue. Но существует *—* это тип glvalue (набор того, что с удостоверением), вы можете переместить&mdash;Если вы знаете, что делает (в том числе, не следует обратиться к ней после перемещения)&mdash;и это xvalue. Мы вернетесь этой идеи еще раз ниже, когда мы рассмотрим полную картину значение категории.

## <a name="rvalue-references-and-reference-binding-rules"></a>Ссылки rvalue, а также правила ссылку привязки
В этом разделе представлены синтаксис для ссылки на rvalue. Мы должны ожидать в другой раздел, чтобы перейти в значительно сократить объем обработка перемещения и переадресации, но они являются проблем, которые решить с помощью ссылки rvalue. Перед мы рассмотрим ссылки rvalue, тем не менее, мы сначала требуется получить более четкую о `T&` &mdash;самое мы ранее вызов только что «ссылки». Это действительно «(не являющиеся const) ссылки lvalue», которая указывает значение, к которому можно написать пользователя справочные материалы по.

```cppwinrt
template<typename T> T& get_by_lvalue_ref() { ... } // Get by lvalue (non-const) reference.
template<typename T> void set_by_lvalue_ref(T&) { ... } // Set by lvalue (non-const) reference.
```

Ссылки lvalue можно привязать lvalue, но не rvalue.

Затем lvalue const ссылок (`T const&`), который ссылок на объекты, на которых пользователь ссылку, *не могут* отправлять (например, константа).

```cppwinrt
template<typename T> T const& get_by_lvalue_cref() { ... } // Get by lvalue const reference.
template<typename T> void set_by_lvalue_cref(T const&) { ... } // Set by lvalue const reference.
```

Const ссылки lvalue можно связать с lvalue или rvalue.

Синтаксис для ссылки на rvalue тип `T` записывается в виде `T&&`. Ссылка rvalue указывает перемещаемой значение&mdash;значение, содержимое которого не требуется сохранить после мы использовали его (например, временное). Начиная с смысл перемещение из (тем самым изменение) значение привязан к ссылка rvalue, `const` и `volatile` классификаторы (также известной как резюме классификаторы), не применяются к ссылки rvalue.

```cppwinrt
template<typename T> T&& get_by_rvalue_ref() { ... } // Get by rvalue reference.
struct A { A(A&& other) { ... } }; // A move constructor takes an rvalue reference.
```

Ссылка rvalue связывает rvalue. На самом деле терминах разрешение перегрузки rvalue *предпочитает* привязаны к ссылка rvalue чем для ссылки lvalue const. Однако ссылка rvalue не могут связывать с lvalue, поскольку, как мы сказали, ссылка rvalue ссылается на значение, содержимое которого предполагается мы не требуется сохранить (скажем, параметр для перемещения конструктора).

Можно также передать rvalue там, где требуется аргумент по значению, путем создания копии (или с помощью конструкции move, если rvalue xvalue).

## <a name="a-glvalue-has-identity-a-prvalue-does-not"></a>Glvalue имеет удостоверение; не поддерживает prvalue
На этом этапе мы знаем, что имеет удостоверения. И мы знаем, что может быть перемещена и что не будет. Но мы еще не, но при этом именованный набор значений, *не* имеют удостоверение. Этот набор называется *prvalue*или *чисто rvalue*.

```cppwinrt
int& get_by_ref() { ... }
int get_by_val() { ... }

int main()
{
    int* addr3{ &(get_by_ref() + 1) }; // Error: get_by_ref() + 1 is a prvalue.
    int* addr4{ &get_by_val() }; // Error: get_by_val() is a prvalue.
}
```

![Lvalue имеет удостоверение; не поддерживает prvalue](images/has-identity2.png)

## <a name="the-complete-picture-of-value-categories"></a>Полную картину значение категории
Он остается только объединить сведения и рисунках выше в single, большой рисунок.

![Полную картину значение категории](images/value-categories.png)

### <a name="glvalue-i"></a>glvalue (i)
Glvalue (обобщенных lvalue) имеет удостоверения.

### <a name="lvalue-im"></a>lvalue (i\ & \!m)
Lvalue (тип glvalue) имеет удостоверение, но не будет перемещать. Это обычно чтения и записи значения, переданные вокруг по ссылке или с помощью ссылки на const или по значению при копировании недорогих. Ссылка rvalue не может быть связана lvalue.

### <a name="xvalue-im"></a>xValue (i\ & млн.)
Xvalue (вид glvalue, но также вид rvalue) имеет удостоверение, а также может быть перемещена. Это может быть lvalue командлета, которое было решено переместить, поскольку копирование обычно высоки, и вы будете не следует обратиться к ней позже. Вот как можно преобразовать в xvalue lvalue.

```cppwinrt
struct A { ... };
A a; // a is an lvalue...
static_cast<A&&>(a); // ...but this expression is an xvalue.
```

В примере кода выше мы еще не перемещаются что-либо еще. Мы только что создали xvalue путем приведения lvalue для ссылка неименованного rvalue. По-прежнему можно указать по имени lvalue; но, как xvalue, теперь *поддерживают* происходит перемещение. Причины выполнения таким образом, и какие перемещение фактически выглядит, будут иметь следует ожидать в другой раздел. Однако можно представить «x» в «xvalue» только для значения «expert» Если, позволяющая. Путем приведения lvalue в xvalue (тип rvalue), значение становится для привязки к ссылка rvalue.

Ниже приведены два других примера xvalues&mdash;вызов функции, которая возвращает ссылку на неименованного rvalue и доступ к должна быть членом xvalue.

```cppwinrt
struct A { int m; };
A&& f();
f(); // This expression is an xvalue...
f().m; // ...and so is this.
```

### <a name="prvalue-im"></a>prvalue (\!i\ & млн.)
Prvalue (чисто rvalue; вид rvalue) не задан параметр identity, но может быть перемещена. Это обычно временных переменных, в результате вызов функции, которая возвращает значение или результат вычисления любое выражение, которое не является glvalue

### <a name="rvalue-m"></a>rvalue (млн.)
Rvalue может быть перемещена. *Справочник по* rvalue всегда относится к rvalue (значение, содержимое которого предполагается мы не требуется, чтобы сохранить).

Но — это ссылка rvalue самого rvalue? *Неименованные* ссылка rvalue (например, показанным в приведенном выше примере кода xvalue) — это xvalue Да, Да, это rvalue. Предпочтительный соблюдать параметру rvalue Справочник по функции, например, конструктором перемещения. С другой стороны (и возможно counter-intuitively) Если ссылка rvalue имеет имя, а затем lvalue — это выражение, состоящее из этого имени. Поэтому он *не может* быть связана параметр ссылки rvalue. Но его можно было делать это&mdash;только что привести его к ссылка неименованного rvalue (xvalue).

```cppwinrt
void foo(A&) { ... }
void foo(A&&) { ... }
void bar(A&& a) // a is a named rvalue reference; it's an lvalue.
{
    foo(a); // Calls foo(A&).
    foo(static_cast<A&&>(a)); // Calls foo(A&&).
}
A&& get_by_rvalue_ref() { ... } // This unnamed rvalue reference is an xvalue.
```

### <a name="im"></a>\!i\ & \!m
Вид значение, которое не задан параметр identity и не будет перемещать является одной комбинации, мы еще не рассматриваются. Но мы его можно проигнорировать, поскольку этой категории не будет полезно представление на языке C++.

## <a name="reference-collapsing-rules"></a>Справочник по свертывание правил
Несколько ссылок like в выражении (ссылки lvalue для ссылки lvalue или ссылка rvalue к ссылка rvalue) отменить один другой ожидания.

- `A& &` не свернется в `A&`.
- `A&& &&` не свернется в `A&&`.

Для ссылки lvalue свернуть несколько, в отличие от ссылки в выражении.

- `A& &&` не свернется в `A&`.
- `A&& &` не свернется в `A&`.

## <a name="forwarding-references"></a>Переадресация справочные материалы
В этом последнем разделе проводится сравнение ссылки rvalue, которые мы еще рассматриваются, различных концепция *переадресации ссылку*.

```cppwinrt
void foo(A&& a) { ... }
```

- `A&&` — Это ссылка rvalue, как показано. Const и переменные не применимы к ссылки rvalue.
- `foo` принимает только rvalues типа **A**.
- Создание ссылки rvalue причине (такие как `A&&`) существует для того, можно создать перегрузку, который оптимизирован для в случае временного (или другие rvalue), передаваемых.

```cppwinrt
template <typename _Ty> void bar(_Ty&& ty) { ... }
```

- `_Ty&&` — Это *переадресации ссылку*. В зависимости от того, передаваемого в `bar`, тип **_Ty** может быть const и не const независимо от переменные/долговременного.
- `bar` принимает любые lvalue или rvalue тип **_Ty**.
- Передача lvalue делает ссылку переадресации становятся `_Ty& &&`, который сворачивает ссылки lvalue `_Ty&`.
- Передача rvalue делает ссылку переадресации становятся `_Ty&& &&`, который сворачивает ссылка rvalue `_Ty&&`.
- Причина переадресации справочные материалы (таких как `_Ty&&`) существует — *не* для оптимизации, но чтобы сделать что передаваемого в них и переадресация на, прозрачно и эффективно. Вы будете придется иметь дело ссылку переадресации только в том случае, если запись (или внимательно изучите) код библиотеки&mdash;, например фабрики функция, которая перенаправляет на аргументы конструктора.

## <a name="sources"></a>"Источники"
* \[Stroustrup, 2013\] Страуструп б.: язык программирования C++, четвертый Edition. Addison по разработке. 2013.
