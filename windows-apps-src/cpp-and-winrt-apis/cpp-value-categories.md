---
author: stevewhims
description: В этом разделе описываются различные категорий значения, которые существуют в C++. Вы несомненно слышали значениями и rvalues, но существуют другие типы слишком.
title: Категории значений и ссылки на них
ms.author: stwhi
ms.date: 08/11/2018
ms.topic: article
keywords: Windows 10, uwp, стандартные, c ++, cpp, winrt, проекция, перемещения, перенаправление, значения категорий, семантику перемещения, точная пересылка, lvalue, rvalue, glvalue, prvalue, xvalue
ms.localizationpriority: medium
ms.openlocfilehash: b600c09c3629ce52590daa42b9046fab3784a78f
ms.sourcegitcommit: e814a13978f33654d8e995584f4b047cb53e0aef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/05/2018
ms.locfileid: "6031778"
---
# <a name="value-categories-and-references-to-them"></a>Категории значений и ссылки на них
В этом разделе описываются различные категории значений (и ссылки на значения), которые существуют в C++. Вы несомненно слышали *значениями* и *rvalues*, но может не представить их в термины, которые в этом разделе представлены. Также существуют другие типы значений, слишком.

Каждое выражение на языке C++ возвращает значение, которое принадлежит к одной из категорий, описанные в этой статье. Существует аспектов языка C++, facilies и правила, которые требуют правильного понять эти значения категорий и ссылки на них. Например получение адреса значения, копирование значение, перемещения значение и переадресации значение на другой функции. В этом разделе не помещаются в все эти аспекты глубины, но он Основополагающая информацию для сплошной понять их.

Информация в этом разделе разбиваются на кадры с точки зрения анализа Страуструпа значения категорий по два независимых свойства удостоверения и movability [Страуструп 2013].

## <a name="an-lvalue-has-identity"></a>Lvalue у удостоверения
Что означает значение иметь *удостоверение*? Если у вас (или может занять) адреса памяти значения и использовать его безопасно, то значение состоит из удостоверения. Таким образом, можно сделать более чем сравнение содержимое значения: можно сравнить или отличить их по идентификатору.

*Lvalue* у удостоверения. Теперь это делается путем только истории объектов, что «l» на «lvalue» представляет собой сокращение от «влево» (как показано, левой части назначения). В C++ lvalue может отображаться слева *или* справа от назначения. «L» на «значениями», затем не помогают фактически воспринимать, а также определить, какие. Вам нужно только понимать, что так мы называем lvalue является значение, которое имеет удостоверения.

Примеры выражений, которые являются значениями: именованной переменной или константы; или функцию, которая возвращает ссылку. Примеры выражения, которые *не* значениями: временный; или функции, которая возвращает значение.

```cppwinrt
int& get_by_ref() { ... }
int get_by_val() { ... }

int main()
{
    std::vector<byte> vec{ 99, 98, 97 };
    std::vector<byte>* addr1{ &vec }; // ok: vec is an lvalue.
    int* addr2{ &get_by_ref() }; // ok: get_by_ref() is an lvalue.

    int* addr3{ &(get_by_ref() + 1) }; // Error: get_by_ref() + 1 is not an lvalue.
    int* addr4{ &get_by_val() }; // Error: get_by_val() is not an lvalue.
}
```

Теперь хотя это утверждение верно, что значениями имеют идентификатор, делать xvalues. Мы будем рассмотрим более какие *xvalue* далее в этой статье. Сейчас просто не забывайте, что существует категорию значение с именем glvalue, для «обобщенными lvalue». Расширенный вариант возможности glvalues содержит значениями (также известной как *Классические значениями*) и xvalues. Таким образом, пока «lvalue у удостоверения» имеет значение true, полный набор действий, которые имеют удостоверение — набор glvalues, как показано на следующем рисунке.

![Lvalue у удостоверения](images/has-identity1.png)

## <a name="an-rvalue-is-movable-an-lvalue-is-not"></a>Rvalue является перемещаемой; не является lvalue
Но есть значения, которые не являются glvalues. Следовательно существует значения, которые *не могут* получить адрес памяти для (или менее нельзя полагаться на его, чтобы быть действительным). Мы увидели таких значений в приведенном выше примере кода. Это может показаться недостаток. Но на самом деле, преимуществами значение нравится то есть можно *переместить* из него (это обычно требовательны), а не скопировать из него (это обычно требуют). Переход с значение означает, что больше не на месте, которое должно быть. Таким образом при попытке доступа к нему в месте, которое должно быть-то избегать. Описание того, где и *как* переместить значение выходит за рамки данного раздела. В этом разделе мы просто нужно знать, что значение, которое может быть перемещена называется *rvalue* (или *Классические rvalue*).

«R» в «rvalue» представляет собой сокращение от «вправо» (как показано, справа части присваиваться). Однако вы можете использовать rvalues и ссылки на rvalues за пределами назначения. «R» в «rvalues», то, не самое сосредоточиться на. Вам нужно только понять, что мы вызываем метод rvalue — это значение, которое может быть перемещена.

Lvalue, и наоборот, не является перемещаемой, как показано на следующем рисунке. Lvalue, которая движется бы пример изменяет определение *lvalue*и было бы произошла непредвиденная ошибка для кода, который очень некую должны иметь возможность продолжать осуществлять доступ к lvalue.

![Rvalue является перемещаемой; не является lvalue](images/is-movable.png)

Не удается переместить lvalue. Однако существует *—* своего рода glvalue (набор действий с помощью удостоверения), который можно переместить&mdash;Если вы знаете, что вы делаете (в том числе необходимо указать не получить к ним доступ после перемещения)&mdash;это xvalue. Мы будем вернемся к предыдущему Эта идея еще раз ниже, когда мы рассмотрим полную картину значения категорий.

## <a name="rvalue-references-and-reference-binding-rules"></a>Ссылки rvalue и правила привязки ссылки
В этом разделе рассматриваются синтаксис для ссылки на rvalue. Мы будем придется ждать другой раздел произведите существенных обработка перемещения и пересылки, но это и есть проблемы, которые решена ссылки rvalue. Прежде чем мы рассмотрим ссылки rvalue, тем не менее, сначала необходимо будет лучше понимает `T&` &mdash;самое мы ранее вызова просто «ссылки». Это действительно «(без const) ссылки lvalue», который ссылается на значение, к которому можно написать пользователь ссылки.

```cppwinrt
template<typename T> T& get_by_lvalue_ref() { ... } // Get by lvalue (non-const) reference.
template<typename T> void set_by_lvalue_ref(T&) { ... } // Set by lvalue (non-const) reference.
```

Ссылки lvalue можно привязать lvalue, но не rvalue.

То есть lvalue const ссылки (`T const&`), который ссылки на объекты, для которых пользователя, который ссылку, *не может* записывать (например, константа).

```cppwinrt
template<typename T> T const& get_by_lvalue_cref() { ... } // Get by lvalue const reference.
template<typename T> void set_by_lvalue_cref(T const&) { ... } // Set by lvalue const reference.
```

Const ссылки lvalue можно привязать к lvalue или rvalue.

Синтаксис для ссылки на rvalue типа `T` записывается в виде `T&&`. Ссылка rvalue относится к перемещаемой значение&mdash;значение, содержимое которого нам не нужно сохранить после мы использовали его (например, временный). С момента суть для перемещения (тем самым меняющимся) значение привязано к ссылка rvalue, `const` и `volatile` квалификаторы (также известной как cv квалификаторы) не относятся к ссылки rvalue.

```cppwinrt
template<typename T> T&& get_by_rvalue_ref() { ... } // Get by rvalue reference.
struct A { A(A&& other) { ... } }; // A move constructor takes an rvalue reference.
```

Ссылка rvalue привязывается к rvalue. На самом деле, с точки зрения разрешение перегрузки rvalue *предпочитает* привязан к ссылка rvalue чем к const ссылки lvalue. Но ссылка rvalue невозможно привязать к lvalue, поскольку, как говорилось, ссылка rvalue ссылается на значение, содержимое которого предполагается, нам не нужно сохранить (скажем, параметра для конструктора перемещения).

Можно также передать rvalue там, где ожидается по значению аргумента, путем копирования при создании (или с помощью конструкции перемещения, если rvalue xvalue).

## <a name="a-glvalue-has-identity-a-prvalue-does-not"></a>Glvalue имеет удостоверение; не prvalue
На этом этапе мы знаем, что у удостоверения. И мы знаем, что является перемещаемой чего нет. Но мы еще не именованный набор значений, *не* имеют идентификаторов. Этот набор называют *prvalue*или *чисто rvalue*.

```cppwinrt
int& get_by_ref() { ... }
int get_by_val() { ... }

int main()
{
    int* addr3{ &(get_by_ref() + 1) }; // Error: get_by_ref() + 1 is a prvalue.
    int* addr4{ &get_by_val() }; // Error: get_by_val() is a prvalue.
}
```

![Lvalue есть удостоверение; не prvalue](images/has-identity2.png)

## <a name="the-complete-picture-of-value-categories"></a>Полную картину значения категорий
Он остается только объединить сведения и иллюстрациях выше в единый, большой рисунок.

![Полную картину значения категорий](images/value-categories.png)

### <a name="glvalue-i"></a>glvalue (i)
Glvalue (универсальный lvalue) имеет удостоверения.

### <a name="lvalue-im"></a>lvalue (i\ & \!m)
Lvalue (типа glvalue) имеет удостоверения, но не перемещаемым. Это обычно чтения и записи значений, которые вы передаете вокруг ссылку или ссылка const или значение при копировании не требовательны. Lvalue не могут быть привязаны к ссылка rvalue.

### <a name="xvalue-im"></a>xValue (i\ & m)
Xvalue (своего рода glvalue, но также своего рода rvalue) имеет удостоверения, а также может быть перемещена. Это может быть lvalue командлета, который вы решили переместить, поскольку копирование является затратной, и вы будете внимательны, чтобы не получить к нему доступ позже. Вот как можно приступить к lvalue xvalue.

```cppwinrt
struct A { ... };
A a; // a is an lvalue...
static_cast<A&&>(a); // ...but this expression is an xvalue.
```

В приведенном выше примере кода мы еще не перешли что-либо еще. Мы только что создали xvalue путем преобразования lvalue для ссылка безымянных rvalue. Это по-прежнему можно идентифицировать по имени lvalue; но, как xvalue теперь *поддержкой* перемещения. Причины выполнения таким образом, и какие перемещения выглядит на самом деле, придется ждать другой раздел. Однако можно представить себе «x» в «xvalue» как значение «эксперта» только если, позволяющая. Путем преобразования lvalue в xvalue (тип rvalue), то это значение становится может уже привязан к ссылка rvalue.

Ниже приведены другие примеры xvalues&mdash;вызова функции, которая возвращает ссылка безымянных rvalue и доступ к членом xvalue.

```cppwinrt
struct A { int m; };
A&& f();
f(); // This expression is an xvalue...
f().m; // ...and so is this.
```

### <a name="prvalue-im"></a>prvalue (\!i\ & m)
Prvalue (чисто rvalue; своего рода rvalue) не имеет удостоверения, но может быть перемещена. Обычно они развертываются временных переменных, результат вызова функции, которая возвращает значение или результат вычисления выражения, который не является glvalue

### <a name="rvalue-m"></a>rvalue (мин)
Rvalue является перемещаемой. *Справочник по* rvalue всегда относится к rvalue (значение, содержимое которого предполагается, нам не нужно сохранить).

Но, ссылка rvalue сам rvalue? *Безымянных* ссылка rvalue (например, показанным в приведенных выше примерах кода xvalue) — это xvalue таким образом, Да, это rvalue. Он предпочитает можно привязать к параметр ссылки функции rvalue, например, конструктором перемещения. И наоборот (и возможно counter-intuitively) Если ссылка rvalue имеет имя, то выражением, состоящим из это имя будет lvalue. Поэтому он *не могут* быть привязаны к параметр ссылки rvalue. Но можно добиться того, поэтому&mdash;просто приведите его к ссылка безымянных rvalue (xvalue).

```cppwinrt
void foo(A&) { ... }
void foo(A&&) { ... }
void bar(A&& a) // a is a named rvalue reference; it's an lvalue.
{
    foo(a); // Calls foo(A&).
    foo(static_cast<A&&>(a)); // Calls foo(A&&).
}
A&& get_by_rvalue_ref() { ... } // This unnamed rvalue reference is an xvalue.
```

### <a name="im"></a>\!i\ & \!m
Вид значение, которое не имеет удостоверений и не перемещаемой представляет собой один сочетание, мы еще не обсуждали. Но мы его можно проигнорировать, связано с этой категорией полезно идея на языке C++.

## <a name="reference-collapsing-rules"></a>Сворачивание ссылку правила
Несколько like ссылок в выражении (ссылки lvalue для ссылки lvalue или ссылка rvalue к ссылка rvalue) отмените выбор одного другого ожидания.

- `A& &` Сворачивает в `A&`.
- `A&& &&` Сворачивает в `A&&`.

Несколько в отличие от ссылки в выражении свернуть, чтобы ссылки lvalue.

- `A& &&` Сворачивает в `A&`.
- `A&& &` Сворачивает в `A&`.

## <a name="forwarding-references"></a>Переадресации ссылки
В этом разделе, последний отличается rvalue ссылки на объекты, которые мы уже обсуждали, с помощью различных концепцию *переадресации ссылки*.

```cppwinrt
void foo(A&& a) { ... }
```

- `A&&` как мы выяснили, — это ссылка rvalue. Const и volatile не относятся к ссылки rvalue.
- `foo` принимает только rvalues типа **A**.
- Ссылки rvalue причина (такие как `A&&`) существует для того, вы можете создать перегрузку, которая оптимизирована для в случае временный (или другие rvalue), передаваемых.

```cppwinrt
template <typename _Ty> void bar(_Ty&& ty) { ... }
```

- `_Ty&&` — Это *переадресации ссылки*. В зависимости от того, вы передаете для `bar`, тип **_Ty** может быть const/без const независимо от volatile/энергонезависимой.
- `bar` принимает любой lvalue или rvalue тип **_Ty**.
- Передача lvalue вызывает ссылку переадресации стать `_Ty& &&`, который сворачивает ссылки lvalue `_Ty&`.
- Передача rvalue вызывает ссылку переадресации стать `_Ty&& &&`, которое сворачивает rvalue справочные материалы по `_Ty&&`.
- Причина переадресации ссылки (такие как `_Ty&&`) существует — *не* для оптимизации, но выполнить, что вы передаете для них и перенаправлять на, прозрачно и эффективно. Вы, скорее всего возникнуть ссылку переадресации только в том случае, если запись (или внимательно изучить) кода библиотеки&mdash;, функции фабрики, которая перенаправляет на аргументы конструктора.

## <a name="sources"></a>"Источники"
* \[Stroustrup, 2013\] Страуструп б.: язык программирования на C++, четвертого выпуск. Addison по разработке. 2013.
