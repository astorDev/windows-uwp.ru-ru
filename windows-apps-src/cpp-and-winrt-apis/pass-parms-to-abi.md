---
description: C++/WinRT упрощает передачу параметров в интерфейс ABI, обеспечивая автоматическое преобразование для общих случаев.
title: Передача параметров в границы интерфейса ABI
ms.date: 07/10/2019
ms.topic: article
keywords: Windows 10, UWP, стандартный, c++, cpp, winrt, проекция, передача, параметры, ABI
ms.localizationpriority: medium
ms.openlocfilehash: 9c5ce6a30e68fe6fc26316bc2f41c6e2556b98ef
ms.sourcegitcommit: 76e8b4fb3f76cc162aab80982a441bfc18507fb4
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/29/2020
ms.locfileid: "82255258"
---
# <a name="passing-parameters-into-the-abi-boundary"></a>Передача параметров в границы интерфейса ABI

Используя типы в пространстве имен **winrt::param**, C++/WinRT упрощает передачу параметров в границы ABI, обеспечивая автоматическое преобразование для общих случаев. Дополнительные сведения и примеры кода см. в руководстве по [обработке строк](/windows/uwp/cpp-and-winrt-apis/strings) и описании [стандартных типов данных С++ и C++/WinRT](/windows/uwp/cpp-and-winrt-apis/std-cpp-data-types).

> [!IMPORTANT]
> Не следует использовать типы в пространстве имен **winrt::param** самостоятельно. Они используются для проецирования.

Многие типы представлены синхронными и асинхронными версиями. C++/ WinRT использует синхронную версию, если параметр передается в синхронный метод, и асинхронную версию, если параметр передается в асинхронный метод. Асинхронная версия предусматривает выполнение дополнительных шагов, что усложняет для вызывающего объекта процесс изменения коллекции до завершения операции. Учтите, что ни один из вариантов не защищает коллекцию от изменений, вносимых другим потоком. Обеспечение защиты — это ваша задача.

## <a name="string-parameters"></a>Параметры строк

**winrt::param::hstring** упрощает передачу параметров в API, которые принимают **HSTRING**.

|Передаваемые типы|Примечания|
|-|-|
|`{}`|Передает пустую строку.|
|**winrt::hstring**||
|**std::wstring_view**|Для литералов можно написать `L"Name"sv`. Представление должно иметь нулевой символ в конце.|
|**std::wstring**|-|
|**wchar_t const\***|Строка с нулевым символом в конце.|

`nullptr` не допускается. Используйте `{}` вместо этого.

Компилятор знает, как обработать `wcslen` в строковых литералах во время компиляции. То есть для литералов `L"Name"sv` и `L"Name"` — это эквиваленты.

Учтите, что объекты **std::wstring_view** не имеют нулевой символ в конце, но для C++/WinRT требуется наличие такого символа в конце строки. Если вы передадите объект **std::wstring_view** без нулевого символа в конце, процесс будет завершен.

## <a name="iterable-parameters"></a>Итерируемые параметры

**winrt::param::iterable\<T\>** and **winrt::param::async_iterable\<T\>** упрощает передачу параметров в API, которые принимают **IIterable\<T\>** .

Коллекции среды выполнения Windows уже являются **IIterable**.

|Передаваемые типы|Sync|Async|Примечания|
|-|-|-|-|
| `nullptr` | Да | Да | Убедитесь, что базовый метод поддерживает `nullptr`.|
| **IIterable\<T\>** | Да | Да | Или что-то, что может быть соответствующим образом преобразовано.|
| **std::vector\<T\> const&** | Да | Нет ||
| **std::vector\<T\>&&** | Да | Да | Содержимое перемещается в итератор для предотвращения изменений.|
| **std::initializer_list\<T\>** | Да | Да | Асинхронная версия копирует элементы.|
| **std::initializer_list\<U\>** | Да | Нет | Необходимо, чтобы **U** можно было преобразовать в **T**.|
| `{ ForwardIt begin, ForwardIt end }` | Да | Нет | Необходимо, чтобы `*begin` можно было преобразовать в **T**.|

Обратите внимание, что **IIterable\<U\>** и **std::vector\<U\>** не разрешены, даже если **U** можно преобразовать в **T**. Для **std::vector\<U\>** можно использовать версию с двойным итератором (см. подробнее ниже).

В некоторых случаях существующий объект может фактически реализовать **IIterable**. Например, **IVectorView\<StorageFile\>** (производное от [**FileOpenPicker.PickMultipleFilesAsync**](/uwp/api/windows.storage.pickers.fileopenpicker.pickmultiplefilesasync)) реализует **IIterable<StorageFile>** . Но также возможна реализация **IIterable<IStorageItem>**  — нужно просто явно это задать.

```cppwinrt
IVectorView<StorageFile> pickedFiles{ co_await filePicker.PickMultipleFilesAsync() };
requestData.SetStorageItems(storageItems.as<IIterable<IStorageItem>>());
```

В других случаях можно использовать версию с двойным итератором.

```cppwinrt
std::vector<StorageFile> storageFiles;
requestData.SetStorageItems({ storageFiles.begin(), storageFiles.end() });
```

Двойной итератор используется, когда у вас есть коллекция, которая не соответствуют ни одному из приведенных выше сценариев. Вы можете использовать его для создания объектов, которые можно преобразовать в **T**. Мы использовали его выше для выполнения итерации по вектору на основе производных типов. Сейчас мы используем его для выполнения итерации не по вектору на основе производных типов.

```cppwinrt
std::array<StorageFile, 3> storageFiles;
requestData.SetStorageItems(storageFiles); // This doesn't work.
requestData.SetStorageItems({ storageFiles.begin(), storageFiles.end() }); // But this works.
```

Реализация [**IIterator\<T\>.GetMany(T\[\])** ](/uwp/api/windows.foundation.collections.iiterator-1.getmany) является более эффективной, если итератор представлен `RandomAcessIt`. В противном случае выполняется несколько проходов по диапазону.

|Передаваемые типы|Sync|Async|Примечания|
|-|-|-|-|
| `nullptr` | Да | Да | Убедитесь, что базовый метод поддерживает `nullptr`.|
| **IIterable\<IKeyValuePair\<K, V\>\>** | Да | Да | Или что-то, что может быть соответствующим образом преобразовано.|
| **std::map\<K, V\> const&** | Да | Нет ||
| **std::map\<K, V\>&&** | Да | Да | Содержимое перемещается в итератор для предотвращения изменений.|
| **std::unordered_map\<K, V\> const&** | Да | Нет ||
| **std::unordered_map\<K, V\>&&** | Да | Да | Содержимое перемещается в итератор для предотвращения изменений.|
| **std::initializer_list\<std::pair\<K, V\>\>** | Да | Да | Типы **K** и **V** должны точно совпадать. Ключи могут не дублироваться. Асинхронная версия копирует элементы.|
| `{ ForwardIt begin, ForwardIt end }` | Да | Нет | Необходимо, чтобы `begin->first` и `begin->second` можно было преобразовать в **K** и **V** соответственно.|

## <a name="vector-view-parameters"></a>Параметры представления векторов

**winrt::param::vector_view\<T\>** и **winrt::param::async_vector_view\<T\>** упрощают передачу параметров в API, которые принимают **IVectorView\<T\>** .

Можно использовать [**IVector\<T\>.GetView**](/uwp/api/windows.foundation.collections.ivector-1.getview) для получения **IVectorView** из **IVector**.

|Передаваемые типы|Sync|Async|Примечания|
|-|-|-|-|
| `nullptr` | Да | Да | Убедитесь, что базовый метод поддерживает `nullptr`.|
| **IVectorView\<T\>** | Да | Да | Или что-то, что может быть соответствующим образом преобразовано.|
| **std::vector\<T\>const&** | Да | Нет ||
| **std::vector\<T\>&&** | Да | Да | Содержимое перемещается в представление для предотвращения изменений.|
| **std::initializer_list\<T\>** | Да | Да | Типы должны полностью совпадать. Асинхронная версия копирует элементы.|
| `{ ForwardIt begin, ForwardIt end }` | Да | Нет | Необходимо, чтобы `*begin` можно было преобразовать в **T**.|

Версию с двойным итератором можно использовать для создания представлений объектов, которые нельзя передавать напрямую. Учтите, что так как векторы поддерживают произвольный доступ, мы рекомендуем передавать `RandomAcessIter`.

## <a name="map-view-parameters"></a>Параметры представления карт

**winrt::param::map_view\<T\>** и **winrt::param::async_map_view\<T\>** упрощают передачу параметров в API, которые принимают **IMapView\<T\>** .

Можно использовать **IMap::GetView** для получения **IMapView** из **IMap**.

|Передаваемые типы|Sync|Async|Примечания|
|-|-|-|-|
| `nullptr` | Да | Да | Убедитесь, что базовый метод поддерживает `nullptr`.|
| **IMapView\<K, V\>** | Да | Да | Или что-то, что может быть соответствующим образом преобразовано.|
| **std::map\<K, V\> const&** | Да | Нет ||
| **std::map\<K, V\>&&** | Да | Да | Содержимое перемещается в представление для предотвращения изменений.|
| **std::unordered_map\<K, V\> const&**  | Да | Нет ||
| **std::unordered_map\<K, V\>&&** | Да | Да | Содержимое перемещается в представление для предотвращения изменений.|
| **std::initializer_list\<std::pair\<K, V\>\>** | Да | Да | Элементы копируются как синхронными, так и асинхронными версиями. Дублировать ключи нельзя.|

## <a name="vector-parameters"></a>Параметры векторов

**winrt::param::vector\<T\>** упрощает передачу параметров в API, которые принимают **IVector\<T\>** .

|Передаваемые типы|Примечания|
|-|-|
| `nullptr` | Убедитесь, что базовый метод поддерживает `nullptr`.|
| **IVector\<T\>** | Или что-то, что может быть соответствующим образом преобразовано.|
| **std::vector\<T\>&&** | Содержимое перемещается в параметр для предотвращения изменений. Результаты не возвращаются.|
| **std::initializer_list\<T\>** | Содержимое копируется в параметр для предотвращения изменений.|

Если этот метод изменяет вектор, единственный способ отследить такое изменение — это передать **IVector** напрямую. Если передать **std::vector**, этот метод изменит копию, а не оригинал.

## <a name="map-parameters"></a>Параметры карт

**winrt::param::map\<T\>** упрощает передачу параметров в API, которые принимают **IMap\<T\>** .

|Передаваемые типы|Примечания|
|-|-|
| `nullptr` | Убедитесь, что базовый метод поддерживает `nullptr`.|
| **IMap\<T\>** | Или что-то, что может быть соответствующим образом преобразовано.|
| **std::map\<K, V\>&&** | Содержимое перемещается в параметр для предотвращения изменений. Результаты не возвращаются.|
| **std::unordered_map\<K, V\>&&** | Содержимое перемещается в параметр для предотвращения изменений. Результаты не возвращаются.|
| **std::initializer_list\<std::pair\<K, V\>\>** | Содержимое копируется в параметр для предотвращения изменений.|

Если этот метод изменяет карту, единственный способ отследить такое изменение — это передать **IMap** напрямую. Если передать **std::map** или **std::unordered_map**, этот метод изменит копию, а не оригинал.

## <a name="array-parameters"></a>Параметры массива

**Winrt::array_view\<T\>** не находится в пространстве имен **winrt::param**, но используется для параметров, которые являются массивами стиля C (*совместимыми массивами*).

|Передаваемые типы|Примечания|
|-|-|
| `{}` | Пустой массив.|
| **array** | Соответствующий массив C (то есть `C array[N];`), где **C** можно преобразовать в **T** и `sizeof(C) == sizeof(T)`. |
| **std::array<C, N>** | Объект C++ **std::array** (**C**), где **C** можно преобразовать в **T** и `sizeof(C) == sizeof(T)`. |
| **std::vector<C>** | Объект C++ **std::vector** (**C**), где **C** можно преобразовать в **T** и `sizeof(C) == sizeof(T)`. |
| `{ T*, T* }` | Пара указателей, которые представляют диапазон [begin, end).|
| **std::initializer_list\<T\>** ||

Кроме того, см. запись блога о [разных шаблонах передачи массивов в стиле языка C через границы среды выполнения Windows ABI](https://devblogs.microsoft.com/oldnewthing/20200205-00/?p=103398).