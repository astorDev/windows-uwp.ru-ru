---
description: C++/WinRT 2.0 позволяет откладывать уничтожение типов реализации и безопасно выполнять запросы во время этой операции. В этом разделе описываются эти функции и объясняется, когда их использовать.
title: Сведения о деструкторах
ms.date: 07/19/2019
ms.topic: article
keywords: windows 10, uwp, стандартная, c++, cpp, winrt, защита, отложенное удаление, безопасные запросы
ms.localizationpriority: medium
ms.openlocfilehash: 9806ea54665b24c246f2023714a14d94ec3bcc8e
ms.sourcegitcommit: 02cc7aaa408efe280b089ff27484e8bc879adf23
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/23/2019
ms.locfileid: "68387801"
---
# <a name="details-about-destructors"></a>Сведения о деструкторах

C++/WinRT 2.0 позволяет откладывать уничтожение типов реализации и безопасно выполнять запросы во время этой операции. В этом разделе описываются эти функции и объясняется, когда их использовать.

## <a name="deferred-destruction"></a>Отложенное удаление

В статье [Diagnosing direct allocations](/windows/uwp/cpp-and-winrt-apis/diag-direct-alloc) (Диагностика прямых выделений) мы упомянули, что ваш тип реализации не может содержать частный деструктор.

Преимущество общедоступного деструктора заключается в том, что он разрешает выполнять отложенное удаление, которое представляет собой возможность выявлять последний вызов [**IUnknown::Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) для объекта, а затем получать права владения таким объектом для откладывания его удаления на неопределенное время.

Напомним, что классические объекты модели COM изначально имеют счетчики ссылок, которыми управляют функции [**IUnknown::AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) и **IUnknown::Release**. В традиционной реализации метода **Release** деструктор на C++ объекта классической модели COM вызывается, когда значение счетчика ссылок достигает 0.

```cppwinrt
uint32_t WINRT_CALL Release() noexcept
{
    uint32_t const remaining{ subtract_reference() };
 
    if (remaining == 0)
    {
        delete this;
    }
 
    return remaining;
}
```

`delete this;` вызывает деструктор объекта до того, как будет освобождена память, занимаемая объектом. Такой подход хорошо работает при условии, что вам не нужно выполнять особые действия в деструкторе.

```cppwinrt
using namespace winrt::Windows::Foundation;
... 
struct Sample : implements<Sample, IStringable>
{
    winrt::hstring ToString() const;
 
    ~Sample() noexcept
    {
        // Too late to do anything interesting.
    }
};
```

Что подразумевается под *особыми действиями*? Начнем с того, что деструктор изначально является синхронным. Вы не можете переходить по потокам, например, если вам нужно удалить ресурсы определенных потоков в другом контексте. Вы не можете отправлять объекту надежные запросы на какой-нибудь другой интерфейс, который вам может потребоваться для освобождения определенных ресурсов. И это далеко не все. В случаях, когда удаление приводит к серьезным последствиям, вам потребуется более гибкое решение. Именно его и предоставляет функция C++/WinRT **final_release**.

```cppwinrt
struct Sample : implements<Sample, IStringable>
{
    winrt::hstring ToString() const;
 
    static void final_release(std::unique_ptr<Sample> ptr) noexcept
    {
        // This is the first stop...
    }
 
    ~Sample() noexcept
    {
        // ...And this happens only when *unique_ptr* finally deletes the object.
    }
};
```

Мы обновили реализацию C++/WinRT для метода **Release**, который теперь вызывает вашу функцию **final_release** сразу же, когда счетчик ссылок объекта достигает значения 0. В таком состоянии объект не имеет ожидающих обработки ссылок и получает эксклюзивные права владения собой. Это позволяет ему передавать права владения собой статической функции **final_release**.

То есть объект преобразует себя из объекта с поддержкой совместного владения в объект с эксклюзивными правами владения. Указатель **std::unique_ptr** имеет эксклюзивные права на владение объектом, поэтому он удалит объект в процессе обработки его семантики (чем и вызвана необходимость в общедоступном деструкторе), если **std::unique_ptr** больше не используется (при условии, что он не перемещен до этого в другое расположение). И это важно. Вы можете использовать объект неопределенно долго при условии, что **std::unique_ptr** не удаляет его. Ниже приведен пример того, как можно переместить объект в другое расположение.

```cppwinrt
struct Sample : implements<Sample, IStringable>
{
    winrt::hstring ToString() const;
 
    static void final_release(std::unique_ptr<Sample> ptr) noexcept
    {
        gc.push_back(std::move(ptr));
    }
};
```

Считайте, что это более детерминированный сборщик мусора. Возможно, более практичным и эффективным способом будет преобразование функции **final_release** в сопрограмму и обработка ее будущего удаления в одном расположении с возможностью приостанавливать потоки и переходить по ним при необходимости.

```cppwinrt
struct Sample : implements<Sample, IStringable>
{
    winrt::hstring ToString() const;
 
    static winrt::fire_and_forget final_release(std::unique_ptr<Sample> ptr) noexcept
    {
        co_await winrt::resume_background(); // Unwind the calling thread.
 
        // Safely perform complex teardown here.
    }
};
```

Приостановка приведет к возврату вызывающего потока, который изначально инициировал вызов к функции **IUnknown::Release**. Для источника вызова это будет значить что объект, который раньше принадлежал ему, больше не доступен через такой указатель интерфейса. Инфраструктуры пользовательского интерфейса часто должны иметь гарантию того, что объекты были удалены в определенном потоке пользовательского интерфейса, который изначально создал объект. Эта функция значительно упрощает выполнение такого требования, так как удаление выполняется отдельно от высвобождения объекта.

## <a name="safe-queries-during-destruction"></a>Безопасная отправка запросов во время удаления

Отложенное удаление позволяет безопасно отправлять запросы интерфейсам во время удаления.

Классическая модель COM основана на двух центральных концепциях. Первая — это подсчет ссылок, а вторая — отправка запросов интерфейсам. Помимо методов **AddRef** и **Release**, интерфейс **IUnknown** предоставляет метод [**QueryInterface**](/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void). Он часто используется определенными инфраструктурами пользовательского интерфейса, например XAML, для перехода по иерархии XAML при моделировании своей системы составного типа. Рассмотрим простой пример.

```cppwinrt
struct MainPage : PageT<MainPage>
{
    ~MainPage()
    {
        DataContext(nullptr);
    }
};
```

Может *показаться*, что здесь все хорошо. Эта страница XAML пытается очистить свой контекст данных в своем деструкторе. Но [**DataContext**](/uwp/api/windows.ui.xaml.frameworkelement.datacontext) является свойством базового класса **FrameworkElement** и располагается в отдельном интерфейсе **IFrameworkElement**. В результате C++/WinRT нужно внедрить вызов к **QueryInterface**, чтобы найти корректную виртуальную таблицу перед вызовом свойства **DataContext**. Но мы, собственно, оказались в деструкторе из-за того, что счетчик ссылок достиг значения 0. Отправка вызова к **QueryInterface** здесь временно увеличивает значение счетчика ссылок, и когда он снова достигает значения 0, объект снова удаляется.

В C++/WinRT 2.0 реализованы дополнительные методы для поддержки такого подхода. Ниже приведена реализация метода Release в C++/WinRT 2.0 в упрощенной форме.

```cppwinrt
uint32_t Release() noexcept
{
    uint32_t const remaining{ subtract_reference() };
 
    if (remaining == 0)
    {
        m_references = 1; // Debouncing!
        T::final_release(...);
    }
 
    return remaining;
}
```

Как можно предугадать, он сначала уменьшает значение счетчика ссылок, а потом запускается только при отсутствии ожидающих обработки ссылок. Но перед вызовом статической функции **final_release**, описанной выше в этом разделе, он стабилизирует счетчик ссылок, задавая для него значение 1. Мы называем это *устранением дребезга* (термин позаимствован из электротехники). Это очень важно для недопущения освобождения последней ссылки. После этого счетчик ссылок перейдет в нестабильное состояние и не сможет обеспечить надежную поддержку для вызова **QueryInterface**.

Вызов **QueryInterface** после освобождения последней ссылки представляет опасность, так как значение счетчика ссылок в таком случае гипотетически может увеличиваться до бесконечности. Поэтому на вас лежит обязанность по вызову только известных ветвей кода, которые не будут продлевать срок жизни объекта. C++/WinRT, со своей стороны, гарантирует отправку таких вызовов к **QueryInterface**,

стабилизируя счетчик ссылок. После освобождения последней ссылки фактическое значение счетчика ссылок будет равно 0 или некоторому непредвиденному значению. Последнее возможно, если использовались слабые ссылки. В любом случае это неприемлемо при последующем вызове **QueryInterface**, так как это обязательно приведет к временному увеличению значения счетчика ссылок (поэтому мы и упомянули устранение дребезга). Установка значения 1 гарантирует, что последний вызов к методу **Release** больше никогда не будет направлен к этому объекту. Это именно то, что нам нужно, так как **std::unique_ptr** теперь владеет объектом, но ограниченные вызовы к парам **QueryInterface**/**Release** будут выполняться безопасно.

Рассмотрим еще более интересный пример.

```cppwinrt
struct MainPage : PageT<MainPage>
{
    ~MainPage()
    {
        DataContext(nullptr);
    }

    static winrt::fire_and_forget final_release(std::unique_ptr<MainPage> ptr)
    {
        co_await 5s;
        co_await winrt::resume_foreground(ptr->Dispatcher());
        ptr = nullptr;
    }
};
```

Сначала вызывается функция **final_release**, которая уведомляет реализацию, что пришло время очистки. Здесь **final_release** выступает в роли сопрограммы. Для моделирования первой точки приостановки в течение первых нескольких секунд сопрограмма ожидает получение пула потоков. Затем она возобновляет работу в потоке диспетчера страницы. Последний шаг включает выполнение запроса, так как [**Dispatcher**](/uwp/api/windows.ui.xaml.dependencyobject.dispatcher) является свойством базового класса **DependencyObject**. Наконец, страница полностью удаляется путем установки значения `nullptr` для указателя **std::unique_ptr**. Это, в свою очередь, приведет к вызову деструктора страницы.

В самом деструкторе мы очистим контекст данных, который (как мы знаем) требует отправки запроса базовому классу **FrameworkElement**.

Все это становится возможным благодаря функции устранения дребезга счетчика ссылок (или его стабилизации), которая предоставляется в C++/WinRT 2.0.