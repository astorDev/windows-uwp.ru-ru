---
author: stevewhims
description: Таблица симптомов и способов их устранения в этом разделе может быть полезна при создании нового кода и переносе существующего приложения.
title: Устранение неполадок C++/WinRT
ms.author: stwhi
ms.date: 05/07/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: Windows 10, uwp, стандартная, c++, cpp, winrt, проекция, устранение неполадок, HRESULT, ошибка
ms.localizationpriority: medium
ms.openlocfilehash: 05542a42e362f024e92547d9eb496b936b85236c
ms.sourcegitcommit: e16c9845b52d5bd43fc02bbe92296a9682d96926
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/19/2018
ms.locfileid: "4949263"
---
# <a name="troubleshooting-cwinrt-issues"></a>Устранение неполадок C++/WinRT

> [!NOTE]
> Сведения об установке и использовании [C + +/ WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) расширения Visual Studio (VSIX) (которое обеспечивает поддержку шаблона проекта, а также C + +/ WinRT MSBuild свойств и целевых объектов) см. в разделе [Поддержка Visual Studio для C + +/ WinRT и VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).

Этот раздел представлен заранее, чтобы вы знали о нем уже сейчас; даже если он еще не требуется. Таблица симптомов и способов их устранения ниже может быть полезна при создании нового кода и переносе существующего приложения. Если вы переносите приложение и жаждете двигаться вперед и добраться до этапа, на котором выполняется построение и запуск вашего проекта, вы можете достичь временного прогресса с помощью комментирования и создания заглушек для любого некритичного кода, вызывающего неполадки, а затем вернуться, чтобы уплатить этот долг позже.

Список ответы на часто задаваемые вопросы см. в разделе [ответы на часто задаваемые вопросы](faq.md).

## <a name="tracking-down-xaml-issues"></a>Отслеживание неполадок XAML
Исключения синтаксического анализа XAML иногда трудно диагностировать &mdash; особенно, если они не содержат полезных сообщений об ошибке. Убедитесь, что отладчик настроен для перехвата первых исключений. Вы сможете проверить переменную исключения в отладчике, чтобы определить, содержат ли HRESULT или сообщение полезные данные. Также изучите сообщения об ошибке от средства синтаксического анализа XAML в окне вывода Visual Studio.

Если ваше приложение завершается и вы знаете только то, что возникло необработанное исключение во время анализа разметки XAML, следовательно оно является результатом ссылки на отсутствующий ресурс. Или это может быть исключением, возникшим в UserControl, пользовательском элементе управления или элементе управления пользовательской панели макета. Крайняя мера—это двоичное разделение. Удалите примерно половину разметки со страницы XAML и запустите приложение еще раз. Теперь вы знаете, находится ли ошибка в той половине, которую вы удалили (которую теперь необходимо восстановить в любом случае) или в той половине, которую вы не удалили. Повторите процесс, разделяя половину, которая содержит ошибку и дальше, пока вы не сможете обнаружить проблему.

## <a name="symptoms-and-remedies"></a>Признаки и средства устранения неполадок
| Проблема | Средство |
|---------|--------|
| Во время выполнения создается исключение со значение HRESULT REGDB_E_CLASSNOTREGISTERED. | Одной из причин возникновения этой ошибки является невозможность загрузить компонент среды выполнения Windows. Убедитесь, что файл метаданных компонента среды выполнения Windows (`.winmd`) имеет то же имя, что и двоичный файл компонента ( `.dll`), которое также совпадает с именем проекта и именем корневого пространства имен. Также убедитесь, что метаданные среды выполнения Windows и двоичный файл были правильно скопированы в процессе сборки в папку `Appx` использующего их приложения. Кроме того, убедитесь, что файл приложения `AppxManifest.xml` (также расположенный в папке `Appx`) содержит элемент **&lt;InProcessServer&gt;** правильно объявляющий активируемый класс и имя двоичного файла. Эта ошибка также может возникнуть, если допущена ошибка создания локально реализованного экземпляра класса среды выполнения через конструктор по умолчанию проецируемого типа. Дополнительные сведения об использовании проецируемых типов в этом случае см. в разделе [Элементы управления XAML; привязка к свойству C++/WinRT](binding-property.md). |
| Компилятор C++ выдает ошибку "*'implements_type': is not a member of any direct or indirect base class of '&lt;projected type&gt;'*". | Это может произойти, когда вы вызываете **make** с именем типа реализации, не соответствующего пространству имен (например, **MyRuntimeClass**), и не включили заголовок этого типа. Компилятор интерпретирует **MyRuntimeClass** в качестве проецируемого типа. Решением является включение заголовка для вашего типа реализации (например, `MyRuntimeClass.h`). |
| Компилятор C++ выдает ошибку "*attempting to reference a deleted function*". | Это может произойти, когда вы вызываете **make**, и тип реализации, который вы передаете в качестве параметра шаблона имеет конструктор по умолчанию `= delete`. Измените файл заголовка типа реализации и замените `= delete` на `= default`. Также можно добавить в IDL конструктор для класса среды выполнения. |
| Вы реализовали [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged), но привязки XAML не обновляются (и пользовательский интерфейс не подписывается на [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)). | Не забудьте установить `Mode=OneWay` (или TwoWay) в выражении привязки в разметке XAML. См. раздел [Элементы управления XAML; привязка к свойству C++/WinRT](binding-property.md). |
| Вы привязываете элемент управления элементами XAML к отслеживаемой коллекции, и при выполнении создается исключение "The parameter is incorrect". | В вашем IDL и реализации объявите отслеживаемые коллекции в качестве типа **Windows.Foundation.Collections.IVector<IInspectable>**. Но возвращайте объект, реализующий **Windows.Foundation.Collections.IObservableVector<T>**, где T — тип вашего элемента. См. раздел [Элементы управления XAML; привязка к коллекции C++/WinRT](binding-collection.md).  |
| Компилятор C++ выдает ошибку формы "*'MyImplementationType_base&lt;MyImplementationType&gt;': no appropriate default constructor available*".|Это может произойти, когда вы получили производное от типа, который имеет нестандартный конструктор. Конструктор производного типа должен передать параметры, которые требуются конструктору базового типа. Рабочий пример см. в разделе [Получение производного от типа, имеющего нестандартный конструктор](author-apis.md#deriving-from-a-type-that-has-a-non-default-constructor).|
| Компилятор C++ выдает ошибку "*cannot convert from 'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' to 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".|Это может произойти при передаче std::vector std::wstring API-интерфейсу среды выполнения Windows, который ожидает коллекцию. Дополнительные сведения см. в разделе [Стандартные типы данных C++ и C++/WinRT](std-cpp-data-types.md).|
| Компилятор C++ выдает ошибку "*cannot convert from 'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' to 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".|Это может произойти при передаче std::vector winrt::hstring асинхронному API-интерфейсу среды выполнения Windows, который ожидает коллекцию, при этом вектор не скопирован и не перемещен в асинхронный вызываемый. Дополнительные сведения см. в разделе [Стандартные типы данных C++ и C++/WinRT](std-cpp-data-types.md).|
| При открытии проекта Visual Studio выдает ошибку "*The application for the project is not installed*".|Если вы еще не сделали этого, необходимо установить **средства универсальной платформы Windows для разработки на C++** в диалоговом окне Visual Studio **Новый проект**. Если это не устраняет проблему, то проект может зависеть от расширения Visual Studio (VSIX) C++/WinRT (см. раздел [Поддержка Visual Studio для C++/WinRT и VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix)).|
| Тесты комплекта сертификации приложений для Windows создают ошибку о том, что один из ваших классов среды выполнения "*не является производным от базового класса Windows. Все составные классы должны наследоваться от типа в пространстве имен Windows*".|Любой класс среды выполнения, (которые были объявлены в приложении), который является производным от базового класса, называется *составные* класса. Первичный базовый класс составные класс должен являться типом из пространства имен Windows.*; Например, [**Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject). См. в разделе [элементы управления XAML; привязка к C + +/ WinRT свойства](binding-property.md) для получения дополнительных сведений.|
| Компилятор C++ создает ошибку "*must be WinRT type*" для специализации делегата EventHandler или TypedEventHandler.|Рассмотрите возможность использования **winrt::delegate&lt;...T&gt;**. См. раздел [Создание событий в C++/WinRT](author-events.md).|
| Компилятор C++ создает ошибку "*must be WinRT type*" для специализации асинхронной операции среды выполнения Windows.|Рассмотрите возможность возврата шаблона [**task**](https://msdn.microsoft.com/library/hh750113) библиотеки параллельных шаблонов (PPL). См. раздел [Параллельная обработка и асинхронные операции](concurrency.md).|
| Компилятор C++ создает ошибку "*error C2220: warning treated as error - no 'object' file generated*".|Исправьте предупреждение или установите параметру **C/C++** > **Общие** > **Обрабатывать предупреждения как ошибки** значение **Нет (/WX-)**.|
| В приложении возникает сбой, так как обработчик событий в объекте C++/WinRT вызывается после удаления объекта.|См. в разделе, [безопасный доступ к *этой* указателя с помощью делегата обработки события](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate).|
| Компилятор C++ создает ошибку "*error C2338: This is only for weak ref support*".|Запрашивается слабая ссылка для типа, который передал структуру маркера **winrt::no_weak_ref** как аргумент шаблона базовому классу. См. в разделе, [отказ от поддержки слабых ссылок](weak-references.md#opting-out-of-weak-reference-support).|
| Компоновщик C++ создает ошибку "*error LNK2019: неразрешенный внешний символ*»|См. в разделе [Почему компоновщик мы получаем мне «LNK2019: неразрешенный внешний символ «ошибка?](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error).|
| Цепочку инструментов LLVM и Clang возникают ошибки при использовании C + +/ WinRT.|Мы не поддерживаем цепочку инструментов LLVM и Clang для C + +/ WinRT, но если вы хотите имитировать, как мы используем его внутри организации, а затем вы можете поэкспериментировать, таких как кандидат, описанные в [можно ли использовать LLVM/Clang для компиляции с C + +/ WinRT?](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt).|
| Компилятор C++ выдает «*Нет подходящего конструктора по умолчанию доступны*» для проецируемого типа. | Если вы пытаетесь отложить инициализацию объекта класса среды выполнения, или можно использовать и реализуем класс среды выполнения в том же проекте, а затем необходимо вызвать `nullptr_t` конструктор. Дополнительные сведения см. в разделе [Использование API-интерфейсов в C++/WinRT](consume-apis.md). |
| Компилятор C++ выдает «*ошибки C3861: «from_abi»: идентификатор не найден*» и другие ошибки, которые происходят *base.h*. Вы можете увидеть эту ошибку, если вы используете Visual Studio 2017 (версии 15.8.0 или более поздней версии) и пакет Windows SDK версии 10.0.17134.0 (Windows 10, версия 1803). | Либо предназначенные для более поздней версии (Дополнительные совместимые) версии пакета SDK для Windows, или задать свойство проекта **C/C++** > **язык** > **режим совместимости: нет** (Кроме того, если **/ permissive-** отображается в свойство проекта **C/C++**  >  **Язык** > **командной строки** в столбце **Дополнительные параметры**, удалите его). |
| Компилятор C++ выдает «*Ошибка C2039: «IUnknown»: не является членом "\'global имен ''*». | См. в разделе [как Перенацелить C + +/ WinRT проекта на более позднюю версию пакета Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |
| Компоновщик C++ создает ошибку "*error LNK2019: неразрешенный внешний символ _WINRT_CanUnloadNow@0 в функции _VSDesignerCanUnloadNow@0 *» | См. в разделе [как Перенацелить C + +/ WinRT проекта на более позднюю версию пакета Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |

> [!NOTE]
> Если в этом разделе не ответить на вопрос, то может оказаться справки, перейдя к [сообществу разработчиков Visual Studio C++](https://developercommunity.visualstudio.com/spaces/62/index.html)или с помощью [ `c++-winrt` метки на Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).
