---
description: Таблица симптомов и способов их устранения в этом разделе может быть полезна при создании нового кода и переносе существующего приложения.
title: Устранение неполадок с C++/WinRT
ms.date: 04/23/2019
ms.topic: article
keywords: windows 10, uwp, standard, c++, cpp, winrt, projection, troubleshooting, HRESULT, error
ms.localizationpriority: medium
ms.openlocfilehash: e53fb74b8287b6aee25ddbdd4563846403ff087e
ms.sourcegitcommit: a7a1e27b04f0ac51c4622318170af870571069f6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/10/2019
ms.locfileid: "67717552"
---
# <a name="troubleshooting-cwinrt-issues"></a>Устранение неполадок с C++/WinRT

> [!NOTE]
> Сведения об установке и использовании [расширения C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) для Visual Studio (VSIX) (которое обеспечивает поддержку шаблона проекта) см. разделе о [поддержке C++/WinRT в Visual Studio](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package).

Эта статья опубликована заранее, чтобы вы знали о проблемах сейчас, даже если эта языковая проекция вам еще не требуется. Приведенная ниже таблица признаков и способов их устранения может быть полезна при создании кода и переносе существующего приложения. Если вы переносите приложение и хотите добраться до этапа, на котором выполняется сборка и запуск вашего проекта, вы можете достичь временного прогресса с помощью комментирования и создания заглушек для любого некритичного кода, вызывающего неполадки, а затем вернуться, чтобы внести соответствующий код позже.

Список часто задаваемых вопросов см. в [этой статье](faq.md).

## <a name="tracking-down-xaml-issues"></a>Отслеживание неполадок XAML
Исключения синтаксического анализа XAML иногда трудно диагностировать, особенно, если они не содержат полезных сообщений об ошибке. Убедитесь, что отладчик настроен для перехвата первых исключений. Вы сможете проверить переменную исключения в отладчике, чтобы определить, содержат ли HRESULT или сообщение полезные данные. Также изучите сообщения об ошибке от средства синтаксического анализа XAML в окне вывода Visual Studio.

Если ваше приложение завершается и вы знаете только то, что возникло необработанное исключение во время анализа разметки XAML, значит ошибка произошла в результате ссылки (по ключу) на отсутствующий ресурс. Это также может быть исключение, возникшее в UserControl, пользовательском элементе управления или элементе управления пользовательской панели макета. Крайняя мера — это двоичное разделение. Удалите примерно половину разметки со страницы XAML и запустите приложение еще раз. Теперь вы знаете, находится ли ошибка в той половине, которую вы удалили (которую теперь необходимо восстановить в любом случае), или в той половине, которую вы не удалили. Повторите процесс, разделяя половину, которая содержит ошибку и дальше, пока вы не сможете обнаружить проблему.

## <a name="symptoms-and-remedies"></a>Признаки и способы устранения неполадок
| Признак | Средство |
|---------|--------|
| Во время выполнения создается исключение со значением HRESULT REGDB_E_CLASSNOTREGISTERED. | См. часто задаваемый вопрос о том, [почему возникает исключение "Класс не зарегистрирован"](faq.md#why-am-i-getting-a-class-not-registered-exception). |
| Компилятор C++ выдает ошибку "*implements_type: не является прямым или косвенным базовым классом для &lt;projected type&gt;* ". | Это может произойти, когда вы вызываете **make** с именем типа реализации, не соответствующим пространству имен (например, **MyRuntimeClass**), и не включили заголовок этого типа. Компилятор интерпретирует **MyRuntimeClass** в качестве проецируемого типа. Чтобы устранить ошибку, включите заголовок для вашего типа реализации (например, `MyRuntimeClass.h`). |
| Компилятор C++ выдает ошибку "*предпринята попытка ссылки на удаленную функцию*". | Это может произойти, когда вы вызываете **make** и тип реализации, который вы передаете в качестве параметра шаблона, имеет конструктор по умолчанию `= delete`. Измените файл заголовка типа реализации и замените `= delete` на `= default`. Вы также можете добавить в код IDL конструктор для класса среды выполнения. |
| Вы реализовали [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged), но привязки XAML не обновляются (и пользовательский интерфейс не подписывается на событие [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)). | Не забудьте установить `Mode=OneWay` (или TwoWay) в выражении привязки в разметке XAML. См. сведения в статье [Элементы управления XAML; привязка к свойству C++/WinRT](binding-property.md). |
| Вы привязываете элемент управления элементами XAML к отслеживаемой коллекции, и во время выполнения создается исключение "Неправильный параметр". | В вашем коде IDL и реализации объявите отслеживаемые коллекции в качестве типа **Windows.Foundation.Collections.IVector<IInspectable>** . Но возвращайте объект, реализующий **Windows.Foundation.Collections.IObservableVector<T>** , где T — тип вашего элемента. См. сведения в статье [Элементы управления XAML; привязка к коллекции C++/WinRT](binding-collection.md).  |
| Компилятор C++ выдает ошибку формы "*MyImplementationType_base&lt;MyImplementationType&gt;: нет подходящего конструктора по умолчанию*".|Это может произойти, когда вы получили производное от типа, который имеет нестандартный конструктор. Конструктор производного типа должен передать параметры, которые требуются конструктору базового типа. Рабочий пример см. в разделе [Получение производного от типа, имеющего нестандартный конструктор](author-apis.md#deriving-from-a-type-that-has-a-non-default-constructor).|
| Компилятор C++ выдает ошибку "*невозможно выполнить преобразование из const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt; в const winrt::param::async_iterable&lt;winrt::hstring&gt; &* ".|Это может произойти при передаче std::vector std::wstring API-интерфейсу среды выполнения Windows, который ожидает коллекцию. Дополнительные сведения см. в статье [Стандартные типы данных C++ и C++/WinRT](std-cpp-data-types.md).|
| Компилятор C++ выдает ошибку "*невозможно выполнить преобразование из const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt; в const winrt::param::async_iterable&lt;winrt::hstring&gt; &* ".|Это может произойти при передаче std::vector winrt::hstring асинхронному API-интерфейсу среды выполнения Windows, который ожидает коллекцию, при этом вектор не скопирован и не перемещен в асинхронный вызываемый. Дополнительные сведения см. в статье [Стандартные типы данных C++ и C++/WinRT](std-cpp-data-types.md).|
| При открытии проекта Visual Studio выдает ошибку "*Приложение для проекта не установлено*".|Если вы еще не сделали этого, необходимо установить **средства универсальной платформы Windows для разработки на C++** в диалоговом окне Visual Studio **Новый проект**. Если это не устраняет проблему, то проект может зависеть от расширения C++/WinRT для Visual Studio (VSIX) (см. сведения в разделе [о поддержке C++/WinRT в Visual Studio](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package).|
| Тесты комплекта сертификации приложений для Windows выдают ошибку о том, что один из классов среды выполнения "*не является производным от базового класса Windows. Все классы, поддерживающие композицию, должны быть производными от типа в пространстве имен Windows*".|Любой класс среды выполнения (объявленный в приложении), который является производным от базового класса, называется *составным*. Исходный базовый класс для составного класса должен быть типом из пространства имен Windows.*, например, [**Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject). Дополнительные сведения см. в статье [Элементы управления XAML; привязка к свойству C++/WinRT](binding-property.md).|
| Компилятор C++ создает ошибку "*должна быть типа WinRT*" для специализации делегата EventHandler или TypedEventHandler.|Рассмотрите возможность использования **winrt::delegate&lt;...T&gt;** . См. сведения в статье [Создание событий в C++/WinRT](author-events.md).|
| Компилятор C++ создает ошибку "*должна быть типа WinRT*" для специализации асинхронной операции среды выполнения Windows.|Рассмотрите возможность возврата класса [**task**](https://docs.microsoft.com/cpp/parallel/concrt/reference/task-class) библиотеки параллельных шаблонов (PPL). См. сведения в статье [Параллельная обработка и асинхронные операции с помощью C++/WinRT](concurrency.md).|
| Компилятор C++ создает ошибку C2220 "*предупреждение обработано как ошибка — файл "object" не создан*".|Исправьте предупреждение или установите для параметра **C/C++**  > **Общие** > **Обрабатывать предупреждения как ошибки** значение **Нет (/WX-)** .|
| В приложении возникает сбой, так как обработчик событий в объекте C++/WinRT вызывается после удаления объекта.|См. сведения в разделе [Безопасный доступ к указателю *this* с помощью делегата, обрабатывающего события](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate).|
| Компилятор C++ создает ошибку *C2338 This is only for weak ref support* (Только для поддержки слабых ссылок).|Запрашивается слабая ссылка для типа, который передал структуру маркера **winrt::no_weak_ref** как аргумент шаблона базовому классу. См. сведения в разделе [Отказ от поддержки слабых ссылок](weak-references.md#opting-out-of-weak-reference-support).|
| Компоновщик C++ создает ошибку "*LNK2019: неразрешенный внешний символ*".|См. в разделе [Почему компоновщик отображает сообщение об ошибке "LNK2019: неразрешенный внешний символ?](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error).|
| Цепочка инструментов LLVM и Clang выдает ошибки при использовании с C++/WinRT.|Мы не поддерживаем цепочку инструментов LLVM и Clang для C++/WinRT, но если нужно эмулировать использование этой проекции на внутреннем уровне, то вы можете попробовать эксперимент, который описан в разделе [Можно ли использовать LLVM/Clang для компиляции с C++/WinRT?](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt).|
| Компилятор C++ выдает ошибку "*нет подходящего конструктора по умолчанию*" для проецируемого типа. | Если вы пытаетесь отложить инициализацию объекта класса среды выполнения или использовать и реализовать класс среды выполнения в том же проекте, вам нужно вызвать конструктор **std::nullptr_t**. Дополнительные сведения см. в статье [Использование API-интерфейсов с помощью C++/WinRT](consume-apis.md). |
| Компилятор C++ выдает ошибку C3861 "*from_abi: идентификатор не найден*" и другие ошибки, полученные в *base.h*. Эта ошибка может возникать, если вы используете Visual Studio 2017 (версии 15.8.0 или более поздней) и целевой пакет Windows SDK 10.0.17134.0 (Windows 10 версии 1803). | Либо используйте в качестве целевой более позднюю (лучше соответствующую) версию пакета Windows SDK, либо задайте свойство проекта **C /C++**  > **Язык** > **Режим совместимости: Нет**. (Кроме того, если параметр **/permissive-** отображается в свойстве проекта **C/C++**  > **Язык** > **Командная строка** в разделе **Дополнительные параметры**, удалите его). |
| Компилятор C++ создает ошибку C2039 " *IUnknown не является членом \`глобального пространства имен*". | См. сведения в разделе [How to retarget your C++/WinRT project to a later version of the Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk) (Как изменить целевую платформу проекта C++/WinRT на более позднюю версию Windows SDK). |
| Компоновщик C++ создает ошибку "*LNK2019: ссылка на неразрешенный внешний символ _WINRT_CanUnloadNow@0 в функции _VSDesignerCanUnloadNow@0* ". | См. сведения в разделе [How to retarget your C++/WinRT project to a later version of the Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk) (Как изменить целевую платформу проекта C++/WinRT на более позднюю версию Windows SDK). |
| В процессе сборки создается сообщение об ошибке *The C++/WinRT VSIX no longer provides project build support.  Please add a project reference to the Microsoft.Windows.CppWinRT Nuget package* (C++/WinRT VSIX больше не поддерживает сборку проекта. Добавьте ссылку на пакет Nuget Microsoft.Windows.CppWinRT в проекте). | Установите пакет NuGet **Microsoft.Windows.CppWinRT** в проект. Дополнительные сведения см. в разделе [Earlier versions of the VSIX extension](intro-to-using-cpp-with-winrt.md#earlier-versions-of-the-vsix-extension) (Более ранние версии расширения VSIX). |
| Компоновщик C++ создает ошибку "*LNK2019: неразрешенный внешний символ*" с упоминанием *winrt::impl::consume_Windows_Foundation_Collections_IVector*. | Начиная с версии [ C++WinRT 2.0](news.md#news-and-changes-in-cwinrt-20), если вы используете основанный на диапазоне параметр `for` в коллекции среды выполнения Windows, то теперь нужно добавить `#include <winrt/Windows.Foundation.Collections.h>`. |
| Компилятор C++ выдает сообщение *Eror C4002: Too many arguments for function-like macro invocation GetCurrentTime* (Ошибка C4002: слишком много аргументов для вызова подобного функции макроса GetCurrentTime). | См. часто задаваемый вопрос о том, [как устранить неоднозначности с GetCurrentTime и (или) TRY](faq.md#how-do-i-resolve-ambiguities-with-getcurrenttime-andor-try). |
| Компилятор C++ выдает сообщение *Error C2334: unexpected token(s) preceding {; skipping apparent function body* (Ошибка C2334: непредвиденные лексемы перед {; пропуск вероятного тела функции). | См. часто задаваемый вопрос о том, [как устранить неоднозначности с GetCurrentTime и (или) TRY](faq.md#how-do-i-resolve-ambiguities-with-getcurrenttime-andor-try). |
| Компилятор C++ выдает сообщение *winrt::impl::produce&lt;D,I&gt; cannot instantiate abstract class, due to missing GetBindingConnector* (winrt::impl::produce<D,I> не может создать экземпляр абстрактного класса из-за отсутствия GetBindingConnector). | Необходимо добавить `#include <winrt/Windows.UI.Xaml.Markup.h>`. |
| Компилятор C++ выдает сообщение *Error C2039: promise_type: is not a member of std::experimental::coroutine_traits<void>* (Ошибка C2039: promise_type не является членом std::experimental::coroutine_traits). | Сопрограмма должна возвращать либо объект асинхронной операции, либо **winrt::fire_and_forget**. См. сведения в статье [Параллельная обработка и асинхронные операции с помощью C++/WinRT](concurrency.md). |
| При работе с проектом появляется сообщение: *Ambiguous access of PopulatePropertyInfoOverride* (Неоднозначный уровень доступа PopulatePropertyInfoOverride). | Эта ошибка может возникать при объявлении одного базового класса в IDL и другого базового класса в разметке XAML. |
| При первом запуске решения C++/WinRT отображается сообщение *Designtime build failed for project MyProject.vcxproj configuration Debug\|x86. IntelliSense might be unavailable*. (Сбой сборки Designtime для конфигурации Debug\|x86 проекта MyProject.vcxproj. Функция IntelliSense может быть недоступной). | Эта проблема с IntelliSense будет устранена после первого выполнения сборки. |
| Попытка задать [**winrt::auto_revoke**](/uwp/cpp-ref-for-winrt/auto-revoke-t) при регистрации делегата вызывает исключение [**winrt::hresult_no_interface**](/uwp/cpp-ref-for-winrt/error-handling/hresult-no-interface). | См. раздел о [сбое регистрации автоматически отзываемого делегата](handle-events.md#if-your-auto-revoke-delegate-fails-to-register). |

> [!NOTE]
> Если в этой статье вы не нашли ответы на свои вопросы, можете перейти к сообществу разработчиков[Visual Studio C++](https://developercommunity.visualstudio.com/spaces/62/index.html) или воспользоваться тегом [`c++-winrt` на сайте Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).
