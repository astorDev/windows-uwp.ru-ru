---
description: Таблица симптомов и способов их устранения в этом разделе может быть полезна при создании нового кода и переносе существующего приложения.
title: Устранение неполадок C++/WinRT
ms.date: 04/23/2019
ms.topic: article
keywords: Windows 10, uwp, стандартная, c++, cpp, winrt, проекция, устранение неполадок, HRESULT, ошибка
ms.localizationpriority: medium
ms.openlocfilehash: 3fe67fd0593c9c1f605a5d1cc7418c348b6ca9c3
ms.sourcegitcommit: ac7f3422f8d83618f9b6b5615a37f8e5c115b3c4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/29/2019
ms.locfileid: "66360101"
---
# <a name="troubleshooting-cwinrt-issues"></a>Устранение неполадок C++/WinRT

> [!NOTE]
> Сведения об установке и использовании [ C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) Visual Studio Extension (VSIX) (который поддерживает шаблон проекта) см. в разделе [поддержка Visual Studio C++/WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package).

Этот раздел представлен заранее, чтобы вы знали о нем уже сейчас; даже если он еще не требуется. Таблица симптомов и способов их устранения ниже может быть полезна при создании нового кода и переносе существующего приложения. Если вы переносите приложение и жаждете двигаться вперед и добраться до этапа, на котором выполняется построение и запуск вашего проекта, вы можете достичь временного прогресса с помощью комментирования и создания заглушек для любого некритичного кода, вызывающего неполадки, а затем вернуться, чтобы уплатить этот долг позже.

Список часто задаваемых вопросов, см. в разделе [часто задаваемые вопросы](faq.md).

## <a name="tracking-down-xaml-issues"></a>Отслеживание неполадок XAML
Исключения синтаксического анализа XAML иногда трудно диагностировать &mdash; особенно, если они не содержат полезных сообщений об ошибке. Убедитесь, что отладчик настроен для перехвата первых исключений. Вы сможете проверить переменную исключения в отладчике, чтобы определить, содержат ли HRESULT или сообщение полезные данные. Также изучите сообщения об ошибке от средства синтаксического анализа XAML в окне вывода Visual Studio.

Если ваше приложение завершается и вы знаете только то, что возникло необработанное исключение во время анализа разметки XAML, следовательно оно является результатом ссылки на отсутствующий ресурс. Или это может быть исключением, возникшим в UserControl, пользовательском элементе управления или элементе управления пользовательской панели макета. Крайняя мера — это двоичное разделение. Удалите примерно половину разметки со страницы XAML и запустите приложение еще раз. Теперь вы знаете, находится ли ошибка в той половине, которую вы удалили (которую теперь необходимо восстановить в любом случае) или в той половине, которую вы не удалили. Повторите процесс, разделяя половину, которая содержит ошибку и дальше, пока вы не сможете обнаружить проблему.

## <a name="symptoms-and-remedies"></a>Признаки и средства устранения неполадок
| Признак | Средство |
|---------|--------|
| Во время выполнения создается исключение со значение HRESULT REGDB_E_CLASSNOTREGISTERED. | Одной из причин возникновения этой ошибки является невозможность загрузить компонент среды выполнения Windows. Убедитесь, что файл метаданных компонента среды выполнения Windows (`.winmd`) имеет то же имя, что и двоичный файл компонента ( `.dll`), которое также совпадает с именем проекта и именем корневого пространства имен. Также убедитесь, что метаданные среды выполнения Windows и двоичный файл были правильно скопированы в процессе сборки в папку `Appx` использующего их приложения. Кроме того, убедитесь, что файл приложения `AppxManifest.xml` (также расположенный в папке `Appx`) содержит элемент **&lt;InProcessServer&gt;** правильно объявляющий активируемый класс и имя двоичного файла. Эта ошибка также может возникнуть, если допущена ошибка создания локально реализованного экземпляра класса среды выполнения через конструктор по умолчанию проецируемого типа. Дополнительные сведения об использовании проецируемых типов в этом случае см. в разделе [Элементы управления XAML; привязка к свойству C++/WinRT](binding-property.md). |
| Компилятор C++ выдает ошибку " *'implements_type': is not a member of any direct or indirect base class of '&lt;projected type&gt;'* ". | Это может произойти, когда вы вызываете **make** с именем типа реализации, не соответствующего пространству имен (например, **MyRuntimeClass**), и не включили заголовок этого типа. Компилятор интерпретирует **MyRuntimeClass** в качестве проецируемого типа. Решением является включение заголовка для вашего типа реализации (например, `MyRuntimeClass.h`). |
| Компилятор C++ выдает ошибку "*attempting to reference a deleted function*". | Это может произойти, когда вы вызываете **make**, и тип реализации, который вы передаете в качестве параметра шаблона имеет конструктор по умолчанию `= delete`. Измените файл заголовка типа реализации и замените `= delete` на `= default`. Также можно добавить в IDL конструктор для класса среды выполнения. |
| Вы реализовали [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged), но привязки XAML не обновляются (и пользовательский интерфейс не подписывается на [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)). | Не забудьте установить `Mode=OneWay` (или TwoWay) в выражении привязки в разметке XAML. См. раздел [Элементы управления XAML; привязка к свойству C++/WinRT](binding-property.md). |
| Вы привязываете элемент управления элементами XAML к отслеживаемой коллекции, и при выполнении создается исключение "The parameter is incorrect". | В вашем IDL и реализации объявите отслеживаемые коллекции в качестве типа **Windows.Foundation.Collections.IVector<IInspectable>** . Но возвращайте объект, реализующий **Windows.Foundation.Collections.IObservableVector<T>** , где T — тип вашего элемента. См. раздел [Элементы управления XAML; привязка к коллекции C++/WinRT](binding-collection.md).  |
| Компилятор C++ выдает ошибку формы " *'MyImplementationType_base&lt;MyImplementationType&gt;': no appropriate default constructor available*".|Это может произойти, когда вы получили производное от типа, который имеет нестандартный конструктор. Конструктор производного типа должен передать параметры, которые требуются конструктору базового типа. Рабочий пример см. в разделе [Получение производного от типа, имеющего нестандартный конструктор](author-apis.md#deriving-from-a-type-that-has-a-non-default-constructor).|
| Компилятор C++ выдает ошибку "*cannot convert from 'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' to 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* ".|Это может произойти при передаче std::vector std::wstring API-интерфейсу среды выполнения Windows, который ожидает коллекцию. Дополнительные сведения см. в разделе [Стандартные типы данных C++ и C++/WinRT](std-cpp-data-types.md).|
| Компилятор C++ выдает ошибку "*cannot convert from 'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' to 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* ".|Это может произойти при передаче std::vector winrt::hstring асинхронному API-интерфейсу среды выполнения Windows, который ожидает коллекцию, при этом вектор не скопирован и не перемещен в асинхронный вызываемый. Дополнительные сведения см. в разделе [Стандартные типы данных C++ и C++/WinRT](std-cpp-data-types.md).|
| При открытии проекта Visual Studio выдает ошибку "*The application for the project is not installed*".|Если вы еще не сделали этого, необходимо установить **средства универсальной платформы Windows для разработки на C++** в диалоговом окне Visual Studio **Новый проект**. Если это не решит проблему, то может зависеть от проекта C++WinRT Visual Studio Extension (VSIX) (см. в разделе [поддержка Visual Studio C++/WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package).|
| Тесты комплекта сертификации приложений для Windows сообщает об ошибке, что один из классов среды выполнения "*не является производным от базового класса Windows. Все классы составных в конечном счете должен быть производным от типа в пространстве имен Windows*«.|Любой класс среды выполнения, (, объявленная в приложении), производный от базового класса называется *составную* класса. Исходным базовым классом для составных класс должен быть типом, возникшая в пространстве имен Windows.*. например [ **Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject). См. в разделе [XAML контролирует; привязка к C++свойство /WinRT](binding-property.md) для получения дополнительных сведений.|
| Компилятор C++ создает ошибку "*must be WinRT type*" для специализации делегата EventHandler или TypedEventHandler.|Рассмотрите возможность использования **winrt::delegate&lt;...T&gt;** . См. раздел [Создание событий в C++/WinRT](author-events.md).|
| Компилятор C++ создает ошибку "*must be WinRT type*" для специализации асинхронной операции среды выполнения Windows.|Рассмотрите возможность возврата шаблона [**task**](https://docs.microsoft.com/cpp/parallel/concrt/reference/task-class) библиотеки параллельных шаблонов (PPL). См. раздел [Параллельная обработка и асинхронные операции](concurrency.md).|
| Компилятор C++ создает ошибку "*error C2220: warning treated as error - no 'object' file generated*".|Устраните причину предупреждения, либо задать **C/C++**  > **Общие** > **обрабатывать предупреждения как ошибки** для  **Нет (/ WX-)** .|
| В приложении возникает сбой, так как обработчик событий в объекте C++/WinRT вызывается после удаления объекта.|См. в разделе [безопасного доступа к *это* указатель с помощью делегата, обрабатывающего события](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate).|
| Компилятор C++ создает "*error C2338: Это только для поддержки слабых ссылок*«.|Запрашивается слабая ссылка для типа, который передал структуру маркера **winrt::no_weak_ref** как аргумент шаблона базовому классу. См. в разделе [отказ от поддержки слабую ссылку](weak-references.md#opting-out-of-weak-reference-support).|
| Компоновщик C++ создает "*Ошибка LNK2019: Неразрешенный внешний символ*"|См. в разделе [почему компоновщик дающее мне «LNK2019: Ошибка неразрешенный внешний символ»? ](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error).|
| Цепочка инструментов LLVM и Clang выдает ошибки при использовании с C++/WinRT.|Мы не поддерживаем LLVM и Clang цепочка инструментов для C++/WinRT, но если нужно эмулировать, как использовать его на внутреннем уровне, то вы можете попробовать эксперимент, такие, как указано в [использовать LLVM/Clang компилировать с параметром C++/WinRT?](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt).|
| Компилятор C++ создает "*нет подходящего конструктора по умолчанию доступные*" для проецируемых типа. | Если вы пытаетесь отложить инициализацию объекта класса среды выполнения или использования и реализовать класс среды выполнения, в том же проекте, то вам потребуется вызвать `nullptr_t` конструктор. Дополнительные сведения см. в разделе [Использование API-интерфейсов в C++/WinRT](consume-apis.md). |
| C++ Компилятор создает "*ошибки C3861: «from_abi»: идентификатор не найден*«и другие ошибки, полученные в *base.h*. Эта ошибка может возникать, если вы используете Visual Studio 2017 (версии 15.8.0 или более поздней версии) и определение целевых объектов пакет Windows SDK версии 10.0.17134.0 (Windows 10 версии 1803). | Либо предназначенных для более поздней версии (лучше соответствует стандарту) версия пакета SDK для Windows, или задать свойство проекта **C/C++**  > **языка** > **режим совместимости: Не** (Кроме того, если **/ permissive-** отображается в свойстве проекта **C/C++**  > **языка** > **командной строки**  под **Дополнительные параметры**, удалите его). |
| Компилятор C++ создает "*Ошибка C2039: «IUnknown»: не является членом "\`глобальное пространство имен ''* «. | См. в разделе [как изменить целевую платформу на C++/WinRT проекта до более поздней версии пакета SDK Windows](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |
| Компоновщик C++ создает "*Ошибка LNK2019: неразрешенный внешний символ _WINRT_CanUnloadNow@0 на которые ссылается функция _VSDesignerCanUnloadNow@0* " | См. в разделе [как изменить целевую платформу на C++/WinRT проекта до более поздней версии пакета SDK Windows](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |
| В процессе сборки создается сообщение об ошибке  *C++WinRT VSIX больше не обеспечивает поддержку построения проекта.  Добавьте ссылку на пакет Microsoft.Windows.CppWinRT Nuget*. | Установка **Microsoft.Windows.CppWinRT** пакет NuGet в проект. Дополнительные сведения см. в разделе [более ранних версиях расширение VSIX](intro-to-using-cpp-with-winrt.md#earlier-versions-of-the-vsix-extension). |
| C++ Компилятор выдает сообщение об ошибке, где упоминается *«std::experimental»* , и/или ошибка формы *ошибки C3861: «resume_background»: идентификатор не найден*. | Начиная с версии [ C++WinRT 2.0](news.md#news-and-changes-in-cwinrt-20), для поддержки соподпрограмме (включая сопрограммы вспомогательные функции, такие как **winrt::resume_background**, **winrt::resume_foreground**и **winrt::resume_on_signal**), вам потребуется `#include <winrt/coroutine.h>`. |
| C++ Компоновщик будет создавать *Ошибка LNK2019: неразрешенный внешний символ*, с помощью упоминание исключения *winrt::impl::consume_Windows_Foundation_Collections_IVector*. | Начиная с версии [ C++WinRT 2.0](news.md#news-and-changes-in-cwinrt-20), если вы используете, основанном на диапазоне `for` коллекции среды выполнения Windows, то теперь нужно будет `#include <winrt/Windows.Foundation.Collections.h>`. |

> [!NOTE]
> Если в этом разделе не ответить на ваш вопрос, то может оказаться справки, посвященной [сообщества разработчиков Visual Studio C++](https://developercommunity.visualstudio.com/spaces/62/index.html), или с помощью [ `c++-winrt` тег на сайте Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).
