---
author: stevewhims
description: Таблица симптомов и способов их устранения в этом разделе может быть полезна при создании нового кода и переносе существующего приложения.
title: Устранение неполадок C++/WinRT
ms.author: stwhi
ms.date: 04/10/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: Windows 10, uwp, стандартная, c++, cpp, winrt, проекция, устранение неполадок, HRESULT, ошибка
ms.localizationpriority: medium
ms.openlocfilehash: 21f5fc4773979b2d7940b85871264e27d56d29c4
ms.sourcegitcommit: ab92c3e0dd294a36e7f65cf82522ec621699db87
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/03/2018
ms.locfileid: "1832268"
---
# <a name="troubleshooting-cwinrtwindowsuwpcpp-and-winrt-apisintro-to-using-cpp-with-winrt-issues"></a>Устранение неполадок [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt)
> [!NOTE]
> **Некоторые сведения относятся к предварительным версиям продуктов, в которые перед коммерческим выпуском могут быть внесены существенные изменения. Майкрософт не дает никаких гарантий, явных или подразумеваемых, в отношении предоставленной здесь информации.**

> [!NOTE]
> Сведения о текущей доступности расширения C++/WinRT для Visual Studio (VSIX) (которое обеспечивает поддержку шаблона проекта, а также свойств и целевых объектов MSBuild C++/WinRT) см. в разделе [Поддержка Visual Studio для C++/WinRT и VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).

Этот раздел представлен заранее, чтобы вы знали о нем уже сейчас; даже если он еще не требуется. Таблица симптомов и способов их устранения ниже может быть полезна при создании нового кода и переносе существующего приложения. Если вы переносите приложение и жаждете двигаться вперед и добраться до этапа, на котором выполняется построение и запуск вашего проекта, вы можете достичь временного прогресса с помощью комментирования и создания заглушек для любого некритичного кода, вызывающего неполадки, а затем вернуться, чтобы уплатить этот долг позже.

## <a name="tracking-down-xaml-issues"></a>Отслеживание неполадок XAML
Исключения синтаксического анализа XAML иногда трудно диагностировать &mdash; особенно, если они не содержат полезных сообщений об ошибке. Убедитесь, что отладчик настроен для перехвата первых исключений. Вы сможете проверить переменную исключения в отладчике, чтобы определить, содержат ли HRESULT или сообщение полезные данные. Также изучите сообщения об ошибке от средства синтаксического анализа XAML в окне вывода Visual Studio.

Если ваше приложение завершается и вы знаете только то, что возникло необработанное исключение во время анализа разметки XAML, следовательно оно является результатом ссылки на отсутствующий ресурс. Или это может быть исключением, возникшим в UserControl, пользовательском элементе управления или элементе управления пользовательской панели макета. Крайняя мера—это двоичное разделение. Удалите примерно половину разметки со страницы XAML и запустите приложение еще раз. Теперь вы знаете, находится ли ошибка в той половине, которую вы удалили (которую теперь необходимо восстановить в любом случае) или в той половине, которую вы не удалили. Повторите процесс, разделяя половину, которая содержит ошибку и дальше, пока вы не сможете обнаружить проблему.

## <a name="symptoms-and-remedies"></a>Признаки и средства устранения неполадок
| Проблема | Средство |
|---------|--------|
| Во время выполнения создается исключение со значение HRESULT REGDB_E_CLASSNOTREGISTERED. | Одной из причин возникновения этой ошибки является невозможность загрузить компонент среды выполнения Windows. Убедитесь, что файл метаданных компонента среды выполнения Windows (`.winmd`) имеет то же имя, что и двоичный файл компонента ( `.dll`), которое также совпадает с именем проекта и именем корневого пространства имен. Также убедитесь, что метаданные среды выполнения Windows и двоичный файл были правильно скопированы в процессе сборки в папку `Appx` использующего их приложения. Кроме того, убедитесь, что файл приложения `AppxManifest.xml` (также расположенный в папке `Appx`) содержит элемент **&lt;InProcessServer&gt;** правильно объявляющий активируемый класс и имя двоичного файла. Эта ошибка также может возникнуть, если допущена ошибка создания локально реализованного экземпляра класса среды выполнения через конструктор по умолчанию проецируемого типа. Дополнительные сведения об использовании проецируемых типов в этом случае см. в разделе [Элементы управления XAML; привязка к свойству C++/WinRT](binding-property.md). |
| Компилятор C++ выдает ошибку "*'implements_type': is not a member of any direct or indirect base class of '&lt;projected type&gt;'*". | Это может произойти, когда вы вызываете **make** с именем типа реализации, не соответствующего пространству имен (например, **MyRuntimeClass**), и не включили заголовок этого типа. Компилятор интерпретирует **MyRuntimeClass** в качестве проецируемого типа. Решением является включение заголовка для вашего типа реализации (например, `MyRuntimeClass.h`). |
| Компилятор C++ выдает ошибку "*attempting to reference a deleted function*". | Это может произойти, когда вы вызываете **make**, и тип реализации, который вы передаете в качестве параметра шаблона имеет конструктор по умолчанию `= delete`. Измените файл заголовка типа реализации и замените `= delete` на `= default`. Также можно добавить в IDL конструктор для класса среды выполнения. |
| Вы реализовали [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged), но привязки XAML не обновляются (и пользовательский интерфейс не подписывается на [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)). | Не забудьте установить `Mode=OneWay` (или TwoWay) в выражении привязки в разметке XAML. См. раздел [Элементы управления XAML; привязка к свойству C++/WinRT](binding-property.md). |
| Вы привязываете элемент управления элементами XAML к отслеживаемой коллекции, и при выполнении создается исключение "The parameter is incorrect". | В вашем IDL и реализации объявите отслеживаемые коллекции в качестве типа **Windows.Foundation.Collections.IVector<IInspectable>**. Но возвращайте объект, реализующий **Windows.Foundation.Collections.IObservableVector<T>**, где T — тип вашего элемента. См. раздел [Элементы управления XAML; привязка к коллекции C++/WinRT](binding-collection.md).  |
| Компилятор C++ выдает ошибку формы "*'MyImplementationType_base&lt;MyImplementationType&gt;': no appropriate default constructor available*".|Это может произойти, когда вы получили производное от типа, который имеет нестандартный конструктор. Конструктор производного типа должен передать параметры, которые требуются конструктору базового типа. Рабочий пример см. в разделе [Получение производного от типа, имеющего нестандартный конструктор](author-apis.md#deriving-from-a-type-that-has-a-non-trivial-constructor).|
| Компилятор C++ выдает ошибку "*cannot convert from 'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' to 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".|Это может произойти при передаче std::vector std::wstring API-интерфейсу среды выполнения Windows, который ожидает коллекцию. Дополнительные сведения см. в разделе [Стандартные типы данных C++ и C++/WinRT](std-cpp-data-types.md).|
| Компилятор C++ выдает ошибку "*cannot convert from 'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' to 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".|Это может произойти при передаче std::vector winrt::hstring асинхронному API-интерфейсу среды выполнения Windows, который ожидает коллекцию, при этом вектор не скопирован и не перемещен в асинхронный вызываемый. Дополнительные сведения см. в разделе [Стандартные типы данных C++ и C++/WinRT](std-cpp-data-types.md).|
| При открытии проекта Visual Studio выдает ошибку "*The application for the project is not installed*".|Если вы еще не сделали этого, необходимо установить **средства универсальной платформы Windows для разработки на C++** в диалоговом окне Visual Studio **Новый проект**. Если это не устраняет проблему, то проект может зависеть от расширения Visual Studio (VSIX) C++/WinRT (см. раздел [Поддержка Visual Studio для C++/WinRT и VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix)).|
| Тесты комплекта сертификации приложений для Windows создают ошибку о том, что один из ваших классов среды выполнения "*не является производным от базового класса Windows. Все составные классы должны наследоваться от типа в пространстве имен Windows*".|Первичный базовый класс для каждого класса среды выполнения, *объявленного в приложении* должен являться типом из пространства имен Windows.*. Вы можете выполнить наследование модели представления от [**Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject). Кроме того, объявите привязываемый базовый класс, производный от **DependencyObject**и наследуйте модели представления от него.|
| Компилятор C++ создает ошибку "*must be WinRT type*" для специализации делегата EventHandler или TypedEventHandler.|Рассмотрите возможность использования **winrt::delegate&lt;...T&gt;**. См. раздел [Создание событий в C++/WinRT](author-events.md).|
| Компилятор C++ создает ошибку "*must be WinRT type*" для специализации асинхронной операции среды выполнения Windows.|Рассмотрите возможность возврата шаблона [**task**](https://msdn.microsoft.com/library/hh750113) библиотеки параллельных шаблонов (PPL). См. раздел [Параллельная обработка и асинхронные операции](concurrency.md).|
| Компилятор C++ создает ошибку "*error C2220: warning treated as error - no 'object' file generated*".|Исправьте предупреждение или установите параметру **C/C++** > **Общие** > **Обрабатывать предупреждения как ошибки** значение **Нет (/WX-)**.|
| В приложении возникает сбой, так как обработчик событий в объекте C++/WinRT вызывается после удаления объекта.|См. раздел [Использование объекта *this* в обработчике событий](handle-events.md#using-the-this-object-in-an-event-handler).|
| Компилятор C++ создает ошибку "*error C2338: This is only for weak ref support*".|Запрашивается слабая ссылка для типа, который передал структуру маркера **winrt::no_weak_ref** как аргумент шаблона базовому классу. См. раздел [Отказ от поддержки слабых ссылок](weak-references.md#opting-out-of-weak-reference-support)|
| Компоновщик C++ создает ошибку "*error LNK2019: Unresolved external symbol*" для API из заголовков пространства имен Windows для проекции C++/WinRT (в пространстве имен winrt).|API объявляется в заголовке, который вы включили, но его определения находится в заголовке, который еще не включен. Включите заголовок с именем для пространства имен API и повторно выполните сборку.|
