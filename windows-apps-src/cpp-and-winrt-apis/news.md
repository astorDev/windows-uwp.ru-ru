---
author: stevewhims
description: Новости и изменения в C + +/ WinRT.
title: Новые возможности в C + +/ WinRT
ms.author: stwhi
ms.date: 10/03/2018
ms.topic: article
keywords: Windows 10, uwp, стандартная, c ++, cpp, winrt, проекция, новости, что приложения, new
ms.localizationpriority: medium
ms.custom: RS5
ms.openlocfilehash: 1a10c9445f5909242675df6b3f2eaefab1aedcb3
ms.sourcegitcommit: ed0304b8a214c03b8aab74b8ef12c9f82b8e3c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/19/2018
ms.locfileid: "7295006"
---
# <a name="whats-new-in-cwinrt"></a>Новые возможности в C + +/ WinRT

В следующей таблице содержит новости и изменения [C + +/ WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) в обычно доступны последнюю версию пакета Windows SDK, который является 10.0.17763.0 (Windows 10, версия 1809). Эти изменения также может быть представлен в более поздних версиях SDK Insider Preview.

## <a name="news-and-changes-in-windows-sdk-version-100177630-windows-10-version-1809"></a>Новости и изменения, в Windows SDK версии 10.0.17763.0 (Windows 10, версия 1809)

| Новые или измененные функции | Дополнительные сведения |
| - | - |
| **Критическое изменение**. Для того чтобы скомпилировать, C + +/ WinRT не зависит от заголовки из пакета Windows SDK. | Ниже приведены [изоляции из файлов заголовков Windows SDK](#isolation-from-windows-sdk-header-files). |
| Формат система проекта Visual Studio был изменен. | См. в разделе [как Перенацелить C + +/ WinRT проекта на более позднюю версию пакета Windows SDK](#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk)ниже. |
| Существует новые функции и базовых классов для передать объект коллекции функции среды выполнения Windows, или реализовать собственные свойства коллекции и типы коллекций. | См. в разделе [коллекции с помощью C + +/ WinRT](collections.md). |
| Можно использовать расширение разметки [{Binding}](/windows/uwp/xaml-platform/binding-markup-extension) с помощью C + +/ WinRT классы среды выполнения. | Дополнительные сведения и примеры кода см. в разделе [Общие сведения о привязке данных](/windows/uwp/data-binding/data-binding-quickstart). |
| Поддержка отмены сопрограммы позволяет зарегистрировать обратный вызов отмены. | Дополнительные сведения и примеры кода см. в разделе [отмены асинхронной операции и обратные вызовы отмены](concurrency.md#canceling-an-asychronous-operation-and-cancellation-callbacks). |
| При создании делегат, указывающий на функцию-член, вы можете установить строгой или слабой ссылки на текущий объект (вместо необработанных *Этот* указатель) в той точке, где регистрируется обработчик. | Дополнительные сведения и примеры кода см. в разделе **при использовании функции-члена как делегат** подразделе в разделе [безопасный доступ к *Этот* указатель с помощью делегата обработки события](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate). |
| Ошибки являются фиксированными, были обнаруженные Visual Studio улучшенные возможности стандарта C++. Цепочку инструментов LLVM и Clang также лучше используются для проверки C + +/ WinRT стандартам. | Вам больше не придется работать проблемы описано в [Почему не нового проекта компиляции? Я использую Visual Studio 2017 (версии 15.8.0 или более поздней версии) и SDK версии 17134](faq.md#why-wont-my-new-project-compile-im-using-visual-studio-2017-version-1580-or-higher-and-sdk-version-17134) |

Другие изменения.

- **Критическое изменение**. [**winrt::get_abi(winrt::hstring const&)**](/uwp/cpp-ref-for-winrt/get-abi) теперь возвращает `void*` вместо `HSTRING`. Вы можете использовать `static_cast<HSTRING>(get_abi(my_hstring));` для получения HSTRING.
- **Критическое изменение**. Теперь возвращает [**WinRT::put_abi(WinRT::hstring&)**](/uwp/cpp-ref-for-winrt/put-abi) `void**` вместо `HSTRING*`. Вы можете использовать `reinterpret_cast<HSTRING*>(put_abi(my_hstring));` для получения HSTRING *.
- **Критическое изменение**. HRESULT теперь проецируется как **winrt::hresult**. Если вам требуется HRESULT (проверка типа или поддержка признаков типа), то вы можете `static_cast` **winrt::hresult**. В противном случае **winrt::hresult** преобразует HRESULT, как включить `unknwn.h` прежде чем включать C + +/ WinRT заголовков.
- **Критическое изменение**. GUID теперь проецируется как **winrt::guid**. API-интерфейсов, которую можно реализовать необходимо использовать **winrt::guid** для параметров GUID. В противном случае **winrt::hresult** преобразует код GUID, как включить `unknwn.h` прежде чем включать C + +/ WinRT заголовков.
- **Критическое изменение**. [**Конструктор winrt::handle_type**](/uwp/cpp-ref-for-winrt/handle-type#handletypehandletype-constructor) были Усиленная делая явные (это теперь труднее написать неправильный код с ним). Если вам необходимо назначить значение необработанное обработка, вызовите [**функцию handle_type::attach**](/uwp/cpp-ref-for-winrt/handle-type#handletypeattach-function) .
- **Критическое изменение**. Подписи **WINRT_CanUnloadNow** и **WINRT_GetActivationFactory** были изменены. Эти функции не должна объявить вообще. Вместо этого включают `winrt/base.h` (который включается автоматически при указании C + +/ файлы заголовков пространства имен WinRT для Windows) для включения объявлений из этих функций.
- Для [**структуры winrt::clock**](/uwp/cpp-ref-for-winrt/clock) **from_FILETIME или to_FILETIME** будут удалены в пользу **from_file_time/to_file_time**.
- API-интерфейсы, которые ожидают **IBuffer** параметров упрощены. Несмотря на то, что большинство API предпочитаете коллекций или массивы, достаточно API-интерфейсы используют **IBuffer** , его необходимо будет легче использовать такие интерфейсы API из C++. Это обновление предоставляет прямой доступ к данным за реализацию **IBuffer** , с помощью же данных соглашение об именовании использовать с контейнерами стандартной библиотеки C++. Это также позволяет избежать конфликтах с именами метаданных, которые традиционно начинаться с прописной буквы.
- Улучшенная создания кода: различные усовершенствования для уменьшения размера кода, улучшения встраивание и оптимизация кэширования фабрики.
- Удалить ненужные рекурсии. Когда командной строки относится к папке, а не к определенному `.winmd`, `cppwinrt.exe` больше не производит рекурсивно для `.winmd` файлов. `cppwinrt.exe` Средство теперь также обрабатывает дубликаты более интеллектуального, сделав его более устойчивыми ошибке пользователя и к неправильно сформированный `.winmd` файлов.
- Жесткой интеллектуальных указателей. Ранее revokers событий, не удалось отозвать при move назначить новое значение. Это позволило помогает выявить проблемы, где смарт-указателя классы не обработка надежно самообновления назначения; корневой каталог в [**шаблон структуры winrt::com_ptr**](/uwp/cpp-ref-for-winrt/com-ptr). **WinRT::com_ptr** была устранена, и событие revokers, привязанной к обрабатывать семантику перемещения правильно таким образом, чтобы они отозвать после назначения.

> [!NOTE]
> Версия 1.0.181002.2 (или более поздней версии) из [C + +/ расширение Visual Studio WinRT (VSIX)](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix) установлен, создав новый C + +/ WinRT проекта автоматически устанавливает [пакет Microsoft.Windows.CppWinRT NuGet](https://www.nuget.org/packages/Microsoft.Windows.CppWinRT/) для данного проекта. Пакет Microsoft.Windows.CppWinRT NuGet обеспечивает повышенную C + +/ WinRT проекта поддержку при построении, что проект переносимые между компьютер для разработки и агента построения (на котором только пакет NuGet и не VSIX, установлены).
>
> Для существующего проекта&mdash;после установки версии 1.0.181002.2 (или более поздней версии) из VSIX&mdash;мы рекомендуем откройте проект в Visual Studio, щелкните **проект** \> **Управление пакетами NuGet …**  \> , **Обзор**, введите или вставьте **Microsoft.Windows.CppWinRT** в поле поиска, выбрать элемент в результатах поиска и нажмите кнопку **Установка** установить пакет для этого проекта.


## <a name="isolation-from-windows-sdk-header-files"></a>Изоляция из файлов заголовков Windows SDK

Это потенциально критических изменений кода.

Для того чтобы скомпилировать, C + +/ WinRT больше не зависит от того, файлы заголовков из пакета Windows SDK. Также файлы заголовков в C++ стандартной библиотеки шаблонов (STL) и библиотеки времени выполнения C (CRT) не добавлять любые заголовки пакета Windows SDK. И это повышает соответствие стандартам, позволит избежать защищающая от случайных зависимостей и значительно уменьшает количество макросов, которые имеют защиту от.

Эта независимость означает, что C + +/ WinRT теперь дополнительные переносимые и стандартам, и он является очередным существует вероятность возникновения он становится кросс компилятор и кросс платформенной библиотеки. Это также означает, что C + +/ WinRT заголовки не негативно затронутые макросы.

Если вы ранее выполняли в C + +/ WinRT, которые добавлять любые заголовки, Windows в вашем проекте, а затем теперь необходимо включать их самостоятельно. Это, в любом случае всегда рекомендуется явным образом включать заголовки, которые зависят от, а не оставлять его на другую библиотеку, чтобы включить их для вас.

В настоящее время единственным исключением для изоляции файл заголовка пакета Windows SDK предназначены для встроенных элементов, а числовые значения. Известных проблем с помощью этих последнего оставшиеся зависимостей не существует.

В проекте можно снова включить взаимодействия с заголовки пакета Windows SDK, если необходимо. Может, например, необходимо реализовать COM-интерфейс (доверию в [**IUnknown**](https://msdn.microsoft.com/library/windows/desktop/ms680509)). В этом примере вспомогательных `unknwn.h` прежде чем включать C + +/ WinRT заголовков. Выполнив так причины C + +/ WinRT базовой библиотеке для включения различные обработчики для поддержки классических COM-интерфейсы. Пример кода, см. в разделе [Автор COM-компонентов с помощью C + +/ WinRT](author-coclasses.md). Аналогичным образом явным образом включать другие заголовки пакета Windows SDK, которые объявлять типы и функции, которые вы хотите вызвать.

## <a name="how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk"></a>Как Перенацелить C + +/ WinRT проекта на более позднюю версию пакета SDK для Windows

Метод переназначение проекта, который, скорее всего результата меньшее проблемой компилятора и компоновщика также является наиболее трудоемкими. Этот метод предусматривает создание нового проекта (предназначенных для Windows SDK версии по вашему выбору), а затем скопировать файлы по в новый проект из старой. Разделы старые будет `.vcxproj` и `.vcxproj.filters` файлов, которые можно просто скопировать более сэкономить добавления файлов в Visual Studio.

Тем не менее существует два других способа Перенацелить проекта в Visual Studio.

- Перейдите в проект **Общие**свойства \> **Версия Windows SDK**и выберите **Все конфигурации** и **Всех платформах**. Установите **Версия Windows SDK** версии, который вы хотите обратиться.
- В **Обозревателе решений**щелкните правой кнопкой мыши узел проекта, щелкните **Перенацелить проекты**, выберите версий, которые вы хотите выбрать и нажмите кнопку **ОК**.

Если обнаружения все компилятора и компоновщика ошибки после использовании любой из этих двух методов, то вы можете попробовать очистки решение (**сборка** > **Очистить решение** и/или вручную удалить все временные папки и файлы) перед попыткой повторного построения.

Если компилятор C++ выдает «*Ошибка C2039: «IUnknown»: не является членом "\'global имен ''*», затем добавьте `#include <unknwn.h>` в верхнюю часть вашего `pch.h` файл (прежде чем включать C + +/ WinRT заголовки).

Также может потребоваться добавить `#include <hstring.h>` после этого.

Если компоновщик C++ создает ошибку "*error LNK2019: неразрешенный внешний символ _WINRT_CanUnloadNow@0 в функции _VSDesignerCanUnloadNow@0 *», то вы можете устранить, добавив `#define _VSDESIGNER_DONT_LOAD_AS_DLL` для вашего `pch.h` файл.
