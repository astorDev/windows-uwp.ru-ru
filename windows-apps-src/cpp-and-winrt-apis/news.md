---
description: Новости и изменения в C + +/ WinRT.
title: Новые возможности в C + +/ WinRT
ms.date: 10/03/2018
ms.topic: article
keywords: Windows 10, uwp, стандартная, c ++, cpp, winrt, проекция, новости, что приложения, new
ms.localizationpriority: medium
ms.custom: RS5
ms.openlocfilehash: 87ab438de08ed5d6165343e7b9c4a559f37b351e
ms.sourcegitcommit: d7613c791107f74b6a3dc12a372d9de916c0454b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/05/2018
ms.locfileid: "8758138"
---
# <a name="whats-new-in-cwinrt"></a>Новые возможности в C + +/ WinRT

В следующей таблице содержит новости и изменения [C + +/ WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) в последней версии обычно доступны в Windows SDK, который является 10.0.17763.0 (Windows 10, версия 1809). Эти изменения также может быть представлен в более поздних версиях SDK Insider Preview.

## <a name="news-and-changes-in-windows-sdk-version-100177630-windows-10-version-1809"></a>Новости и изменения, в Windows SDK версии 10.0.17763.0 (Windows 10, версия 1809)

| Новые или измененные функции | Дополнительные сведения |
| - | - |
| **Критическое изменение**. Для того чтобы скомпилировать, C + +/ WinRT не зависит от заголовки из пакета Windows SDK. | Ниже приведены [изоляции из файлов заголовков Windows SDK](#isolation-from-windows-sdk-header-files). |
| Формат система проекта Visual Studio был изменен. | См. в разделе [как Перенацелить C + +/ WinRT проект до более поздней версии Windows SDK](#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk)ниже. |
| Существуют новые функции и базовых классов для передачи объекта коллекции в функцию среды выполнения Windows или реализовывать собственные свойства коллекции и типы коллекций. | См. в разделе [коллекции с помощью C + +/ WinRT](collections.md). |
| Можно использовать расширение разметки [{Binding}](/windows/uwp/xaml-platform/binding-markup-extension) с помощью C + +/ WinRT классы среды выполнения. | Дополнительные сведения и примеры кода см. в разделе [Общие сведения о привязке данных](/windows/uwp/data-binding/data-binding-quickstart). |
| Поддержка отмены сопрограммы позволяет зарегистрировать обратный вызов отмены. | Дополнительные сведения и примеры кода см. в разделе [отмены асинхронной операции и обратные вызовы отмены](concurrency.md#canceling-an-asychronous-operation-and-cancellation-callbacks). |
| При создании делегат, указывающий на функцию-член, вы можете установить строгой или слабой ссылки на текущий объект (вместо необработанных *Этот* указатель) в той точке, где регистрируется обработчик. | Дополнительные сведения и примеры кода см. в разделе **при использовании функции-члена представителем** подразделе в разделе [безопасный доступ к *этой* указателя с помощью делегата обработки события](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate). |
| Ошибки являются фиксированными, были обнаруженные Visual Studio повышенной соответствие стандартам C++. Цепочку инструментов LLVM и Clang также лучше используются для проверки C + +/ WinRT стандартам. | Вам больше не придется работать проблемы создать новый проект не будет описано в [Почему компиляции? Я использую Visual Studio 2017 (версии 15.8.0 или более поздней версии) и пакет SDK версии 17134](faq.md#why-wont-my-new-project-compile-im-using-visual-studio-2017-version-1580-or-higher-and-sdk-version-17134) |

Другие изменения.

- **Критическое изменение**. [**winrt::get_abi(winrt::hstring const&)**](/uwp/cpp-ref-for-winrt/get-abi) теперь возвращает `void*` вместо `HSTRING`. Вы можете использовать `static_cast<HSTRING>(get_abi(my_hstring));` для получения HSTRING.
- **Критическое изменение**. Теперь возвращает [**WinRT::put_abi(WinRT::hstring&)**](/uwp/cpp-ref-for-winrt/put-abi) `void**` вместо `HSTRING*`. Вы можете использовать `reinterpret_cast<HSTRING*>(put_abi(my_hstring));` для получения HSTRING *.
- **Критическое изменение**. HRESULT теперь проецируется как **winrt::hresult**. Если вам требуется HRESULT (проверка типа или поддержка характеристикам типов), то вы можете `static_cast` **winrt::hresult**. В противном случае **winrt::hresult** преобразует HRESULT, до тех пор, пока вы включить `unknwn.h` прежде чем включать C + +/ WinRT заголовков.
- **Критическое изменение**. GUID теперь проецируется как **winrt::guid**. API-интерфейсов, которую можно реализовать необходимо использовать **winrt::guid** для параметров GUID. В противном случае **winrt::hresult** преобразует код GUID, до тех пор, пока вы включить `unknwn.h` прежде чем включать C + +/ WinRT заголовков.
- **Критическое изменение**. [**Конструктор winrt::handle_type**](/uwp/cpp-ref-for-winrt/handle-type#handletypehandletype-constructor) , сохраняются, делая явные (трудно теперь написать неправильный код с ним). Если вам необходимо назначить значение необработанных дескриптор, вызовите [**функцию handle_type::attach**](/uwp/cpp-ref-for-winrt/handle-type#handletypeattach-function) .
- **Критическое изменение**. Подписи **WINRT_CanUnloadNow** и **WINRT_GetActivationFactory** были изменены. Эти функции не должна объявить вообще. Вместо этого включают `winrt/base.h` (который включается автоматически при указании C + +/ файлы заголовков пространства имен WinRT для Windows) для включения объявлений из этих функций.
- Для [**структуры winrt::clock**](/uwp/cpp-ref-for-winrt/clock) **from_FILETIME или to_FILETIME** будут удалены в пользу **from_file_time/to_file_time**.
- API-интерфейсы, которые ожидают **IBuffer** параметров упрощены. Несмотря на то, что большинство API предпочитаете коллекции и массивы, достаточно API-интерфейсы используют **IBuffer** , необходимые для более эффективного использования таких API-интерфейсы из C++. Это обновление предоставляет прямой доступ к данным за реализацию **IBuffer** , с помощью одного данных соглашение об именовании используемые контейнеров стандартной библиотеки C++. Это также позволяет избежать конфликтах с именами метаданных, которые традиционно начинаться с прописной буквы.
- Улучшенная создания кода: различные усовершенствования сократить объем кода повышают встраивание и оптимизация кэширования фабрики.
- Удалить ненужные рекурсии. Когда командной строки относится к папке, а не к определенному `.winmd`, `cppwinrt.exe` больше не производит рекурсивно для `.winmd` файлов. `cppwinrt.exe` Средство теперь также обрабатывает дубликаты более интеллектуального, сделав его более устойчивыми ошибке пользователя и к неправильно сформированный `.winmd` файлов.
- Жесткой интеллектуальных указателей. Ранее revokers событие, не удалось отозвать при move назначен новое значение. Это позволило помогает выявить проблемы, где смарт-указателя классы не обработка надежно самообновления назначения; корневой каталог [**шаблон структуры winrt::com_ptr**](/uwp/cpp-ref-for-winrt/com-ptr). **WinRT::com_ptr** была устранена, и событие revokers, привязанной к обрабатывать семантику перемещения правильно таким образом, чтобы они отозвать после назначения.

> [!NOTE]
> Версия 1.0.181002.2 (или более поздней версии) из [C + +/ расширение Visual Studio WinRT (VSIX)](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix) установлен, создав новый C + +/ WinRT проекта автоматически устанавливает [пакет Microsoft.Windows.CppWinRT NuGet](https://www.nuget.org/packages/Microsoft.Windows.CppWinRT/) для данного проекта. Пакет Microsoft.Windows.CppWinRT NuGet обеспечивает повышенную C + +/ WinRT проект поддержку при построении, что проект переносимые между компьютер для разработки и агента построения (на котором только пакет NuGet, а не VSIX установлен).
>
> Для существующего проекта&mdash;после установки версии 1.0.181002.2 (или более поздней версии) из VSIX&mdash;мы рекомендуем откройте проект в Visual Studio, щелкните **проект** \> **Управление пакетами NuGet …**  \> , **Обзор**, введите или вставьте **Microsoft.Windows.CppWinRT** в поле поиска, выбрать элемент в результатах поиска и нажмите кнопку **Установка** установить пакет для этого проекта.


## <a name="isolation-from-windows-sdk-header-files"></a>Изоляция из файлов заголовков Windows SDK

Это потенциально критических изменений в коде.

Для того чтобы скомпилировать, C + +/ WinRT больше не зависит от того, файлы заголовков из пакета Windows SDK. Также файлы заголовков в C++ стандартной библиотеки шаблонов (STL) и библиотеки времени выполнения C (CRT) не добавлять любые заголовки пакета Windows SDK. И это повышает соответствие стандартам, позволит избежать защищающая от случайных зависимостей и значительно уменьшает количество макросов, которые имеют защиту от.

Эта независимость означает, что C + +/ WinRT теперь дополнительные переносимые и стандартам, и он является очередным вероятность его получения статуса кросс компилятор и кросс платформенной библиотеки. Это также означает, что C + +/ WinRT заголовки не негативно затронутые макросы.

Если вы ранее выполняли в C + +/ WinRT, которые добавлять любые заголовки Windows в вашем проекте, а затем теперь необходимо включить их. Это, в любом случае всегда рекомендуется явным образом включать заголовки, которые зависят от, а не оставлять на другую библиотеку, чтобы включить их для вас.

На данный момент единственное исключение из изоляции файл заголовка пакета Windows SDK предназначены для встроенных функций и числовые значения. Известных проблем этих последнего оставшиеся каких-либо зависимостей не существует.

В вашем проекте можно снова включить взаимодействия с заголовками Windows SDK, если необходимо. Например, можно реализовать COM-интерфейс (доверию в [**IUnknown**](https://msdn.microsoft.com/library/windows/desktop/ms680509)). В этом примере вспомогательных `unknwn.h` прежде чем включать C + +/ WinRT заголовков. Делать это выводится C + +/ WinRT базовой библиотеке включить различные обработчики для поддержки классических COM-интерфейсы. Пример кода, см. в разделе [Author COM-компонентов с помощью C + +/ WinRT](author-coclasses.md). Аналогичным образом явным образом включать другие заголовки пакета Windows SDK, которые объявлять типы и функции, которые вы хотите вызвать.

## <a name="how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk"></a>Как Перенацелить C + +/ WinRT проект до более поздней версии Windows SDK

Метод переназначение проекте, который может привести к меньшее проблема компилятора и компоновщика также является наиболее трудоемкими. Этот метод предусматривает создание нового проекта (предназначенных для Windows SDK версии по вашему выбору), а затем скопировать файлы по в новый проект из старой. Разделы старые будет `.vcxproj` и `.vcxproj.filters` файлы, которые можно просто скопировать более чем сэкономить добавления файлов в Visual Studio.

Тем не менее существует два других способа Перенацелить проекта в Visual Studio.

- Последовательно выберите пункты проекта **Общие**свойства \> **Версия Windows SDK**и установите **Все конфигурации** и **Всех платформ**. Задайте **Версия Windows SDK** версии, вы хотите обратиться.
- В **Обозревателе решений**щелкните правой кнопкой мыши узел проекта, щелкните **Перенацелить проекты**, выберите версий, которые вы хотите выбрать и нажмите кнопку **ОК**.

При возникновении все компилятора и компоновщика ошибки после применения любого из этих двух методов, а затем вы можете попробовать очистки решение (**сборка** > **Очистить решение** и/или вручную удалить все временные папки и файлы) перед попыткой повторного построения.

Если компилятор C++ выдает «*Ошибка C2039: «IUnknown»: не является членом "\'global имен ''*», затем добавьте `#include <unknwn.h>` в верхней части вашего `pch.h` файл (прежде чем включать C + +/ WinRT заголовки).

Также может потребоваться добавить `#include <hstring.h>` после этого.

Если компоновщик C++ создает ошибку "*error LNK2019: неразрешенный внешний символ _WINRT_CanUnloadNow@0 в функцию _VSDesignerCanUnloadNow@0 *», а затем вы можете устранить, добавив `#define _VSDESIGNER_DONT_LOAD_AS_DLL` для вашей `pch.h` файла.
