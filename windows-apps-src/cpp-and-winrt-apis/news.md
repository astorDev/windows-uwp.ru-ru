---
author: stevewhims
description: Новости и изменения в C + +/ WinRT.
title: Новые возможности в C + +/ WinRT
ms.author: stwhi
ms.date: 10/03/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: Windows 10, uwp, стандартная, c ++, cpp, winrt, проекция, новости, что приложения, new
ms.localizationpriority: medium
ms.openlocfilehash: bc6be28e112dfdd14b3585bd88ba066fbeae382d
ms.sourcegitcommit: 933e71a31989f8063b020746fdd16e9da94a44c4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/11/2018
ms.locfileid: "4539025"
---
# <a name="whats-new-in-cwinrt"></a>Новые возможности в C + +/ WinRT

В следующей таблице содержит новости и изменения [C + +/ WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) в обычно доступны последнюю версию пакета Windows SDK, который является 10.0.17763.0 (Windows 10, версия 1809). Эти изменения также может быть представлен в более поздних версиях SDK Insider Preview.

## <a name="news-and-changes-in-windows-sdk-version-100177630-windows-10-version-1809"></a>Новости и изменения, в Windows SDK версии 10.0.17763.0 (Windows 10, версия 1809)

| Новые или измененные функции | Дополнительные сведения |
| - | - |
| **Критическое изменение**. Для того чтобы скомпилировать, C + +/ WinRT не зависит от заголовки из пакета Windows SDK. | Ниже приведены [изоляции из файлов заголовков Windows SDK](#isolation-from-windows-sdk-header-files). |
| Формат система проекта Visual Studio был изменен. | См. в разделе [как Перенацелить C + +/ WinRT проекта на более позднюю версию пакета Windows SDK](#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk)ниже. |
| Существуют новые функции и базовых классов для передать объект коллекции функции среды выполнения Windows, или реализовать собственные свойства коллекции и типов коллекций. | См. в разделе [коллекции с помощью C + +/ WinRT](collections.md). |
| Можно использовать расширение разметки [{Binding}](/windows/uwp/xaml-platform/binding-markup-extension) в C + +/ WinRT классы среды выполнения. | Дополнительные сведения и примеры кода см. в разделе [Общие сведения о привязке данных](/windows/uwp/data-binding/data-binding-quickstart). |
| Поддержка отмены сопрограммы позволяет зарегистрировать обратный вызов отмены. | Дополнительные сведения и примеры кода см. в разделе [отмены асинхронной операции и обратные вызовы отмены](concurrency.md#canceling-an-asychronous-operation-and-cancellation-callbacks). |
| При создании делегат, указывающий на функцию-член, вы можете установить строгой или слабой ссылки на объект текущего (вместо необработанных *Этот* указатель) в точке, где регистрируется обработчик. | Дополнительные сведения и примеры кода см. **Если вы используете функцию-член как делегат** вложенных раздела [безопасный доступ к *Этот* указатель с помощью делегата обработки события](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate). |
| Ошибки являются фиксированными, были обнаруженные Visual Studio улучшенные возможности стандарта C++. Цепочку инструментов LLVM и Clang также лучше используются для проверки C + +/ WinRT стандартам. | Вам больше не придется работать проблемы описаны в [Почему не нового проекта компиляции? Я использую Visual Studio 2017 (версии 15.8.0 или более поздней версии) и пакет SDK версии 17134](faq.md#why-wont-my-new-project-compile-im-using-visual-studio-2017-version-1580-or-higher-and-sdk-version-17134) |

Другие изменения.

- **Критическое изменение**. [**winrt::get_abi(winrt::hstring const&)**](/uwp/cpp-ref-for-winrt/get-abi) теперь возвращает `void*` вместо `HSTRING`. Вы можете использовать `static_cast<HSTRING>(get_abi(my_hstring));` для получения HSTRING.
- **Критическое изменение**. Теперь возвращает [**WinRT::put_abi(WinRT::hstring&)**](/uwp/cpp-ref-for-winrt/put-abi) `void**` вместо `HSTRING*`. Вы можете использовать `reinterpret_cast<HSTRING*>(put_abi(my_hstring));` для получения HSTRING *.
- **Критическое изменение**. Теперь HRESULT проецируется как **winrt::hresult**. Если вам требуется HRESULT (проверка типа или поддержка признаков типа), то вы можете `static_cast` **winrt::hresult**. В противном случае **winrt::hresult** преобразует HRESULT, как включить `unknwn.h` прежде чем включать C + +/ WinRT заголовков.
- **Критическое изменение**. GUID теперь проецируется как **winrt::guid**. API-интерфейсов, которую можно реализовать необходимо использовать **winrt::guid** для параметров GUID. В противном случае **winrt::hresult** преобразует код GUID, как включить `unknwn.h` прежде чем включать C + +/ WinRT заголовков.
- **Критическое изменение**. [**Конструктор winrt::handle_type**](/uwp/cpp-ref-for-winrt/handle-type#handletypehandletype-constructor) , сохраняются, делая явные (это теперь труднее написать неправильный код с ним). Если вам необходимо назначить значение необработанных дескриптор, вызовите [**функцию handle_type::attach**](/uwp/cpp-ref-for-winrt/handle-type#handletypeattach-function) .
- **Критическое изменение**. Подписи **WINRT_CanUnloadNow** и **WINRT_GetActivationFactory** были изменены. Эти функции не должна объявить вообще. Вместо этого включают `winrt/base.h` (который включается автоматически при указании C + +/ файлы заголовков пространства имен WinRT для Windows) для включения объявлений из этих функций.
- Для [**структуры winrt::clock**](/uwp/cpp-ref-for-winrt/clock) **from_FILETIME или to_FILETIME** будут удалены в пользу **from_file_time/to_file_time**.
- API-интерфейсы, которые ожидают **IBuffer** параметров упрощены. Несмотря на то, что большинство API предпочитаете коллекции и массивы, достаточно API-интерфейсы используют **IBuffer** , необходимые для удобнее использовать такие интерфейсы API из C++. Это обновление предоставляет прямой доступ к данным за реализацию **IBuffer** , с помощью одного данных соглашение об именовании используется с контейнерами стандартной библиотеки C++. Кроме того, это позволяет избежать конфликтах с именами метаданных, которые традиционно начинаться с прописной буквы.
- Улучшенная создание кода: различные усовершенствования для уменьшения размера кода, улучшения встраивание и оптимизация кэширования фабрики.
- Удалить ненужные рекурсии. Когда командной строки относится к папке, а не для конкретного `.winmd`, `cppwinrt.exe` больше не производит рекурсивно для `.winmd` файлов. `cppwinrt.exe` Средство теперь также обрабатывает дубликаты более интеллектуального более устойчивыми, ошибки пользователя, и к неправильно сформированный `.winmd` файлов.
- Зафиксированного интеллектуальных указателей. Ранее revokers события, не удалось отозвать при перемещения назначенный новое значение. Это позволило помогает выявить проблемы, где смарт-указателя классы не обработки надежно самообновления назначения; корнем [**шаблон структуры winrt::com_ptr**](/uwp/cpp-ref-for-winrt/com-ptr). **WinRT::com_ptr** была устранена, и revokers события, привязанной к обработки семантику перемещения правильно таким образом, чтобы они отозвать после назначения.

> [!NOTE]
> Версия 1.0.181002.2 (или более поздней версии) из [C + +/ расширение Visual Studio WinRT (VSIX)](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix) установки, создав новый C + +/ WinRT проекта автоматически устанавливает [пакет Microsoft.Windows.CppWinRT NuGet](https://www.nuget.org/packages/Microsoft.Windows.CppWinRT/) для данного проекта. Пакет Microsoft.Windows.CppWinRT NuGet обеспечивает повышенную C + +/ WinRT проекта построения поддержки, Создание проекта переносимые между компьютер для разработки и агента построения (на котором только пакет NuGet и не VSIX, установлены).
>
> Для существующего проекта&mdash;после установки версии 1.0.181002.2 (или более поздней версии) из VSIX&mdash;рекомендуется откройте проект в Visual Studio, щелкните **проект** \> **Управление пакетами NuGet …**  \> , **Обзор**, введите или вставьте **Microsoft.Windows.CppWinRT** в поле поиска, выбрать элемент в результатах поиска и нажмите кнопку **установить** для установки пакета для этого проекта.


## <a name="isolation-from-windows-sdk-header-files"></a>Изоляция из файлов заголовков Windows SDK

Это потенциально критических изменений в коде.

Для того чтобы скомпилировать, C + +/ WinRT больше не зависит от того, файлы заголовков из пакета Windows SDK. Также файлы заголовков в библиотеке времени выполнения C (CRT) и C++ стандартной библиотеки шаблонов (STL) не добавлять любые заголовки пакета Windows SDK. И, повышает соответствие стандартам, позволит избежать защищающая от случайных зависимостей и значительно уменьшает количество макросов, которые имеют защиту от.

Эта независимость означает, что C + +/ WinRT теперь более переносимые и стандартам, и он является очередным вероятность его получения статуса кросс компилятор и кросс платформенной библиотеки. Это также означает, что C + +/ WinRT заголовки не негативно затронутые макросов.

Если вы ранее выполняли в C + +/ WinRT, которые добавлять любые заголовки Windows в свой проект, а затем теперь необходимо включить их. Это, в любом случае всегда рекомендуется явным образом включать заголовки, которые зависят от, а не оставлять его на другую библиотеку, чтобы включить их для вас.

В настоящее время только исключения для изоляции файл заголовка пакета Windows SDK предназначены для встроенных элементов, а числовые значения. Известных проблем с помощью этих последнего оставшиеся зависимостей не существует.

В проекте можно снова включить взаимодействия с заголовки пакета Windows SDK, если необходимо. Например, можно реализовать интерфейс COM (корнем в [**IUnknown**](https://msdn.microsoft.com/library/windows/desktop/ms680509)). В этом примере включить `unknwn.h` прежде чем включать C + +/ WinRT заголовков. Выполнив так причины C + +/ WinRT базовой библиотеке включить различные обработчики для поддержки классических COM-интерфейсы. Пример кода, см. в разделе [Автор COM-компоненты с помощью C + +/ WinRT](author-coclasses.md). Аналогичным образом явным образом включать другие заголовки пакета Windows SDK, которые объявлять типы и функции, которые вы хотите вызвать.

## <a name="how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk"></a>Как Перенацелить C + +/ WinRT проекта на более позднюю версию пакета SDK для Windows

Метод переназначение проекта, который может привести к меньшее проблемы компилятора и компоновщика также является наиболее трудоемкий. Этот метод предусматривает создание нового проекта (предназначенных для Windows SDK версии по вашему выбору), а затем скопировать файлы по в новый проект из старой. Разделы старые будет `.vcxproj` и `.vcxproj.filters` файлы, которые можно просто скопировать более чем сэкономить добавления файлов в Visual Studio.

Тем не менее существует два других способов Перенацелить проекта в Visual Studio.

- Перейдите в проект **Общие**свойства \> **Версия Windows SDK**и установите **Все конфигурации** и **Всех платформ**. Установите **Версия Windows SDK** версии, который вы хотите обратиться.
- В **Обозревателе решений**щелкните правой кнопкой мыши узел проекта, выберите **Перенацелить проекты**, выберите версий, которые вы хотите выбрать и нажмите кнопку **ОК**.

Если обнаружения все компилятора и компоновщика ошибки после использовании любой из этих двух методов, то вы можете попробовать очистки решение (**сборка** > **Очистить решение** и/или вручную удалить все временные папки и файлы) до попытки выполнить построение снова.

Если компилятор C++ выдает "*Ошибка C2039: «IUnknown»: не является членом" \'global пространства имен ''*«, затем добавьте `#include <unknwn.h>` в верхней части вашего `pch.h` файл (прежде чем включать C + +/ WinRT заголовки).

Также может потребоваться добавить `#include <hstring.h>` после этого.

Если компоновщик C++ создает ошибку "*error LNK2019: неразрешенный внешний символ _WINRT_CanUnloadNow@0 в функции _VSDesignerCanUnloadNow@0 *«, затем вы можете устранить, добавив `#define _VSDESIGNER_DONT_LOAD_AS_DLL` для вашей `pch.h` файла.
