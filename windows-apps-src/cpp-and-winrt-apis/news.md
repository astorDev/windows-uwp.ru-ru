---
description: Новости и изменения в C++/WinRT.
title: Новые возможности в C + +/ WinRT
ms.date: 01/29/2019
ms.topic: article
keywords: Windows 10, uwp, standard, c ++, cpp, winrt, проекции, новости, что его новые
ms.localizationpriority: medium
ms.custom: RS5
ms.openlocfilehash: cb624a93a010dfe9784cf8c26beed12c6cf2f77d
ms.sourcegitcommit: b034650b684a767274d5d88746faeea373c8e34f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2019
ms.locfileid: "57639959"
---
# <a name="whats-new-in-cwinrt"></a>Новые возможности в C + +/ WinRT

В следующей таблице содержит новости и примет [C + +/ WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) в общем доступе последнюю версию пакета SDK для Windows, которая представляет собой 10.0.17763.0 (Windows 10, версия 1809). Эти изменения могут также присутствовать в более поздних версиях Insider Preview пакета SDK.

## <a name="news-and-changes-in-windows-sdk-version-100177630-windows-10-version-1809"></a>Новости и изменения, в пакете Windows SDK версии 10.0.17763.0 (Windows 10, версия 1809)

| Новые и измененные функции | Дополнительные сведения |
| - | - |
| **Критическое изменение**. Для его компиляции, C + +/ WinRT не зависит от заголовков из пакета Windows SDK. | См. в разделе [отдельно от файлов заголовков Windows SDK](#isolation-from-windows-sdk-header-files)ниже. |
| Формат системы проекта Visual Studio был изменен. | См. в разделе [как изменить целевую платформу C + +/ WinRT проекта до более поздней версии пакета SDK Windows](#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk)ниже. |
| Существуют новые функции и базовые классы, которые помогут вам передать объект коллекции среды выполнения Windows функции или реализовать свои собственные свойства и коллекции типов коллекций. | См. в разделе [коллекций с использованием C + +/ WinRT](collections.md). |
| Можно использовать [{Binding}](/windows/uwp/xaml-platform/binding-markup-extension) расширения разметки с использованием C + +/ WinRT классов среды выполнения. | Дополнительные сведения и примеры кода см. в разделе [Общие сведения о привязке данных](/windows/uwp/data-binding/data-binding-quickstart). |
| Поддержка отмены соподпрограмме позволяет зарегистрировать обратный вызов отмены. | Дополнительные сведения и примеры кода см. в разделе [Отмена асинхронной операции и обратные вызовы отмены](concurrency.md#canceling-an-asychronous-operation-and-cancellation-callbacks). |
| При создании делегат, указывающий на функцию-член, вы можете установить надежный или слабую ссылку на текущий объект (вместо необработанного *это* указателя) в точке, в котором зарегистрирован обработчик. | Дополнительные сведения и примеры кода см. в разделе **при использовании функции-члена в качестве делегата** подраздел в разделе [безопасного доступа к *это* указатель с помощью делегата, обрабатывающего события](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate). |
| Исправлены ошибки, которые были обнаруженные Visual Studio улучшенное соответствие стандарту c++. Цепочка инструментов LLVM и Clang также лучше использовать для проверки C + +/ WinRT в соответствие стандартам. | Больше не придется столкнуться проблему, описанную в [почему мой новый проект не будет компилироваться? Я использую Visual Studio 2017 (версии 15.8.0 или более поздней версии) и пакет SDK версии 17134](faq.md#why-wont-my-new-project-compile-im-using-visual-studio-2017-version-1580-or-higher-and-sdk-version-17134) |

Другие изменения.

- **Критическое изменение**. [**WinRT::get_abi(WinRT::hstring const&)** ](/uwp/cpp-ref-for-winrt/get-abi) теперь возвращает `void*` вместо `HSTRING`. Можно использовать `static_cast<HSTRING>(get_abi(my_hstring));` для получения HSTRING.
- **Критическое изменение**. [**WinRT::put_abi(WinRT::hstring&)** ](/uwp/cpp-ref-for-winrt/put-abi) теперь возвращает `void**` вместо `HSTRING*`. Можно использовать `reinterpret_cast<HSTRING*>(put_abi(my_hstring));` для получения HSTRING *.
- **Критическое изменение**. HRESULT теперь защищен как **winrt::hresult**. Если необходимо, чтобы значение HRESULT (проверку типов, или для поддержки признаков типа), то вы можете `static_cast` **winrt::hresult**. В противном случае **winrt::hresult** преобразует значение HRESULT, до тех пор, пока вы включают `unknwn.h` перед включением C + +/ WinRT заголовки.
- **Критическое изменение**. GUID теперь защищен как **winrt::guid**. Для API-интерфейсы, реализуемые, необходимо использовать **winrt::guid** для параметров GUID. В противном случае **winrt::hresult** преобразует GUID, до тех пор, пока вы включают `unknwn.h` перед включением C + +/ WinRT заголовки.
- **Критическое изменение**. [ **Конструктор winrt::handle_type** ](/uwp/cpp-ref-for-winrt/handle-type#handletypehandletype-constructor) были записаны на диск, делая явные (теперь стало труднее писать неверный код с ним). Если вам нужно назначить необработанного значения дескриптора, вызвать [ **функция handle_type::attach** ](/uwp/cpp-ref-for-winrt/handle-type#handletypeattach-function) вместо этого.
- **Критическое изменение**. В отношении сигнатур **WINRT_CanUnloadNow** и **WINRT_GetActivationFactory** были изменены. Эти функции не должны объявлять вообще. Вместо этого включить `winrt/base.h` (который автоматически включается при включении C + +/ файлы заголовков пространство имен WinRT Windows) для включения объявления этих функций.
- Для [ **структуры winrt::clock**](/uwp/cpp-ref-for-winrt/clock), **from_FILETIME/to_FILETIME** являются устаревшими для **from_file_time/to_file_time**.
- Интерфейсы API, которые ожидают **IBuffer** параметры упрощены. Несмотря на то, что большинство интерфейсов API предпочитаете коллекций или массивов, достаточно API-интерфейсы полагаться на **IBuffer** что ей нужно быть проще с помощью таких API из C++. Это обновление обеспечивает прямой доступ к данным за **IBuffer** реализации, с помощью же данных соглашение об именовании контейнеров стандартной библиотеки C++. Это также позволяет избежать конфликтов имен метаданных, которые обычно начинаются с заглавной буквы.
- Улучшенное создание кода: различные улучшения, уменьшающие размер кода, повышения встраивания и оптимизации кэширования фабрики.
- Удалить ненужные рекурсии. Если командной строке упоминается в папку, а не конкретному `.winmd`, `cppwinrt.exe` средство больше не выполняет рекурсивный `.winmd` файлов. `cppwinrt.exe` Средство также теперь обрабатывает дубликаты более разумно, сделав его более устойчивым к ошибки пользователя и на неправильно сформированный `.winmd` файлов.
- Зафиксированный интеллектуальные указатели. Ранее revokers событие, не удалось отозвать при move присвоено значение. Это позволило выявить ошибку, где классы интеллектуальных указателей не были обработки надежно присваивания; в [ **winrt::com_ptr структуры шаблона**](/uwp/cpp-ref-for-winrt/com-ptr). **WinRT::com_ptr** была исправлена, и событие revokers, исправлена для обработки семантики перемещения правильно таким образом, они отзовут после назначения.

> [!IMPORTANT]
> Были внесены важные изменения [C + +/ WinRT Visual Studio Extension (VSIX)](https://aka.ms/cppwinrt/vsix), как в версии 1.0.181002.2, а позже — в версии 1.0.190128.4. Дополнительные сведения об этих изменениях и их влиянии на существующие проекты [поддержка Visual Studio для C + +/ WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package) и [более ранних версиях расширение VSIX](intro-to-using-cpp-with-winrt.md#earlier-versions-of-the-vsix-extension).

## <a name="isolation-from-windows-sdk-header-files"></a>Отдельно от файлов заголовков Windows SDK

Потенциально Это критическое изменение для кода.

Для его компиляции, C + +/ WinRT больше не зависит от файлов заголовков из пакета Windows SDK. Файлы заголовков в библиотеке времени выполнения C (CRT) и C++ стандартной библиотеки шаблонов (STL) также не включайте все заголовки Windows SDK. И, улучшает совместимость со стандартами, позволяет избежать случайного зависимостей и значительно сокращает количество макросов, которых следует остерегаться.

Эта независимость означает, что C + +/ WinRT теперь дополнительные переносимые и соответствие отраслевым стандартам, и он является очередным возможность стать кросс компилятор и кросс платформенную библиотеку. Это также означает, что C + +/ WinRT заголовки не оказывается негативное влияние макросы.

Если ранее оно было оставлено для C + +/ WinRT включать какие-либо заголовки Windows в проекте, то теперь нужно будет включать их. Это, в любом случае всегда рекомендуется явным образом включать заголовки, от которых зависит и не оставить его на другую библиотеку, чтобы включить их для вас.

В настоящее время единственным исключением изоляции файл заголовка пакета SDK для Windows предназначены для встроенных функций и числовыми значениями. Существуют известные проблемы с эти последние оставшиеся зависимости отсутствуют.

В проекте можно снова включить взаимодействие с заголовками Windows SDK, если вам нужно. Например, можно реализовать интерфейс COM (с корнем в [ **IUnknown**](https://msdn.microsoft.com/library/windows/desktop/ms680509)). Для этого примера включают `unknwn.h` перед включением C + +/ WinRT заголовки. Выполнив это выводится C + +/ WinRT базовой библиотеки для включения используются различные обработчики для поддержки классического COM-интерфейсов. Пример кода см. в разделе [автор компонентов COM с помощью C + +/ WinRT](author-coclasses.md). Аналогично явным образом включить других заголовков Windows SDK, которые объявляют типы или функции, которые вы хотите вызвать.

## <a name="how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk"></a>Как изменить целевую платформу C + +/ WinRT проекта до более поздней версии пакета SDK для Windows

Метод для целевой платформы проекта, которая, скорее всего, приведет к наименьшим количеством проблему компилятора и компоновщика также — наиболее трудоемкий процесс. Этот метод включает в себя создание нового проекта (предназначенных для версии пакета SDK для Windows по своему усмотрению), а затем скопировать файлы через для нового проекта из старой. Будет существовать разделы старая `.vcxproj` и `.vcxproj.filters` файлы, которые вы можете просто скопируйте более сэкономить Добавление файлов в Visual Studio.

Тем не менее существует два способа изменить целевую платформу проекта в Visual Studio.

- Перейдите к свойству проекта **Общие** \> **версия пакета SDK для Windows**и выберите **все конфигурации** и **всех платформ**. Задайте **версия пакета SDK для Windows** с версией, вы будете работать.
- В **обозревателе решений**, щелкните правой кнопкой мыши узел проекта, щелкните **Перенацелить проекты**, Выбор версии, необходимо выбирать и нажмите кнопку **ОК**.

Если возникают все компилятора или компоновщика ошибки после применения любого из этих двух методов, то вы можете попробовать очистки решения (**построения** > **Очистить решение** и/или вручную удалить все временные папки и файлы) перед попыткой повторной сборки.

Если компилятор C++ создает "*Ошибка C2039: «IUnknown»: не является членом "\`глобальное пространство имен ''*«, затем добавьте `#include <unknwn.h>` в верхнюю часть вашей `pch.h` файла (до включения C + +/ WinRT заголовки).

Также может потребоваться добавить `#include <hstring.h>` после этого.

Если компоновщик C++ создает "*Ошибка LNK2019: неразрешенный внешний символ _WINRT_CanUnloadNow@0 на которые ссылается функция _VSDesignerCanUnloadNow@0* «, то можно устранить, добавив `#define _VSDESIGNER_DONT_LOAD_AS_DLL` для вашей `pch.h` файл.
