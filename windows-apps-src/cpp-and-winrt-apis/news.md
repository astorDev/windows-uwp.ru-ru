---
description: Новости и изменения в C + +/ WinRT.
title: Новые возможности в C + +/ WinRT
ms.date: 01/29/2019
ms.topic: article
keywords: Windows 10, uwp, стандартная, c ++, cpp, winrt, проекция, новости, что приложения, new
ms.localizationpriority: medium
ms.custom: RS5
ms.openlocfilehash: cb624a93a010dfe9784cf8c26beed12c6cf2f77d
ms.sourcegitcommit: 2d2483819957619b6de21b678caf887f3b1342af
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/01/2019
ms.locfileid: "9042436"
---
# <a name="whats-new-in-cwinrt"></a>Новые возможности в C + +/ WinRT

В следующей таблице содержит новости и изменения [C + +/ WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) в-общедоступен последнюю версию пакета Windows SDK, который является 10.0.17763.0 (Windows 10, версия 1809). Эти изменения также может быть представлен в более поздних версиях SDK Insider Preview.

## <a name="news-and-changes-in-windows-sdk-version-100177630-windows-10-version-1809"></a>Новости и изменения, в Windows SDK версии 10.0.17763.0 (Windows 10, версия 1809)

| Новые или измененные функции | Дополнительные сведения |
| - | - |
| **Критическое изменение**. Для того чтобы скомпилировать, C + +/ WinRT не зависит от заголовки из пакета Windows SDK. | Ниже приведены [изоляции из файлов заголовков Windows SDK](#isolation-from-windows-sdk-header-files). |
| Формат система проекта Visual Studio был изменен. | См. в разделе [как Перенацелить C + +/ WinRT проекта на более позднюю версию пакета Windows SDK](#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk)ниже. |
| Существует новые функции и базовых классов для передачи объекта коллекции в функцию среды выполнения Windows, или реализовать собственные свойства коллекции и типы коллекций. | См. в разделе [коллекции с помощью C + +/ WinRT](collections.md). |
| Можно использовать расширения разметки [{Binding}](/windows/uwp/xaml-platform/binding-markup-extension) с C + +/ WinRT классы среды выполнения. | Дополнительные сведения и примеры кода см. в разделе [Общие сведения о привязке данных](/windows/uwp/data-binding/data-binding-quickstart). |
| Поддержка отмены сопрограммы позволяет зарегистрировать обратный вызов отмены. | Дополнительные сведения и примеры кода см. в разделе [отмены асинхронной операции и обратные вызовы отмены](concurrency.md#canceling-an-asychronous-operation-and-cancellation-callbacks). |
| При создании делегат, указывающий на функцию-член, вы можете установить строгой или слабой ссылки на текущий объект (вместо необработанных *Этот* указатель) в той точке, где регистрируется обработчик. | Дополнительные сведения и примеры кода см. в разделе **при использовании функции-члена представителем** подразделе в разделе [безопасный доступ к *этой* указателя с помощью делегата обработки события](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate). |
| Ошибки являются фиксированными, были обнаруженные Visual Studio повышенной соответствие стандартам C++. Цепочку инструментов LLVM и Clang также лучше используются для проверки C + +/ WinRT стандартам. | Вам больше не придется работать проблемы описаны в [Почему не создать новый проект компиляции? Я использую Visual Studio 2017 (версии 15.8.0 или более поздней версии) и пакет SDK версии 17134](faq.md#why-wont-my-new-project-compile-im-using-visual-studio-2017-version-1580-or-higher-and-sdk-version-17134) |

Другие изменения.

- **Критическое изменение**. Теперь возвращает [**WinRT::get_abi(WinRT::hstring const&)**](/uwp/cpp-ref-for-winrt/get-abi) `void*` вместо `HSTRING`. Вы можете использовать `static_cast<HSTRING>(get_abi(my_hstring));` для получения HSTRING.
- **Критическое изменение**. Теперь возвращает [**WinRT::put_abi(WinRT::hstring&)**](/uwp/cpp-ref-for-winrt/put-abi) `void**` вместо `HSTRING*`. Вы можете использовать `reinterpret_cast<HSTRING*>(put_abi(my_hstring));` для получения HSTRING *.
- **Критическое изменение**. HRESULT теперь проецируется как **winrt::hresult**. Если вам требуется HRESULT (проверка типа или поддержка характеристикам типов), то вы можете `static_cast` **winrt::hresult**. В противном случае **winrt::hresult** преобразует HRESULT, до тех пор, пока вы включить `unknwn.h` прежде чем включать C + +/ WinRT заголовков.
- **Критическое изменение**. GUID теперь проецируется как **winrt::guid**. API-интерфейсов, которую можно реализовать необходимо использовать **winrt::guid** для параметров GUID. В противном случае **winrt::hresult** преобразует код GUID, до тех пор, пока вы включить `unknwn.h` прежде чем включать C + +/ WinRT заголовков.
- **Критическое изменение**. [**Конструктор winrt::handle_type**](/uwp/cpp-ref-for-winrt/handle-type#handletypehandletype-constructor) , сохраняются, делая явных (стало сложнее написания неверно кода с ним). Если вам необходимо назначить значение необработанное обработка, вызовите [**функцию handle_type::attach**](/uwp/cpp-ref-for-winrt/handle-type#handletypeattach-function) .
- **Критическое изменение**. Подписи **WINRT_CanUnloadNow** и **WINRT_GetActivationFactory** были изменены. Эти функции не должна объявить вообще. Вместо этого включают `winrt/base.h` (который включается автоматически при указании C + +/ файлы заголовков пространства имен WinRT для Windows) для включения объявлений из этих функций.
- Для [**структуры winrt::clock**](/uwp/cpp-ref-for-winrt/clock) **from_FILETIME/to_FILETIME** будут удалены в пользу **from_file_time/to_file_time**.
- API-интерфейсы, которые ожидают **IBuffer** параметров упрощены. Несмотря на то, что большинство API предпочитаете коллекции и массивы, достаточно API-интерфейсы используют **IBuffer** , необходимые для более эффективного использования таких API-интерфейсы из C++. Это обновление предоставляет прямой доступ к данным за реализацию **IBuffer** , с помощью одного данных соглашение об именовании использовать с контейнерами стандартной библиотеки C++. Это также позволяет избежать конфликтах с именами метаданные, которые традиционно начинаться с прописной буквы.
- Улучшенная создания кода: различные усовершенствования для уменьшения размера кода, повысить встраивание и оптимизация кэширования фабрики.
- Удалить ненужные рекурсии. Когда командной строки относится к папке, а не к определенному `.winmd`, `cppwinrt.exe` больше не производит рекурсивный `.winmd` файлов. `cppwinrt.exe` Средство теперь также обрабатывает дубликаты более интеллектуального загрузками ошибке пользователя, и к неправильно сформированный `.winmd` файлов.
- Жесткой интеллектуальных указателей. Ранее revokers событие, не удалось отозвать при перемещения назначенный новое значение. Это позволило помогает выявить проблемы, где смарт-указателя классы не обработка надежно самообновления назначения; корневой каталог [**шаблон структуры winrt::com_ptr**](/uwp/cpp-ref-for-winrt/com-ptr). **WinRT::com_ptr** была устранена, и событие revokers, привязанной к обрабатывать семантику перемещения правильно таким образом, чтобы они отозвать после назначения.

> [!IMPORTANT]
> Важные изменения были внесены [C + +/ расширение Visual Studio WinRT (VSIX)](https://aka.ms/cppwinrt/vsix), как в версии 1.0.181002.2 и затем см. Далее в версии 1.0.190128.4. Дополнительные сведения об этих изменениях, и их влиянии на существующих проектов [Поддержка Visual Studio для C + +/ WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package) и [более ранних версиях расширение VSIX](intro-to-using-cpp-with-winrt.md#earlier-versions-of-the-vsix-extension).

## <a name="isolation-from-windows-sdk-header-files"></a>Изоляция из файлов заголовков Windows SDK

Это потенциально критических изменений в коде.

Для того чтобы скомпилировать, C + +/ WinRT больше не зависит от того, файлы заголовков из пакета Windows SDK. Также файлы заголовков в библиотеке времени выполнения C (CRT) и C++ стандартной библиотеки шаблонов (STL) не добавлять любые заголовки пакета Windows SDK. И это повышает соответствие стандартам, позволяет избежать защищающая от случайных зависимостей и значительно уменьшает количество макросов, которые необходимо выполнить для защиты от.

Эта независимость означает, что C + +/ WinRT теперь дополнительные переносимые и стандартам, и он является очередным возможность его получения статуса кросс компилятор и кросс платформенной библиотеки. Это также означает, что C + +/ WinRT заголовки не негативно затронутые макросов.

Если вы ранее выполняли в C + +/ WinRT, которые добавлять любые заголовки Windows в вашем проекте, то теперь необходимо включать их самостоятельно. Это, в любом случае всегда рекомендуется явным образом включать заголовки, которые зависят от, а не оставлять его на другую библиотеку, чтобы включить их для вас.

На данный момент единственное исключение из изоляции файл заголовка пакета Windows SDK предназначены для встроенных элементов, а числовые значения. Известных проблем этих последнего оставшиеся каких-либо зависимостей не существует.

В проекте можно снова включить взаимодействия с заголовки пакета Windows SDK, если необходимо. Например, можно реализовать COM-интерфейс (корнем в [**IUnknown**](https://msdn.microsoft.com/library/windows/desktop/ms680509)). В этом примере вспомогательных `unknwn.h` прежде чем включать C + +/ WinRT заголовков. Делать это выводится C + +/ WinRT базовой библиотеке для включения различные обработчики для поддержки классических COM-интерфейсы. Пример кода, см. в разделе [Author COM-компонентов с помощью C + +/ WinRT](author-coclasses.md). Аналогичным образом явным образом включать любые другие заголовки пакета Windows SDK, которые объявлять типы и функции, которые вы хотите вызвать.

## <a name="how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk"></a>Как Перенацелить C + +/ WinRT проекта на более позднюю версию пакета SDK для Windows

Метод переназначение проекте, который может привести к меньшее проблемы компилятора и компоновщика также является наиболее трудоемкий. Этот метод предусматривает создание нового проекта (предназначенных для Windows SDK версии по вашему выбору), а затем скопировать файлы по в новый проект из старой. Будет присутствовать разделы старые `.vcxproj` и `.vcxproj.filters` файлов, которые можно просто скопировать более чем сэкономить добавления файлов в Visual Studio.

Тем не менее существует два других способа Перенацелить проекта в Visual Studio.

- Перейдите в проект **Общие**свойства \> **Версия Windows SDK**и установите **Все конфигурации** и **Всех платформ**. Задайте **Версия Windows SDK** версии, вы хотите обратиться.
- В **Обозревателе решений**щелкните правой кнопкой мыши узел проекта, щелкните **Перенацелить проекты**, выберите версий, которые вы хотите выбрать и нажмите кнопку **ОК**.

При возникновении все компилятора и компоновщика ошибки после применения любого из этих двух методов, а затем вы можете попробовать очистки решение (**сборка** > **Очистить решение** и/или вручную удалить все временные папки и файлы) перед попыткой повторного построения.

Если компилятор C++ выдает "*Ошибка C2039: «IUnknown»: не является членом" \'global имен ''*«, затем добавьте `#include <unknwn.h>` в верхнюю часть вашей `pch.h` файл (прежде чем включать C + +/ WinRT заголовки).

Также может потребоваться добавить `#include <hstring.h>` после этого.

Если компоновщик C++ создает ошибку "*error LNK2019: неразрешенный внешний символ _WINRT_CanUnloadNow@0 в функцию _VSDesignerCanUnloadNow@0 *«, то вы можете устранить, добавив `#define _VSDESIGNER_DONT_LOAD_AS_DLL` для вашей `pch.h` файла.
