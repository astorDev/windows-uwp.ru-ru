---
description: Новости и изменения в C++/WinRT.
title: Новые возможности C++/WinRT
ms.date: 04/23/2019
ms.topic: article
keywords: Windows 10, uwp, standard, c ++, cpp, winrt, проекции, новости, что его новые
ms.localizationpriority: medium
ms.custom: RS5
ms.openlocfilehash: a84e118d988d8bf6a7d26eba7d5dd009c7ad44f3
ms.sourcegitcommit: ac7f3422f8d83618f9b6b5615a37f8e5c115b3c4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/29/2019
ms.locfileid: "66360137"
---
# <a name="whats-new-in-cwinrt"></a>Новые возможности C++/WinRT

## <a name="news-and-changes-in-cwinrt-20"></a>Новости и изменения, в C++WinRT 2.0

Дополнительные сведения о [ C++WinRT Visual Studio Extension (VSIX)](https://aka.ms/cppwinrt/vsix), [пакет Microsoft.Windows.CppWinRT NuGet](https://www.nuget.org/packages/Microsoft.Windows.CppWinRT/)и `cppwinrt.exe` средство&mdash;научитесь получить и установить их&mdash;см. в разделе [поддержка Visual Studio C++/WinRT, XAML, расширения VSIX и пакет NuGet](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package).

### <a name="changes-to-the-cwinrt-visual-studio-extension-vsix-for-version-20"></a>Изменения в C++WinRT Visual Studio Extension (VSIX) для версии 2.0

- Визуализатор отладки теперь поддерживает Visual Studio 2019 г.; а также продолжение работы Visual Studio 2017.
- Прочие исправления ошибок были внесены.

### <a name="changes-to-the-microsoftwindowscppwinrt-nuget-package-for-version-20"></a>Изменения в пакете Microsoft.Windows.CppWinRT NuGet для версии 2.0

- `cppwinrt.exe` Средство теперь входит в пакет Microsoft.Windows.CppWinRT NuGet, и это средство создает заголовки платформенный проекции для каждого проекта по требованию. Следовательно `cppwinrt.exe` средства больше не зависит от пакета SDK для Windows (хотя, по-прежнему поставляется с пакетом SDK для обеспечения совместимости).
- `cppwinrt.exe` Создает проекцию заголовков в каждой конкретной платформы или конфигурации промежуточных папку ($IntDir) для включения параллельных сборок.
- C++Поддержка построения /WinRT (свойства и целевые объекты) теперь полностью задокументирован, в случае, если вы хотите вручную настроить файлы проекта. См. в разделе [пакет NuGet Microsoft.Windows.CppWinRT](https://github.com/Microsoft/xlang/blob/master/src/package/cppwinrt/nuget/readme.md).
- Прочие исправления ошибок были внесены.

### <a name="changes-to-cwinrt-for-version-20"></a>Изменения в C++/WinRT для версии 2.0

#### <a name="open-source"></a>Открытым исходным кодом

`cppwinrt.exe` Средство принимает метаданные среды выполнения Windows (`.winmd`) файла и создает из него стандартный заголовок файловыми C++ библиотеки, *проекты* API, описанные в метаданных. Таким образом, вы можете использовать эти API из вашей C++/WinRT кода.

Это средство теперь является полностью проект с открытым кодом на сайте GitHub. Посетите [Microsoft\/xlang](https://github.com/Microsoft/xlang), а затем щелкните для **src** > **средство** > **cppwinrt**.

#### <a name="xlang-libraries"></a>библиотеки XLANG

Полностью переносимые заголовка библиотеке (для синтаксического анализа формат ECMA-335 метаданных, используемые средой выполнения Windows) является основанием для среды выполнения Windows и xlang средств, в дальнейшем. В частности, мы также переписала `cppwinrt.exe` средство с нуля использования библиотек xlang. Это обеспечивает гораздо более точные запросы метаданных, разрешение несколько давние проблемы с C++/WinRT проекция.

#### <a name="fewer-dependencies"></a>Меньшим числом зависимостей

Из-за считывателя метаданных xlang `cppwinrt.exe` само средство имеет меньшее количество зависимостей. Это делает гораздо более гибким, а также можно использовать в различных сценариях&mdash;особенно в ограниченного создания сред. В частности, она больше не зависит от `RoMetadata.dll`.
 
Это-зависимости для `cppwinrt.exe` 2.0.
 
- api-ms-win-core-processenvironment-l1-1-0.dll
- API-MS-Win-Core-libraryloader-L1-2-0.dll
- XmlLite.dll
- api-ms-win-core-memory-l1-1-0.dll
- api-ms-win-core-handle-l1-1-0.dll
- api-ms-win-core-file-l1-1-0.dll
- SHLWAPI.dll
- ADVAPI32.dll
- KERNEL32.dll
- api-ms-win-core-rtlsupport-l1-1-0.dll
- api-ms-win-core-processthreads-l1-1-0.dll
- api-ms-win-core-heap-l1-1-0.dll
- api-ms-win-core-console-l1-1-0.dll
- API-MS-Win-Core-Localization-L1-2-0.dll

В отличие от этих зависимостей, который `cppwinrt.exe` имеет 1.0.

- ADVAPI32.dll
- SHELL32.dll
- api-ms-win-core-file-l1-1-0.dll
- XmlLite.dll
- API-MS-Win-Core-libraryloader-L1-2-0.dll
- api-ms-win-core-processenvironment-l1-1-0.dll
- RoMetadata.dll
- SHLWAPI.dll
- KERNEL32.dll
- api-ms-win-core-rtlsupport-l1-1-0.dll
- api-ms-win-core-heap-l1-1-0.dll
- api-ms-win-core-timezone-l1-1-0.dll
- api-ms-win-core-console-l1-1-0.dll
- API-MS-Win-Core-Localization-L1-2-0.dll
- OLEAUT32.dll
- api-ms-win-core-winrt-error-l1-1-0.dll
- api-ms-win-core-winrt-error-l1-1-1.dll
- api-ms-win-core-winrt-l1-1-0.dll
- api-ms-win-core-winrt-string-l1-1-0.dll
- API-MS-Win-Core-Synch-L1-1-0.dll
- API-MS-Win-Core-ThreadPool-L1-2-0.dll
- api-ms-win-core-com-l1-1-0.dll
- api-ms-win-core-com-l1-1-1.dll
- API-MS-Win-Core-Synch-L1-2-0.dll 

#### <a name="the-windows-runtime-noexcept-attribute"></a>Среда выполнения Windows `noexcept` атрибут

Среда выполнения Windows имеет новый `[noexcept]` атрибут, который можно использовать для оформления методов и свойств в [MIDL 3.0](/uwp/midl-3/predefined-attributes). Наличие атрибута указывает на вспомогательные средства, что реализация не создает исключения (и возвращать непройденного HRESULT). Это позволяет языковых проекций оптимизировать создание кода, что позволяет избежать обработки исключений, требуемом для поддержки вызовов двоичного интерфейса (ABI) приложения, которые могут привести к сбою.

C++/ WinRT использует преимущества этого, производя C++ `noexcept` реализаций рассматриваемый и разработке кода. Если у вас есть API методы или свойства, которые являются освободить сбой и вы являетесь, отвечающим размер кода, вы можете изучить этот атрибут.

#### <a name="optimized-code-generation"></a>Оптимизированного кода

C++/ WinRT теперь приводит к возникновению ошибки еще более эффективным C++ исходный код (в фоновом) чтобы C++ компилятор может привести к наименьшую и наиболее эффективный двоичный код невозможно. Многие из улучшений, предназначены для сокращения стоимости обработки исключений, избегая ненужных информация для раскрутки. Двоичные файлы, использующие большие объемы C++/WinRT кода будет примерно увидеть уменьшению размера кода на 4%. Код также эффективнее (выполняется быстрее) из-за числа ограниченной команд.

Новая функция взаимодействия, доступных пользователю, а также используют эти улучшения. Все C++/WinRT типов, являющихся владельцами ресурса теперь включает конструктор для владельца напрямую, как избежать предыдущего этапа.

```cppwinrt
ABI::Windows::Foundation::IStringable* raw = ...

IStringable projected(raw, take_ownership_from_abi);

printf("%ls\n", projected.ToString().c_str());
```

#### <a name="optimized-exception-handling-eh-code-generation"></a>Обработка исключений (EH)-оптимизированного кода

Это изменение дополняет работы, выполняемой для Microsoft C++ оптимизатор группой, чтобы снизить затраты на обработку исключений. При использовании бинарных интерфейсов приложений (ABI) (например, COM) сильно в коде, вы будете наблюдать большого объема кода при использовании данной модели.

```cpp
int32_t Function() noexcept
{
    try
    {
        // code here constitutes unique value.
    }
    catch (...)
    {
        // code here is always duplicated.
    }
}
```

C++/ WinRT сам создает этот шаблон для каждого API, который реализуется. С тысячами функции API здесь все оптимизации могут быть значительными. В прошлом, оптимизатор не обнаружить, что те блоки catch идентичны, поэтому оно дублирования кода вокруг каждого интерфейса ABI (который в свою очередь, влияющая убеждении, что с помощью исключений в системный код создает большие двоичные файлы). Однако в Visual Studio 2019 г., C++ компилятора свертки всех этих catch фанклеты и сохраняются только те, которые являются уникальными. Результатом является снижение 18% дальнейшие и общий размер кода для двоичных файлов, которые во многом полагаются на этот шаблон. Не только код EH теперь более эффективно, чем использование кодов возврата, но также беспокоиться о больших двоичных файлов теперь находится в прошлое.

#### <a name="incremental-build-improvements"></a>Усовершенствования инкрементное построение

`cppwinrt.exe` Программа сравнивает теперь выходные данные созданного заголовка или исходного файла с содержимым любого существующего файла на диске, и он только выводит файл, если файл был изменен на самом деле. Это экономит значительное время с дискового ввода-вывода и гарантирует, что файлы не считаются «грязный» с C++ компилятора. Результатом является избегать или сокращается, во многих случаях этого повторной компиляции.

#### <a name="generic-interfaces-are-now-all-generated"></a>Универсальные интерфейсы стали всех созданных

Из-за считывателя метаданных xlang C++/WinRT теперь создает все интерфейсы, параметризованные или универсальным, из метаданных. Интерфейсы, такие как [Windows::Foundation:: Collections::\<T\> ](/uwp/api/windows.foundation.collections.ivector_t_) созданный из метаданных чаще, чем созданный вручную `winrt/base.h`. Результатом является, размер `winrt/base.h` сокращено вдвое, и что оптимизации создаются правой кнопкой мыши в код (который было непросто сделать откат вручную при использовании).

> [!IMPORTANT]
> Интерфейсы, такие как пример теперь отображаются в их заголовках соответствующих пространств имен, а не в `winrt/base.h`. Поэтому если вы еще не сделано, вы должны включать заголовок соответствующего пространства имен, чтобы использовать интерфейс.

#### <a name="component-optimizations"></a>Компонент оптимизации

Это обновление добавляет поддержку нескольких дополнительных согласиться оптимизации для C++/WinRT, описанные в следующих разделах. Так как эти оптимизации являются критическими изменениями (которые может потребоваться внести незначительные изменения для поддержки), вам потребуется их включить явным образом с помощью `cppwinrt.exe` инструмента `-opt` флаг.

Новый проект (на основе шаблона проекта) будет использовать `-opt` по умолчанию.

##### <a name="uniform-construction-and-direct-implementation-access"></a>Универсальный код конструкцию и прямой реализации доступа

Эти два способа оптимизации предоставить компоненту прямого доступа к собственные типы реализации, даже в том случае, если она использует только проецируемых типов. Нет необходимости использовать [ **сделать**](/uwp/cpp-ref-for-winrt/make), [ **make_self**](/uwp/cpp-ref-for-winrt/make-self), ни [ **get_self** ](/uwp/cpp-ref-for-winrt/get-self) Если вы просто хотите использовать поверхности открытого API. Вызовы будут компилируются до прямые вызовы в реализации и их даже может быть полностью встроен.

##### <a name="type-erased-factories"></a>Стирания типа фабрики

Эта оптимизация позволяет избежать #include зависимости в `module.g.cpp` таким образом, его нужно перекомпилировать не каждый раз, чтобы любой класс реализаций, что происходит изменение. Результатом является Ускоренная сборка производительности.

#### <a name="smarter-and-more-efficient-modulegcpp-for-large-projects-with-multiple-libs"></a>Быстрее и эффективнее `module.g.cpp` для крупных проектов с нескольких библиотек

`module.g.cpp` Теперь файл также содержит два дополнительных составную вспомогательные методы, с именем **winrt_can_unload_now**, и **winrt_get_activation_factory**. Они были разработаны для крупных проектов, где DLL состоит из несколько библиотек, каждый из которых свои собственные классы среды выполнения. В этом случае необходимо вручную Сшивать DLL **DllGetActivationFactory** и **DllCanUnloadNow**. Эти вспомогательные методы упрощают для вас сделать это, как избежать случайной возникновения ошибки. `cppwinrt.exe` Инструмента `-lib` флаг может также использоваться для предоставления каждого отдельного lib свой собственный заголовок (а не `winrt_xxx`), чтобы каждый lib функции могут по отдельности с именем и таким образом в сочетании однозначно.

#### <a name="new-winrtcoroutineh-header"></a>Новый `winrt/coroutine.h` заголовка

`winrt/coroutine.h` Заголовок — это новый дом для всех C++поддержки сопрограмм /WinRT элемента. Ранее, и эта поддержка размещался в нескольких местах, который мы полагаем, слишком ограничивающим. Так как теперь создаются асинхронные интерфейсы среды выполнения Windows, а не написан вручную, теперь находятся в `winrt/Windows.Foundation.h`. Помимо более понятным и совместимостью, это означает, что сопрограммы вспомогательные функции, такие как [ **resume_foreground** ](/uwp/cpp-ref-for-winrt/resume-foreground) больше не нужно быть приписываются в конец заголовка определенному пространству имен. Вместо этого они могут более естественным образом включать их зависимости. Это Дополнительно позволяет **resume_foreground** для поддержки возобновление не только на заданного [ **Windows::UI::Core::CoreDispatcher**](/uwp/api/windows.ui.core.coredispatcher), но она теперь также поддерживает возобновление на заданного [ **Windows::System::DispatcherQueue**](/uwp/api/windows.system.dispatcherqueue). Ранее может быть поддерживается только один; но не оба, так как определение может находиться только в одном пространстве имен.

Ниже приведен пример **DispatcherQueue** поддержки.

```cppwinrt
fire_and_forget Async(DispatcherQueueController controller)
{
    bool queued = co_await resume_foreground(controller.DispatcherQueue());
    assert(queued);

    // This is just to simulate queue failure...
    co_await controller.ShutdownQueueAsync();

    queued = co_await resume_foreground(controller.DispatcherQueue());
    assert(!queued);
}
```

Методы, помеченные сопрограммы теперь также оформляются с использованием `[[nodiscard]]`, тем самым повышения удобства их использования. Если забыть (или недооценивают вам придется) `co_await` их, чтобы они работали, то из-за `[[nodiscard]]`, подобные ошибки теперь вызывают Предупреждение компилятора.

#### <a name="help-with-diagnosing-stack-allocations"></a>Помочь в диагностике выделение памяти в стеке

Так как имена классов прогнозируемые и реализации совпадают (по умолчанию) и отличаются только по пространству имен, это возможно по ошибке, один для второго и случайно создать реализацию в стеке, а не с помощью [ **сделать** ](/uwp/cpp-ref-for-winrt/make) семейства вспомогательных функций. Это может быть тяжело диагностировать, в некоторых случаях, поскольку объект может быть уничтожен, пока ссылки на медиафайл все еще обрабатываются. Теперь утверждение обнаружит это, для отладочных сборок. Хотя утверждение не обнаружит выделение памяти в стеке в соподпрограмме, тем не менее рекомендуется перехватывать большинство подобных ошибок.

#### <a name="improved-capture-helpers-and-variadic-delegates"></a>Улучшенные захвата вспомогательные методы и делегаты с переменным числом аргументов

Это обновление устраняет ограничение со вспомогательными функциями отслеживания, поддерживая проецируемых типов, а также. Это появляется, и с помощью API взаимодействия среды выполнения Windows, если они возвращают проецированный тип.

Это обновление также добавляет поддержку [ **get_strong** ](/uwp/cpp-ref-for-winrt/implements#implementsget_strong-function) и [ **get_weak** ](/uwp/cpp-ref-for-winrt/implements#implementsget_weak-function) при создании делегата с переменным числом аргументов (отличных от Windows времени выполнения).

#### <a name="support-for-deferred-destruction-and-safe-qi-during-destruction"></a>Поддержка для отложенного удаления и безопасном QI во время уничтожения

Приложение XAML можно получить в сложности из-за необходимости выполнения самой [ **QueryInterface** ](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(q_)) (QI) в деструкторе, чтобы вызывать реализацию очистки вверх или вниз по иерархии. Но, что вызов включает в себя QI после уже имеет счетчик ссылок объекта равно нулю. Это обновление добавляет поддержку для получения счетчика ссылок, что когда он достигает нуля, он может не быть снова включены; по-прежнему предоставляя QI для любого временного объекта, необходимые во время уничтожения. Эта процедура неизбежна в некоторых приложениях XAML и элементов управления, и C++/WinRT теперь устойчив к нему.

Уничтожение может быть отложено, предоставляя статический **final_release** функции и перемещение владения **unique_ptr** в других контекстах.

```cppwinrt
struct Sample : implements<Sample, IStringable>
{
    hstring ToString()
    {
        return L"Sample";
    }

    ~Sample()
    {
        // Called when the unique_ptr below is reset.
    }

    static void final_release(std::unique_ptr<Sample> ptr) noexcept
    {
        // Move 'ptr' as needed to delay destruction.
    }
};
```

В примере ниже один раз **MainPage** освобождается (для последний раз), **final_release** вызывается. Функция проводит пять секунд ожидания (в пуле потоков), что затем возобновляется с помощью страницы **Dispatcher** (требуется QI/AddRef и Release для работы). Затем он сбрасывает **unique_ptr**, чего **MainPage** деструктор для фактически вызывается. Даже здесь **DataContext** вызывается, которая требует QI для **IFrameworkElement**. Очевидно, что не нужно реализовывать вашей **final_release** как соподпрограмме. Работает, но становится очень простой для перемещения на другой поток удаления.

```cppwinrt
struct MainPage : PageT<MainPage>
{
    MainPage()
    {
    }

    ~MainPage()
    {
        DataContext(nullptr);
    }

    static IAsyncAction final_release(std::unique_ptr<MainPage> ptr)
    {
        co_await 5s;

        co_await resume_foreground(ptr->Dispatcher());

        ptr = nullptr;
    }
};
```

#### <a name="improved-support-for-com-style-single-interface-inheritance"></a>Улучшенная поддержка наследования единый интерфейс в стиле COM

А также для программирования среды выполнения Windows, C++/WinRT также позволяет создавать и использовать только для COM API. Это обновление дает возможность реализации COM-сервера, где уже существует в иерархии интерфейса. Это не является обязательным для среды выполнения Windows; Однако он необходим для некоторых реализаций COM.

#### <a name="correct-handling-of-out-params"></a>Правильный обработка `out` params

Он может быть сложным в эксплуатации `out` params; особенно массивов в среде выполнения Windows. Благодаря этому обновлению C++/WinRT значительно более надежные и устойчивые к ошибок, когда дело доходит до `out` params и массивов; ли эти параметры поступать через это проекция, или от разработчика COM, кто использует необработанные ABI и лица, вносящего ошибки, не выполняя инициализации переменных согласованно. В любом случае C++/WinRT, теперь выполняются правильные действия, когда дело доходит до передачей проецируемых типов ABI (запомнив освобождать любые ресурсы), а в том случае, когда дело доходит до обнулению или сняв выходные параметры, которые поступают через интерфейс ABI.

#### <a name="events-now-handle-invalid-tokens-reliably"></a>События теперь обработать недопустимые токены надежно

[ **Winrt::event** ](/uwp/cpp-ref-for-winrt/event) реализация теперь правильно обрабатывает случай, где его **удалить** был вызван с недопустимым значением маркера (значение, которое не присутствует в массив).

#### <a name="coroutine-locals-are-now-destroyed-before-the-coroutine-returns"></a>Сопрограммы локальные переменные теперь удаляются перед возвратом сопрограммы

Традиционным способом реализации типа сопрограммы могут разрешить "Локальные" в соподпрограмме будут уничтожены *после* сопрограммы возвращает/завершения (а не перед окончательной приостановки). Возобновление любой ожидающий объект теперь откладывается до окончательного приостановки, чтобы избежать этой проблемы и начисления другие преимущества.

## <a name="news-and-changes-in-windows-sdk-version-100177630-windows-10-version-1809"></a>Новости и изменения, в пакете Windows SDK версии 10.0.17763.0 (Windows 10, версия 1809)

В следующей таблице содержит новости и изменения для C++/WinRT в пакете Windows SDK версии 10.0.17763.0 (Windows 10, версия 1809).

| Новые и измененные функции | Дополнительные сведения |
| - | - |
| **Критическое изменение**. Для его компиляции C++/WinRT не зависит от заголовков из пакета Windows SDK. | См. в разделе [отдельно от файлов заголовков Windows SDK](#isolation-from-windows-sdk-header-files)ниже. |
| Формат системы проекта Visual Studio был изменен. | См. в разделе [как изменить целевую платформу на C++/WinRT проекта до более поздней версии пакета SDK для Windows](#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk)ниже. |
| Существуют новые функции и базовые классы, которые помогут вам передать объект коллекции среды выполнения Windows функции или реализовать свои собственные свойства и коллекции типов коллекций. | См. в разделе [коллекций с C++/WinRT](collections.md). |
| Можно использовать [{Binding}](/windows/uwp/xaml-platform/binding-markup-extension) расширения разметки с вашей C++/WinRT классы среды выполнения. | Дополнительные сведения и примеры кода см. в разделе [Общие сведения о привязке данных](/windows/uwp/data-binding/data-binding-quickstart). |
| Поддержка отмены соподпрограмме позволяет зарегистрировать обратный вызов отмены. | Дополнительные сведения и примеры кода см. в разделе [Отмена асинхронной операции и обратные вызовы отмены](concurrency.md#canceling-an-asychronous-operation-and-cancellation-callbacks). |
| При создании делегат, указывающий на функцию-член, вы можете установить надежный или слабую ссылку на текущий объект (вместо необработанного *это* указателя) в точке, в котором зарегистрирован обработчик. | Дополнительные сведения и примеры кода см. в разделе **при использовании функции-члена в качестве делегата** подраздел в разделе [безопасного доступа к *это* указатель с помощью делегата, обрабатывающего события](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate). |
| Исправлены ошибки, которые были обнаруженные Visual Studio улучшенное соответствие стандарту c++. Цепочка инструментов LLVM и Clang также лучше использовать для проверки C++/WinRT на соответствие стандартам. | Больше не придется столкнуться проблему, описанную в [почему мой новый проект не будет компилироваться? Я использую Visual Studio 2017 (версии 15.8.0 или более поздней версии) и пакет SDK версии 17134](faq.md#why-wont-my-new-project-compile-im-using-visual-studio-2017-version-1580-or-higher-and-sdk-version-17134) |

Другие изменения.

- **Критическое изменение**. [**WinRT::get_abi(WinRT::hstring const&)** ](/uwp/cpp-ref-for-winrt/get-abi) теперь возвращает `void*` вместо `HSTRING`. Можно использовать `static_cast<HSTRING>(get_abi(my_hstring));` для получения HSTRING.
- **Критическое изменение**. [**WinRT::put_abi(WinRT::hstring&)** ](/uwp/cpp-ref-for-winrt/put-abi) теперь возвращает `void**` вместо `HSTRING*`. Можно использовать `reinterpret_cast<HSTRING*>(put_abi(my_hstring));` для получения HSTRING *.
- **Критическое изменение**. HRESULT теперь защищен как **winrt::hresult**. Если необходимо, чтобы значение HRESULT (проверку типов, или для поддержки признаков типа), то вы можете `static_cast` **winrt::hresult**. В противном случае **winrt::hresult** преобразует значение HRESULT, до тех пор, пока вы включают `unknwn.h` до включения любой C++/WinRT заголовки.
- **Критическое изменение**. GUID теперь защищен как **winrt::guid**. Для API-интерфейсы, реализуемые, необходимо использовать **winrt::guid** для параметров GUID. В противном случае **winrt::guid** преобразует GUID, до тех пор, пока вы включают `unknwn.h` до включения любой C++/WinRT заголовки.
- **Критическое изменение**. [ **Конструктор winrt::handle_type** ](/uwp/cpp-ref-for-winrt/handle-type#handle_typehandle_type-constructor) были записаны на диск, делая явные (теперь стало труднее писать неверный код с ним). Если вам нужно назначить необработанного значения дескриптора, вызвать [ **функция handle_type::attach** ](/uwp/cpp-ref-for-winrt/handle-type#handle_typeattach-function) вместо этого.
- **Критическое изменение**. В отношении сигнатур **WINRT_CanUnloadNow** и **WINRT_GetActivationFactory** были изменены. Эти функции не должны объявлять вообще. Вместо этого включить `winrt/base.h` (который автоматически включается при включении любого C++файлы заголовков пространство имен WinRT Windows) для включения объявления этих функций.
- Для [ **структуры winrt::clock**](/uwp/cpp-ref-for-winrt/clock), **from_FILETIME/to_FILETIME** являются устаревшими для **from_file_time/to_file_time**.
- Интерфейсы API, которые ожидают **IBuffer** параметры упрощены. Несмотря на то, что большинство интерфейсов API предпочитаете коллекций или массивов, достаточно API-интерфейсы полагаться на **IBuffer** что ей нужно быть проще с помощью таких API из C++. Это обновление обеспечивает прямой доступ к данным за **IBuffer** реализации, с помощью же данных соглашение об именовании контейнеров стандартной библиотеки C++. Это также позволяет избежать конфликтов имен метаданных, которые обычно начинаются с заглавной буквы.
- Улучшенное создание кода: различные улучшения, уменьшающие размер кода, повышения встраивания и оптимизации кэширования фабрики.
- Удалить ненужные рекурсии. Если командной строке упоминается в папку, а не конкретному `.winmd`, `cppwinrt.exe` средство больше не выполняет рекурсивный `.winmd` файлов. `cppwinrt.exe` Средство также теперь обрабатывает дубликаты более разумно, сделав его более устойчивым к ошибки пользователя и на неправильно сформированный `.winmd` файлов.
- Зафиксированный интеллектуальные указатели. Ранее revokers событие, не удалось отозвать при move присвоено значение. Это позволило выявить ошибку, где классы интеллектуальных указателей не были обработки надежно присваивания; в [ **winrt::com_ptr структуры шаблона**](/uwp/cpp-ref-for-winrt/com-ptr). **WinRT::com_ptr** была исправлена, и событие revokers, исправлена для обработки семантики перемещения правильно таким образом, они отзовут после назначения.

> [!IMPORTANT]
> Были внесены важные изменения [ C++WinRT Visual Studio Extension (VSIX)](https://aka.ms/cppwinrt/vsix), как в версии 1.0.181002.2, а позже — в версии 1.0.190128.4. Дополнительные сведения об этих изменениях и их влиянии на существующие проекты [поддержка Visual Studio C++/WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package) и [более ранних версиях расширение VSIX](intro-to-using-cpp-with-winrt.md#earlier-versions-of-the-vsix-extension).

### <a name="isolation-from-windows-sdk-header-files"></a>Отдельно от файлов заголовков Windows SDK

Потенциально Это критическое изменение для кода.

Для его компиляции C++/WinRT больше не зависит от файлов заголовков из пакета Windows SDK. Файлы заголовков в библиотеке времени выполнения C (CRT) и C++ стандартной библиотеки шаблонов (STL) также не включайте все заголовки Windows SDK. И, улучшает совместимость со стандартами, позволяет избежать случайного зависимостей и значительно сокращает количество макросов, которых следует остерегаться.

Эта независимость означает, что C++/WinRT теперь дополнительные переносимые и соответствие отраслевым стандартам, и он является очередным возможность стать кросс компилятор и кросс платформенную библиотеку. Это также означает, что C++/WinRT заголовки не оказывается негативное влияние макросы.

Если ранее вы его, чтобы оставить C++/WinRT включать какие-либо заголовки Windows в проекте, то теперь нужно будет включать их. Это, в любом случае всегда рекомендуется явным образом включать заголовки, от которых зависит и не оставить его на другую библиотеку, чтобы включить их для вас.

В настоящее время единственным исключением изоляции файл заголовка пакета SDK для Windows предназначены для встроенных функций и числовыми значениями. Существуют известные проблемы с эти последние оставшиеся зависимости отсутствуют.

В проекте можно снова включить взаимодействие с заголовками Windows SDK, если вам нужно. Например, можно реализовать интерфейс COM (с корнем в [ **IUnknown**](https://docs.microsoft.com/windows/desktop/api/unknwn/nn-unknwn-iunknown)). Для этого примера включают `unknwn.h` до включения любой C++/WinRT заголовки. Выполнив это выводится C++/WinRT базовой библиотеки для включения используются различные обработчики для поддержки классического COM-интерфейсов. Пример кода см. в разделе [компонентов автором COM с помощью C++/WinRT](author-coclasses.md). Аналогично явным образом включить других заголовков Windows SDK, которые объявляют типы или функции, которые вы хотите вызвать.

### <a name="how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk"></a>Как изменить целевую платформу на C++/WinRT проекта до более поздней версии пакета SDK для Windows

Метод для целевой платформы проекта, которая, скорее всего, приведет к наименьшим количеством проблему компилятора и компоновщика также — наиболее трудоемкий процесс. Этот метод включает в себя создание нового проекта (предназначенных для версии пакета SDK для Windows по своему усмотрению), а затем скопировать файлы через для нового проекта из старой. Будет существовать разделы старая `.vcxproj` и `.vcxproj.filters` файлы, которые вы можете просто скопируйте более сэкономить Добавление файлов в Visual Studio.

Тем не менее существует два способа изменить целевую платформу проекта в Visual Studio.

- Перейдите к свойству проекта **Общие** \> **версия пакета SDK для Windows**и выберите **все конфигурации** и **всех платформ**. Задайте **версия пакета SDK для Windows** с версией, вы будете работать.
- В **обозревателе решений**, щелкните правой кнопкой мыши узел проекта, щелкните **Перенацелить проекты**, Выбор версии, необходимо выбирать и нажмите кнопку **ОК**.

Если возникают все компилятора или компоновщика ошибки после применения любого из этих двух методов, то вы можете попробовать очистки решения (**построения** > **Очистить решение** и/или вручную удалить все временные папки и файлы) перед попыткой повторной сборки.

Если компилятор C++ создает "*Ошибка C2039: «IUnknown»: не является членом "\`глобальное пространство имен ''* «, затем добавьте `#include <unknwn.h>` в верхнюю часть вашей `pch.h` файла (до включения любой C++/WinRT заголовки).

Также может потребоваться добавить `#include <hstring.h>` после этого.

Если компоновщик C++ создает "*Ошибка LNK2019: неразрешенный внешний символ _WINRT_CanUnloadNow@0 на которые ссылается функция _VSDesignerCanUnloadNow@0* «, то можно устранить, добавив `#define _VSDESIGNER_DONT_LOAD_AS_DLL` для вашей `pch.h` файл.
