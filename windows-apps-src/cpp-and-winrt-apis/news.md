---
author: stevewhims
description: Новости и изменения в C + +/ WinRT.
title: Новые возможности в C + +/ WinRT
ms.author: stwhi
ms.date: 10/03/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: Windows 10, uwp, стандартная, c ++, cpp, winrt, проекция, новости, что приложения, new
ms.localizationpriority: medium
ms.openlocfilehash: 3cc28092020639d108ec35898ad1d6bddcd055f5
ms.sourcegitcommit: e6daa7ff878f2f0c7015aca9787e7f2730abcfbf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/03/2018
ms.locfileid: "4317472"
---
# <a name="whats-new-in-cwinrt"></a>Новые возможности в C + +/ WinRT

В следующей таблице содержит новости и изменения [C + +/ WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) в-общедоступен последнюю версию пакета Windows SDK, который является 10.0.17763.0 (Windows 10, версия 1809). Эти изменения также может быть представлен в более поздних версиях SDK Insider Preview.

## <a name="news-and-changes-in-windows-sdk-version-100177630-windows-10-version-1809"></a>Новости и изменения, в Windows SDK версии 10.0.17763.0 (Windows 10, версия 1809)

| Новые или измененные функции | Дополнительные сведения |
| - | - |
| **Критическое изменение**. Для того чтобы скомпилировать, C + +/ WinRT не зависит от заголовки из пакета Windows SDK. | Ниже приведены [изоляции из файлов заголовков Windows SDK](#isolation-from-windows-sdk-header-files). |
| Формат система проекта Visual Studio был изменен. | См. в разделе [как Перенацелить C + +/ WinRT проект до более поздней версии Windows SDK](#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk)ниже. |
| Существует новые функции и базовых классов для передачи объекта коллекции в функцию среды выполнения Windows, или реализовать собственные свойства коллекции и типы коллекций. | См. в разделе [коллекции с помощью C + +/ WinRT](collections.md). |
| Можно использовать расширение разметки [{Binding}](/windows/uwp/xaml-platform/binding-markup-extension) с помощью C + +/ WinRT классы среды выполнения. | Дополнительные сведения и примеры кода см. в разделе [Общие сведения о привязке данных](/windows/uwp/data-binding/data-binding-quickstart). |
| Поддержка отмены сопрограммы позволяет зарегистрировать обратный вызов отмены. | Дополнительные сведения и примеры кода см. в разделе [отмены асинхронной операции и обратные вызовы отмены](concurrency.md#canceling-an-asychronous-operation-and-cancellation-callbacks). |
| При создании делегат, указывающий на функцию-член, вы можете установить строгой или слабой ссылки на текущий объект (вместо необработанных *Этот* указатель) в той точке, где регистрируется обработчик. | Дополнительные сведения и примеры кода см. в разделе **при использовании функции-члена представителем** подразделе в разделе [безопасного доступа к *Этот* указатель с помощью делегата обработки события](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate). |
| Ошибки являются фиксированными, были обнаруженные Visual Studio улучшенные возможности стандарта C++. Также лучше цепочку инструментов LLVM и Clang используется для проверки C + +/ WinRT стандартам. | Вам больше не придется работать проблему описано в [Почему не создать новый проект компиляции? Я использую Visual Studio 2017 (версии 15.8.0 или более поздней версии) и пакет SDK 17134 версии](faq.md#why-wont-my-new-project-compile-im-using-visual-studio-2017-version-1580-or-higher-and-sdk-version-17134) |

Другие изменения.

- **Критическое изменение**. [**winrt::get_abi(winrt::hstring const&)**](/uwp/cpp-ref-for-winrt/get-abi) теперь возвращает `void*` вместо `HSTRING`. Вы можете использовать `static_cast<HSTRING>(get_abi(my_hstring));` для получения HSTRING.
- **Критическое изменение**. Теперь возвращает [**WinRT::put_abi(WinRT::hstring&)**](/uwp/cpp-ref-for-winrt/put-abi) `void**` вместо `HSTRING*`. Вы можете использовать `reinterpret_cast<HSTRING*>(put_abi(my_hstring));` для получения HSTRING *.
- **Критическое изменение**. HRESULT теперь проецируется как **winrt::hresult**. Если вам требуется HRESULT (проверка типа или поддержка характеристикам типов), то вы можете `static_cast` **winrt::hresult**. В противном случае **winrt::hresult** преобразует HRESULT, до тех пор, пока вы включить `unknwn.h` прежде чем включать C + +/ WinRT заголовков.
- **Критическое изменение**. GUID теперь проецируется как **winrt::guid**. API-интерфейсов, которую можно реализовать необходимо использовать **winrt::guid** для параметров GUID. В противном случае **winrt::hresult** преобразует код GUID, до тех пор, пока вы включить `unknwn.h` прежде чем включать C + +/ WinRT заголовков.
- **Критическое изменение**. [**Конструктор winrt::handle_type**](/uwp/cpp-ref-for-winrt/handle-type#handletypehandletype-constructor) , сохраняются, делая явных (стало сложнее написать ошибка в коде с ним). Если вам необходимо назначить значение необработанные дескриптор, вызовите [**функцию handle_type::attach**](/uwp/cpp-ref-for-winrt/handle-type#handletypeattach-function) .
- **Критическое изменение**. Подписи **WINRT_CanUnloadNow** и **WINRT_GetActivationFactory** были изменены. Эти функции не должна объявить вообще. Вместо этого включают `winrt/base.h` (который включается автоматически при указании C + +/ файлы заголовков пространства имен WinRT для Windows) для включения объявлений из этих функций.
- Для [**структуры winrt::clock**](/uwp/cpp-ref-for-winrt/clock) **from_FILETIME или to_FILETIME** будут удалены в пользу **from_file_time/to_file_time**.
- API-интерфейсы, которые ожидают **IBuffer** параметров упрощены. Несмотря на то, что большинство API предпочитаете коллекции и массивы, достаточно API-интерфейсы используют **IBuffer** , его необходимо будет легче использовать такие интерфейсы API из C++. Это обновление предоставляет прямой доступ к данным за реализацию **IBuffer** , с помощью одного данных соглашение об именовании используемые контейнеров стандартной библиотеки C++. Это также позволяет избежать конфликтах с именами метаданных, которые традиционно начинаться с прописной буквы.
- Улучшенная создание кода: различные усовершенствования для уменьшения размера кода, улучшения встраивание и оптимизация кэширования фабрики.
- Удалить ненужные рекурсии. Когда командной строки относится к папке, а не к определенному `.winmd`, `cppwinrt.exe` больше не производит рекурсивно для `.winmd` файлов. `cppwinrt.exe` Средство теперь также обрабатывает дубликаты более интеллектуального, сделав его более устойчивыми ошибке пользователя и к неправильно сформированный `.winmd` файлов.
- Жесткой интеллектуальных указателей. Ранее revokers событие, не удалось отозвать при перемещения назначенный новое значение. Это позволило помогает выявить проблемы, где смарт-указателя классы не обработка надежно самостоятельной назначения; корневой каталог в [**шаблон структуры winrt::com_ptr**](/uwp/cpp-ref-for-winrt/com-ptr). **WinRT::com_ptr** была устранена, и событие revokers, привязанной к обрабатывать семантику перемещения правильно таким образом, чтобы они отозвать после назначения.

## <a name="isolation-from-windows-sdk-header-files"></a>Изоляция из файлов заголовков Windows SDK

Это потенциально критических изменений в коде.

Для того чтобы скомпилировать, C + +/ WinRT больше не зависит от того, файлы заголовков из пакета Windows SDK. Также файлы заголовков в библиотеки времени выполнения C (CRT) и C++ стандартной библиотеки шаблонов (STL) не добавлять любые заголовки пакета Windows SDK. И это повышает соответствие стандартам, позволит избежать защищающая от случайных зависимостей и значительно уменьшает количество макросов, которые имеют защиту от.

Эта независимость означает, что C + +/ WinRT теперь дополнительные переносимые и стандартам, и он является очередным вероятность его получения статуса кросс компилятор и кросс платформенной библиотеки. Это также означает, что C + +/ WinRT заголовки не негативно затронутые макросы.

Если вы ранее выполняли в C + +/ WinRT, которые добавлять любые заголовки Windows в вашем проекте, то теперь необходимо включить их самостоятельно. Это, в любом случае всегда рекомендуется явным образом включать заголовки, которые зависят от, а не оставлять его на другую библиотеку, чтобы включить их для вас.

Единственное исключение из пакета Windows SDK изоляции файл заголовка сейчас для встроенных функций и числовые значения. Существует не известных проблем, с помощью этих последнего оставшиеся зависимостей.

В проекте можно снова включить взаимодействия с заголовками Windows SDK, если необходимо. Например, можно реализовать COM-интерфейс (доверию в [**IUnknown**](https://msdn.microsoft.com/library/windows/desktop/ms680509)). В этом примере включить `unknwn.h` прежде чем включать C + +/ WinRT заголовков. Делать это выводится C + +/ WinRT базовой библиотеке включить различные обработчики для поддержки классических COM-интерфейсы. Пример кода, см. в разделе [Author COM-компоненты с помощью C + +/ WinRT](author-coclasses.md). Аналогичным образом явным образом включать другие заголовки пакета Windows SDK, которые объявлять типы и функции, которые вы хотите вызвать.

## <a name="how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk"></a>Как Перенацелить C + +/ WinRT проекта на более позднюю версию пакета SDK для Windows

Метод переназначение проекта, который, скорее всего результата в выпуске за меньшее компилятора и компоновщика также является наиболее трудоемкого. Этот метод предусматривает создание нового проекта (предназначенных для Windows SDK версии по вашему выбору), а затем скопировать файлы по в новый проект из старой. Разделы старые будет `.vcxproj` и `.vcxproj.filters` файлы, которые можно просто скопировать более чем сэкономить добавления файлов в Visual Studio.

Тем не менее существует два других способа Перенацелить проекта в Visual Studio.

- Последовательно выберите пункты проекта **Общие**свойства \> **Версия Windows SDK**и выберите **Все конфигурации** и **Всех платформах**. Установите **Версия Windows SDK** версии, который вы хотите обратиться.
- В **Обозревателе решений**щелкните правой кнопкой мыши узел проекта, щелкните **Перенацелить проекты**, выберите версий, которые вы хотите выбрать и нажмите кнопку **ОК**.

При возникновении все компилятора и компоновщика ошибки после применения любого из этих двух методов, а затем вы можете попробовать очистки решение (**сборка** > **Очистить решение** и/или вручную удалить все временные папки и файлы) перед попыткой повторного построения.

Если компилятор C++ выдает «*Ошибка C2039: «IUnknown»: не является членом "\'global имен ''*», затем добавьте `#include <unknwn.h>` в верхнюю часть вашего `pch.h` файл (прежде чем включать C + +/ WinRT заголовки).

Также может потребоваться добавить `#include <hstring.h>` после этого.

Если компоновщик C++ создает ошибку "*error LNK2019: неразрешенный внешний символ _WINRT_CanUnloadNow@0 в функции _VSDesignerCanUnloadNow@0 *», затем вы можете устранить, добавив `#define _VSDESIGNER_DONT_LOAD_AS_DLL` для вашего `pch.h` файл.
