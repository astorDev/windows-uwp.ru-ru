---
author: jwmsft
ms.assetid: 386faf59-8f22-2e7c-abc9-d04216e78894
title: "Анимации композиции"
description: "Многие свойства объектов композиции и эффектов можно анимировать, используя анимацию по ключевым кадрам или анимацию с помощью выражений. Это позволяет изменять свойства элементов пользовательского интерфейса во времени или на основе расчетов."
ms.author: jimwalk
ms.date: 02/08/2017
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp
ms.openlocfilehash: e7d0f5c3fc0d1414dc1b4f714683494fcffd4f51
ms.sourcegitcommit: b42d14c775efbf449a544ddb881abd1c65c1ee86
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/20/2017
---
# <a name="composition-animations"></a>Анимации композиции

API-интерфейсы Windows.UI.Composition позволяют создавать, анимировать и преобразовывать объекты композиции, а также применять к ним различные манипуляции в унифицированном уровне API. Анимации композиции— это эффективный и удобный способ выполнения анимаций в пользовательском интерфейсе приложения. Они были разработаны с нуля, чтобы ваши анимации могли выполняться с частотой 60 кадров в секунд независимо от потока пользовательского интерфейса и у вас была необходимая гибкость для создания удивительных возможностей взаимодействия с пользователем, используя не только привязку ко времени, но также входные данные и другие свойства для запуска анимаций.

В этой статье представлен обзор доступных функций, позволяющих анимировать свойства объекта композиции. Предполагается, что вы знакомы с основами структуры визуального уровня. Дополнительные сведения см. в разделе [Визуальный компонент композиции](./composition-visual-tree.md).

Существует два типа анимаций композиции: **анимация по ключевым кадрам** и **анимация с помощью выражений**.

![Типы анимации](./images/composition-animation-types.png)

## <a name="types-of-composition-animations"></a>Типы анимаций композиции

**Анимация по ключевым кадрам**— это традиционная *покадровая* анимация с привязкой ко времени. Вы можете явно определять *контрольные точки*, описывающие, каким должно быть анимированное значение в определенных точках на временной шкале анимации. Что более важно, вы можете использовать функции для реалистичной анимации (другое название— интерполяторы) для описания перехода между контрольными точками.

**Неявные анимации**— тип анимации, которая позволяет определять многократно используемые анимации или последовательности анимаций отдельно от основной логики приложения. Неявные анимации позволяют создавать *шаблоны* анимации и связывать их с триггерами. Эти триггеры представляют собой изменения свойств, являющиеся результатом выполнения явных назначений. Вы можете определять шаблон как отдельную анимацию или группу анимаций. Группы анимаций— это набор шаблонов анимации, которые можно запускать одновременно неявным образом или с помощью триггера. При работе с неявными анимациями отсутствует необходимость в регулярном создании явных анимаций по ключевым кадрам, когда требуется изменить значение свойства и увидеть, как выполняется его анимирование.

**Анимация с помощью выражений**— это новый тип анимации, реализованный в визуальном уровне в ноябрьском обновлении Windows 10 (сборка 10586).
Коротко говоря, анимация с помощью выражений позволяет создавать математические связи между свойствами объектов класса [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx) и дискретными значениями, которые будут анализироваться и обновляться для каждого кадра. Вы можете создавать ссылки на свойства объектов композиции и наборы свойств, использовать вспомогательные математические функции и даже ссылаться на входные данные для запуска этих математических связей. Выражения могут использоваться для описания более сложных видов взаимодействия с пользователем (например, закрепленных заголовков и параллакса) на платформе Windows.

## <a name="why-composition-animations"></a>Преимущества анимаций композиции

**Производительность.** При создании универсальных Windows-приложений большая часть кода выполняется в потоке пользовательского интерфейса.
Чтобы обеспечить плавное выполнение анимаций на разных категориях устройств, система выполняет вычисление анимированных значений и обработку на независимом потоке для сохранения частоты обновления в 60кадр/с.
Это значит, что вам не нужно беспокоиться о плавности выполнения анимаций, так как за это будет отвечать система, в то время как приложения будут выполнять другие сложные операции для реализации сложных видов взаимодействия с пользователем.

**Возможности.** Целью использования анимаций композиции в визуальном уровне является упрощение процесса создания красивых пользовательских интерфейсов. Мы хотим предоставить вам различные типы анимаций, которые помогут вам реализовывать свои удивительные замыслы.

**Шаблоны.** Все анимации композиции в визуальном уровне являются шаблонами. Благодаря этому вы можете применять одну анимацию к нескольким объектам без необходимости в создании отдельных анимаций.
Это позволяет использовать одни и те же анимации и оптимизировать свойства или параметры для других целей, не беспокоясь о том, что это отразится на предыдущих действиях.

Возможные примеры анимаций рассмотрены в беседах разработчиков в рамках конференции BUILD, посвященных [анимациям с помощью выражений](https://channel9.msdn.com/events/Build/2016/P486), [интерактивным способам взаимодействия](https://channel9.msdn.com/Events/Build/2016/P405), [неявным анимациям](https://channel9.msdn.com/events/Build/2016/P484) и [подключенным анимациям](https://channel9.msdn.com/events/Build/2016/P485).

Примеры использования API-интерфейсов и ряд других высококачественных примеров кода, написанного с помощью API-интерфейсов, см. на [странице веб-сайта GitHub, посвященной композиции](http://go.microsoft.com/fwlink/?LinkID=789439).

## <a name="what-can-you-animate-with-composition-animations"></a>Что можно анимировать с помощью анимаций композиции?

Анимации композиции можно применять к большинству свойств объектов композиции, например свойствам объектов классов [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx) и **InsetClip**.
Анимации композиции можно также применять к эффектам композиции и наборам свойств. **При выборе элемента, к которому требуется применить анимацию, обращайте внимание на его тип. Используйте представленные ниже таблицы для определения создаваемого типа анимации по ключевым кадрам или типа, в который должно разрешаться ваше выражение.**

### <a name="visual"></a>Объект класса Visual

|Анимируемые свойства объекта класса Visual|Тип|
|------|------|
|AnchorPoint (Точка привязки)|Vector3 (Вектор 2)|
|CenterPoint (Центральная точка)|Vector3 (Вектор 3)|
|Offset (Смещение)|Vector3 (Вектор 3)|
|Opacity (Прозрачность)|Scalar (Скаляр)|
|Orientation (Ориентация)|Quaternion (Кватернион)|
|RotationAngle (Угол поворота)|Scalar (Скаляр)|
|RotationAngleInDegrees (Угол поворота в градусах)|Scalar (Скаляр)|
|RotationAxis (Ось поворота)|Vector3 (Вектор 3)|
|Scale (Масштаб)|Vector3 (Вектор 3)|
|Size (Размер)|Vector3 (Вектор 2)|
|TransformMatrix* (Матрица преобразования)|Matrix4x4 (Матрица 4 x 4)|
*Если требуется анимировать все свойство TransformMatrix в качестве типа Matrix4x4, для этого необходимо использовать анимацию с помощью выражений.
Или же можно выбрать отдельные ячейки матрицы и применить к ним анимацию по ключевым кадрам либо анимацию с помощью выражений.

### <a name="insetclip"></a>Объекты класса InsetClip

|Анимируемые свойства объектов класса InsetClip|Тип|
|-------------------------------|-------|
|BottomInset (Углубление вниз)|Scalar (Скаляр)|
|LeftInset (Углубление влево)|Scalar (Скаляр)|
|RightInset (Углубление вправо)|Scalar (Скаляр)|
|TopInset (Углубление вверх)|Scalar (Скаляр)|

## <a name="visual-sub-channel-properties"></a>Свойства подканала объекта класса Visual

Помимо возможности анимирования свойств объектов класса [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx) для применения анимации также можно выбирать *подканальные* компоненты этих свойств.
Предположим, вы просто хотите анимировать смещение по оси X (X Offset) объекта класса [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx), а не все смещение (Offset) полностью.
Анимацию можно применить либо к свойству Vector3 Offset, либо к компоненту Scalar X свойства Offset.
Вдобавок к возможности выбирать отдельный подканальный компонент свойства вы можете выбрать несколько компонентов.
Например, вы можете выбрать компоненты X и Y свойства Scale.

|Анимируемые подканальные свойства объекта класса Visual|Тип|
|----------------------------------------|------|
|AnchorPoint.x, y (Точка привязки x, y)|Scalar (Скаляр)|
|AnchorPoint.xy (Точка привязки xy)|Vector3 (Вектор 2)|
|CenterPoint.x, y, z (Центральная точка x, y, z)|Scalar (Скаляр)|
|CenterPoint.xy, xz, yz (Центральная точка xy, xz, yz)|Vector3 (Вектор 2)|
|Offset.x, y, z (Смещение x, y, z)|Scalar (Скаляр)|
|Offset.xy, xz, yz (Смещение xy, xz, yz)|Vector3 (Вектор 2)|
|RotationAxis.x, y, z (Ось поворота x, y, z)|Scalar (Скаляр)|
|RotationAxis.xy, xz, yz (Ось поворота xy, xz, yz)|Vector3 (Вектор 2)|
|Scale.x, y, z (Масштаб x, y, z)|Scalar (Скаляр)|
|Scale.xy, xz, yz (Масштаб xy, xz, yz)|Vector3 (Вектор 2)|
|Size.x, y (Размер x, y)|Scalar (Скаляр)|
|Size.xy (Размер xy)|Vector3 (Вектор 2)|
|TransformMatrix. _11 ... TransformMatrix. _NN, (Матрица преобразования _11 ... Матрица преобразования_NN,)|Scalar (Скаляр)|
|TransformMatrix._11_12 ... TransformMatrix._NN_NN (Матрица преобразования _11_12 ... Матрица преобразования_NN_NN)|Vector3 (Вектор 2)|
|TransformMatrix._11_12_13 ... TransformMatrix._NN_NN_NN (Матрица преобразования _11_12_13 ... Матрица преобразования_NN_NN_NN)|Vector3 (Вектор 3)|
|TransformMatrix._11_12_13_14 (Матрица преобразования _11_12_13_14)|Vector4 (Вектор 4)|
|Color* (Цвет)|Colors (Windows.UI) (Цвета, Windows.UI)|

*Процесс анимации подканала Color (Цвет) свойства Brush (Кисть) немного отличается. Выполняется прикрепление функции StartAnimation() к объекту Visual.Brush; после чего параметром "Color" объявляется свойство для анимации.
(Дополнительное описание процесса анимации цвета представлено ниже)

## <a name="property-sets-and-effects"></a>Наборы свойств и эффекты

Помимо возможности анимирования свойств объектов класса [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx) и InsetClip композиции можно также анимировать свойства в наборе свойств (PropertySet) или эффекты.
При работе с наборами свойств выполняется определение свойства, которое помещается на хранение в набор свойств композиции. В дальнейшем это свойство можно будет выбрать для анимации (а также одновременно с этим установить на него ссылку из другого свойства). Более подробно об этом будет рассказано в разделах ниже.

При работе с эффектами вы можете определять графические эффекты с помощью API-интерфейсов эффектов композиции (см. [Обзор эффектов](./composition-effects.md).
Вдобавок к возможности определения эффектов вы также можете анимировать значения свойств эффекта.
Для этого необходимо выполнить нацеливание компонента свойств свойства Brush на спрайтовые визуальные элементы.

## <a name="quick-formula-getting-started-with-composition-animations"></a>Краткое руководство: начало работы с анимациями композиции

Прежде чем разбираться более подробно в том, как создавать и использовать различные типы анимаций, ознакомьтесь с приведенным ниже кратким руководством по эффективной работе с анимациями композиции.

1. Получите компоновщик. Это можно сделать со страницы или из класса FrameworkElement, в котором выполняется анимация.
1. Создайте новый объект для анимации: им будет анимация по ключевым кадрам или анимация на основе выражений.
    * При выполнении анимации по ключевым кадрам необходимо создать тип анимации по ключевым кадрам, который будет соответствовать типу анимируемого свойства.
    * Есть только один тип анимации на основе выражений.
1. Выберите содержимое для анимации: добавьте ключевые кадры или определите строку выражения.
    * При выполнении анимации по ключевым кадрам убедитесь, что значение ключевых кадров и анимируемое свойство относятся к одному и тому же типу.
    * При выполнении анимации на основе выражений убедитесь, что строка выражения будет разрешаться в тот же тип, что и анимируемое свойство.
1. Запустите анимацию объекта [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx), свойство которого требуется анимировать. Вызовите функцию StartAnimation и добавьте в качестве параметров имя анимируемого свойства (в строковом формате) и анимируемый объект.

```cs
// KeyFrame Animation Example to target Opacity property
// Step 1 - Get the compositor
_compositor = ElementCompositionPreview.GetElementVisual(this).Compositor;

// Step 2 - Create your animation object
var animation = _compositor.CreateScalarKeyFrameAnimation();

// Step 3 - Define Content
animation.Duration = TimeSpan.FromSeconds(1);
animation.InsertKeyFrame(1f, 0.2f);

// Step 4 - Attach animation to Visual property and start animation
_targetVisual.StartAnimation(nameof(Visual.Opacity), animation);

// Expression Animation Example to target Opacity property
// Step 2 - Create your animation object
var expression = _compositor.CreateExpressionAnimation();
// Step 3 - Define Content (you can also define the string as part of the expression object
// declaration)
expression.Expression = "targetVisual.Offset.X / windowWidth";
expression.SetReferenceParameter("targetVisual", _target);
expression.SetScalarParameter("windowWidth", _xSizeWindow);
// Step 4 - Attach animation to Visual property and start animation
_targetVisual.StartAnimation("Opacity", expression);

```

## <a name="using-keyframe-animations"></a>Анимация по ключевым кадрам

Анимация по ключевым кадрам— это анимация с привязкой ко времени, в которой используются один или несколько ключевых кадров, указывающих изменение значения во времени.
Кадры представляют собой метки или контрольные точки, позволяющие определять, каким должно быть анимированное значение в определенный момент времени.

### <a name="creating-your-animation-and-defining-keyframes"></a>Создание собственной анимации и определение ключевых кадров

Для создания анимации по ключевым кадрам используйте метод конструктора вашего объекта Compositor, который соответствует типу того свойства, которое вы хотите анимировать.
Существуют следующие типы анимации по ключевым кадрам:

* ColorKeyFrameAnimation
* QuaternionKeyFrameAnimation
* ScalarKeyFrameAnimation
* Vector2KeyFrameAnimation
* Vector3KeyFrameAnimation
* Vector4KeyFrameAnimation

Например, в следующем фрагменте кода создается анимация по ключевым кадрам Vector3.

```cs
var animation = _compositor.CreateVector3KeyFrameAnimation();
```

Каждый ключевой кадр создается путем вставки отдельных сегментов ключевых кадров и указания двух компонентов, а также (при необходимости) третьего компонента.

* Time: нормализованное состояние изменения ключевого кадра (значение— от 0,0 до 1,0).
* Value: анимируемое значение в конкретный момент времени.
* Функция Easing для реалистичной анимации; необязательный компонент: функция для описания интерполяции между предыдущим и текущим ключевым кадром (будет рассмотрена позже).

В следующем фрагменте кода ключевой кадр вставляется в среднюю точку анимации.

```cs
animation.InsertKeyFrame(0.5f, new Vector3(50.0f, 80.0f, 0.0f));
```

**Примечание.** При анимировании цвета с помощью анимации по ключевым кадрам следует помнить о нескольких дополнительных моментах:

1. Функция StartAnimation прикрепляется к объекту Visual.Brush вместо объекта [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx), где **Color** является параметром свойства, которое необходимо анимировать.
1. Компонент "value" ключевого кадра определяется объектом Colors пространства имен Windows.UI.
1. Вы можете определить цветовое пространство для интерполяции, задав свойство InterpolationColorSpace. Возможные значения:
    * CompositionColorSpace.Rgb
    * CompositionColorSpace.Hsl

## <a name="keyframe-animation-properties"></a>Свойства анимации по ключевым кадрам

Определив анимацию по ключевым кадрам и отдельные ключевые кадры, можно указать различные свойства анимации.

* DelayTime (Время задержки)— время перед началом анимации после вызова функции StartAnimation().
* Duration— продолжительность анимации.
* IterationBehavior— количество повторений (либо бесконечное повторение) анимации.
* IterationCount— число конечных временных периодов, в течение которых повторяется анимация по ключевым кадрам.
* KeyFrameCount— число ключевых кадров в определенной анимации по ключевым кадрам.
* StopBehavior— определяет поведение анимируемого значения при вызове функции StopAnimation.
* Direction— определяет направление анимации, которую необходимо воспроизвести.

В следующем фрагменте кода для анимации устанавливается значение продолжительности, равное 5 секундам.

```cs
animation.Duration = TimeSpan.FromSeconds(5);
```

## <a name="easing-functions"></a>Функции для реалистичной анимации

Функции для реалистичной анимации (CompositionEasingFunction) указывают, как изменяются промежуточные значения между предыдущим и текущим значениями ключевого кадра. Если для ключевого кадра не задана функция для реалистичной анимации, используется кривая по умолчанию.

Поддерживаются три типа функций для реалистичной анимации.

* Линейная
* Кривая Безье третьего порядка
* Этап

Кривые Безье третьего порядка представляют собой параметрическую функцию, часто используемую для описания плавных кривых, которые можно масштабировать. При использовании кривой Безье третьего порядка с анимациями по ключевым кадрам композиции необходимо определить две контрольные точки, являющиеся объектами Vector2. Эти контрольные точки используются для определения формы кривой. Для визуализации процесса формирования кривой Безье третьего порядка по двум контрольным точкам рекомендуется использовать веб-сайты, аналогичные [этому](http://cubic-bezier.com/#0,-0.01,.48,.99).

Чтобы создать функцию для реалистичной анимации, используйте метод конструктора объекта Compositor. В следующих фрагментах кода выполняется создание линейной функции для реалистичной анимации и построение простой кривой Безье третьего порядка с членом EaseIn.

```cs
var linear = _compositor.CreateLinearEasingFunction();
var easeIn = _compositor.CreateCubicBezierEasingFunction(new Vector2(0.5f, 0.0f), new Vector2(1.0f, 1.0f));
var step = _compositor.CreateStepEasingFunction();
```

Чтобы добавить функцию для реалистичной анимации к ключевому кадру, просто добавьте третий параметр к ключевому кадру при его вставке в анимацию.

В следующем фрагменте кода функция для реалистичной анимации EaseIn добавляется к ключевому кадру.

```cs
animation.InsertKeyFrame(0.5f, new Vector3(50.0f, 80.0f, 0.0f), easeIn);
```

## <a name="starting-and-stopping-keyframe-animations"></a>Запуск и остановка анимации по ключевым кадрам

После того как вы определили анимацию и ключевые кадры, вы можете подключить анимацию. При запуске анимации необходимо указать объект [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx), который необходимо анимировать, целевое свойство для анимации и ссылку на анимацию.
Для этого необходимо вызвать функцию StartAnimation(). Следует помнить, что вызов функции StartAnimation() для свойства приведет к отключению и удалению любых ранее запущенных анимаций.
**Примечание.** Ссылка на анимируемое свойство имеет строковый формат.

В фрагменте кода ниже выполняется настройка и запуск анимации свойства Offset объекта [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx).

```cs
targetVisual.StartAnimation("Offset", animation);
```

Если требуется выполнить нацеливание на свойства подканала, для этого подканал добавляется в строку, определяющую анимируемое свойство.
В примерах выше синтаксис изменится на StartAnimation("Offset.X, animation2), где animation2 представляет собой ScalarKeyFrameAnimation.

После запуска анимации ее также можно остановить до завершения ее выполнения. Для этого используется функция StopAnimation().
В следующем фрагменте кода выполняется остановка анимации свойства Offset объекта [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx).

```cs
targetVisual.StopAnimation("Offset");
```

Кроме того, можно настраивать поведение анимации при ее явной остановке. Для этого необходимо задать свойство Stop Behavior (Поведение остановки) анимации. Есть три параметра:

* LeaveCurrentValue: анимация отметит значение анимируемого свойства в качестве последнего вычисляемого значения анимации.
* SetToFinalValue: анимация отметит значение анимируемого свойства в качестве значения последнего ключевого кадра.
* SetToInitialValue: анимация отметит значение анимируемого свойства в качестве значения первого ключевого кадра.

В следующем фрагменте кода выполняется настройка свойства StopBehavior для анимации по ключевым кадрам.

```cs
animation.StopBehavior = AnimationStopBehavior.LeaveCurrentValue;
```

## <a name="animation-completion-events"></a>События завершения анимации

При работе с анимацией по ключевым кадрам вы можете использовать пакеты анимации, чтобы указать, когда должна завершиться отдельная анимация (либо группы анимаций).
Помещать в пакеты можно только события завершения анимации по ключевым кадрам. У выражений нет четко заданного конечного состояния, поэтому они не генерируют события завершения.
При запуске анимации на основе выражений внутри пакета анимация будет выполнена правильно и это не повлияет на генерирование пакета.

Событие завершения пакета возникает после завершения всех анимаций внутри пакета.
Время, необходимое для инициации события пакета, определяется самой продолжительной анимацией или анимацией с самой большой задержкой в пакете.
Объединение конечных состояний полезно использовать, когда нужно знать, когда завершаются группы выбранных анимаций, чтобы запланировать другую работу.

Пакеты высвобождаются при генерировании события завершения. Вы также можете в любое время вызвать метод Dispose(), чтобы освободить ресурс раньше.
Вам может потребоваться вручную высвободить объект пакета, если помещенная в пакет анимация завершилась раньше и вы не хотите принимать событие завершения.
При прерывании выполнения анимации или ее отмене создается событие завершения, засчитываемое для того пакета, в котором оно было установлено.
Это показано в примере Animation_Batch SDK на [странице веб-сайта GitHub, посвященной композиции/Windows](http://go.microsoft.com/fwlink/p/?LinkId=789439).

## <a name="scoped-batches"></a>Пакеты с заданной областью

Для объединения определенной группы анимаций или нацеливания на событие завершения отдельной анимации сначала нужно создать пакет с заданной областью.

```cs
CompositionScopedBatch myScopedBatch = _compositor.CreateScopedBatch(CompositionBatchTypes.Animation);
```

После создания пакета с заданной областью все запущенные анимации объединяются, пока пакет явным образом не будет приостановлен либо остановлен с помощью функций Suspend или End.

Вызов функции Suspend останавливает объединение конечных состояний анимаций, до тех пор пока не будет вызвана функция Resume. Это позволяет явным образом исключить содержимое из данного пакета.

В следующем фрагменте кода анимация, нацеленная на свойство Offset объекта VisualA, не будет добавлена в пакет.

```cs
myScopedBatch.Suspend();
VisualA.StartAnimation("Offset", myAnimation);
myScopeBatch.Resume();
```

Чтобы завершить выполнение пакета, необходимо вызвать метод End(). Если не вызвать метод End, пакет будет оставаться открытым, постоянно собирая объекты.

В следующем фрагменте кода и на схеме ниже представлен пример того, как пакет будет выполнять объединение анимаций для отслеживания их конечных состояний.
Обратите внимание, что в этом примере пакет будет отслеживать только конечные состояния анимаций 1, 3 и 4, кроме анимации 2.

```cs
myScopedBatch.End();
CompositionScopedBatch myScopedBatch =  _compositor.CreateScopedBatch(CompositionBatchTypes.Animation);
// Start Animation1
[…]
myScopedBatch.Suspend();
// Start Animation2
[…]
myScopedBatch.Resume();
// Start Animation3
[…]
// Start Animation4
[…]
myScopedBatch.End();
```

![Пакет с заданной областью содержит анимации 1, 3 и 4, в то время как анимация 2 исключена из него](./images/composition-scopedbatch.png)

## <a name="batching-a-single-animations-completion-event"></a>Создание пакета с событием завершения отдельной анимации

Если вы хотите узнать, когда заканчивается отдельная анимация, вам необходимо создать пакет с заданной областью, запустить анимацию и завершить пакет. Пример.

```cs
CompositionScopedBatch myScopedBatch =  _compositor.CreateScopedBatch(CompositionBatchTypes.Animation);
Visual.StartAnimation("Opacity", myAnimation);
myScopedBatch.End();
```

## <a name="retrieving-a-batchs-completion-event"></a>Извлечение события завершения пакета

При создании пакета с отдельной анимацией или группой анимаций извлечение события завершения пакета осуществляется аналогичным образом.
Для этого выполняется регистрация метода обработки события для события Completed целевого пакета.

```cs
myScopedBatch.Completed += OnBatchCompleted;
```

## <a name="batch-states"></a>Состояния пакетов

Есть два свойства, которые можно использовать для определения состояния имеющегося пакета— IsActive и IsEnded.

Свойство IsActive возвращает значение "true", если целевой пакет открыт для сбора анимаций. Когда пакет будет приостановлен или завершен, свойство IsActive будет возвращать значение "false".

Свойство IsEnded возвращает значение "true", когда к этому конкретному пакету нельзя добавить анимацию. Чтобы завершить пакет, для него необходимо явно вызвать метод End().

## <a name="using-expression-animations"></a>Анимация с помощью выражений

Анимация с помощью выражений— это новый тип анимации, реализованный в ноябрьском обновлении Windows 10 (сборка 10586).
Если рассматривать обобщенно, в основе анимации с помощью выражений лежит использование математического выражения/связи между дискретными значениями, а также ссылок на другие свойства объекта композиции.
В отличие от анимации по ключевым кадрам, когда используется функция интерполятора (кривая Безье третьего, четвертого, пятого порядка и т.д.) для описания изменения значения с течением времени, при анимации с помощью выражений используется математическое уравнение для вычисления анимированного значения для каждого кадра.
Важно отметить, что у анимации с помощью выражений отсутствует заданная продолжительность— после запуска анимации она будет выполняться и использовать математическое уравнение для вычисления значения анимируемого свойства до тех пор, пока не будет явным образом остановлена.

**Так какие же преимущества есть у анимации с помощью выражений?**

Анимацию с помощью выражений по-настоящему удобно использовать для того, чтобы создать математическую связь, которая будет содержать ссылки на параметры или свойства других объектов.
Это значит, что вы можете создать выражение, ссылающееся на значения свойств других объектов композиции, локальные переменные или даже общие значения из наборов свойств композиции.
За счет использования этой ссылочной модели, а также с учетом того, что выражение вычисляется для каждого кадра, при изменении значений, определяющих выражение, изменяется и результат выражения.
Этот открывает широкие возможности, недоступные при традиционной анимации по ключевым кадрам, когда значения должны являться дискретными и быть определены заранее.
Например, анимацию с помощью выражений можно использовать для описания таких видов взаимодействия с пользователем, как закрепленные заголовки и параллакс.

**Примечание.** Когда речь идет о математическом уравнении, определяющем объект анимации с помощью выражений, используются термины "Выражение" или "Строка выражения".

## <a name="creating-and-attaching-your-expression-animation"></a>Создание и прикрепление анимации с помощью выражений

Прежде чем перейти к разговору о синтаксисе создания анимаций на основе выражений, необходимо рассмотреть несколько основных принципов работы с этим типом анимации.

* Анимация на основе выражений использует заданное математическое уравнение для определения значения анимируемого свойства для каждого кадра.
* Математическое уравнение вставляется в выражение в виде строки.
* Результат математического уравнения должен разрешаться в тот же тип, что и тип анимируемого свойства. Если эти типы не совпадают, при вычислении выражения возникнет ошибка. Если ваше уравнение разрешается не в число— Nan (число/0)— система использует предыдущее вычисленное значение.
* Анимации на основе выражений обладают *бесконечным жизненным циклом*— они выполняются, пока не будут остановлены.

Чтобы создать анимацию на основе выражений, используйте конструктор вашего объекта композиции и определите необходимое математическое выражение.

Ниже приведен пример конструктора, определяющего очень простое выражение, которое суммирует два скалярных значения (более сложное выражение будет рассмотрено в следующем разделе).

```cs
var expression = _compositor.CreateExpressionAnimation("0.2 + 0.3");
```

По аналогии с анимацией по ключевым кадрам после определения анимации на основе выражений ее необходимо прикрепить к объекту Visual и объявить анимируемое свойство.
Далее работа с примером выше продолжается, в ходе которой анимация на основе выражений прикрепляется к свойству Opacity объекта [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx) (тип Scalar).

```cs
targetVisual.StartAnimation("Opacity", expression);
```

## <a name="components-of-your-expression-string"></a>Компоненты строки выражения

В примере из предыдущего раздела продемонстрировано сложение двух простых скалярных значений.
Несмотря на то, что этот фрагмент кода является рабочим, в нем не представлены все возможности использования выражений.
В отношении примера выше стоит отметить, что поскольку используемые в нем значения являются дискретными, для каждого кадра выражение будет разрешаться в значение 0,5 и будет оставаться неизменным на протяжении всего жизненного цикла анимации.
Истинным потенциалом использования выражений является возможность задавать математическую связь, в рамках которой может выполняться периодическое или постоянное изменение значений.

Рассмотрим различные компоненты, из которых могут состоять подобные типы выражений.

### <a name="operators-precedence-and-associativity"></a>Операторы, приоритет и ассоциативность

Строка выражения поддерживает использование стандартных операторов для описания математических связей между разными компонентами уравнения.

|Категория| Операторы|
|--------|-----------|
|Унарные| -|
|Мультипликативные|* /|
|Аддитивные|+ -|
|Оператор деления по модулю| %|

Аналогичным образом, при вычислении выражения соблюдается приоритет и ассоциативность операторов в соответствии со спецификацией языка C#.
Другими словами, выражение будет соблюдать основной порядок операций.

В примере ниже, в ходе вычисления выражения, операции со значениями в скобках будут выполнены в первую очередь, после чего будет разрешена оставшаяся часть уравнения в соответствии с порядком выполнения операций.

```cs
"(5.0 * (72.4 – 36.0) + 5.0" // (5.0 * 36.4 + 5) -> (182 + 5) -> 187
```

### <a name="property-parameters"></a>Параметры свойств

Одной из сильных сторон языка выражений являются параметры свойств.
В строку выражения можно добавлять ссылки на значения свойств от других объектов, таких как визуальный объект композиции, набор свойств композиции ([Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx), Composition Property Set) или других объектов C#.

Чтобы использовать эти объекты в строке выражения, в качестве параметров достаточно задать ссылки на анимацию на основе выражений.
Для этого нужно сопоставить строку, используемую в выражении, с фактическим объектом. За счет этого в ходе вычисления уравнения система будет знать, что именно необходимо проверить, чтобы вычислить значение.
Существуют разные типы параметров, коррелирующие с типом объекта, который требуется добавить в уравнение:

|Тип|Функция для создания параметра|
|----|------------------------------|
|Scalar (Скаляр)|SetScalarParameter(String ref, Scalar obj)|
|Vector (Вектор)|SetVector2Parameter(String ref, Vector2 obj)<br/>SetVector3Parameter(String ref, Vector3 obj)<br/>SetVector4Parameter(String ref, Vector4 obj)|
|Matrix (Матрица)|SetMatrix3x2Parameter(String ref, Matrix3x2 obj)<br/>SetMatrix4x4Parameter(String ref, Matrix4x4 obj)|
|Quaternion (Кватернион)|SetQuaternionParameter(String ref, Quaternion obj)|
|Color (Цвет)|SetColorParameter(String ref, Color obj)|
|CompositionObject (Объект композиции)|SetReferenceParameter(String ref, Composition object obj)|
|Boolean (Логическое)| SetBooleanParameter(String ref, Boolean obj)|

В следующем фрагменте кода выполняется создание анимации на основе выражений, которая будет ссылаться на свойство Offset двух других объектов [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx) композиции и базовый объект Vector3 System.Numerics.

```cs
var commonOffset = new Vector3(25.0, 17.0, 10.0);
var expression = _compositor.CreateExpressionAnimation("SomeOffset / ParentOffset + additionalOffset");
expression.SetVector3Parameter("SomeOffset", childVisual.Offset);
expression.SetVector3Parameter("ParentOffset", parentVisual.Offset);
expression.SetVector3Parameter("additionalOffset", commonOffset);
```

Кроме того, используя модель, описанную выше, можно установить ссылку на значение набора свойств из выражения.
Наборы свойств композиции представляют собой простой способ хранения данных, используемых анимациями, а также полезны для формирования данных, поддерживающих совместное и многократное использование, которые в том числе не привязаны к сроку жизни любого другого объекта композиции.
Ссылки на значения набора свойств можно устанавливать в выражении таким же образом, как и другие ссылки на свойства. (Дополнительные сведения о наборах свойств приведены в следующем разделе)

Пример выше можно изменить так, чтобы набор свойств использовался для определения commonOffset, а не локальной переменной.

```cs
_sharedProperties = _compositor.CreatePropertySet();
_sharedProperties.InsertVector3("commonOffset", offset);
var expression = _compositor.CreateExpressionAnimation("SomeOffset / ParentOffset + sharedProperties.commonOffset");
expression.SetVector3Parameter("SomeOffset", childVisual.Offset);
expression.SetVector3Parameter("ParentOffset", parentVisual.Offset);
expression.SetReferenceParameter("sharedProperties", _sharedProperties);
```

Наконец, при установке ссылок на свойства других объектов также можно установить ссылки на свойства подканала— в строке выражения или в качестве части параметра ссылки.

В примере ниже выполняется установка ссылок на подканал Х свойств Offset от двух объектов [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx)— одна непосредственно в самой строке выражения и другая при создании параметра ссылки.
Обратите внимание, что при установке ссылки на компонент Х свойства Offset тип параметра необходимо изменить на Scalar Parameter, а не на Vector3, как в предыдущем примере.

```cs
var expression = _compositor.CreateExpressionAnimation("xOffset/ ParentOffset.X");
expression.SetScalarParameter("xOffset", childVisual.Offset.X);
expression.SetVector3Parameter("ParentOffset", parentVisual.Offset);
```

### <a name="expression-helper-functions-and-constructors"></a>Вспомогательные функции выражений и конструкторы

Помимо доступа к операторам и параметрам свойств, также имеется доступ к списку математических функций, которые можно использовать в выражениях.
Эти функции можно использовать для выполнения вычислений и операций с разными типами, которые обычно выполняются с объектами System.Numerics.

В примере ниже создается выражение, которое будет применяться к свойствам типа Scalar и использует вспомогательную функцию Clamp.

```cs
var expression = _compositor.CreateExpressionAnimation("Clamp((scroller.Offset.y * -1.0) – container.Offset.y, 0, container.Size.y – header.Size.y)"
```

Помимо списка вспомогательных функций также можно использовать встроенные методы конструктора внутри строки выражения, которые будут создавать экземпляр этого типа на основании предоставленных параметров.

В примере ниже создается выражение, которое определяет новый объект Vector3 в строке выражения.

```cs
var expression = _compositor.CreateExpressionAnimation("Offset / Vector3(targetX, targetY, targetZ");
```

Полный список всех вспомогательных функций и конструкторов см. в разделе "Приложение" или список ниже с разбиением по типам.

* [Scalar (Скаляр)](#scalar)
* [Vector3 (Вектор 2)](#vector2)
* [Vector3 (Вектор 3)](#vector3)
* [Matrix3x2 (Матрица 3 х 2)](#matrix3x2)
* [Matrix4x4 (Матрица 4 х 4)](#matrix4x4)
* [Quaternion (Кватернион)](#quaternion)
* [Color (Цвет)](#color)

### <a name="expression-keywords"></a>Ключевые слова выражения

Вы можете использовать специальные "ключевые слова", которые обрабатываются по-разному при вычислении выражения.
Поскольку они являются "ключевыми словами" их нельзя использовать в качестве части параметра строки соответствующих им ссылок на свойства.

|Ключевое слово|Описание|
|-------|--------------|
|This.StartingValue| Предоставляет ссылку на исходное начальное значение анимируемого свойства.|
|This.CurrentValue|Предоставляет ссылку на "известное" в настоящий момент значение свойства.|
|Pi| Предоставляет ссылку ключевого слова на значение PI.|

В примере ниже представлено использование ключевого слова this.StartingValue.

```cs
var expression = _compositor.CreateExpressionAnimation("this.StartingValue + delta");
```

### <a name="expressions-with-conditionals"></a>Условные выражения

Помимо работы с математическими выражениями с помощью операторов, ссылок на свойства, функций и конструкторов можно также создать выражение, содержащее тренарный оператор.

```cs
(condition ? ifTrue_expression : ifFalse_expression)
```

Условные операторы позволяют создавать выражения, которые могут основываться на определенных условиях. В этом случае для расчета значения анимируемого свойства система будет использовать другие математические связи.
Тренарные операторы можно размещать в качестве выражений для операторов, возвращающих значения "true" или "false".

В инструкции условия поддерживаются следующие условные операторы.

* Оператор «Равно» (==)
* Оператор «Не равно» (!=)
* Оператор «Меньше, чем» (<)
* Оператор «Меньше или равно» (<=)
* Оператор «Больше» (>)
* Оператор «Больше или равно» (>=)

В инструкциях условия поддерживаются следующие логические операции в виде операторов и функций.

* Логическое «НЕ»: ! / Not(bool1)
* Логическое «И»: && / And(bool1, bool2)
* Логическое «ИЛИ»: || / Or(bool1, bool2)

Следующий фрагмент кода демонстрирует пример использования условных операторов в анимации на основе выражений.

```cs
var expression = _compositor.CreateExpressionAnimation("target.Offset.x > 50 ? 0.0f + (target.Offset.x / parent.Offset.x) : 1.0f");
```

## <a name="expression-keyframes"></a>Ключевые кадры выражения

Выше в этом документе мы рассмотрели создание анимации по ключевым кадрам и анимации на основе выражений, а также различные компоненты, которые можно использовать для создания строки выражения. Что если вам требуется использовать возможности анимации на основе выражений вместе с интерполяцией по времени, предоставляемой анимацией по ключевым кадрам?
Выход есть— это ключевые кадры выражения.

Вместо определения дискретного значения для каждой контрольной точки в анимации по ключевым кадрам в качестве значения можно использовать строку выражения.
В этом случае система будет использовать строку выражения для расчета того, каким должно быть значение анимируемого свойства в конкретной точке на временной шкале.
Затем система просто выполнит интерполяцию этого значения, как при обычной анимации по ключевым кадрам.

Для использования ключевых кадров выражения необходимость в создании особых анимаций отсутствует— достаточно просто вставить ключевой кадр выражения в стандартную анимацию по ключевым кадрам, указать время и определить строку выражения в качестве значения. В примере ниже представлен этот процесс. Строка выражения в нем используется в качестве значения для одного из ключевых кадров.

```cs
var animation = _compositor.CreateScalarKeyFrameAnimation();
animation.InsertExpressionKeyFrame(0.25, "VisualBOffset.X / VisualAOffset.Y");
animation.InsertKeyFrame(1.00f, 0.8f);
```

## <a name="expression-sample"></a>Пример выражения

В следующем фрагменте кода представлен пример настройки анимации на основе выражений для создания простого эффекта параллакса, когда значения ввода извлекаются из средства прокрутки.

```cs
// Get scrollviewer
ScrollViewer myScrollViewer = ThumbnailList.GetFirstDescendantOfType<ScrollViewer>();
_scrollProperties = ElementCompositionPreview.GetScrollViewerManipulationPropertySet(myScrollViewer);

// Setup the expression
_parallaxExpression = compositor.CreateExpressionAnimation();
_parallaxExpression.SetScalarParameter("StartOffset", 0.0f);
_parallaxExpression.SetScalarParameter("ParallaxValue", 0.5f);
_parallaxExpression.SetScalarParameter("ItemHeight", 0.0f);
_parallaxExpression.SetReferenceParameter("ScrollManipulation", _scrollProperties);
_parallaxExpression.Expression = "(ScrollManipulation.Translation.Y + StartOffset - (0.5 *  ItemHeight)) * ParallaxValue - (ScrollManipulation.Translation.Y + StartOffset - (0.5   * ItemHeight))";
```

## <a name="animating-with-property-sets"></a>Анимация с помощью наборов свойств

Наборы свойств композиции предоставляют возможность помещать значения на хранение, а затем использовать их в нескольких анимациях без привязки ко времени жизни другого объекта композиции.
Наборы свойств очень полезны для хранения часто используемых значений с дальнейшей установкой на них ссылок в анимациях.
Наборы свойств можно также использовать для хранения данных на основе логики приложения, применяющихся для запуска выполнения выражения.

Чтобы создать набор свойств, используйте метод конструктора объекта Compositor:

```cs
_sharedProperties = _compositor.CreatePropertySet();
```

После создания набора свойств в него можно добавить свойство и значение.

```cs
_sharedProperties.InsertVector3("NewOffset", offset);
```

Подобно тому, о чем мы говорили ранее, вы можете установить ссылку на значение этого набора свойств в анимации на основе выражений.

```cs
var expression = _compositor.CreateExpressionAnimation("this.target.Offset + sharedProperties.NewOffset");
expression.SetReferenceParameter("sharedProperties", _sharedProperties);
targetVisual.StartAnimation("Offset", expression);
```

Значения набора свойств можно также анимировать. Для этого нужно прикрепить анимацию к объекту PropertySet, а затем установить ссылку на имя свойства в строке.
Ниже приведен пример анимации свойства NewOffset в наборе свойств с помощью анимации по ключевым кадрам.

```cs
var keyFrameAnimation = _compositor.CreateVector3KeyFrameAnimation()
keyFrameAnimation.InsertKeyFrame(0.5f, new Vector3(25.0f, 68.0f, 0.0f);
keyFrameAnimation.InsertKeyFrame(1.0f, new Vector3(89.0f, 125.0f, 0.0f);
_sharedProperties.StartAnimation("NewOffset", keyFrameAnimation);
```

Возможно, вам интересно узнать, что произойдет со значением анимируемого свойства, к которому прикреплена анимация на основе выражений, когда в приложении будет запущен этот код.
В этом случае сначала результатом выполнения выражения станет значение, однако, когда анимация по ключевым кадрам начнет анимировать свойство в наборе свойств, значение выражения также обновится, поскольку уравнение вычисляется для каждого кадра. В этом заключается удобство использования наборов свойств для работы с анимацией на основе выражений и анимацией по ключевым кадрам.

## <a name="manipulationpropertyset"></a>Набор свойств ManipulationPropertySet

Помимо использования наборов свойств композиции разработчики также могут работать с набором свойств ManipulationPropertySet, позволяющим осуществлять доступ к свойствам ScrollViewer для XAML. В дальнейшем эти свойства можно использовать в анимации с помощью выражений, а также устанавливать на них ссылки для описания более сложных видов взаимодействия с пользователем, таких как закрепленные заголовки и параллакс. Примечание. Вы можете выбрать ScrollViewer любого элемента управления XAML (ListView, GridView и т.д.), в котором есть содержимое с возможностью прокрутки, и использовать ScrollViewer для получения доступа к набору свойств ManipulationPropertySet таких прокручиваемых элементов управления.

В выражении можно устанавливать ссылки на следующие свойства средства прокрутки:

|Свойство| Тип|
|--------|-----|
|Translation (Преобразование)| Vector3 (Вектор 3)|
|Pan (Сдвиг)| Vector3 (Вектор 3)|
|Scale (Масштаб)| Vector3 (Вектор 3)|
|CenterPoint (Центральная точка)| Vector3 (Вектор 3)|
|Matrix (Матрица)| Matrix4x4 (Матрица 4 х 4)|

Чтобы получить ссылку на набор свойств ManipulationPropertySet, используйте метод GetScrollViewerManipulationPropertySet класса ElementCompositionPreview.

```csharp
CompositionPropertySet manipPropSet = ElementCompositionPreview.GetScrollViewerManipulationPropertySet(myScroller);
```

Получив ссылку на этот набор свойств, можно установить ссылки на свойства средства прокрутки, содержащиеся в этом наборе свойств. Сначала необходимо создать параметр ссылки.

```csharp
ExpressionAnimation exp = compositor.CreateExpressionAnimation();
exp.SetReferenceParameter("ScrollManipulation", manipPropSet);
```

После настройки параметра ссылки вы сможете устанавливать ссылки на свойства набора свойств ManipulationPropertySet в выражении.

```csharp
exp.Expression = “ScrollManipulation.Translation.Y / ScrollBounds”;
_target.StartAnimation(“Opacity”, exp);
```

## <a name="using-implicit-animations"></a>Работа с неявными анимациями

Анимации— это отличный способ описания поведения для пользователей. Существует несколько способов анимирования содержимого, однако при использовании всех описанных выше способов необходимо явным образом *запустить* анимацию. Несмотря на то, что это позволяет получить полный контроль над операцией определения начала анимации, процесс управления усложняется, когда требуется запуск анимации при каждом изменении значения свойства. Это происходить довольно часто, когда в приложениях стиль приложения, определяющий анимации, отделен от логики приложения, которая определяет основные компоненты и инфраструктуру приложения. С помощью неявных анимаций проще и удобнее определять анимацию отдельно от основной логики приложения. Выполнение анимаций можно привязывать к конкретным триггерам изменения свойств.

### <a name="setting-up-your-implicitanimationcollection"></a>Настройка объекта ImplicitAnimationCollection

Определение неявных анимаций выполняется с помощью других объектов **CompositionAnimation** (**KeyFrameAnimation** или **ExpressionAnimation**). Объект **ImplicitAnimationCollection** представляет собой набор объектов **CompositionAnimation**, запускаемых при срабатывании *триггера* изменения свойства. Обратите внимание, что при определении анимаций необходимо задать свойство **Target**, определяющее свойства объекта [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx), к которым будет применяться анимация после ее запуска. Свойство **Target** можно задавать только для свойств объекта класса [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx), поддерживающих анимацию.
В фрагменте кода ниже выполняется создание одиночной анимации **Vector3KeyFrameAnimation**, которая определяется как часть коллекции анимаций **ImplicitAnimationCollection**. Затем коллекция анимаций **ImplicitAnimationCollection** прикрепляется к свойству **ImplicitAnimation** объекта класса [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx), чтобы при срабатывании соответствующего триггера происходил запуск анимации.

```csharp
Vector3KeyFrameAnimation animation = _compositor.CreateVector3KeyFrameAnimation();
animation.DelayTime =  TimeSpan.FromMilliseconds(index);
animation.InsertExpressionKeyFrame(1.0f, "this.FinalValue");
animation.Target = "Offset";
ImplicitAnimationCollection implicitAnimationCollection = compositor.CreateImplicitAnimationCollection();

visual.ImplicitAnimations = implicitAnimationCollection;
```

### <a name="triggering-when-the-implicitanimation-starts"></a>Работа триггеров при запуске анимации ImplicitAnimation

Триггер— это термин, используемый для описания запуска анимации неявным образом. На данным момент триггеры представляют собой изменения, вносимые в любые поддерживающие анимацию свойства объекта класса [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx). Эти изменения происходят за счет явного задания свойства. Например, при размещении триггера **Offset** в коллекции **ImplicitAnimationCollection** и привязке к нему анимации изменения, вносимые в свойство **Offset** целевого объекта класса [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx), будут запускать анимацию нового значения с помощью анимации из этой коллекции.
В приведенном выше примере кода с целью назначения триггера свойству **Offset** целевого объекта класса [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx) добавлена дополнительная строка.

```csharp
implicitAnimationCollection["Offset"] = animation;
```

Обратите внимание, что у коллекции **ImplicitAnimationCollection** может быть несколько триггеров. Это значит, что неявная анимация или группа анимаций будут запускаться при изменении разных свойств. В приведенном выше примере кода разработчик может при необходимости добавить триггер для других свойств, таких как Opacity (Прозрачность).

### <a name="thisfinalvalue"></a>this.FinalValue

В первом примере, демонстрирующем создание неявной анимации, мы применили ключевой кадр выражения к ключевому кадру со значением "1.0" и назначили ему выражение **this.FinalValue**. **this.FinalValue**— это зарезервированное ключевое слово в языке выражений, обеспечивающее возможность разного поведения неявных анимаций. **this.FinalValue** привязывает набор значений в свойстве API к анимации. Это помогает создавать полноценные шаблоны. Использование **this.FinalValue** при создании явных анимаций является нецелесообразным, так как в этом случае свойство API задается мгновенно, в то время как при работе с неявными анимациями это свойство задается с задержкой.

## <a name="using-animation-groups"></a>Работа с группами анимаций

**CompositionAnimationGroup** позволяет без труда создавать группы анимаций, которые могут быть использованы вместе с неявными или явными анимациями.

### <a name="creating-and-populating-animation-groups"></a>Создание и заполнение групп анимаций

С помощью метода **CreateAnimationGroup** объекта Compositor вы можете создавать группу анимаций.

```sharp
CompositionAnimationGroup animationGroup = _compositor.CreateAnimationGroup();
animationGroup.Add(animationA);
animationGroup.Add(animationB);
```

После создания группы в нее можно добавлять отдельные анимации. Обратите внимание, что запускать отдельные анимации явным образом не требуется. Запуск этих анимаций будет выполняться при вызове метода **StartAnimationGroup** для явного сценария или при появлении триггера в неявном сценарии.
Примечание. У анимаций, добавляемых в группу, должно быть задано свойство **Target**. От этого зависит, какое свойство целевого объекта класса [Visual](https://msdn.microsoft.com/library/windows/apps/windows.ui.composition.visual.aspx) они будут анимировать.

### <a name="using-animation-groups-with-implicit-animations"></a>Использование группы анимаций с неявными анимациями

Вы можете создавать неявные анимации таким образом, чтобы при срабатывании триггера запускался набор анимаций в виде группы анимаций. В этом случае группу анимаций необходимо определить в виде набора анимаций, запускающегося при появлении триггера.

```csharp
implicitAnimationCollection["Offset"] = animationGroup;
```

### <a name="using-animation-groups-with-explicit-animations"></a>Использование группы анимаций с явными анимациями

Вы можете создавать явные анимации таким образом, чтобы при вызове метода **StartAnimationGroup** происходил запуск отдельных анимаций, добавленных в группу. Обратите внимание, что в вызове **StartAnimation** отсутствует целевое свойство группы, так как отдельные анимации могут быть нацелены на разные свойства. Убедитесь, что для каждой анимации задано целевое свойство.

```csharp
visual.StartAnimationGroup(AnimationGroup);
```

### <a name="e2e-sample"></a>Пример E2E

В примере кода ниже представлен процесс анимирования свойства Offset (Смещение) неявным образом при определении нового значения.

```csharp
class PropertyAnimation
{
    PropertyAnimation(Compositor compositor, SpriteVisual heroVisual, SpriteVisual listVisual)
    {
      // Define ImplicitAnimationCollection
        ImplicitAnimationCollection implicitAnimations =
        compositor.CreateImplicitAnimationCollection();

        // Trigger animation when the “Offset” property changes.
        implicitAnimations["Offset"] = CreateAnimation(compositor);

        // Assign ImplicitAnimations to a visual. Unlike Visual.Children,
        // ImplicitAnimations can be shared by multiple visuals so that they
        // share the same implicit animation behavior (same as Visual.Clip).
        heroVisual.ImplicitAnimations = implicitAnimations;

        // ImplicitAnimations can be shared among visuals
        listVisual.ImplicitAnimations = implicitAnimations;

        listVisual.Offset = new Vector3(20f, 20f, 20f);
    }

    Vector3KeyFrameAnimation CreateAnimation(Compositor compositor)
    {
        Vector3KeyFrameAnimation animation = compositor.CreateVector3KeyFrameAnimation();
        animation.InsertExpressionKeyFrame(0f, "this.StartingValue");
        animation.InsertExpressionKeyFrame(1f, "this.FinalValue");
        animation.Target = “Offset”;
        animation.Duration = TimeSpan.FromSeconds(0.25);
        return animation;
    }
}
```

## <a name="appendix"></a>Приложение

### <a name="expression-functions-by-structure-type"></a>Функции выражения по типу структуры

### <a name="scalar"></a>Scalar (Скаляр)

|Операции функций и конструкторов| Описание|
|-----------------------------------|--------------|
|Abs(Float value)| Возвращает число с плавающей точкой, представляющее собой абсолютное значение параметра Float|
|Clamp(Float value, Float min, Float max)| Возвращает число с плавающей точкой, которое больше чем min и меньше чем max или min, если значение меньше чем min или max, и если значение больше max|
|Max (Float value1, Float value2)| Возвращает большее число с плавающей точкой, находящееся между значением 1 и значением 2.|
|Min (Float value1, Float value2)| Возвращает меньшее число с плавающей точкой, находящееся между значением 1 и значением 2|
|Lerp(Float value1, Float value2, Float progress)| Возвращает число с плавающей точкой, которое представляет собой результат вычисления линейной интерполяции между двумя скалярными значениями с учетом значения состояния изменения ключевого кадра (Примечание. Значения от 0,0 до 1,0)|
|Slerp(Float value1, Float value2, Float progress)| Возвращает число с плавающей точкой, которое представляет собой результат вычисления сферической интерполяции между двумя значениями с плавающей точкой с учетом значения состояния изменения ключевого кадра (Примечание. Значения от 0,0 до 1,0)|
|Mod(Float value1, Float value2)| Возвращает остаток числа с плавающей точкой, являющийся результатом деления значения 1 и значения 2|
|Ceil(Float value)| Возвращает параметр Float, округленный до следующего большего целого числа|
|Floor(Float value)| Возвращает параметр Float, округленный до следующего меньшего целого числа|
|Sqrt(Float value)| Возвращает квадратный корень параметра Float|
|Square(Float value)| Возвращает квадратный корень параметра Float|
|Sin(Float value1)| Возвращает синус параметра Float|
|Asin(Float value2)| Возвращает арксинус параметра Float|
|Cos(Float value1)| Возвращает косинус параметра Float|
|ACos(Float value2)| Возвращает арккосинус параметра Float|
|Tan(Float value1)| Возвращает тангенс параметра Float|
|ATan(Float value2)| Возвращает арктангенс параметра Float|
|Round(Float value)| Возвращает параметр Float, округленный до ближайшего целого числа|
|Log10(Float value)| Возвращает результат логарифма (base 10) параметра Float|
|Ln(Float value)| Возвращает результат натурального логарифма параметра Float|
|Pow(Float value, Float power)| Возвращает результат параметра Float, возведенного в определенную степень|
|ToDegrees(Float radians)| Возвращает параметр Float, преобразованный в градусы|
|ToRadians(Float degrees)| Возвращает параметр Float, преобразованный в радианы|

### <a name="vector2"></a>Vector2

|Операции функций и конструкторов|Описание|
|-----------------------------------|--------------|
|Abs (Vector2 value)|Возвращает Vector2 с абсолютным значением, примененным к каждому компоненту|
|Clamp (Vector2 value1, Vector2 min, Vector2 max)|Возвращает Vector2, содержащий скрепленные значения для каждого соответствующего компонента|
|Max (Vector2 value1, Vector2 value2)|Возвращает Vector2, применивший функцию Max к каждому из соответствующих компонентов значения 1 и значения 2|
|Min (Vector2 value1, Vector2 value2)|Возвращает Vector2, применивший функцию Min к каждому из соответствующих компонентов значения 1 и значения 2|
|Scale(Vector2 value, Float factor)|Возвращает Vector2 с каждым компонентом вектора, умноженным на коэффициент масштабирования|
|Transform(Vector2 value, Matrix3x2 matrix)|Возвращает Vector2, являющийся результатом линейного преобразования между Vector2 и Matrix3x2 (то есть умножения вектора на матрицу)|
|Lerp(Vector2 value1, Vector2 value2, Float progress)|Возвращает Vector2, который представляет собой результат вычисления линейной интерполяции между двумя значениями Vector2 с учетом значения состояния изменения ключевого кадра (Примечание. Значения от 0,0 до 1,0)|
|Length(Vector2 value)|Возвращает число с плавающей точкой, представляющее собой длину/величину Vector2|
|LengthSquared(Vector2)|Возвращает число с плавающей точкой, представляющее собой квадрат длины/величины Vector2|
|Distance(Vector2 value1, Vector2 value2)|Возвращает число с плавающей точкой, представляющее собой расстояние между двумя значениями Vector2|
|DistanceSquared(Vector2 value1, Vector2 value2)|Возвращает число с плавающей точкой, представляющее собой квадрат расстояния между двумя значениями Vector2|
|Normalize(Vector2 value)|Возвращает Vector2, представляющий собой единичный вектор параметра, в котором все компоненты были нормализованы|
|Vector2(Float x, Float y)|Выполняет построение Vector2 с помощью двух параметров Float|

### <a name="vector3"></a>Vector3

|Операции функций и конструкторов|Описание|
|-----------------------------------|--------------|
|Abs (Vector3 value)|Возвращает Vector3 с абсолютным значением, примененным к каждому компоненту|
|Clamp (Vector3 value1, Vector3 min, Vector3 max)|Возвращает Vector3, содержащий скрепленные значения для каждого соответствующего компонента|
|Max (Vector3 value1, Vector3 value2)|Возвращает Vector3, применивший функцию Max к каждому из соответствующих компонентов значения 1 и значения 2|
|Min (Vector3 value1, Vector3 value2)|Возвращает Vector3, применивший функцию Min к каждому из соответствующих компонентов значения 1 и значения 2|
|Scale(Vector3 value, Float factor)|Возвращает Vector3 с каждым компонентом вектора, умноженным на коэффициент масштабирования|
|Lerp(Vector3 value1, Vector3 value2, Float progress)|Возвращает Vector3, который представляет собой результат вычисления линейной интерполяции между двумя значениями Vector3 с учетом значения состояния изменения ключевого кадра (Примечание. Значения от 0,0 до 1,0)|
|Length(Vector3 value)|Возвращает число с плавающей точкой, представляющее собой длину/величину Vector3|
|LengthSquared(Vector3)|Возвращает число с плавающей точкой, представляющее собой квадрат длины/величины Vector3|
|Distance(Vector3 value1, Vector3 value2)|Возвращает число с плавающей точкой, представляющее собой расстояние между двумя значениями Vector3|
|DistanceSquared(Vector3 value1, Vector3 value2)|Возвращает число с плавающей точкой, представляющее собой квадрат расстояния между двумя значениями Vector3|
|Normalize(Vector3 value)|Возвращает Vector3, представляющий собой единичный вектор параметра, в котором все компоненты были нормализованы|
|Vector3(Float x, Float y, Float z)|Выполняет построение Vector3 с помощью трех параметров Float|

### <a name="vector4"></a>Vector4

|Операции функций и конструкторов|Описание|
|-----------------------------------|--------------|
|Abs (Vector4 value)|Возвращает Vector4 с абсолютным значением, примененным к каждому компоненту|
|Clamp (Vector4 value1, Vector4 min, Vector4 max)|Возвращает Vector4, содержащий скрепленные значения для каждого соответствующего компонента|
|Max (Vector4 value1 Vector4 value2)|Возвращает Vector4, применивший функцию Max к каждому из соответствующих компонентов значения 1 и значения 2|
|Min (Vector4 value1 Vector4 value2)|Возвращает Vector4, применивший функцию Min к каждому из соответствующих компонентов значения 1 и значения 2|
|Scale(Vector3 value, Float factor)|Возвращает Vector3 с каждым компонентом вектора, умноженным на коэффициент масштабирования|
|Transform(Vector4 value, Matrix4x4 matrix)|Возвращает Vector4, являющийся результатом линейного преобразования между Vector4 и Matrix4x4 (то есть умножения вектора на матрицу)|
|Lerp(Vector4 value1, Vector4 value2, Float progress)|Возвращает Vector4, который представляет собой результат вычисления линейной интерполяции между двумя значениями Vector4 с учетом значения состояния изменения ключевого кадра (Примечание. Значения от 0,0 до 1,0)|
|Length(Vector4 value)|Возвращает число с плавающей точкой, представляющее собой длину/величину Vector4|
|LengthSquared(Vector4)|Возвращает число с плавающей точкой, представляющее собой квадрат длины/величины Vector4|
|Distance(Vector4 value1, Vector4 value2)|Возвращает число с плавающей точкой, представляющее собой расстояние между двумя значениями Vector4|
|DistanceSquared(Vector4 value1, Vector4 value2)|Возвращает число с плавающей точкой, представляющее собой квадрат расстояния между двумя значениями Vector4|
|Normalize(Vector4 value)|Возвращает Vector4, представляющий собой единичный вектор параметра, в котором все компоненты были нормализованы|
|Vector4(Float x, Float y, Float z, Float w)|Выполняет построение Vector4 с помощью четырех параметров Float|

### <a name="matrix3x2"></a>Matrix3x2

|Операции функций и конструкторов|   Описание|
|-----------------------------------|--------------|
|Scale(Matrix3x2 value, Float factor)|  Возвращает Matrix3x2 с каждым компонентом матрицы, умноженным на коэффициент масштабирования|
|Inverse(Matrix 3x2 value)| Возвращает объект Matrix3x2, представляющий собой обратную матрицу|
|Matrix3x2(Float M11, Float M12, Float M21, Float M22, Float M31, Float M32)|   Выполняет построение Matrix3x2 с помощью шести параметров Float|
|Matrix3x2.CreateFromScale(Vector2 scale)|  Выполняет построение Matrix3x2 из Vector2, представляющего собой масштаб<br/>\[scale.X, 0,0<br/> 0,0, scale.Y<br/> 0,0, 0,0 \]|
|Matrix3x2.CreateFromTranslation(Vector2 translation)|  Выполняет построение Matrix3x2 из Vector2, представляющего собой преобразование<br/>\[1,0, 0,0,<br/> 0,0, 1,0,<br/> translation.X, translation.Y\]|
|Matrix3x2.CreateSkew(Float x, Float y, Vector2 centerpoint)| Выполняет построение Matrix3x2 с помощью двух параметров Float и одного Vector2, представляющего собой наклон<br/>\[1,0, Tan(y),<br/>Tan(x), 1,0,<br/>-centerpoint.Y * Tan(x), -centerpoint.X * Tan(y)\]|
|Matrix3x2.CreateRotation(Float radians)| Выполняет построение Matrix3x2 с помощью поворота в радианах<br/>\[Cos(radians), Sin(radians),<br/>-Sin(radians), Cos(radians),<br/>0,0, 0,0 \]|
|Matrix3x2.CreateTranslation(Vector2 translation)| Аналогично операции CreateFromTranslation|
|Matrix3x2.CreateScale(Vector2 scale)| Аналогично операции CreateFromScale|


### <a name="matrix4x4"></a>Matrix4x4

|Операции функций и конструкторов|   Описание|
|-----------------------------------|--------------|
|Scale(Matrix4x4 value, Float factor)|  Возвращает Matrix 4x4 с каждым компонентом матрицы, умноженным на коэффициент масштабирования|
|Inverse(Matrix4x4)|    Возвращает объект Matrix4x4, представляющий собой обратную матрицу|
|Matrix4x4(Float M11, Float M12, Float M13, Float M14,<br/>Float M21, Float M22, Float M23, Float M24,<br/>    Float M31, Float M32, Float M33, Float M34,<br/>    Float M41, Float M42, Float M43, Float M44)| Выполняет построение Matrix4x4 с помощью шестнадцати параметров Float|
|Matrix4x4.CreateFromScale(Vector3 scale)|  Выполняет построение Matrix4x4 из Vector3, представляющего собой масштаб<br/>\[scale.X, 0,0, 0,0, 0,0,<br/> 0,0, scale.Y, 0,0, 0,0,<br/> 0,0, 0,0, scale.Z, 0,0,<br/> 0,0, 0,0, 0,0, 1,0\]|
|Matrix4x4.CreateFromTranslation(Vector3 translation)|  Выполняет построение Matrix4x4 из Vector3, представляющего собой преобразование<br/>\[1,0, 0,0, 0,0, 0,0,<br/> 0,0, 1,0, 0,0, 0,0,<br/> 0,0, 0,0, 1,0, 0,0,<br/> translation.X, translation.Y, translation.Z, 1,0\]|
|Matrix4x4.CreateFromAxisAngle(Vector3 axis, Float angle)|  Выполняет построение Matrix4x4 из оси Vector3 и параметра Float, представляющего собой угол|
|Matrix4x4(Matrix3x2 matrix)| Выполняет построение Matrix4x4 с помощью Matrix3x2<br/>\[matrix.11, matrix.12, 0, 0,<br/>matrix.21, matrix.22, 0, 0,<br/>0, 0, 1, 0,<br/>matrix.31, matrix.32, 0, 1\]|
|Matrix4x4.CreateTranslation(Vector3 translation)| Аналогично операции CreateFromTranslation|
|Matrix4x4.CreateScale(Vector3 scale)| Аналогично операции CreateFromScale|


### <a name="quaternion"></a>Quaternion

|Операции функций и конструкторов|   Описание|
|-----------------------------------|--------------|
|Slerp(Quaternion value1, Quaternion value2, Float progress)|   Возвращает кватернион, который представляет собой результат вычисления сферической интерполяции между двумя значениями кватерниона с учетом значения состояния изменения ключевого кадра (Примечание. Значения от 0,0 до 1,0)|
|Concatenate(Quaternion value1 Quaternion value2)|  Возвращает кватернион, представляющий собой объединение двух кватернионов (то есть кватернион, представляющий собой сочетание двух отдельных вращений)|
|Length(Quaternion value)|  Возвращает число с плавающей точкой, представляющее собой длину/величину кватерниона.|
|LengthSquared(Quaternion)| Возвращает число с плавающей точкой, представляющее собой квадрат длины/величины кватерниона|
|Normalize(Quaternion value)|   Возвращает кватернион с нормализированными компонентами|
|Quaternion.CreateFromAxisAngle(Vector3 axis, Scalar angle)|    Выполняет построение кватерниона из оси Vector3 и параметра Scalar, представляющего собой угол|
|Quaternion(Float x, Float y, Float z, Float w)|    Выполняет построение кватерниона из четырех чисел с плавающей точкой|

### <a name="color"></a>Color

|Операции функций и конструкторов|   Описание|
|-----------------------------------|--------------|
|ColorLerp(Color colorTo, Color colorFrom, Float progress)| Возвращает объект Color, представляющий собой результат вычисления линейной интерполяции между двумя объектами цвета с учетом значения состояния изменения ключевого кадра (Примечание. Значения от 0,0 до 1,0)|
|ColorLerpRGB(Color colorTo, Color colorFrom, Float progress)|  Возвращает объект Color, представляющий собой результат вычисления линейной интерполяции между двумя объектами с учетом значения состояния изменения ключевого кадра в цветовом пространстве RGB|
|ColorLerpHSL(Color colorTo, Color colorFrom, Float progress)|  Возвращает объект Color, представляющий собой результат вычисления линейной интерполяции между двумя объектами с учетом значения состояния изменения ключевого кадра в цветовом пространстве HSL|
|ColorArgb(Float a, Float r, Float g, Float b)| Выполняет построение объекта, представляющего собой цвет, задаваемый компонентами ARGB|
|ColorHsl(Float h, Float s, Float l)|   Выполняет построение объекта, представляющего собой цвет, определяемый компонентами HSL (Примечание. Оттенок задается значениями от 0 до 2pi)|

