---
author: normesta
Description: "В этой статье рассказывается, что необходимо знать перед преобразованием приложения в приложение UWP с помощью Desktop Bridge. Подготовка приложения к процессу преобразования, как правило, не требует больших усилий."
Search.Product: eADQiWindows 10XVcnh
title: "Мост переноса классических приложений на UWP: подготовка"
ms.author: normesta
ms.date: 03/09/2017
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp
ms.assetid: 71a57ca2-ca00-471d-8ad9-52f285f3022e
ms.openlocfilehash: 1f18efd5738d357ee88b481c65fc02f503afb703
ms.sourcegitcommit: 909d859a0f11981a8d1beac0da35f779786a6889
translationtype: HT
---
# <a name="desktop-to-uwp-bridge-prepare"></a>Мост переноса классических приложений на UWP: подготовка

В этой статье рассказывается, что необходимо знать перед преобразованием приложения с помощью моста переноса классических приложений на UWP. Подготовка приложения к процессу преобразования, как правило, не требует больших усилий. Однако если что-либо из перечисленного ниже относится к вашему приложению, необходимо устранить проблему, прежде чем приступать к преобразованию. Не забывайте, что лицензирование и автоматическое обновление вашего приложения обеспечивается Магазином Windows, поэтому эти возможности можно исключить из вашей базы кода.

+ __Приложение использует версию .NET ниже, чем 4.6.1__. Поддерживается только .NET версии 4.6.1. Перед преобразованием приложение необходимо настроить для работы с .NET 4.6.1.

+ __Ваше приложение всегда запускается с повышенными привилегиями безопасности__. Ваше приложение должно работать при его выполнении в качестве текущего пользователя. Пользователи, устанавливающие ваше приложение из Магазина Windows, могут не являться системными администраторами, поэтому необходимость выполнения вашего приложения с более высокими привилегиями означает, что оно будет работать неправильно для обычных пользователей.

+ __Вашему приложению нужен драйвер, работающий в режиме ядра, или служба Windows__. Мост подходит для приложения, но он не поддерживает драйвер, работающий в режиме ядра, или службу Windows, которая должна работать с правами учетной записи системы. Вместо службы Windows используйте [фоновую задачу](https://msdn.microsoft.com/windows/uwp/launch-resume/create-and-register-a-background-task).

+ __Модули вашего приложения загружаются во внутрипроцессном режиме в процессы, которые отсутствуют в пакете приложения для Windows. Это запрещено и означает, что внутрипроцессные расширения, такие как [расширения оболочки](https://msdn.microsoft.com/library/windows/desktop/dd758089.aspx), не поддерживаются. Но если у вас есть два приложения в одинаковом пакете, вы можете настроить межпроцессное взаимодействие между ними.

+ __Ваше приложение вызывает [SetDllDirectory](https://msdn.microsoft.com/library/windows/desktop/ms686203) или [AddDllDirectory](https://msdn.microsoft.com/library/windows/desktop/hh310513)__. В настоящее время эти функции не поддерживаются для преобразованных приложений. Мы работаем над тем, чтобы добавить поддержку в дальнейших выпусках. В качестве обходного пути вы можете скопировать все DLL-файлы, которые вы искали с помощью этих функций, в корневой каталог пакета.

+ __Ваше приложение использует пользовательский идентификатор пользовательской модели (AUMID) приложения__. Если ваш процесс вызывает элемент [SetCurrentProcessExplicitAppUserModelID](https://msdn.microsoft.com/library/windows/desktop/dd378422.aspx), чтобы задать собственный AUMID, то этот процесс может использовать только тот AUMID, который был сформирован для него средой модели приложения/ пакетом приложения для Windows. Вы не можете определять пользовательские AUMID.

+ __Ваше приложение изменяет куст реестра HKEY_LOCAL_MACHINE (HKLM)__. Любая попытка приложения создать ключ HKLM или открыть такой ключ для изменения в результате приведет к сбою в виде отказа в доступе. Не забывайте, что у вашего приложения есть собственное закрытое виртуализированное представление реестра, поэтому в такой ситуации понятие куста реестра на уровне пользователя и компьютера (чем является HKLM) неприменимо. Потребуется найти другой способ достичь того, чего требовалось при использовании HKLM, например запись в HKEY_CURRENT_USER (HKCU).

+ __Ваше приложение использует подраздел реестра ddeexec в качестве средства для запуска другого приложения__. Вместо этого используйте один из обработчиков команды DelegateExecute в соответствии с настройками различных расширений Activatable* в вашем [манифесте пакета приложения](https://msdn.microsoft.com/library/windows/apps/br211474.aspx).

+ __Ваше приложение выполняет запись в папку AppData с намерением поделиться данными с другим приложением__. После преобразования AppData перенаправляется в локальное хранилище данных приложения, являющееся частным хранилищем для каждого приложения UWP. Используйте другие средства межпроцессного обмена данными. Подробнее: [Хранение и извлечение параметров и прочих данных приложения](https://msdn.microsoft.com/windows/uwp/app-settings/store-and-retrieve-app-data).

+ __Ваше приложение выполняет запись в папку установки приложения__. Например, ваше приложение выполняет запись в файл журнала, который вы поместили в тот же каталог, что и файл exe. Эта операция не поддерживается, поэтому потребуется найти другое расположение, например, локальное хранилище данных приложения.

+ __Для установки приложения требуется участие пользователя__. Ваш установщик приложений должен запускаться в автоматическом режиме, а также устанавливать все свои дополнительные компоненты, которые не активированы по умолчанию в чистом образе ОС.

+ __Ваше приложение использует Current Working Directory (текущий рабочий каталог)__. Во время выполнения ваше преобразованное приложение не получит тот же рабочий каталог, который был ранее указан для вашего ярлыка .LNK на рабочем столе. Необходимо изменить CWD во время выполнения, если у вашего приложения должен быть правильный каталог, чтобы оно работало должным образом.

+ __Ваше приложение запрашивает доступ UIAccess__. Если приложение задает значение `UIAccess=true` элементу `requestedExecutionLevel` манифеста UAC, то преобразование в UWP не поддерживается на данный момент. Подробнее см. в разделе [Обзор системы безопасности модели автоматизации пользовательского интерфейса](https://msdn.microsoft.com/library/ms742884.aspx).

+ __Приложение предоставляет объекты модели COM или сборки GAC для использования другими процессами__. В текущем выпуске приложение не может предоставлять объекты модели COM или сборки GAC для использования процессами, возникающими в результате запуска исполняемых файлов, которые являются внешними по отношению к пакету приложения для Windows. Процессы из пакета могут регистрировать и использовать объекты модели COM и сборки GAC обычным образом, но они не будут видны извне. Это означает, что сценарии межпрограммного взаимодействия (например, OLE) не будут работать при их вызове внешними процессами.

+ __Приложение связывается с библиотеками времени выполнения C (CRT) неподдерживаемым способом__. Библиотека времени выполнения C/C++ Майкрософт предоставляет процедуры для программирования в среде операционной системы Microsoft Windows. Эти процедуры автоматизируют выполнение многих распространенных задач программирования, которые не предоставляются языками C и C++. Если ваше приложение использует библиотеку среды выполнения C/C++, необходимо убедиться, что она связана поддерживаемом способом.

    Visual Studio 2015 поддерживает как динамическое связывание, чтобы код мог использовать общие файлы DLL, так и статическое связывание для связывания библиотеки непосредственно с кодом, до текущей версии CRT. По возможности мы рекомендуем использовать в приложениях динамическое связывание Visual Studio 2015.

    Поддержка различных типов связывания зависит от версии Visual Studio. Подробности см. в следующей таблице:

    <table>
    <th>Версия Visual Studio</td><th>Динамическое связывание</th><th>Статическое связывание</th></th>
    <tr><td>2005 (VC 8)</td><td>Не поддерживается</td><td>Поддерживается</td>
    <tr><td>2008 (VC 9)</td><td>Не поддерживается</td><td>Поддерживается</td>
    <tr><td>2010 (VC 10)</td><td>Поддерживается</td><td>Поддерживается</td>
    <tr><td>2012 (VC 11)</td><td>Поддерживается</td><td>Не поддерживается</td>
    <tr><td>2013 (VC 12)</td><td>Поддерживается</td><td>Не поддерживается</td>
    <tr><td>2015 (VC 14)</td><td>Поддерживается</td><td>Поддерживается</td>
    </table>

    Примечание. Во всех случаях связывание необходимо выполнять с самой последней общедоступной библиотекой CRT.

+ __Приложение устанавливает и загружает сборки из параллельной папки Windows (SxS)__. Например, в вашем приложении используются библиотеки времени выполнения C VC8 или VC9 и они динамически подключаются из папки Windows SxS, то есть в коде используются общие файлы DLL из общей папки. Такой способ связывания не поддерживается. Необходимо подключать их статически, то есть связать с распространяемыми файлами библиотеки непосредственно в самом коде.

+ __Ваше приложение использует зависимость в папке System32/SysWOW64__. Чтобы эти DLL-файлы начали работать, необходимо включить их в часть вашего пакета приложения для Windows, находящуюся в виртуальной файловой системе. Это гарантирует, что приложение будет работать так, как если бы DLL-файлы были установлены в папке **System32**/**SysWOW64**. В корне пакета создайте папку с именем **VFS**. В этой папке создайте папки **SystemX64** и **SystemX86**. Затем поместите 32-разрядную версию DLL-файла в папку **SystemX86**, а 64-разрядную версию— в папку **SystemX64**.

+ __Ваше приложение использует пакет платформы Dev11 VCLibs__. Библиотеки VCLibs 11 можно установить напрямую из Магазина Windows, если они определены как зависимость в пакете приложения для Windows. Для этого внесите следующее изменение в манифест вашего пакета приложения. В узле `<Dependencies>` добавьте:  
`<PackageDependency Name="Microsoft.VCLibs.110.00.UWPDesktop" MinVersion="11.0.24217.0" Publisher="CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US" />`  
Во время установки из Магазина Windows будет установлена нужная версия (x86 или x64) платформы VCLibs 11 перед установкой приложения.  
Зависимости не будут установлены в случае установки путем загрузки неопубликованного приложения. Чтобы установить зависимости на компьютере вручную, вам потребуется скачать и установить [пакеты платформы VC 11.0 для моста для настольных компьютеров](https://www.microsoft.com/download/details.aspx?id=53340&WT.mc_id=DX_MVP4025064). Подробнее об этих сценариях см. в разделе [Использование среды выполнения Visual C++ в проекте Centennial](https://blogs.msdn.microsoft.com/vcblog/2016/07/07/using-visual-c-runtime-in-centennial-project/).

+ __Ваше приложение содержит настраиваемый список переходов__. Списки переходов следует использовать с учетом некоторых оговорок и условий.

    - __Архитектура вашего приложения не соответствует операционной системе.__  На текущий момент списки переходов работают неверно при несоответствии архитектур приложения и операционной системы (например, при запуске приложения x86 в Windows x64). На текущий момент единственное решение— перекомпиляция приложения с использованием соответствующей архитектуры.

    - __Ваше приложение создает элементы списка переходов и вызовы [ICustomDestinationList::SetAppID](https://msdn.microsoft.com/library/windows/desktop/dd378403(v=vs.85).aspx) или [SetCurrentProcessExplicitAppUserModelID](https://msdn.microsoft.com/library/windows/desktop/dd378422(v=vs.85).aspx)__. Не задавайте свой AppID в коде программными средствами. Это приведет к тому, что элементы списка переходов не будут отображаться. Если вашему приложению требуется пользовательский идентификатор, укажите это с помощью файла манифеста. Инструкции см. в разделе [Ручное преобразование приложения в приложение UWP с помощью Desktop Bridge](desktop-to-uwp-manual-conversion.md). AppID для вашего приложения указан в разделе *YOUR_PRAID_HERE*.

    - __Ваше приложение добавляет ссылку на оболочку списка переходов, которая ссылается на исполняемый элемент в пакете__. Напрямую запускать исполняемые файлы в пакете из списка переходов нельзя (за исключением абсолютного пути собственного файла .exe приложения). Вместо этого зарегистрируйте псевдоним выполнения приложения (который позволит вашему преобразованному приложению запускаться через ключевое слово, как будто оно находится в PATH) и задайте в качестве целевого пути ссылки путь к этому псевдониму. Дополнительные сведения о том, как использовать расширение appExecutionAlias, см. в разделе [Расширение возможностей приложений, преобразованных с помощью Desktop Bridge](desktop-to-uwp-extensions.md). Обратите внимание, что если требуется, чтобы ресурсы ссылки в списке переходов совпадали с исходным файлом .exe, необходимо задать ресурсы, такие как значок, используя [**SetIconLocation**](https://msdn.microsoft.com/library/windows/desktop/bb761047(v=vs.85).aspx), а для отображения имени использовать PKEY_Title, так же, как и для других пользовательских записей.

    - __Ваше приложение добавляет элементы списка переходов, которые ссылаются на ресурсы в пакете приложения по абсолютному пути__. Путь установки приложения может измениться при обновлении пакетов, изменении расположения ресурсов (например, значков, документов, исполняемых файлов и т. д.). Если элементы списка переходов ссылаются на такие ресурсы по абсолютным путям, то приложение должно периодически обновлять свой список переходов (например, при запуске приложения) для обеспечения правильности путей. Либо можно использовать API-интерфейсы UWP [**Windows.UI.StartScreen.JumpList**](https://msdn.microsoft.com/library/windows/apps/windows.ui.startscreen.jumplist.aspx), которые позволяют ссылаться на ресурсы строк и изображений с помощью схемы URI package-relative ms-resource (которая также поддерживает определение языка, DPI и высокой контрастности).
