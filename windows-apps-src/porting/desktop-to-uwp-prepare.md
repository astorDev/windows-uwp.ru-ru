---
author: normesta
Description: "В этой статье рассказывается, что необходимо знать перед упаковкой приложения с помощью моста для классических приложений. Подготовка приложения к процессу упаковки, как правило, не требует больших усилий."
Search.Product: eADQiWindows 10XVcnh
title: "Подготовка приложения к упаковке (мост для классических приложений)"
ms.author: normesta
ms.date: 05/25/2017
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp
ms.assetid: 71a57ca2-ca00-471d-8ad9-52f285f3022e
ms.openlocfilehash: f7337ee7bf78730e2300a11d7d606f328c7c418b
ms.sourcegitcommit: 77bbd060f9253f2b03f0b9d74954c187bceb4a30
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2017
---
# <a name="prepare-to-package-an-app-desktop-bridge"></a>Подготовка приложения к упаковке (мост для классических приложений)

В этой статье рассказывается, что необходимо знать перед упаковкой классического приложения. Подготовка приложения к процессу упаковки, как правило, не требует больших усилий. Однако если что-либо из перечисленного ниже относится к вашему приложению, необходимо устранить проблему, прежде чем приступать к упаковке. Не забывайте, что лицензирование и автоматическое обновление вашего приложения обеспечивается Магазином Windows, поэтому любые возможности, относящиеся к этим задачам, можно исключить из вашей базы кода.

+ __Приложение использует версию .NET ниже, чем 4.6.1__. Поддерживается только .NET версии 4.6.1. Перед упаковкой приложение необходимо перенацелить для работы с .NET 4.6.1.

+ __Ваше приложение всегда запускается с повышенными привилегиями безопасности__. Ваше приложение должно работать при его выполнении в качестве текущего пользователя. Пользователи, устанавливающие ваше приложение из Магазина Windows, могут не являться системными администраторами, поэтому необходимость выполнения вашего приложения с более высокими привилегиями означает, что оно будет работать неправильно для обычных пользователей.

+ __Вашему приложению нужен драйвер, работающий в режиме ядра, или служба Windows__. Мост подходит для приложения, но он не поддерживает драйвер, работающий в режиме ядра, или службу Windows, которая должна работать с правами учетной записи системы. Вместо службы Windows используйте [фоновую задачу](https://msdn.microsoft.com/windows/uwp/launch-resume/create-and-register-a-background-task).

+ __Модули вашего приложения загружаются во внутрипроцессном режиме в процессы, которые отсутствуют в пакете приложения для Windows__. Это запрещено и означает, что внутрипроцессные расширения, такие как [расширения оболочки](https://msdn.microsoft.com/library/windows/desktop/dd758089.aspx), не поддерживаются. Но если у вас есть два приложения в одинаковом пакете, вы можете настроить межпроцессное взаимодействие между ними.

+ __Приложение использует идентификатор модели пользователя приложения (AUMID)__. Если ваш процесс вызывает элемент [SetCurrentProcessExplicitAppUserModelID](https://msdn.microsoft.com/library/windows/desktop/dd378422.aspx), чтобы задать собственный AUMID, то этот процесс может использовать только тот AUMID, который был сформирован для него средой модели приложения/ пакетом приложения для Windows. Вы не можете определять пользовательские AUMID.

+ __Ваше приложение изменяет куст реестра HKEY_LOCAL_MACHINE (HKLM)__. Любая попытка приложения создать ключ HKLM или открыть такой ключ для изменения в результате приведет к сбою в виде отказа в доступе. Не забывайте, что у вашего приложения есть собственное закрытое виртуализированное представление реестра, поэтому в такой ситуации понятие куста реестра на уровне пользователя и компьютера (чем является HKLM) неприменимо. Потребуется найти другой способ достичь того, чего требовалось при использовании HKLM, например запись в HKEY_CURRENT_USER (HKCU).

+ __Ваше приложение использует подраздел реестра ddeexec в качестве средства для запуска другого приложения__. Вместо этого используйте один из обработчиков команды DelegateExecute в соответствии с настройками различных расширений Activatable* в вашем [манифесте пакета приложения](https://msdn.microsoft.com/library/windows/apps/br211474.aspx).

+ __Ваше приложение выполняет запись в папку AppData или в реестр с намерением поделиться данными с другим приложением__. После преобразования AppData перенаправляется в локальное хранилище данных приложения, являющееся частным хранилищем для каждого приложения UWP.

  Все записи, которые ваше приложение вносит в куст реестра HKEY_LOCAL_MACHINE, перенаправляются в изолированный двоичный файл, а все записи, которые ваше приложение вносит в куст реестра HKEY_CURRENT_USER, помещаются в отдельное для каждого пользователя и каждого приложения расположение. Дополнительные сведения о перенаправлении файлов и реестра см. в разделе [Как работает мост для классических приложений](desktop-to-uwp-behind-the-scenes.md).  

  Используйте другие средства межпроцессного обмена данными. Подробнее: [Хранение и извлечение параметров и прочих данных приложения](https://msdn.microsoft.com/windows/uwp/app-settings/store-and-retrieve-app-data).

+ __Ваше приложение выполняет запись в папку установки приложения__. Например, ваше приложение выполняет запись в файл журнала, который вы поместили в тот же каталог, что и файл exe. Эта операция не поддерживается, поэтому потребуется найти другое расположение, например, локальное хранилище данных приложения.

+ __Для установки приложения требуется участие пользователя__. Ваш установщик приложений должен запускаться в автоматическом режиме, а также устанавливать все свои дополнительные компоненты, которые не активированы по умолчанию в чистом образе ОС.

+ __Ваше приложение использует Current Working Directory (текущий рабочий каталог)__. Во время выполнения ваше упакованное классическое приложение не получит тот же рабочий каталог, который был ранее указан для вашего ярлыка .LNK на рабочем столе. Необходимо изменить CWD во время выполнения, если у вашего приложения должен быть правильный каталог, чтобы оно работало должным образом.

+ __Ваше приложение запрашивает доступ UIAccess__. Если приложение задает значение `UIAccess=true` элементу `requestedExecutionLevel` манифеста UAC, то преобразование в UWP не поддерживается на данный момент. Подробнее см. в разделе [Обзор системы безопасности модели автоматизации пользовательского интерфейса](https://msdn.microsoft.com/library/ms742884.aspx).

+ __Приложение предоставляет объекты модели COM__. Процессы и расширения из пакета могут регистрировать и использовать серверы COM и OLE, как внутрипроцессные, так и внепроцессные (OOP).  Creators Update добавляет поддержку технологии Packaged COM, позволяющей регистрировать серверы OOP COM и OLE, которые видимы за пределами пакета.  См. раздел [Поддержка сервера COM и документа OLE для моста для классических приложений](https://blogs.windows.com/buildingapps/2017/04/13/com-server-ole-document-support-desktop-bridge/#bjPyETFgtpZBGrS1.97).

   Технология Packaged COM поддерживает работу с существующими API модели COM, но не будет работать для расширений приложения, которые зависят от чтения реестра напрямую, так как расположение для Packaged COM находится в частном расположении.

+ __Приложение разрешает другим процессам использовать сборки GAC__. В текущем выпуске приложение не может предоставлять сборки GAC для использования процессами, возникающими в результате запуска исполняемых файлов, которые являются внешними по отношению к пакету приложения для Windows. Процессы из пакета могут регистрировать и использовать сборки GAC обычным образом, но они не будут видны извне. Это означает, что сценарии межпрограммного взаимодействия (например, OLE) не будут работать при их вызове внешними процессами.

+ __Приложение связывается с библиотеками времени выполнения C (CRT) неподдерживаемым способом__. Библиотека времени выполнения C/C++ Майкрософт предоставляет процедуры для программирования в среде операционной системы Microsoft Windows. Эти процедуры автоматизируют выполнение многих распространенных задач программирования, которые не предоставляются языками C и C++. Если ваше приложение использует библиотеку среды выполнения C/C++, необходимо убедиться, что она связана поддерживаемом способом.

    Visual Studio 2015 поддерживает как динамическое связывание, чтобы код мог использовать общие файлы DLL, так и статическое связывание для связывания библиотеки непосредственно с кодом, до текущей версии CRT. По возможности мы рекомендуем использовать в приложениях динамическое связывание Visual Studio 2015.

    Поддержка различных типов связывания зависит от версии Visual Studio. Подробности см. в следующей таблице:

    <table>
    <th>Версия Visual Studio</td><th>Динамическое связывание</th><th>Статическое связывание</th></th>
    <tr><td>2005 (VC 8)</td><td>Не поддерживается</td><td>Поддерживается</td>
    <tr><td>2008 (VC 9)</td><td>Не поддерживается</td><td>Поддерживается</td>
    <tr><td>2010 (VC 10)</td><td>Поддерживается</td><td>Поддерживается</td>
    <tr><td>2012 (VC 11)</td><td>Поддерживается</td><td>Не поддерживается</td>
    <tr><td>2013 (VC 12)</td><td>Поддерживается</td><td>Не поддерживается</td>
    <tr><td>2015 (VC 14)</td><td>Поддерживается</td><td>Поддерживается</td>
    </table>

    Примечание. Во всех случаях связывание необходимо выполнять с самой последней общедоступной библиотекой CRT.

+ __Приложение устанавливает и загружает сборки из параллельной папки Windows (SxS)__. Например, в вашем приложении используются библиотеки времени выполнения C VC8 или VC9 и они динамически подключаются из папки Windows SxS, то есть в коде используются общие файлы DLL из общей папки. Такой способ связывания не поддерживается. Необходимо подключать их статически, то есть связать с распространяемыми файлами библиотеки непосредственно в самом коде.

+ __Ваше приложение использует зависимость в папке System32/SysWOW64__. Чтобы эти DLL-файлы начали работать, необходимо включить их в часть вашего пакета приложения для Windows, находящуюся в виртуальной файловой системе. Это гарантирует, что приложение будет работать так, как если бы DLL-файлы были установлены в папке **System32**/**SysWOW64**. В корне пакета создайте папку с именем **VFS**. В этой папке создайте папки **SystemX64** и **SystemX86**. Затем поместите 32-разрядную версию DLL-файла в папку **SystemX86**, а 64-разрядную версию— в папку **SystemX64**.

+ __Ваше приложение использует пакет платформы Dev11 VCLibs__. Библиотеки VCLibs 11 можно установить напрямую из Магазина Windows, если они определены как зависимость в пакете приложения для Windows. Для этого внесите следующее изменение в манифест вашего пакета приложения. В узле `<Dependencies>` добавьте:  
`<PackageDependency Name="Microsoft.VCLibs.110.00.UWPDesktop" MinVersion="11.0.24217.0" Publisher="CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US" />`  
Во время установки из Магазина Windows будет установлена нужная версия (x86 или x64) платформы VCLibs 11 перед установкой приложения.  
Зависимости не будут установлены в случае установки путем загрузки неопубликованного приложения. Чтобы установить зависимости на компьютере вручную, вам потребуется скачать и установить [пакеты платформы VC 11.0 для моста для настольных компьютеров](https://www.microsoft.com/download/details.aspx?id=53340&WT.mc_id=DX_MVP4025064). Подробнее об этих сценариях см. в разделе [Использование среды выполнения Visual C++ в проекте Centennial](https://blogs.msdn.microsoft.com/vcblog/2016/07/07/using-visual-c-runtime-in-centennial-project/).

+ __Ваше приложение содержит настраиваемый список переходов__. Списки переходов следует использовать с учетом некоторых оговорок и условий.

    - __Архитектура вашего приложения не соответствует операционной системе.__  На текущий момент списки переходов работают неверно при несоответствии архитектур приложения и операционной системы (например, при запуске приложения x86 в Windows x64). На текущий момент единственное решение— перекомпиляция приложения с использованием соответствующей архитектуры.

    - __Ваше приложение создает элементы списка переходов и вызовы [ICustomDestinationList::SetAppID](https://msdn.microsoft.com/library/windows/desktop/dd378403(v=vs.85).aspx) или [SetCurrentProcessExplicitAppUserModelID](https://msdn.microsoft.com/library/windows/desktop/dd378422(v=vs.85).aspx)__. Не задавайте свой AppID в коде программными средствами. Это приведет к тому, что элементы списка переходов не будут отображаться. Если вашему приложению требуется пользовательский идентификатор, укажите это с помощью файла манифеста. См. указания в разделе [Упаковка приложения вручную (мост для классических приложений)](desktop-to-uwp-manual-conversion.md). AppID для вашего приложения указан в разделе *YOUR_PRAID_HERE*.

    - __Ваше приложение добавляет ссылку на оболочку списка переходов, которая ссылается на исполняемый элемент в пакете__. Напрямую запускать исполняемые файлы в пакете из списка переходов нельзя (за исключением абсолютного пути собственного файла .exe приложения). Вместо этого зарегистрируйте псевдоним выполнения приложения (который позволит вашему упакованному приложению запускаться через ключевое слово, как будто оно находится в PATH) и задайте в качестве целевого пути ссылки путь к этому псевдониму. Дополнительные сведения об использовании расширения appExecutionAlias см. в разделе [Интеграция приложения с Windows 10 (мост для классических приложений)](desktop-to-uwp-extensions.md). Обратите внимание, что если требуется, чтобы ресурсы ссылки в списке переходов совпадали с исходным файлом .exe, необходимо задать ресурсы, такие как значок, используя [**SetIconLocation**](https://msdn.microsoft.com/library/windows/desktop/bb761047(v=vs.85).aspx), а для отображения имени использовать PKEY_Title, так же, как и для других пользовательских записей.

    - __Ваше приложение добавляет элементы списка переходов, которые ссылаются на ресурсы в пакете приложения по абсолютному пути__. Путь установки приложения может измениться при обновлении пакетов, изменении расположения ресурсов (например, значков, документов, исполняемых файлов и т. д.). Если элементы списка переходов ссылаются на такие ресурсы по абсолютным путям, то приложение должно периодически обновлять свой список переходов (например, при запуске приложения) для обеспечения правильности путей. Либо можно использовать API-интерфейсы UWP [**Windows.UI.StartScreen.JumpList**](https://msdn.microsoft.com/library/windows/apps/windows.ui.startscreen.jumplist.aspx), которые позволяют ссылаться на ресурсы строк и изображений с помощью схемы URI package-relative ms-resource (которая также поддерживает определение языка, DPI и высокой контрастности).

+ __Для выполнения задач приложение запускает служебную программу__. Избегайте запуска служебных программ командной строки, таких как PowerShell и Cmd.exe. Фактически, если пользователи устанавливают ваше приложение в системе под управлением Windows 10 S, то в дальнейшем ваше приложение не сможет запустить эти служебные программы вообще. Это может заблокировать вашему приложению возможность отправки в Магазин Windows, так как все приложения, отправляемые в Магазин Windows, должны быть совместимы с Windows 10 S.

Служебные программы часто предоставляют удобный способ для получения информации из операционной системы, доступа к реестру или к возможностям системы. Однако для выполнения такого рода задач можно использовать API UWP. Они более производительны, так как для их запуска не требуется отдельный исполняемый файл, но более важно то, что эти интерфейсы не позволяют приложениям выходить за пределы пакета. Дизайн приложения по-прежнему отвечает требованиям изоляции, доверия и безопасности, которые сопутствуют приложению, перенесенному из классического приложения, а поведение вашего приложения будет соответствовать поведению, принятому в системах под управлением Windows10S.

+ __В приложении размещаются надстройки, подключаемые модули и расширения__.   Во многих случаях расширения в стиле COM устанавливаются как расширения с полным доверием, и, скорее всего, они будут работать до тех пор, пока не будут упакованы. Это связано с тем, что эти установщики могут использовать свои возможности полного доверия для изменения реестра и размещения файлов расширений независимо от того, где ваше ведущее приложение ожидает их найти.

   Однако если эти расширения были упакованы, а затем установлены в виде пакета приложений для Windows, они не будут работать, поскольку все пакеты (ведущее приложение и расширение) будут изолированы друг от друга. Подробную информацию о том, как мост для классических приложений изолирует приложения от системы, см. в разделе [Как работает мост для классических приложений](desktop-to-uwp-behind-the-scenes.md).

 Все приложения и расширения, которые устанавливаются пользователями в системе под управлением Windows 10 S, должны устанавливаться в виде пакетов приложений для Windows. Поэтому если вы планируете упаковать ваши расширения или приветствуете их упаковку вашими участниками, подумайте о том, как облегчить обмен данными между пакетом ведущего приложения и любыми пакетами расширений. Вы можете сделать это, например, с помощью [службы приложений](../launch-resume/app-services.md).

+ __Приложение генерирует код__. Приложение может генерировать код, который используется в памяти, но избегайте записи этого кода на диск, так как процесс сертификации приложений для Windows не сможет проверить этот код перед отправкой приложения. Кроме того, приложения, которые записывают код на диск, не будут работать правильно в системах под управлением Windows 10 S. Это может заблокировать вашему приложению возможность отправки в Магазин Windows, так как все приложения, отправляемые в Магазин Windows, должны быть совместимы с Windows 10 S.

+ __Приложение использует API MAPI__. В настоящий момент [API MAPI для Outlook](https://msdn.microsoft.com/library/office/cc765775.aspx(d=robot)) не поддерживается в приложениях, перенесенных с помощью моста классических приложений.

## <a name="next-steps"></a>Следующие шаги

**Создание пакета приложения для Windows для классических приложений**

См. раздел [Создание пакета приложения для Windows](desktop-to-uwp-root.md#convert).

**Поиск ответов на конкретные вопросы**

Наша команда следит за этими [тегами StackOverflow](http://stackoverflow.com/questions/tagged/project-centennial+or+desktop-bridge).

**Оставьте отзыв об этой статье**

Используйте раздел комментариев ниже.
