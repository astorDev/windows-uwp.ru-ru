---
author: normesta
Description: This article lists things you need to know before packaging your desktop application. You may not need to do much to get your app ready for the packaging process.
Search.Product: eADQiWindows 10XVcnh
title: Подготовка для упаковки классического приложения (мост для классических приложений)
ms.author: normesta
ms.date: 05/18/20188
ms.topic: article
keywords: windows 10, uwp
ms.assetid: 71a57ca2-ca00-471d-8ad9-52f285f3022e
ms.localizationpriority: medium
ms.openlocfilehash: ba89ab06062f5ba40bb96f4d558bd89a16e591d1
ms.sourcegitcommit: 38f06f1714334273d865935d9afb80efffe97a17
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/09/2018
ms.locfileid: "6205189"
---
# <a name="prepare-to-package-a-desktop-application"></a>Подготовка для упаковки классического приложения

В этой статье рассказывается, что необходимо знать перед упаковкой классического приложения. У вас может не быть больших усилий Подготовка приложения к процессу упаковки, но если какие-либо из перечисленного ниже относится к вашему приложению, необходимо устранить проблему, прежде чем упаковки. Не забывайте, что лицензирование и автоматическое обновление вашего приложения обеспечивается Microsoft Store, поэтому любые возможности, относящиеся к этим задачам, можно исключить из вашей базы кода.

>[!IMPORTANT]
>Возможность создания пакета приложения для Windows для классического приложения (также известное как моста для классических приложений) впервые появился в Windows 10 версии 1607 и может использоваться только в проектах, предназначенных для Юбилейного обновления Windows 10 (10.0; Сборка 14393) или более поздней версии в Visual Studio.

+ __Приложение требует версии .NET 4.6.2__. Необходимо убедиться, что приложение выполняется в .NET 4.6.2. Невозможно требовать или перераспределять версии ниже 4.6.2. Это версия .NET, которая поставлялась в юбилейном обновлении Windows 10. Проверив, что приложение работает в этой версии гарантирует, что приложение будет продолжать совместимость с будущими обновлениями Windows 10.  Если ваше приложение предназначено для .NET Framework 4.0 или более поздней версии, ожидается работать в .NET 4.6.2, но он все равно необходимо тестировать.

+ __Приложение всегда запускается с повышенными привилегиями безопасности__. Ваше приложение должно работать при его выполнении в качестве текущего пользователя. Пользователи, устанавливающие ваше приложение из Microsoft Store могут не являться системными администраторами, поэтому необходимость выполнения вашего приложения для более высокими привилегиями означает, что оно будет работать неправильно для обычных пользователей. Приложения, требующие повышения прав для любой своей функций, не будут приняты в Microsoft Store.

+ __Вашему приложению требуется в режиме ядра драйвера или службы Windows__. Мост подходит для приложения, но он не поддерживает драйвер, работающий в режиме ядра, или службу Windows, которая должна работать с правами учетной записи системы. Вместо службы Windows используйте [фоновую задачу](https://msdn.microsoft.com/windows/uwp/launch-resume/create-and-register-a-background-task).

+ __Модули вашего приложения загружаются во внутрипроцессном режиме в процессы, которые отсутствуют в пакете приложения для Windows__. Это запрещено и означает, что внутрипроцессные расширения, такие как [расширения оболочки](https://msdn.microsoft.com/library/windows/desktop/dd758089.aspx), не поддерживаются. Но если у вас есть два приложения в одинаковом пакете, вы можете настроить межпроцессное взаимодействие между ними.

+ __Приложение использует пользовательский пользователя идентификатор модели приложения (AUMID)__. Если ваш процесс вызывает [SetCurrentProcessExplicitAppUserModelID](https://msdn.microsoft.com/library/windows/desktop/dd378422.aspx) , чтобы задать собственный AUMID, то оно может использовать только AUMID сформирован для него пакета приложения для приложения модели среды и Windows. Вы не можете определять пользовательские AUMID.

+ __Ваше приложение изменяет куст реестра HKEY_LOCAL_MACHINE (HKLM)__. Любая попытка приложения создать ключ HKLM или открыть такой для изменения приведет к сбою в виде доступе. Помните, что ваше приложение имеет собственный закрытый виртуализированных представление реестра, поэтому понятие куст реестра пользователя и компьютера (который является, что такое HKLM) не применяется. Потребуется найти другой способ достичь того, чего требовалось при использовании HKLM, например запись в HKEY_CURRENT_USER (HKCU).

+ __Приложение использует подраздел реестра ddeexec с точки зрения запуск другого приложения__. Вместо этого используйте один из обработчиков команды DelegateExecute в соответствии с настройками различных расширений Activatable* в вашем [манифесте пакета приложения](https://msdn.microsoft.com/library/windows/apps/br211474.aspx).

+ __Ваше приложение выполняет запись в папку AppData или в реестр с намерением поделиться данными с другим приложением__. После преобразования AppData перенаправляется в локальное хранилище данных приложения, являющееся частным хранилищем для каждого приложения UWP.

  Все операции, которые ваше приложение записывает данные в куст реестра HKEY_LOCAL_MACHINE перенаправляются в изолированном двоичный файл и любые записи, которые ваше приложение записывает данные в куст реестра HKEY_CURRENT_USER помещаются в частной каждого пользователя и каждого приложения расположении. Дополнительные сведения о перенаправлении файлов и реестра см. в разделе [Как работает мост для классических приложений](desktop-to-uwp-behind-the-scenes.md).  

  Используйте другие средства межпроцессного обмена данными. Подробнее: [Хранение и извлечение параметров и прочих данных приложения](https://msdn.microsoft.com/windows/uwp/app-settings/store-and-retrieve-app-data).

+ __Ваше приложение записывает данные в папку установки для вашего приложения__. Например приложение записывает в файл журнала, который вы поместили в тот же каталог, что exe-файл. Эта операция не поддерживается, поэтому потребуется найти другое расположение, например, локальное хранилище данных приложения.

+ __Установки вашего приложения требуется участие пользователя__. Установщик приложения должен иметь возможность запускаться в автоматическом режиме, и его необходимо установить все свои дополнительные компоненты, которые не активированы по умолчанию в чистом образе ОС.

+ __Приложение использует текущий рабочий каталог__. Во время выполнения ваше упакованное классическое приложение не получит тот же рабочий каталог, который был ранее указан на рабочем столе. Ярлык LNK. Необходимо изменить CWD во время выполнения, если в правильный каталог является важным фактором для вашего приложения для правильной работы.

+ __Приложение запрашивает доступ UIAccess__. Если приложение задает значение `UIAccess=true` элементу `requestedExecutionLevel` манифеста UAC, то преобразование в UWP не поддерживается на данный момент. Подробнее см. в разделе [Обзор системы безопасности модели автоматизации пользовательского интерфейса](https://msdn.microsoft.com/library/ms742884.aspx).

+ __Приложение предоставляет объекты модели COM__. Процессы и расширения из пакета могут регистрировать и использовать серверы COM и OLE, как внутрипроцессные, так и внепроцессные (OOP).  Creators Update добавляет поддержку технологии Packaged COM, позволяющей регистрировать серверы OOP COM и OLE, которые видимы за пределами пакета.  См. раздел [Поддержка сервера COM и документа OLE для моста для классических приложений](https://blogs.windows.com/buildingapps/2017/04/13/com-server-ole-document-support-desktop-bridge/#bjPyETFgtpZBGrS1.97).

   Технология Packaged COM поддерживает работу с существующими API модели COM, но не будет работать для расширений приложения, которые зависят от чтения реестра напрямую, так как расположение для Packaged COM находится в частном расположении.

+ __Приложение предоставляет GAC для использования другими процессами__. В текущем выпуске приложение не может предоставлять сборки GAC для использования процессами, возникающими в результате внешний исполняемые файлы запуска для пакета приложения для Windows. Процессы из пакета могут регистрировать и использовать сборки GAC обычным образом, но они не будут видны извне. Это означает, что сценарии межпрограммного взаимодействия (например, OLE) не будут работать при их вызове внешними процессами.

+ __Ваше приложение является связывание для связывания библиотеки времени выполнения C (CRT) неподдерживаемым способом__. Библиотека времени выполнения C/C++ Майкрософт предоставляет процедуры для программирования в среде операционной системы Microsoft Windows. Эти процедуры автоматизируют выполнение многих распространенных задач программирования, которые не предоставляются языками C и C++. Если ваше приложение использует библиотеку среды выполнения C/C++, необходимо убедиться, что она связана поддерживаемом способом.

    Visual Studio 2017 поддерживает как динамическое связывание, чтобы код мог использовать общие файлы DLL, так и статическое связывание для связывания библиотеки непосредственно с кодом, до текущей версии CRT. Если это возможно мы рекомендуем использовать приложения в динамическое связывание Visual STUDIO 2017.

    Поддержка различных типов связывания зависит от версии Visual Studio. Подробности см. в следующей таблице:

    <table>
    <th>Версия Visual Studio</td><th>Динамическое связывание</th><th>Статическое связывание</th></th>
    <tr><td>2005 (VC 8)</td><td>Не поддерживается</td><td>Поддерживается</td>
    <tr><td>2008 (VC 9)</td><td>Не поддерживается</td><td>Поддерживается</td>
    <tr><td>2010 (VC 10)</td><td>Поддерживается</td><td>Поддерживается</td>
    <tr><td>2012 (VC 11)</td><td>Поддерживается</td><td>Не поддерживается</td>
    <tr><td>2013 (VC 12)</td><td>Поддерживается</td><td>Не поддерживается</td>
    <tr><td>2015 и 2017 (VC 14)</td><td>Поддерживается</td><td>Поддерживается</td>
    </table>

    Примечание. Во всех случаях связывание необходимо выполнять с самой последней общедоступной библиотекой CRT.

+ __Приложение устанавливает и загружает сборки из папки Windows рядом друг с другом__. Например приложение использует библиотеки среды выполнения C VC8 или VC9 и динамическое связывание их из папки Windows рядом друг с другом, это означает, что в коде используются общие файлы DLL из общей папки. Такой способ связывания не поддерживается. Необходимо подключать их статически, то есть связать с распространяемыми файлами библиотеки непосредственно в самом коде.

+ __Приложение использует зависимость в папке System32/SysWOW64__. Чтобы эти DLL-файлы начали работать, необходимо включить их в часть вашего пакета приложения для Windows, находящуюся в виртуальной файловой системе. Это гарантирует, что приложение ведет себя, как если бы DLL-файлы были установлены в **System32**/**SysWOW64** папки. В корне пакета создайте папку с именем **VFS**. В этой папке создайте папки **SystemX64** и **SystemX86**. Затем поместите 32-разрядную версию DLL-файла в папку **SystemX86**, а 64-разрядную версию— в папку **SystemX64**.

+ __Ваше приложение использует пакет платформы VCLibs__. Библиотеки VCLibs можно установить напрямую из Microsoft Store, если они определены как зависимость в пакете приложения для Windows. Например, если приложение использует пакеты Dev11 VCLibs, внесите следующее изменение в манифест пакета приложения: в разделе `<Dependencies>` узел, добавьте:  
`<PackageDependency Name="Microsoft.VCLibs.110.00.UWPDesktop" MinVersion="11.0.24217.0" Publisher="CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US" />`  
Во время установки из Microsoft Store будет установлена нужная версия (x86 или x64) платформы VCLibs перед установкой приложения.  
Зависимости не будут установлены, если приложение установлено путем загрузки неопубликованных приложений. Чтобы установить зависимости на компьютере вручную, вам потребуется скачать и установить соответствующий пакет платформы VCLibs для моста для настольных компьютеров. Подробнее об этих сценариях см. в разделе [Использование среды выполнения Visual C++ в проекте Centennial](https://blogs.msdn.microsoft.com/vcblog/2016/07/07/using-visual-c-runtime-in-centennial-project/).

  **Пакеты платформы**:

  * [Пакеты платформы VC 14.0 для моста для классических приложений](https://www.microsoft.com/download/details.aspx?id=53175)
  * [Пакеты платформы VC 12.0 для моста для классических приложений](https://www.microsoft.com/download/details.aspx?id=53176)
  * [Пакеты платформы VC 11.0 для моста для классических приложений](https://www.microsoft.com/download/details.aspx?id=53340)


+ __Ваше приложение содержит настраиваемый список переходов__. Списки переходов следует использовать с учетом некоторых оговорок и условий.

    - __Архитектура вашего приложения не соответствует операционной системе.__  Списки переходов в настоящее время работают неверно при несоответствии приложения и архитектуры ОС (например, x x86 приложения, работающие на x64 Windows). В настоящее время не имеет решения отличный от перекомпилировать приложения для соответствующей архитектуры.

    - __Приложение создает списка переходов и вызовы [ICustomDestinationList::SetAppID](https://msdn.microsoft.com/library/windows/desktop/dd378403(v=vs.85).aspx) или [SetCurrentProcessExplicitAppUserModelID](https://msdn.microsoft.com/library/windows/desktop/dd378422(v=vs.85).aspx)__. Не задавайте свой AppID в коде программными средствами. Это приведет к тому, что элементы списка переходов не будут отображаться. Если приложению требуется пользовательский идентификатор, укажите это с помощью файла манифеста. Для инструкций обратитесь к [упаковки классического приложения вручную](desktop-to-uwp-manual-conversion.md) . AppID для вашего приложения указан в разделе *YOUR_PRAID_HERE*.

    - __Ваше приложение добавляет ссылку на оболочку списка переходов, ссылается на исполняемый элемент в пакете__. Напрямую запускать исполняемые файлы в пакете из списка переходов нельзя (за исключением абсолютного пути собственного файла .exe приложения). Вместо этого зарегистрируйте псевдоним выполнения приложения (который позволит упакованного классического приложения запускаться через ключевое слово, как будто оно находится в PATH) и вместо этого задайте целевого пути ссылки путь к этому псевдониму. Дополнительные сведения о том, как использовать расширение appExecutionAlias, см. в разделе [Интеграция приложения для настольных компьютеров с Windows 10](desktop-to-uwp-extensions.md). Обратите внимание, что если требуется, чтобы ресурсы ссылки в списке переходов совпадали с исходным файлом .exe, необходимо задать ресурсы, такие как значок, используя [**SetIconLocation**](https://msdn.microsoft.com/library/windows/desktop/bb761047(v=vs.85).aspx), а для отображения имени использовать PKEY_Title, так же, как и для других пользовательских записей.

    - __Ваше приложение добавляет элементы списка переходов, которые ссылаются на ресурсы в пакет вашего приложения по абсолютному пути__. Путь установки приложения может измениться при обновлении пакетов, изменении расположения ресурсов (например, значков, документов, исполняемый файл и т. д.). Если списка переходов ссылаются на такие ресурсы по абсолютным путям, то приложение должно периодически обновлять свой переходов список (например, при запуске приложения) для обеспечения правильности путей. Либо можно использовать API-интерфейсы UWP [**Windows.UI.StartScreen.JumpList**](https://msdn.microsoft.com/library/windows/apps/windows.ui.startscreen.jumplist.aspx), которые позволяют ссылаться на ресурсы строк и изображений с помощью схемы URI package-relative ms-resource (которая также поддерживает определение языка, DPI и высокой контрастности).

+ __Приложение запускает служебную программу для выполнения задач__. Избегайте запуска служебных программ командной строки, таких как PowerShell и Cmd.exe. На самом деле Если пользователи устанавливают ваше приложение в системе под управлением Windows 10 S, затем приложения не смогут запустить их вообще. Это может заблокировать приложению возможность отправки в Microsoft Store, так как все приложения, отправляемые в Microsoft Store, должны быть совместимы с Windows 10 S.

Служебные программы часто предоставляют удобный способ для получения информации из операционной системы, доступа к реестру или к возможностям системы. Однако для выполнения такого рода задач можно использовать API UWP. Эти API они более производительны, так как они не требуется отдельный исполняемый файл для запуска, но что более важно, они позволяют приложениям выходить за пределы пакета приложения. Дизайн приложения-прежнему отвечает требованиям изоляции, доверия и безопасности, входящих в состав приложения, которое упаковки и ваше приложение будет работать правильно в системах под управлением Windows 10 S.

+ __Вашего приложения узлов надстройки, подключаемые модули или расширения__.   Во многих случаях расширения в стиле COM устанавливаются как расширения с полным доверием, и, скорее всего, они будут работать до тех пор, пока не будут упакованы. Это, так как эти установщики могут использовать свои возможности полного доверия для изменения реестра и размещения файлов расширений везде, где ваше ведущее приложение ожидает их найти.

   Тем не менее если эти расширения упакованы, а затем установлены в виде пакета приложения для Windows, они не будут работать, поскольку все пакеты (ведущее приложение и расширение) будут изолированы друг от друга. На дополнительные сведения о том, как приложения изолированы от системы, см. в разделе [работает Desktop Bridge](desktop-to-uwp-behind-the-scenes.md).

 Все приложения и расширения, которые устанавливаются пользователями в системе под управлением Windows 10 S, должны устанавливаться в виде пакетов приложений для Windows. Поэтому если вы планируете упаковать ваши расширения или вы планируете побудить участники их, подумайте о том, как облегчить обмен данными между пакетом ведущего приложения и любыми пакетами расширений. Вы можете сделать это, например, с помощью [службы приложений](../launch-resume/app-services.md).

+ __Приложение генерирует код__. Ваше приложение может генерировать код, который используется в памяти, но Избегайте записи этого кода на диск, так как процесс сертификации приложений для Windows не может проверить этот код перед отправкой приложения. Кроме того приложения, которые записывают код на диск не будут работать правильно в системах под управлением Windows 10 S. Это может заблокировать приложению возможность отправки в Microsoft Store, так как все приложения, отправляемые в Microsoft Store, должны быть совместимы с Windows 10 S.

>[!IMPORTANT]
> После создания пакета приложения для Windows, пожалуйста Протестируйте приложение, чтобы убедиться, что оно работает правильно в системах под управлением Windows 10 S. Все приложения, отправляемые в Microsoft Store должны быть совместимы с Windows 10 S. несовместимые приложения не будут приняты в магазине. См. статью [Тестирование приложения для Windows на Windows 10 S](desktop-to-uwp-test-windows-s.md).

## <a name="next-steps"></a>Дальнейшие действия

**Поиск ответов на вопросы**

Есть вопросы? Задайте их на Stack Overflow. Наша команда следит за этими [тегами](http://stackoverflow.com/questions/tagged/project-centennial+or+desktop-bridge). Вы также можете задать нам вопросы [здесь](https://social.msdn.microsoft.com/Forums/en-US/home?filter=alltypes&sort=relevancedesc&searchTerm=%5BDesktop%20Converter%5D).

**Оставьте отзыв или предложите новые возможности для реализации**

См. раздел [UserVoice](https://wpdev.uservoice.com/forums/110705-universal-windows-platform/category/161895-desktop-bridge-centennial)

**Создание пакета приложения для Windows для классических приложений**

См. раздел [Создание пакета приложения для Windows](desktop-to-uwp-root.md#convert).
