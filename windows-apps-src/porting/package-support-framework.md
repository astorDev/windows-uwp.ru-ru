---
author: normesta
Description: Fix issues that prevent your desktop application from running in an MSIX container
Search.Product: eADQiWindows 10XVcnh
title: Устранение проблем, которые препятствуют созданию приложения рабочего стола в контейнер MSIX
ms.author: normesta
ms.date: 07/02/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 46d5705233af9e8254b9ac89a2d6e9891e90701f
ms.sourcegitcommit: 9e2c34a5ed3134aeca7eb9490f05b20eb9a3e5df
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/17/2018
ms.locfileid: "3986371"
---
# <a name="apply-runtime-fixes-to-an-msix-package-by-using-the-package-support-framework"></a>Применить с помощью платформа поддержки пакетов исправлений во время выполнения пакет MSIX

Платформа поддержки пакетов представляет собой набор с открытым исходным кодом, позволяющее применять исправления существующего приложения win32 при отсутствии доступа к исходному коду, позволяющие выполнять в контейнере MSIX. Платформа поддержки пакетов помогает приложению рекомендации современных общеязыковой среды выполнения.

Создать структуру поддержки пакета, мы использовать [обходит](https://www.microsoft.com/en-us/research/project/detours) технологии, которая является открытым исходным кодом, разработанная в Microsoft Research (MSR) и помогает с API перенаправление и перехвата.

Эта платформа является открытым исходным кодом, легкий и можно использовать ее для решения проблем приложения быстро. Он также дает возможность обратиться к сообщества по всему миру и использовать инвестиции других.

## <a name="a-quick-look-inside-of-the-package-support-framework"></a>Быстрый взгляд внутри платформа поддержки пакетов

Платформа поддержки пакетов содержится исполняемый файл, библиотека DLL диспетчера среда выполнения и набор исправлений во время выполнения.

![Платформа поддержки пакетов](images/desktop-to-uwp/package-support-framework.png)

Вот как это работает. Вы создадите файл конфигурации, который указывает fix(s), которую требуется применить к приложению. Затем изменим пакета указывать исполняемый файл запуска оболочки.

Когда пользователь запускает приложение, оболочку запуска является первый исполняемый файл, запускающий. Он считывает файл конфигурации и внедряет fix(s) во время выполнения и во время выполнения диспетчер библиотек DLL в процессе приложения.

![Пакет поддержки Framework DLL введения](images/desktop-to-uwp/package-support-framework-2.png)

Диспетчеру среды применяется исправление при необходимости выполнения приложения в контейнер MSIX.

Это руководство поможет вам определить проблемы с совместимостью приложений и найти и применить расширение среды выполнения исправления, их устранения.

<a id="identify" />

## <a name="identify-packaged-application-compatibility-issues"></a>Определение проблем совместимости приложений в пакете

Во-первых создайте пакет приложения. Затем, установить его, запустите его и понаблюдать за его поведением. Может появиться сообщения об ошибках, которые могут помочь в идентификации проблемы совместимости. [Process Monitor](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) можно также использовать для выявления проблем.  Распространенные проблемы относятся приложения предположения относительно рабочего каталога и программа разрешения пути.

### <a name="using-process-monitor-to-identify-an-issue"></a>Чтобы определить проблему с помощью Process Monitor

[Монитор процессов](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) является мощным служебная программа для просмотра файла приложения и операциями с реестром и его результаты.  Это поможет понять проблемы совместимости приложений.  После открытия Process Monitor, добавьте фильтр (фильтр > Фильтр...) чтобы включались только события из исполняемого файла приложения.

![ProcMon App фильтра](images/desktop-to-uwp/procmon_app_filter.png)

Будет отображен список событий. Для многих из этих событий слово **Успех** будет отображаться в столбце **результат** .

![ProcMon событий](images/desktop-to-uwp/procmon_events.png)

При необходимости можно отфильтровать события, чтобы только Показать только ошибки.

![Исключить ProcMon успеха](images/desktop-to-uwp/procmon_exclude_success.png)

Если вы подозреваете, ошибка доступа файловой системы, поиск неудачные события, которые находятся в папке System32/SysWOW64 или путь к файлу пакета. Фильтры также могут помочь здесь слишком. Начать в нижней части списка и прокрутите его вверх. Недавно возникли неполадки, которые отображаются в нижней части этого списка. Не забывайте большинства ошибок, которые содержат строки, например, «отказано в доступе» и «путь и имя не найдено» и игнорировать вещи, которые выглядят подозрительно. [PSFSample](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/samples/PSFSample/) имеет две проблемы. Можно просмотреть эти вопросы в списке, который появляется на следующем рисунке.

![ProcMon Config.txt](images/desktop-to-uwp/procmon_config_txt.png)

Первый выпуск в этот образ приложение не может читать из файла «Config.txt», который находится в каталоге «C:\Windows\SysWOW64». Маловероятно, что приложение пытается напрямую ссылаться на этот путь. Скорее всего выполняется чтение из файла с помощью относительный путь, и по умолчанию «System32/SysWOW64» является рабочий каталог приложения. Это предполагает, что приложение ожидает его текущий рабочий каталог будет присвоено где-нибудь в пакете. Глядя в appx, мы видим, что файл существует в том же каталоге, что и исполняемый файл.

![App Config.txt](images/desktop-to-uwp/psfsampleapp_config_txt.png)

Вторая проблема появляется на следующем рисунке.

![Файл журнала ProcMon](images/desktop-to-uwp/procmon_logfile.png)

В этом выпуске приложения не удается записать файл журнала его путь к пакету. Это предположить, что оболочка перенаправление файла может помочь.

<a id="find" />

## <a name="find-a-runtime-fix"></a>Найти исправление среды выполнения

Инструмент содержит исправления во время выполнения, можно использовать прямо сейчас, такие как оболочка перенаправление файла.

### <a name="file-redirection-shim"></a>Перенаправление файлов оболочки

[Оболочка совместимости перенаправления файл](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/develop/FileRedirectionShim) можно использовать для перенаправления попытки записи или чтения данных в каталоге, не доступны из приложения, которое выполняется в контейнере MSIX.

Например если приложение записывает в файл журнала, который находится в том же каталоге, что и исполняемый файл приложения, [Оболочка перенаправления файл](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/develop/FileRedirectionShim) можно использовать для создания файла журнала в другое место, например хранилище данных локальных приложений.

### <a name="runtime-fixes-from-the-community"></a>Среда выполнения исправления от сообщества

Убедитесь, что для просмотра вклады сообщества в нашей странице [GitHub](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/develop) . Существует вероятность, что другие разработчики устранили ошибку, сходные с вашими и общей среды выполнения исправления.

## <a name="apply-a-runtime-fix"></a>Исправление, во время выполнения

Можно применить средство во время выполнения некоторые простые средства из пакета Windows SDK и выполните следующие действия.

> [!div class="checklist"]
> * Создание макета папки пакета
> * Получение файлов платформа поддержки пакетов
> * Добавить их в пакет
> * Изменение манифеста пакета
> * Создание файла конфигурации

Давайте разберем каждую задачу.

### <a name="create-the-package-layout-folder"></a>Создание макета папки пакета

Если уже имеется файл .appx можно распаковать содержимое в папку макет, который будет служить в качестве промежуточной области для пакета.  Это можно сделать из **x64 собственных средств командной строки для VS 2017 г.**, или вручную в папку Bin SDK в путь исполняемого поиска.

```
makeappx unpack /p PSFSamplePackage_1.0.60.0_AnyCPU_Debug.appx /d PackageContents

```

Это позволит получить то, что выглядит следующим образом.

![Макет пакета](images/desktop-to-uwp/package_contents.png)

Если начать с нет файла .appx, файлов и папок пакета можно создать "с нуля".

### <a name="get-the-package-support-framework-files"></a>Получение файлов платформа поддержки пакетов

Инструмент Nuget-пакет можно получить с помощью Visual Studio. Его также можно получить с помощью средства командной строки Nuget автономный.

#### <a name="get-the-package-by-using-visual-studio"></a>Получить пакет с помощью Visual Studio

В Visual Studio щелкните правой кнопкой мыши узел в решение или проект и выбрать одну из команд Управление пакетами Nuget.  Поиск **Microsoft.PackageSupportFramework** или **Инструмент** найти местоположение пакета для Nuget.org. Затем установите его.

#### <a name="get-the-package-by-using-the-command-line-tool"></a>Получить пакет с помощью средства командной строки

Средство командной строки Nuget установку из этого местоположения: https://www.nuget.org/downloads. Затем из командной строки Nuget, выполните следующую команду:

```
nuget install Microsoft.PackageSupportFramework
```

### <a name="add-the-package-support-framework-files-to-your-package"></a>Добавить файлы платформа поддержки пакетов в упаковке

Добавьте необходимые 32-разрядные и 64-разрядные библиотеки DLL Инструмент и исполняемые файлы каталога пакета. Руководствуйтесь следующей таблицей. Будет также требуется включить исправлений общеязыковой среды выполнения, которые необходимы. В нашем примере мы должны исправить среды выполнения перенаправление файла.

| Исполняемый файл приложения является x64 | Исполняемый файл приложения является x86 |
|-------------------------------|-----------|
| [ShimLauncher64.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimLauncher/readme.md) |  [ShimLauncher32.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimLauncher/readme.md) |
| [ShimRuntime64.dll](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRuntime/readme.md) | [ShimRuntime32.dll](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRuntime/readme.md) |
| [ShimRunDll64.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRunDll/readme.md) | [ShimRunDll32.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRunDll/readme.md) |

Содержимое пакета теперь должен выглядеть примерно следующим образом.

![Двоичные файлы пакета](images/desktop-to-uwp/package_binaries.png)

### <a name="modify-the-package-manifest"></a>Изменение манифеста пакета

Откройте в текстовом редакторе манифест пакета, а затем установите `Executable` атрибута `Application` элемент, имя исполняемого файла средства запуска оболочки.  Если вы знаете архитектуру целевого приложения, выберите соответствующую версию, ShimLauncher32.exe или ShimLauncher64.exe.  В противном случае ShimLauncher32.exe будут работать во всех случаях.  Вот пример.

```xml
<Package ...>
  ...
  <Applications>
    <Application Id="PSFSample"
                 Executable="ShimLauncher32.exe"
                 EntryPoint="Windows.FullTrustApplication">
      ...
    </Application>
  </Applications>
</Package>
```

### <a name="create-a-configuration-file"></a>Создание файла конфигурации

Создать имя файла ``config.json``и сохраните этот файл в корневую папку пакета. Измените объявленный app код файла config.json для исполняемого файла, просто заменить. Используя знания, полученные с помощью Process Monitor, вы можно также настроить рабочий каталог, а также использовать оболочку перенаправление файла для перенаправления операций чтения и записи в файлы с расширением LOG относительно пакета в каталоге «PSFSampleApp».

```json
{
    "applications": [
        {
            "id": "PSFSample",
            "executable": "PSFSampleApp/PSFSample.exe",
            "workingDirectory": "PSFSampleApp/"
        }
    ],
    "processes": [
        {
            "executable": "PSFSample",
            "shims": [
                {
                    "dll": "FileRedirectionShim.dll",
                    "config": {
                        "redirectedPaths": {
                            "packageRelative": [
                                {
                                    "base": "PSFSampleApp/",
                                    "patterns": [
                                        ".*\\.log"
                                    ]
                                }
                            ]
                        }
                    }
                }
            ]
        }
    ]
}
```
Далее приводится руководство по схеме config.json.

| Массив | key | Значение |
|-------|-----------|-------|
| Приложения | id |  Используйте значение `Id` атрибута `Application` элемент в манифесте пакета. |
| Приложения | исполняемый файл | Пакет относительный путь к исполняемому файлу, который требуется запустить. В большинстве случаев это значение можно получить из файла манифеста пакета перед внесением изменений. Это значение `Executable` атрибута `Application` элемент. |
| Приложения | workingDirectory | (Необязательно) Путь относительно пакета для использования в качестве рабочего каталога приложения, которое запускается. Если это значение не задано, операционная система использует `System32` каталог в качестве рабочего каталога приложения. |
| процессы | исполняемый файл | В большинстве случаев это будет имя `executable` настройки выше, удалить путь и расширение. |
| режимы совместимости | библиотеки DLL | Путь относительно пакета .appx оболочка для загрузки. |
| режимы совместимости | конфигурации | (Необязательно) Управляет поведением dl оболочки. Точный формат это значение изменяется на основе оболочки, оболочки как каждое исправление можно интерпретировать «блоб», как ему. |

`applications`, `processes`, И `shims` ключи являются массивами. Это означает, что файл config.json используется для указания более одного приложения, процессы и оболочки библиотеки DLL.


### <a name="package-and-test-the-app"></a>Пакет и тестирование приложения

Создайте пакет.

```
makeappx pack /d PackageContents /p PSFSamplePackageFixup.appx
```

Затем подпишите его.

```
signtool sign /a /v /fd sha256 /f ExportedSigningCertificate.pfx PSFSamplePackageFixup.appx
```

Дополнительные сведения содержатся в разделе [способы создания сертификата подписи пакета](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/how-to-create-a-package-signing-certificate) и [подписать пакет с помощью signtool](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/how-to-sign-a-package-using-signtool)

С помощью PowerShell, необходимо установите пакет.

>[!NOTE]
> Не забудьте сначала удалить пакет.

```
powershell Add-AppxPackage .\PSFSamplePackageFixup.appx
```

Запустите приложение и проверьте работу с применить исправление во время выполнения.  Повторите шаги упаковки при необходимости и диагностики.

### <a name="use-the-trace-shim"></a>Использование оболочки трассировки

Альтернативный способ диагностики проблем совместимости приложений в пакете является использование оболочки трассировки. Эта библиотека DLL входит в состав Инструмент и обеспечивает подробное представление диагностики поведения приложения, подобные Process Monitor.  Специально выявить проблемы совместимости приложений.  Для использования трассировки оболочки, добавить DLL-ФАЙЛ пакета, config.json, добавьте следующий фрагмент и затем упаковать и установки приложения.

```json
{
    "dll": "TraceShim.dll",
    "config": {
        "traceLevels": {
            "filesystem": "allFailures"
        }
    }
}
```

По умолчанию оболочка трассировки отфильтровывает сбоев, которые могут считаться «ожидается».  Например приложения могут попытаться безусловно удалить файл без проверки, если он уже существует, игнорируя результат. Это имеет нежелательным следствием, некоторые непредвиденные сбои могут получить отфильтрованы, поэтому в приведенном выше примере мы решили всех ошибок приема из функций файловой системы. Для этого мы знаем из прежде, чем попытка чтения из файла Config.txt выдает сообщение «файл не найден». Это происходит сбой, который часто наблюдается и обычно не предполагается, что к неожиданным. На практике это вероятно, лучше всего начать фильтрацию только непредвиденные сбои, а затем добравшись до всех сбоев при наличии проблемы, которая по-прежнему не удается определить.

По умолчанию выходные данные трассировки оболочки отправляется для присоединенного отладчика. Например мы не следует прикрепить отладчик и вместо этого будет использоваться программа [DebugView](https://docs.microsoft.com/en-us/sysinternals/downloads/debugview) от компании SysInternals для просмотра его выходных данных. После запуска приложения, мы видим те же ошибки как раньше, что бы указывают нам же исправления во время выполнения.

![Файл TraceShim не найден](images/desktop-to-uwp/traceshim_filenotfound.png)

![Отказано в TraceShim](images/desktop-to-uwp/traceshim_accessdenied.png)

## <a name="debug-extend-or-create-a-runtime-fix"></a>Отладка, расширения или создания исправления во время выполнения

Можно использовать Visual Studio для отладки среды выполнения исправления, расширения среды выполнения исправления или создать новый. Необходимо выполнить эти действия будут успешными.

> [!div class="checklist"]
> * Добавьте проект упаковки
> * Добавьте проект для исправления во время выполнения
> * Добавить проект, который запускает исполняемый модуль запуска оболочки
> * Настройка проекта упаковки

Когда все готово, решение будет выглядеть примерно следующим образом.

![Завершенное решение](images/desktop-to-uwp/runtime-fix-project-structure.png)

Давайте рассмотрим каждый проект в этом примере.

| Проект | Описание |
|-------|-----------|
| DesktopApplicationPackage | Этот проект основан на [проекте упаковки приложения Windows](desktop-to-uwp-packaging-dot-net.md) и выводит его в пакет MSIX. |
| Runtimefix | Это Dynamic-Linked библиотеки C++ проект, который содержит одну или несколько функций замены, которые служат исправления во время выполнения. |
| ShimLauncher | Это пустой проект C++. Этот проект является местом для сбора файлов среды выполнения распространяемый пакет поддержки платформы. Он выводит исполняемый файл. Этот исполняемый файл — это первое, запускаемые при запуске решения. |
| WinFormsDesktopApplication | Этот проект содержит исходный код для настольного приложения. |

Рассмотрим пример, содержащий все проекты этих типов, содержатся в разделе [PSFSample](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/samples/PSFSample/).

Рассмотрим шаги, чтобы создать и настроить каждый из этих проектов в решении.


### <a name="create-a-package-solution"></a>Создание пакета решения

Если решение не уже приложения для настольных компьютеров, создайте новое **Пустое решение** в Visual Studio.

![Пустое решение](images/desktop-to-uwp/blank-solution.png)

Можно также добавить любые проекты приложений, у вас есть.

### <a name="add-a-packaging-project"></a>Добавьте проект упаковки

Если у вас еще нет **Упаковки проекта приложения Windows**, создайте его и добавьте его в решение.

![Шаблон проекта пакета](images/desktop-to-uwp/package-project-template.png)

Дополнительные сведения о проекте упаковки приложения Windows [пакет приложения с помощью Visual Studio](desktop-to-uwp-packaging-dot-net.md)см.

В **Обозревателе решений**щелкните правой кнопкой мыши проект упаковки, выберите **Изменить**и добавить ее в конце файла проекта:

```
<Target Name="PSFRemoveSourceProject" AfterTargets="ExpandProjectReferences" BeforeTargets="_ConvertItems">
<ItemGroup>
  <FilteredNonWapProjProjectOutput Include="@(_FilteredNonWapProjProjectOutput)">
  <SourceProject Condition="'%(_FilteredNonWapProjProjectOutput.SourceProject)'=='<your runtime fix project name goes here>'" />
  </FilteredNonWapProjProjectOutput>
  <_FilteredNonWapProjProjectOutput Remove="@(_FilteredNonWapProjProjectOutput)" />
  <_FilteredNonWapProjProjectOutput Include="@(FilteredNonWapProjProjectOutput)" />
</ItemGroup>
</Target>
```

### <a name="add-project-for-the-runtime-fix"></a>Добавьте проект для исправления во время выполнения

В решение добавьте проект C++ **Библиотеки динамической компоновки (DLL)** .

![Библиотека времени выполнения исправления](images/desktop-to-uwp/runtime-fix-library.png)

Щелкните правой кнопкой мыши, проекта и выберите команду **Свойства**.

В окне свойств найдите поле **Стандартного языка C++** и выберите в раскрывающемся списке рядом с этим полем, **C ++ 17 стандарт ISO (/ std:c ++ 17)** параметр.

![ISO 17 параметр](images/desktop-to-uwp/iso-option.png)

Щелкните правой кнопкой мыши проект и выберите в контекстном меню выберите параметр **Управление пакетами Nuget** . Убедитесь, что параметр **источник пакета** для **всех** или **nuget.org**.

Далее щелкните значок параметры этого поля.

Поиск *Инструмент** Nuget пакет, а затем установить его для этого проекта.

![NuGet-пакет](images/desktop-to-uwp/psf-package.png)

Если требуется отладка или расширить существующее исправление во время выполнения, добавьте файлов исправления среды выполнения, которые получены с помощью руководства описаны в разделе [найти исправление среды выполнения](#find) данного руководства.

Если планируется создать новые исправления, ничего не добавляют к проекту просто еще. Мы поможем вам добавить нужные файлы в проект данного руководства. Теперь продолжим настройку вашего решения.

### <a name="add-a-project-that-starts-the-shim-launcher-executable"></a>Добавить проект, который запускает исполняемый модуль запуска оболочки

В решение добавьте проект **Пустой проект** C++.

![Пустой проект](images/desktop-to-uwp/blank-app.png)

Добавьте пакет Nuget **Инструмент** для этого проекта, используя то же руководство, описанных в предыдущем разделе.

Откройте страницы свойств для проекта, а также на странице **Общие** настройки свойства **Имя целевого** ``ShimLauncher32`` или ``ShimLauncher64`` в зависимости от архитектуры приложения.

![Ссылка запуска оболочки](images/desktop-to-uwp/shim-exe-reference.png)

Добавьте ссылку проекта в проект исправления во время выполнения в решении.

![исправление ссылок во время выполнения](images/desktop-to-uwp/reference-fix.png)

Щелкните ссылку правой кнопкой мыши, а затем применить эти значения в окне « **Свойства** ».

| Свойство | Значение |
|-------|-----------|-------|
| Копировать локальные | True |
| Копировать локально вспомогательные сборки | True |
| Выходной сборки ссылки | True |
| Использовать библиотеки из зависимостей | False |
| Ссылки библиотеки зависимостей входных данных | False |

### <a name="configure-the-packaging-project"></a>Настройка проекта упаковки

В проекте упаковки щелкните правой кнопкой мыши папку **Приложения** и выберите **Добавить ссылку**.

![Добавление ссылки на проект](images/desktop-to-uwp/add-reference-packaging-project.png)

Выберите проект запуска оболочки и проект приложения для настольных компьютеров и нажмите кнопку « **ОК** ».

![Проект классического приложения](images/desktop-to-uwp/package-project-references.png)

>[!NOTE]
> При отсутствии исходного кода приложения, просто выберите проект запуска оболочки. Мы покажем, как создавать ссылку на исполняемый файл при создании файла конфигурации.

В узел **приложения** щелкните правой кнопкой мыши приложение запуска оболочки и затем выберите команду **установить в качестве точки входа**.

![Задание точки входа](images/desktop-to-uwp/set-startup-project.png)

Добавьте в файл с именем ``config.json`` проект упаковки, затем скопируйте и вставьте в файл следующий текст json. Свойства **Пакета действия** для **содержимого**.

```json
{
    "applications": [
        {
            "id": "",
            "executable": "",
            "workingDirectory": ""
        }
    ],
    "processes": [
        {
            "executable": "",
            "shims": [
                {
                    "dll": "",
                    "config": {
                    }
                }
            ]
        }
    ]
}
```
Укажите значение для каждого ключа. Эта таблица используется в качестве руководства.

| Массив | key | Значение |
|-------|-----------|-------|
| Приложения | id |  Используйте значение `Id` атрибута `Application` элемент в манифесте пакета. |
| Приложения | исполняемый файл | Пакет относительный путь к исполняемому файлу, который требуется запустить. В большинстве случаев это значение можно получить из файла манифеста пакета перед внесением изменений. Это значение `Executable` атрибута `Application` элемент. |
| Приложения | workingDirectory | (Необязательно) Путь относительно пакета для использования в качестве рабочего каталога приложения, которое запускается. Если это значение не задано, операционная система использует `System32` каталог в качестве рабочего каталога приложения. |
| процессы | исполняемый файл | В большинстве случаев это будет имя `executable` настройки выше, удалить путь и расширение. |
| режимы совместимости | библиотеки DLL | Пакет относительный путь для загрузки DLL-Библиотеки оболочки. |
| режимы совместимости | конфигурации | (Необязательно) Управляет поведением dl оболочки. Точный формат это значение изменяется на основе оболочки, оболочки как каждое исправление можно интерпретировать «блоб», как ему. |

Когда вы закончите, ваш ``config.json`` файла будет выглядеть примерно следующим образом.

```json
{
  "applications": [
    {
      "id": "DesktopApplication",
      "executable": "DesktopApplication/WinFormsDesktopApplication.exe",
      "workingDirectory": "WinFormsDesktopApplication"
    }
  ],
  "processes": [
    {
      "executable": ".*App.*",
      "shims": [ { "dll": "RuntimeFix.dll" } ]
    }
  ]
}

```

>[!NOTE]
> `applications`, `processes`, И `shims` ключи являются массивами. Это означает, что файл config.json используется для указания более одного приложения, процессы и оболочки библиотеки DLL.

### <a name="debug-a-runtime-fix"></a>Отладка во время выполнения исправления

В Visual Studio нажмите клавишу F5, чтобы запустить отладчик.  Первое, что запускает является запуска приложения оболочки, который в свою очередь, запускает приложения для настольных компьютеров назначения.  Для отладки целевого приложения для настольных ПК, вам придется вручную подключиться к процессу приложения для настольных компьютеров, выбрав **Отладка**->**Присоединение к процессу**, а затем выбрав процесса приложения. Чтобы разрешить отладку приложения .NET с собственной среды выполнения исправления DLL, выберите типы управляемый и машинный код (Отладка в смешанном режиме).  

После настройки это, можно устанавливать точки останова к строкам кода, в коде приложения для настольных компьютеров и исправление проекта во время выполнения. Если нет исходного кода для приложения, можно задавать точки останова только к строкам кода в проекте исправления во время выполнения.

>[!NOTE]
> Visual Studio предоставляет простой разработки и отладки, существуют некоторые ограничения, поэтому далее в этом руководстве мы рассмотрим другие методы отладки, которые можно применить.

## <a name="create-a-runtime-fix"></a>Создание исправления во время выполнения

Если не существует еще среды выполнения устранить проблему, необходимо устранить, можно создать новое исправление во время выполнения путем написания функции замены и включая все данные конфигурации, имеет смысл. Давайте рассмотрим каждый компонент.

### <a name="replacement-functions"></a>Замена функции

Во-первых определите функции вызывает сбой при запуске приложения в контейнере MSIX. Затем можно создать функции замены, которые хотелось бы диспетчеру среды вместо вызова. Это дает возможность реализации функции замените поведение, которое соответствует правилам современных общеязыковой среды выполнения.

В Visual Studio откройте проект исправления общеязыковой среды выполнения, созданного ранее в этом руководстве.

Объявления ``SHIM_DEFINE_EXPORTS`` макрос и затем добавьте оператор include для `shim_framework.h` в верхней части каждого. Файл CPP, который планируется добавить функции исправления вашей среды выполнения.

```c++
#define SHIM_DEFINE_EXPORTS
#include <shim_framework.h>
```
>[!IMPORTANT]
>Убедитесь, что `SHIM_DEFINE_EXPORTS` макрос отображается перед инструкции include.

Создать функцию, которая имеет ту же сигнатуру функции кто имеет поведение, которую требуется изменить. Ниже приведен пример функции, которая заменяет `MessageBoxW` функции.

```c++
auto MessageBoxWImpl = &::MessageBoxW;
int WINAPI MessageBoxWShim(
    _In_opt_ HWND hwnd,
    _In_opt_ LPCWSTR,
    _In_opt_ LPCWSTR caption,
    _In_ UINT type)
{
    return MessageBoxWImpl(hwnd, L"SUCCESS: This worked", caption, type);
}

DECLARE_SHIM(MessageBoxWImpl, MessageBoxWShim);
```

Вызов `DECLARE_SHIM` сопоставляет `MessageBoxW` функции к новой функции замены. Когда приложение пытается вызвать `MessageBoxW` функции, он будет вызывать функцию замены вместо.

#### <a name="protect-against-recursive-calls-to-functions-in-runtime-fixes"></a>Защита от рекурсивных вызовов функций в среде выполнения исправления

При необходимости можно применить `reentrancy_guard` типа для функции, предотвращения рекурсивных вызовов функций в среде выполнения исправления.

Например, можно создать функцию замены для `CreateFile` функции. Реализация может вызывать `CopyFile` функция, но реализация `CopyFile` может вызвать функцию `CreateFile` функции. Это может привести к бесконечному рекурсивному цикла вызовов `CreateFile` функции.

Дополнительные сведения о `reentrancy_guard` [authoring.md](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/Authoring.md) см.

### <a name="configuration-data"></a>Данные конфигурации

Если необходимо добавить данные конфигурации среды выполнения исправление, рассмотрите возможность добавления в ``config.json``. Таким образом, можно использовать `ShimQueryCurrentDllConfig` легко анализировать данные. В этом примере выполняется разбор значения логического значения и строки в соответствующем файле конфигурации.

```c++
if (auto configRoot = ::ShimQueryCurrentDllConfig())
{
    auto& config = configRoot->as_object();

    if (auto enabledValue = config.try_get("enabled"))
    {
        g_enabled = enabledValue->as_boolean().get();
    }

    if (auto logPathValue = config.try_get("logPath"))
    {
        g_logPath = logPathValue->as_string().wstring();
    }
}
```

## <a name="other-debugging-techniques"></a>Другие методы отладки

Хотя Visual Studio предоставляет простой разработки и отладки, существуют некоторые ограничения.

Во-первых отладка F5 запускает приложение, вместо установки из пакета .appx развертывание свободные файлы из пути к папке макет пакета.  Макет папки обычно не имеет те же ограничения безопасности папки установленного пакета. В результате может оказаться невозможно воспроизвести ошибки отказ доступа путь пакета перед применением исправления во время выполнения.

Чтобы устранить эту проблему, используйте развертывание пакета .appx вместо F5 свободного файла развертывания.  Чтобы создать файл пакета .appx, программа [MakeAppx](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/make-appx-package--makeappx-exe-) из пакета Windows SDK, как описано выше. Или, из внутри Visual Studio, щелкните правой кнопкой мыши узел проекта приложения и выберите **магазин**->**Создание пакетов приложений**.

Еще одна проблема с Visual Studio, что он не имеет встроенной поддержки для присоединения все дочерние процессы, запущенные в отладчике.   Это затрудняет для отладки логики, выполняющаяся при запуске целевого приложения, который необходимо вручную присоединить с помощью Visual Studio после запуска.

Чтобы устранить эту проблему, следует Используйте отладчик, поддерживаемые дочерний процесс присоединения.  Обратите внимание, что обычно не позволяет присоединить отладчик just-in-time (JIT) к целевому приложению.  Это происходит потому, что большинство методов JIT включает запуск отладчика вместо целевого приложения через раздел реестра ImageFileExecutionOptions.  Это нарушает detouring механизм, используемый ShimLauncher.exe для вставки ShimRuntime.dll в основное приложение.  WinDbg, в состав [Средств отладки для Windows](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index), а также получить из [Пакета Windows SDK](https://developer.microsoft.com/en-US/windows/downloads/windows-10-sdk)поддерживает дочерний процесс присоединения.  Он также поддерживает непосредственно [запуска и отладки приложения UWP](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-a-uwp-app-using-windbg#span-idlaunchinganddebuggingauwpappspanspan-idlaunchinganddebuggingauwpappspanspan-idlaunchinganddebuggingauwpappspanlaunching-and-debugging-a-uwp-app).

Запустить отладку при запуске целевого приложения как дочерний процесс, ``WinDbg``.

```
windbg.exe -plmPackage PSFSampleWithFixup_1.0.59.0_x86__7s220nvg1hg3m -plmApp PSFSample
```

В ``WinDbg`` запрос, включения отладки дочерних и задавать точки останова.

```
.childdbg 1
g
```
(выполнение до конечное приложение запускается и переключается в режим отладчика)

```
sxe ld fixup.dll
g
```
(выполнение до исправления загрузки библиотеки DLL)

```
bp ...
```

>[!NOTE]
> [PLMDebug](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/plmdebug) также позволяет присоединить отладчик к приложению при запуске, а также в состав [Средств отладки для Windows](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index).  Тем не менее оно является более сложным в использовании, чем прямая поддержка теперь в WinDbg.

## <a name="support-and-feedback"></a>Поддержка и отзывы

**Поиск ответов на вопросы**

Есть вопросы? Задайте их на Stack Overflow. Наша команда следит за этими [тегами](http://stackoverflow.com/questions/tagged/project-centennial+or+desktop-bridge). Вы также можете задать нам вопросы [здесь](https://social.msdn.microsoft.com/Forums/en-US/home?filter=alltypes&sort=relevancedesc&searchTerm=%5BDesktop%20Converter%5D).
