---
Description: Исправить проблемы, препятствующие своего настольного приложения из выполнения MSIX контейнера
Search.Product: eADQiWindows 10XVcnh
title: Исправить проблемы, препятствующие своего настольного приложения из выполнения MSIX контейнера
ms.date: 07/02/2018
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 80f9c8bad9445bd9cfef9b09c00f99929fda37aa
ms.sourcegitcommit: b034650b684a767274d5d88746faeea373c8e34f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2019
ms.locfileid: "57590729"
---
# <a name="apply-runtime-fixes-to-an-msix-package-by-using-the-package-support-framework"></a>Применение исправлений для среды выполнения к пакету MSIX при помощи платформы пакета поддержки

Платформа поддержки пакета — пакету средств открытым исходным кодом, который служит для применения исправления в существующее приложение win32, если у вас нет доступа к исходному коду, могут выполняться в контейнере MSIX. Платформа поддержки пакетов помогает следуйте этим рекомендациям современных общеязыковой среды выполнения приложений.

Дополнительные сведения см. в разделе [платформа поддержки пакетов](https://docs.microsoft.com/windows/msix/package-support-framework-overview).

Это руководство поможет вам определить проблемы совместимости приложений, и для поиска, применить и расширения среды выполнения, исправления, устраните их.

<a id="identify" />

## <a name="identify-packaged-application-compatibility-issues"></a>Выявить проблемы совместимости упакованных приложений

Во-первых создайте пакет приложения. Затем установите его, запустите его и наблюдать за его поведением. Может появиться сообщения об ошибках, которые могут помочь выявить проблемы совместимости. Можно также использовать [Process Monitor](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) для выявления проблем.  Распространенные проблемы связаны с приложения предположения относительно разрешения пути рабочий каталог и программы.

### <a name="using-process-monitor-to-identify-an-issue"></a>С помощью Process Monitor, чтобы выявлять неполадки

[Process Monitor](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) — это мощная служебная программа для отслеживания файлов приложения и операции с реестром и их результаты.  Это поможет вам понять проблемы совместимости приложений.  После открытия Process Monitor, Добавление фильтра (Filter > Фильтр...) чтобы включались только события из исполняемый файл приложения.

![Фильтр приложения ProcMon](images/desktop-to-uwp/procmon_app_filter.png)

Появится список событий. Для многих из этих событий, слово **успех** будет отображаться в **результат** столбца.

![ProcMon события](images/desktop-to-uwp/procmon_events.png)

При необходимости можно фильтровать события по только сбоев.

![Исключить ProcMon успех](images/desktop-to-uwp/procmon_exclude_success.png)

Если вы подозреваете, сбой доступа к файловой системе, найдите события с ошибками, которые находятся под System32/SysWOW64 или путь к файлу пакета. Фильтры также здесь также может помочь. Запустите в нижней части списка и прокрутите вверх. Недавно произошли сбои, которые отображаются в нижней части списка. Обратите внимание большинство ошибок, которые содержат строки, такие как «доступ запрещен» и «путь и имя не найдено» и игнорировать вещи, которые выглядят как подозрительные. [PSFSample](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/samples/PSFSample/) есть две проблемы. Вы увидите эти проблемы в списке, который отображается на следующем рисунке.

![ProcMon Config.txt](images/desktop-to-uwp/procmon_config_txt.png)

Первая проблема, отображаемый в этот образ приложение не смог прочитать из файла «Config.txt», который находится в каталоге «C:\Windows\SysWOW64». Маловероятно, что приложение пытается напрямую ссылаться на этот путь. Скорее всего он пытается производить чтение из этого файла с помощью относительного пути, и по умолчанию «System32/SysWOW64» — рабочий каталог приложения. Это предполагает, что приложение ожидает его текущий рабочий каталог будет присвоено где-то в пакете. Глядя в AppX-файл, мы видим, что файл существует в том же каталоге, что и исполняемый файл.

![Приложение Config.txt](images/desktop-to-uwp/psfsampleapp_config_txt.png)

Вторая проблема появляется на следующем рисунке.

![Файл журнала ProcMon](images/desktop-to-uwp/procmon_logfile.png)

В этом выпуске приложения не смог написать файл .log путь к каталогу пакета. Это предположить, что может помочь адресную привязку перенаправления файла.

<a id="find" />

## <a name="find-a-runtime-fix"></a>Найти исправление среды выполнения

Инструмент содержит исправления среды выполнения, которые можно использовать прямо сейчас, такие как перенаправление файл адресная привязка.

### <a name="file-redirection-fixup"></a>Файл исправления перенаправления

Можно использовать [адресной привязки перенаправления файла](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/master/fixups/FileRedirectionFixup) для перенаправления попытки записи или чтения данных в каталоге, не доступны из приложения, которое выполняется в контейнере MSIX.

Например, если приложение записывает в файл журнала, который находится в том же каталоге, что и исполняемый файл приложения, затем можно использовать [адресной привязки перенаправления файла](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/master/fixups/FileRedirectionFixup) для создания данного файла журнала в другое расположение, например хранилище данных локального приложения.

### <a name="runtime-fixes-from-the-community"></a>Среда выполнения исправления от сообщества

Не забудьте проверить материалы сообщества, чтобы наши [GitHub](https://github.com/Microsoft/MSIX-PackageSupportFramework) страницы. Вполне возможно, что другие разработчики устранили проблему сходные с вашими и общий доступ к среде выполнения исправления.

## <a name="apply-a-runtime-fix"></a>Исправление, среда выполнения

Можно применить средство среды выполнения с помощью нескольких простых средств из пакета SDK для Windows и выполнив следующие действия.

> [!div class="checklist"]
> * Создание папки макета пакета
> * Получение файлов, поддерживающая Структура пакета
> * Добавить их в пакет
> * Изменение манифеста пакета
> * Создание файла конфигурации

Давайте разберем каждой задачи.

### <a name="create-the-package-layout-folder"></a>Создайте папку макета пакета

Если уже имеется файл .msix (или AppX), можно распаковать его содержимое в папку макета, который будет использоваться в качестве промежуточной области для пакета. Это можно сделать из командной строки с помощью средства MakeAppx, в зависимости от способа установки пакета SDK, это, где вы найдете средство makeappx.exe компьютера с Windows 10: x86: \Windows Kits\10\bin\x86\makeappx.exe файлы (x86) C:\Program x64: C:\Program файлы (x86) \Windows Kits\10\bin\x64\makeappx.exe

```ps
makeappx unpack /p PSFSamplePackage_1.0.60.0_AnyCPU_Debug.msix /d PackageContents

```

Это даст вам то, что выглядит следующим образом.

![Макет пакета](images/desktop-to-uwp/package_contents.png)

Если у вас нет файла .msix (или AppX) для начала, можно создать папки пакета и файлов с нуля.

### <a name="get-the-package-support-framework-files"></a>Получение файлов, поддерживающая Структура пакета

Пакет Nuget Инструмент можно получить с помощью средства командной строки Nuget автономного или с помощью Visual Studio.

#### <a name="get-the-package-by-using-the-command-line-tool"></a>Получение пакета с помощью средства командной строки

Установите средство командной строки Nuget из этого расположения: https://www.nuget.org/downloads. Затем из командной строки Nuget, выполните следующую команду:

```ps
nuget install Microsoft.PackageSupportFramework
```

#### <a name="get-the-package-by-using-visual-studio"></a>Получение пакета с помощью Visual Studio

В Visual Studio щелкните правой кнопкой мыши узел вашего решения или проекта и выберите одну из команд, управление пакетами Nuget.  Поиск **Microsoft.PackageSupportFramework** или **Инструмент** поиска пакета на сайте Nuget.org. Затем установите его.

### <a name="add-the-package-support-framework-files-to-your-package"></a>Добавьте файлы в пакет поддержки Framework пакета

Добавьте необходимые библиотеки DLL 32-разрядных и 64-разрядных Инструмент и исполняемые файлы в каталог пакета. Руководствуйтесь следующей таблицей. Также нужно будет включать все исправления среды выполнения, которые необходимы. В нашем примере мы должны исправления файла среды выполнения перенаправления.

| Исполняемый файл приложения является x64 | Исполняемый файл приложения является x86 |
|-------------------------------|-----------|
| [PSFLauncher64.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/master/PsfLauncher/readme.md) |  [PSFLauncher32.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/master/PsfLauncher/readme.md) |
| [PSFRuntime64.dll](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/master/PsfRuntime/readme.md) | [PSFRuntime32.dll](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/master/PsfRuntime/readme.md) |
| [PSFRunDll64.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/PsfRunDll/readme.md) | [PSFRunDll32.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/PsfRunDll/readme.md) |

Пакет содержимого должен выглядеть примерно следующим образом.

![Двоичные файлы пакета](images/desktop-to-uwp/package_binaries.png)

### <a name="modify-the-package-manifest"></a>Изменение манифеста пакета

Откройте манифест пакета в текстовом редакторе, а затем задайте `Executable` атрибут `Application` элемент имя исполняемого файла средства запуска Инструмент.  Если вы знаете архитектуру целевого приложения, выберите нужную версию, PSFLauncher32.exe или PSFLauncher64.exe.  В противном случае PSFLauncher32.exe будет работать во всех случаях.  Рассмотрим пример.

```xml
<Package ...>
  ...
  <Applications>
    <Application Id="PSFSample"
                 Executable="PSFLauncher32.exe"
                 EntryPoint="Windows.FullTrustApplication">
      ...
    </Application>
  </Applications>
</Package>
```

### <a name="create-a-configuration-file"></a>Создание файла конфигурации

Создать имя файла ``config.json``и сохраните этот файл в корневую папку пакета. Измените объявленный Идентификатору в файле config.json указывал на исполняемый файл, который вы только что заменили. С помощью знания, полученные с помощью Process Monitor, вы можно также настроить рабочий каталог, а также использовать перенаправление адресная привязка файла для перенаправления операций чтения и записи файлов log в каталоге «PSFSampleApp» зависящий от пакета.

```json
{
    "applications": [
        {
            "id": "PSFSample",
            "executable": "PSFSampleApp/PSFSample.exe",
            "workingDirectory": "PSFSampleApp/"
        }
    ],
    "processes": [
        {
            "executable": "PSFSample",
            "fixups": [
                {
                    "dll": "FileRedirectionFixup.dll",
                    "config": {
                        "redirectedPaths": {
                            "packageRelative": [
                                {
                                    "base": "PSFSampleApp/",
                                    "patterns": [
                                        ".*\\.log"
                                    ]
                                }
                            ]
                        }
                    }
                }
            ]
        }
    ]
}
```

Вот руководство по схеме config.json:

| Массив | key | Значение |
|-------|-----------|-------|
| Приложения | id |  Используйте значение `Id` атрибут `Application` элемента в манифесте пакета. |
| Приложения | исполняемый файл | Путь относительно пакета исполняемый файл, который требуется запустить. В большинстве случаев это значение можно получить из файла манифеста пакета перед внесением изменений. Это значение `Executable` атрибут `Application` элемента. |
| Приложения | WorkingDirectory | (Необязательно) Путь относительно пакета для использования в качестве приложения, которое запускает рабочий каталог. Если это значение не задано, операционная система использует `System32` каталог в качестве рабочего каталога приложения. |
| процессы | исполняемый файл | В большинстве случаев это будет имя `executable` настроенных выше с расширением путь к файлу и удалены. |
| исправления | библиотеки DLL | Путь, зависящий от пакета с адресной привязкой,.msix/.appx для загрузки. |
| исправления | конфигурации | (Необязательно) Определяет, как ведет себя dl адресной привязки. Точный формат этого значения зависит по принципу исправление, исправление, как каждого исправления может интерпретировать «blob», насколько это требуется. |

`applications`, `processes`, И `fixups` ключи являются массивами. Это означает, что можно использовать файл config.json указание более одного приложения, процессами и адресная привязка библиотеки DLL.

### <a name="package-and-test-the-app"></a>Пакет и протестируйте приложение

Создайте пакет.

```ps
makeappx pack /d PackageContents /p PSFSamplePackageFixup.msix
```

Затем подписать его.

```ps
signtool sign /a /v /fd sha256 /f ExportedSigningCertificate.pfx PSFSamplePackageFixup.msix
```

Дополнительные сведения см. в разделе [как создать сертификат для подписи пакетов](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/how-to-create-a-package-signing-certificate) и [том, как подписать пакет с помощью signtool](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/how-to-sign-a-package-using-signtool)

С помощью PowerShell, установите пакет.

>[!NOTE]
> Не забудьте сначала удалить пакет.

```ps
powershell Add-AppPackage .\PSFSamplePackageFixup.msix
```

Запустите приложение и понаблюдайте за поведением с применить исправление среды выполнения.  Повторите этапы упаковки при необходимости и диагностики.

### <a name="use-the-trace-fixup"></a>Использование трассировки адресная привязка

Альтернативный способ для диагностики проблем совместимости упакованных приложений является использование трассировки адресная привязка. Эта библиотека DLL входит в состав Инструмент и предоставляет подробные диагностические поведение приложения, аналогичную Process Monitor.  Он специально позволяет выявить проблемы совместимости приложений.  Для использования трассировки адресная привязка, добавить DLL-ФАЙЛ пакета, добавьте следующий фрагмент в config.json и затем упаковать и установить приложение.

```json
{
    "dll": "TraceFixup.dll",
    "config": {
        "traceLevels": {
            "filesystem": "allFailures"
        }
    }
}
```

По умолчанию адресная привязка трассировки отфильтровывает сбоев, которые могут считаться «ожидалось».  Например приложения может попытаться безусловно удаление файла без проверки, если он уже существует, игнорируя результат. Это оказывает вследствие сожалению, некоторые непредвиденные сбои могут получить с помощью фильтра, поэтому в приведенном выше примере мы решили всех ошибок приема из функций файловой системы. Это делается так как мы знаем из прежде, чем попытка чтения из файла Config.txt выдает сообщение «файл не найден». Это, часто наблюдаемая и предполагается, что обычно не непредвиденная ошибка. На практике это скорее всего, лучше всего для начала фильтрации только в случае неожиданных сбоев и затем возврат к все ошибки, если имеется проблема, которая по-прежнему не удается определить.

По умолчанию выходные данные трассировки адресная привязка отправляется к подключенному отладчику. В этом примере мы не присоединит отладчик и вместо этого будет использовать [DebugView](https://docs.microsoft.com/en-us/sysinternals/downloads/debugview) программы от компании SysInternals для просмотра его выходных данных. После запуска приложения, мы видим те же ошибки как и раньше, который направил бы нам к тем же исправления среды выполнения.

![Не найден файл TraceShim](images/desktop-to-uwp/traceshim_filenotfound.png)

![Отказано в доступе TraceShim](images/desktop-to-uwp/traceshim_accessdenied.png)

## <a name="debug-extend-or-create-a-runtime-fix"></a>Отладка, расширение или создание исправление среды выполнения

Visual Studio можно использовать для отладки исправление среды выполнения, расширить исправление среды выполнения или создать новый. Необходимо выполнить следующие действия для успешного выполнения.

> [!div class="checklist"]
> * Добавить проект упаковки
> * Добавление проекта для исправления среды выполнения
> * Добавить проект, который запускает Инструмент средство запуска исполняемого файла
> * Настроить проект упаковки

Когда все будет готово, ваше решение будет выглядеть примерно следующим образом.

![Готового решения](images/desktop-to-uwp/runtime-fix-project-structure.png)

Давайте взглянем на каждый проект в этом примере.

| Проект | Описание |
|-------|-----------|
| DesktopApplicationPackage | Этот проект основан на [проект упаковки приложений Windows](desktop-to-uwp-packaging-dot-net.md) и он выводит MSIX пакета. |
| Runtimefix | Это проект C++ Dynamic-Linked библиотеки, которая содержит одну или несколько функций замены, которые служат для выполнения исправления. |
| PSFLauncher | Это пустой проект C++. Этот проект — это место для сбора файлов среды выполнения распространяемого пакета поддержки платформы. Он выводит исполняемый файл. Этот исполняемый файл — это первое, что выполняется при запуске решения. |
| WinFormsDesktopApplication | Этот проект содержит исходный код для настольного приложения. |

Чтобы просмотреть полный пример, в котором содержатся все из этих типов проектов, см. в разделе [PSFSample](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/samples/PSFSample/).

Давайте рассмотрим шаги, чтобы создать и настроить каждый из этих проектов в решении.

### <a name="create-a-package-solution"></a>Создание пакета решения

Если у вас нет решения для своего настольного приложения, создайте новый **пустое решение** в Visual Studio.

![Пустое решение](images/desktop-to-uwp/blank-solution.png)

Вы также можете добавить все проекты приложения, которые у вас есть.

### <a name="add-a-packaging-project"></a>Добавить проект упаковки

Если у вас нет **проект упаковки приложений Windows**, создайте ее и добавьте его в решение.

![Шаблон проекта пакета](images/desktop-to-uwp/package-project-template.png)

Дополнительные сведения о проект упаковки приложений Windows, см. в разделе [упаковки приложения с помощью Visual Studio](desktop-to-uwp-packaging-dot-net.md).

В **обозревателе решений**, щелкните правой кнопкой мыши проект упаковки, выберите **изменить**, а затем добавьте это в нижней части файла проекта:

```xml
<Target Name="PSFRemoveSourceProject" AfterTargets="ExpandProjectReferences" BeforeTargets="_ConvertItems">
<ItemGroup>
  <FilteredNonWapProjProjectOutput Include="@(_FilteredNonWapProjProjectOutput)">
  <SourceProject Condition="'%(_FilteredNonWapProjProjectOutput.SourceProject)'=='<your runtime fix project name goes here>'" />
  </FilteredNonWapProjProjectOutput>
  <_FilteredNonWapProjProjectOutput Remove="@(_FilteredNonWapProjProjectOutput)" />
  <_FilteredNonWapProjProjectOutput Include="@(FilteredNonWapProjProjectOutput)" />
</ItemGroup>
</Target>
```

### <a name="add-project-for-the-runtime-fix"></a>Добавление проекта для исправления среды выполнения

Добавление C++ **библиотеки динамической компоновки (DLL)** проекта к решению.

![Исправление библиотеки времени выполнения](images/desktop-to-uwp/runtime-fix-library.png)

Щелкните правой кнопкой мыши, проекта, а затем выберите **свойства**.

На страницах свойств найти **стандартом языка C++** поле и выберите в раскрывающемся списке рядом с этого поля, **стандарт ISO C ++ 17 (/ std: c ++ 17)** параметр.

![ISO 17 параметр](images/desktop-to-uwp/iso-option.png)

Щелкните правой кнопкой мыши этот проект, а затем в контекстном меню выберите **управление пакетами Nuget** параметр. Убедитесь, что **источник пакета** параметру присваивается **все** или **nuget.org**.

Затем щелкните значок "Параметры" этого поля.

Поиск *Инструмент** Nuget пакета, а затем установить его для этого проекта.

![пакет NuGet](images/desktop-to-uwp/psf-package.png)

Если требуется выполнить отладку или расширить существующий средство среды выполнения, добавьте файлы исправление среды выполнения, полученные с помощью рекомендации, описанные в [найти исправление среды выполнения](#find) разделе данного руководства.

Если вы хотите создать совершенно новое исправление, ничего не добавляют к этому проекту пока что. Мы поможем вам добавить нужные файлы в этот проект, далее в этом руководстве. Пока мы продолжим настройку решения.

### <a name="add-a-project-that-starts-the-psf-launcher-executable"></a>Добавить проект, который запускает Инструмент средство запуска исполняемого файла

Добавление C++ **пустой проект** проекта к решению.

![Пустой проект](images/desktop-to-uwp/blank-app.png)

Добавить **Инструмент** пакет Nuget в проект с помощью же рекомендации, описанные в предыдущем разделе.

Откройте страницы свойств для проекта, а также в **Общие** задать на странице "Параметры" **имя целевого** свойства ``PSFLauncher32`` или ``PSFLauncher64`` в зависимости от архитектуры приложения.

![Справочник по запуска Инструмент](images/desktop-to-uwp/shim-exe-reference.png)

Добавьте ссылку на проект в проект исправление среды выполнения в решении.

![ссылка на исправление среды выполнения](images/desktop-to-uwp/reference-fix.png)

Щелкните правой кнопкой мыши ссылку, а затем в **свойства** окна, применять эти значения.

| Свойство | Значение |
|-------|-----------|
| Копировать локальные | True |
| Копировать локальные вспомогательные сборки | True |
| Выходные данные ссылочной сборки | True |
| Компоновать зависимости библиотек | False |
| Входные файлы зависимостей библиотек связи | False |

### <a name="configure-the-packaging-project"></a>Настроить проект упаковки

В проекте упаковки щелкните правой кнопкой мыши папку **Приложения** и выберите **Добавить ссылку**.

![Добавление ссылки на проект](images/desktop-to-uwp/add-reference-packaging-project.png)

Выберите проект запуска Инструмент и проект классического приложения, а затем выберите **ОК** кнопки.

![Проект классического приложения](images/desktop-to-uwp/package-project-references.png)

>[!NOTE]
> При отсутствии исходного кода в приложение, просто выберите Инструмент запуска проекта. Мы покажем, как создать ссылку исполняемого файла, при создании файла конфигурации.

В **приложений** узел, щелкните правой кнопкой мыши Инструмент запуска приложения, а затем выберите **задать как точку входа**.

![Задание точки входа](images/desktop-to-uwp/set-startup-project.png)

Добавьте в файл с именем ``config.json`` в проект упаковки, затем скопируйте и вставьте следующий текст json в файл. Задайте **действие пакета** свойства **содержимого**.

```json
{
    "applications": [
        {
            "id": "",
            "executable": "",
            "workingDirectory": ""
        }
    ],
    "processes": [
        {
            "executable": "",
            "fixups": [
                {
                    "dll": "",
                    "config": {
                    }
                }
            ]
        }
    ]
}
```

Укажите значение для каждого ключа. Используйте эту таблицу в качестве руководства.

| Массив | key | Значение |
|-------|-----------|-------|
| Приложения | id |  Используйте значение `Id` атрибут `Application` элемента в манифесте пакета. |
| Приложения | исполняемый файл | Путь относительно пакета исполняемый файл, который требуется запустить. В большинстве случаев это значение можно получить из файла манифеста пакета перед внесением изменений. Это значение `Executable` атрибут `Application` элемента. |
| Приложения | WorkingDirectory | (Необязательно) Путь относительно пакета для использования в качестве приложения, которое запускает рабочий каталог. Если это значение не задано, операционная система использует `System32` каталог в качестве рабочего каталога приложения. |
| процессы | исполняемый файл | В большинстве случаев это будет имя `executable` настроенных выше с расширением путь к файлу и удалены. |
| исправления | библиотеки DLL | Путь, зависящий от пакета исправления библиотеки DLL для загрузки. |
| исправления | конфигурации | (Необязательно) Определяет, как ведет себя адресная привязка библиотеки DLL. Точный формат этого значения зависит по принципу исправление, исправление, как каждого исправления может интерпретировать «blob», насколько это требуется. |

Когда закончите, ваш ``config.json`` файла будет выглядеть следующим образом.

```json
{
  "applications": [
    {
      "id": "DesktopApplication",
      "executable": "DesktopApplication/WinFormsDesktopApplication.exe",
      "workingDirectory": "WinFormsDesktopApplication"
    }
  ],
  "processes": [
    {
      "executable": ".*App.*",
      "fixups": [ { "dll": "RuntimeFix.dll" } ]
    }
  ]
}

```

>[!NOTE]
> `applications`, `processes`, И `fixups` ключи являются массивами. Это означает, что можно использовать файл config.json указание более одного приложения, процессами и адресная привязка библиотеки DLL.

### <a name="debug-a-runtime-fix"></a>Отладка исправление среды выполнения

В Visual Studio нажмите клавишу F5 для запуска отладчика.  Первое, что начинается является запуск приложения Инструмент, который в свою очередь, запускает своего настольного приложения в целевой.  Чтобы отладить приложение рабочего стола, вы должны вручную присоединить к процессу классическое приложение, выбрав **Отладка**->**присоединение к процессу**и затем выбрав приложение процесс. Чтобы разрешить отладку приложения .NET с собственной среды выполнения исправление библиотеки DLL, выберите типы управляемого и машинного кода (Отладка в смешанном режиме).  

После настройки это, можно задать точки останова рядом с строк кода в код приложения рабочего стола и исправление проект среды выполнения. При отсутствии исходного кода в приложение, вы сможете задать точки останова только к строкам кода в проекте исправление среды выполнения.

>[!NOTE]
> Хотя Visual Studio предоставляет простой разработки и отладки, существуют некоторые ограничения, поэтому далее в этом руководстве мы обсудим другие методы отладки, которые можно применить.

## <a name="create-a-runtime-fix"></a>Создать исправление среды выполнения

Если не существует, но среды выполнения устранить проблемы, что вы хотите разрешить, можно создать новое исправление среды выполнения путем написания замещающих функций и включая любые данные конфигурации, имеет смысл. Давайте взглянем на каждой части.

### <a name="replacement-functions"></a>Функции замены

Сначала определите, какая функция вызывает сбой при запуске приложения в контейнере MSIX. Затем можно создать замещающих функций, которые вы хотите вызвать вместо этого диспетчер среды выполнения. Это дает возможность заменить реализацию функции, поведение, которое соответствует правилам современных общеязыковой среды выполнения.

В Visual Studio откройте проект исправление среды выполнения, созданный ранее в этом руководстве.

Объявите ``FIXUP_DEFINE_EXPORTS`` макрос и затем добавьте оператор include для `fixup_framework.h` в верхней части каждого. CPP-файл, где планируется добавить функции среды выполнения исправления.

```c++
#define FIXUP_DEFINE_EXPORTS
#include <fixup_framework.h>
```

>[!IMPORTANT]
>Убедитесь, что `FIXUP_DEFINE_EXPORTS` макрос появляется перед инструкцией include.

Создайте функцию, которая имеет ту же сигнатуру функции, имеет поведение, необходимо изменить. Ниже приведен пример функции, которая заменяет `MessageBoxW` функции.

```c++
auto MessageBoxWImpl = &::MessageBoxW;
int WINAPI MessageBoxWFixup(
    _In_opt_ HWND hwnd,
    _In_opt_ LPCWSTR,
    _In_opt_ LPCWSTR caption,
    _In_ UINT type)
{
    return MessageBoxWImpl(hwnd, L"SUCCESS: This worked", caption, type);
}

DECLARE_FIXUP(MessageBoxWImpl, MessageBoxWFixup);
```

Вызов `DECLARE_FIXUP` сопоставляет `MessageBoxW` функцию для новой функции замены. Когда приложение пытается вызвать `MessageBoxW` функции, он будет вызывать функцию замены вместо этого.

#### <a name="protect-against-recursive-calls-to-functions-in-runtime-fixes"></a>Защититься от рекурсивных вызовов функций в среде выполнения исправления

При необходимости можно применить `reentrancy_guard` типа для функций, которые служат для рекурсивных вызовов функций в среде выполнения исправления.

Например, вы создаете функцию замены для `CreateFile` функции. Реализация может вызывать `CopyFile` функция, но реализация `CopyFile` функция может вызывать `CreateFile` функции. Это может привести к бесконечному рекурсивному цикла вызовов `CreateFile` функции.

Дополнительные сведения о `reentrancy_guard` см. в разделе [authoring.md](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/Authoring.md)

### <a name="configuration-data"></a>Данные конфигурации

Если вы хотите добавить конфигурации среды выполнения исправления, рассмотрите возможность добавления его в ``config.json``. Таким образом, вы можете использовать `FixupQueryCurrentDllConfig` легко проанализировать эти данные. В этом примере анализирует типы boolean и string значение из этого файла конфигурации.

```c++
if (auto configRoot = ::FixupQueryCurrentDllConfig())
{
    auto& config = configRoot->as_object();

    if (auto enabledValue = config.try_get("enabled"))
    {
        g_enabled = enabledValue->as_boolean().get();
    }

    if (auto logPathValue = config.try_get("logPath"))
    {
        g_logPath = logPathValue->as_string().wstring();
    }
}
```

## <a name="other-debugging-techniques"></a>Другие функции отладки

Во время Visual Studio вы получаете простой разработки и отладки, существуют некоторые ограничения.

Во-первых, отладку по клавише F5 запускает приложение, развертывание свободные файлы из папки путь макета пакета, а не выполнять установку из .msix / AppX-пакета.  Папки макета обычно не имеет те же ограничения безопасности папки установленного пакета. Таким образом воспроизвести ошибки отказ доступа путь пакета до применения исправления среды выполнения не возможно.

Чтобы устранить эту проблему, используйте .msix / .appx пакет развертывания, а не F5 свободный файл развертывания.  Чтобы создать .msix / пакета AppX-файл, используйте [MakeAppx](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/make-appx-package--makeappx-exe-) служебной программы из пакета SDK Windows, как описано выше. Либо, в Visual Studio щелкните правой кнопкой мыши узел проекта приложения и выберите **Store**->**создание пакетов приложения**.

Еще одна проблема с Visual Studio — в том, что она имеет встроенную поддержку для присоединения к любые дочерние процессы, запущенные отладчиком.   Это затрудняет для отладки логики, выполняющаяся при запуске целевого приложения, которое должно быть вручную присоединено с помощью Visual Studio после запуска.

Чтобы устранить эту проблему, используйте отладчик, который поддерживает дочерний процесс присоединения.  Обратите внимание на то, что он не обычно позволяют подключить just-in-time (JIT) отладчик к целевому приложению.  Это, так как большинство методов JIT включают запуск отладчика вместо целевого приложения, с помощью раздела реестра ImageFileExecutionOptions.  Это противоречит detouring механизм, используемый PSFLauncher.exe для вставки FixupRuntime.dll на целевое приложение.  WinDbg, включенные в [средства отладки для Windows](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index), полученными из [пакета Windows SDK](https://developer.microsoft.com/en-US/windows/downloads/windows-10-sdk), присоединение поддерживает дочернего процесса.  Он также поддерживает непосредственно [запуска и отладки приложения UWP](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-a-uwp-app-using-windbg#span-idlaunchinganddebuggingauwpappspanspan-idlaunchinganddebuggingauwpappspanspan-idlaunchinganddebuggingauwpappspanlaunching-and-debugging-a-uwp-app).

Чтобы выполнить отладку запуска приложения целевой как дочерний процесс, запустите ``WinDbg``.

```ps
windbg.exe -plmPackage PSFSampleWithFixup_1.0.59.0_x86__7s220nvg1hg3m -plmApp PSFSample
```

В ``WinDbg`` введите команду Включить отладку дочерних и задавать точки останова.

```ps
.childdbg 1
g
```

(выполнено, пока целевое приложение запускается и переключается в режим отладчика)

```ps
sxe ld fixup.dll
g
```

(выполняются до исправление, которое при загрузке библиотеки DLL)

```ps
bp ...
```

>[!NOTE]
> [PLMDebug](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/plmdebug) также позволяют подключить отладчик к приложению при запуске, а также включается в [средства отладки для Windows](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index).  Тем не менее это сложнее в использовании, чем прямое поддержке теперь в WinDbg.

## <a name="support-and-feedback"></a>Поддержка и отзывы

**Найдите ответы на ваши вопросы**

Есть вопросы? Задайте их на Stack Overflow. Наша команда следит за этими [тегами](https://stackoverflow.com/questions/tagged/project-centennial+or+desktop-bridge). Вы также можете задать нам вопросы [здесь](https://social.msdn.microsoft.com/Forums/en-US/home?filter=alltypes&sort=relevancedesc&searchTerm=%5BDesktop%20Converter%5D).
