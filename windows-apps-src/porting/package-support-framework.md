---
author: hickeys
Description: Fix issues that prevent your desktop application from running in an MSIX container
Search.Product: eADQiWindows 10XVcnh
title: Устранение проблем, которые не классического приложения от запуска в контейнере MSIX
ms.author: hickeys
ms.date: 07/02/2018
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: fe869cee0d59eb099e3cb828dfee4eccd27a56ae
ms.sourcegitcommit: 93c0a60cf531c7d9fe7b00e7cf78df86906f9d6e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/22/2018
ms.locfileid: "7578018"
---
# <a name="apply-runtime-fixes-to-an-msix-package-by-using-the-package-support-framework"></a>Применение исправлений среды выполнения для пакета MSIX с помощью платформа поддержки пакетов

Платформа поддержки пакета — комплекту с открытым исходным кодом, который помогает вам применение исправлений существующие приложения win32 при нет доступа к исходный код, чтобы оно могло выполняться в контейнере MSIX. Платформа поддержки пакетов помогает следуйте рекомендациям среды современные среды выполнения приложения.

Дополнительные сведения см. в разделе [Платформа поддержки пакетов](https://docs.microsoft.com/windows/msix/package-support-framework-overview).

Это руководство поможет вам для идентификации проблем совместимости приложений, и для поиска, применения и расширение среды выполнения исправления, их устранения.

<a id="identify" />

## <a name="identify-packaged-application-compatibility-issues"></a>Определяем проблемы совместимости, упакованного приложения

Во-первых создайте пакет для вашего приложения. Затем, установите его, запустить его и проверка его поведения. Может появиться сообщения об ошибках, которые помогают выявить проблемы совместимости. Можно также использовать [Монитор процессов](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) по выявлению проблем.  Распространенные проблемы связаны с приложения предположения относительно разрешения рабочий каталог и программа пути.

### <a name="using-process-monitor-to-identify-an-issue"></a>С помощью монитора процесс для идентификации проблемы

[Монитор процессов](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) — это мощное служебная программа для наблюдение файл приложения и операций реестра и их результаты.  Это может помочь вам понять проблем совместимости приложений.  После открытия монитор процессов, добавьте фильтр (фильтр > Фильтр …) для включения только события из исполняемый файл приложения.

![Фильтр ProcMon приложения](images/desktop-to-uwp/procmon_app_filter.png)

Появится список событий. Для многих из этих событий слово **Успех** будет отображаться в столбце **результат** .

![События ProcMon](images/desktop-to-uwp/procmon_events.png)

При необходимости вы можете отфильтровать события, чтобы отображать только сбоев.

![Успех ProcMon Exclude](images/desktop-to-uwp/procmon_exclude_success.png)

Если вы подозреваете ошибки доступа файловой системы, поиск сбой события, которые относятся к System32/SysWOW64 или путь к файлу пакета. Фильтры также поможет здесь слишком. Запустите в нижней части этого списка и прокрутку вверх. Недавно произошли ошибки, которые отображаются в нижней части этого списка. Обратите внимание, большинство ошибок, которые содержать строки, такие как «доступ запрещен» и «путь/имя не найдено» и игнорировать вещей, которые выглядят как подозрительные. [PSFSample](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/samples/PSFSample/) имеет два проблемы. Вы можете увидеть эти проблемы в списке, который отображается на следующем рисунке.

![ProcMon Config.txt](images/desktop-to-uwp/procmon_config_txt.png)

В первом проблема, которая отображается в это изображение приложения происходит сбой для чтения из файла «Config.txt», который находится в папке «C:\Windows\SysWOW64». Маловероятно, что приложение пытается ссылаться на этот путь напрямую. Скорее всего его пытаются чтение из этого файла с помощью относительный путь, и по умолчанию «System32/SysWOW64» является рабочий каталог приложения. Это предполагает, что приложение ожидает его текущий рабочий каталог для значение где-то в пакете. Ищете внутри appx, мы видим, что файл существует в том же каталоге, что и исполняемый файл.

![Config.txt приложения](images/desktop-to-uwp/psfsampleapp_config_txt.png)

Вторая проблема отображается на следующем рисунке.

![Файл журнала ProcMon](images/desktop-to-uwp/procmon_logfile.png)

В этом выпуске приложения происходит сбой для записи файл журнала его путь к пакету. Это предположить, что исправление перенаправления файл может помочь.

<a id="find" />

## <a name="find-a-runtime-fix"></a>Найдите исправление среды выполнения

Инструмент содержит исправлений среды выполнения, которые можно использовать прямо сейчас, такие как исправить перенаправления файла.

### <a name="file-redirection-fixup"></a>Исправить перенаправление файла

[Исправить перенаправления файл](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/master/fixups/FileRedirectionFixup) можно использовать для перенаправления попытки записи или чтения данных в каталоге, который не доступен из приложения, которое выполняется в контейнере MSIX.

Например если приложение записывает в файл журнала, который находится в том же каталоге приложения исполняемый, [Исправить перенаправления файл](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/master/fixups/FileRedirectionFixup) можно использовать для создания этого файла журнала в другом месте, таких как локальное хранилище данных приложения.

### <a name="runtime-fixes-from-the-community"></a>Исправлений среды выполнения от сообщества

Не забудьте изучить взносы сообщества на нашу страницу [GitHub](https://github.com/Microsoft/MSIX-PackageSupportFramework) . Это возможно, что другие разработчики была устранена проблема, сходные с вашими и предоставили исправление среды выполнения.

## <a name="apply-a-runtime-fix"></a>Применение исправлений среды выполнения

Можно применить существующий исправление среды выполнения с помощью несколько простых средств из пакета Windows SDK и, выполнив следующие действия.

> [!div class="checklist"]
> * Создайте папку макета пакета
> * Получение файлов платформа поддержки пакетов
> * Добавление их в пакет
> * Изменение манифеста пакета
> * Создание файла конфигурации

Давайте пройти все задачи.

### <a name="create-the-package-layout-folder"></a>Создайте папку макета пакета

Если у вас уже есть файл .msix (или AppX-файл), можно распаковать его содержимое в папку макета, который будет служить промежуточной области для пакета. Это можно сделать из командной строки с помощью средства makemsix, зависит от пути установки пакета SDK, это, где вы найдете средства makemsix.exe свой компьютер с Windows 10: x86: C:\Program Files (x86) \Windows Kits\10\bin\x86\makemsix.exe x64: C:\Program Files () x86) \Windows Kits\10\bin\x64\makemsix.exe

```ps
makemsix unpack /p PSFSamplePackage_1.0.60.0_AnyCPU_Debug.msix /d PackageContents

```

Это даст вам то, что выглядит следующим образом.

![Макет пакета](images/desktop-to-uwp/package_contents.png)

Если у вас нет .msix (или .appx) файл начать с, можно создать папку пакета и файлы с нуля.

### <a name="get-the-package-support-framework-files"></a>Получение файлов платформа поддержки пакетов

Вы можете получить пакет Nuget Инструмент, с помощью средства командной строки Nuget автономный или с помощью Visual Studio.

#### <a name="get-the-package-by-using-the-command-line-tool"></a>Получите пакет с помощью средства командной строки

Установить средство командной строки Nuget из этого расположения: https://www.nuget.org/downloads. Из командной строки Nuget, выполните следующую команду:

```ps
nuget install Microsoft.PackageSupportFramework
```

#### <a name="get-the-package-by-using-visual-studio"></a>Получите пакет с помощью Visual Studio

В Visual Studio щелкните правой кнопкой мыши узел вашего решения или проекта и выберите одну из команд Управление пакетами Nuget.  Поиск **Microsoft.PackageSupportFramework** или **Инструмент** поиска пакета Nuget.org. Затем установите его.

### <a name="add-the-package-support-framework-files-to-your-package"></a>Добавление в пакет файлов пакета поддержки Framework

Добавьте необходимые 32-разрядные и 64-разрядных Инструмент DLL-файлы и исполняемые файлы в каталог пакета. Руководствуйтесь следующей таблицей. Также необходимо включить все исправлений среды выполнения, которые необходимо. В нашем примере нам нужно исправить файл перенаправления среды выполнения.

| Исполняемый файл приложения является x64 | Исполняемый файл приложения является x86 |
|-------------------------------|-----------|
| [PSFLauncher64.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/master/PsfLauncher/readme.md) |  [PSFLauncher32.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/master/PsfLauncher/readme.md) |
| [PSFRuntime64.dll](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/master/PsfRuntime/readme.md) | [PSFRuntime32.dll](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/master/PsfRuntime/readme.md) |
| [PSFRunDll64.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/PsfRunDll/readme.md) | [PSFRunDll32.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/PsfRunDll/readme.md) |

Содержимое пакета теперь должен выглядеть примерно следующим образом.

![Двоичные файлы пакета](images/desktop-to-uwp/package_binaries.png)

### <a name="modify-the-package-manifest"></a>Изменение манифеста пакета

Откройте манифест пакета в текстовом редакторе, а затем установите `Executable` атрибут `Application` элемента к имени Инструмент запуска исполняемого файла.  Если вы знаете архитектуре целевого приложения, выберите соответствующую версию, PSFLauncher32.exe или PSFLauncher64.exe.  В противном случае PSFLauncher32.exe будут работать во всех случаях.  Вот пример.

```xml
<Package ...>
  ...
  <Applications>
    <Application Id="PSFSample"
                 Executable="PSFLauncher32.exe"
                 EntryPoint="Windows.FullTrustApplication">
      ...
    </Application>
  </Applications>
</Package>
```

### <a name="create-a-configuration-file"></a>Создание файла конфигурации

Создать имя файла ``config.json``и сохраните этот файл в корневую папку пакета. Измените объявленного идентификатор config.json файла, чтобы указать исполняемый файл, который вы только что заменены на. С помощью знания, полученная в результате с помощью процесса монитора, вы можете также задать рабочий каталог как также использовать исправить перенаправления файла для перенаправления операций чтения и записи в файлы с расширением LOG package-relative в каталоге «PSFSampleApp».

```json
{
    "applications": [
        {
            "id": "PSFSample",
            "executable": "PSFSampleApp/PSFSample.exe",
            "workingDirectory": "PSFSampleApp/"
        }
    ],
    "processes": [
        {
            "executable": "PSFSample",
            "fixups": [
                {
                    "dll": "FileRedirectionFixup.dll",
                    "config": {
                        "redirectedPaths": {
                            "packageRelative": [
                                {
                                    "base": "PSFSampleApp/",
                                    "patterns": [
                                        ".*\\.log"
                                    ]
                                }
                            ]
                        }
                    }
                }
            ]
        }
    ]
}
```

Ниже приведена руководство по схеме config.json.

| Массив | key | Значение |
|-------|-----------|-------|
| Приложения | id |  Используйте значение `Id` атрибут `Application` в манифесте пакета. |
| Приложения | исполняемый | Пакет относительный путь исполняемого файла, который вы хотите начать. В большинстве случаев это значение можно получить из файл манифеста пакета перед внесением изменений. Это значение `Executable` атрибут `Application` элемента. |
| Приложения | workingDirectory | (Необязательно) Путь package-relative для использования в качестве рабочий каталог приложения, которое запускается. Если это значение не задано, операционная система использует `System32` каталог как рабочий каталог приложения. |
| процессы | исполняемый | В большинстве случаев это будет имя `executable` настроено выше с расширением путь и файл удален. |
| исправления | Библиотека DLL | Пакет относительный путь к исправить,.msix/.appx для загрузки. |
| исправления | конфигурации | (Необязательно) Элементы управления, как ведет себя рассылки исправить. Точный формат это значение зависит от на основе исправить, исправить как каждого исправления может интерпретировать этот «большой двоичный объект», так как оно будет. |

`applications`, `processes`, И `fixups` ключи являются массивами. Это означает, что можно использовать файл config.json более одного приложения, процесс и исправить DLL.

### <a name="package-and-test-the-app"></a>Пакет и тестирования приложения

Затем создайте пакет.

```ps
makeappx pack /d PackageContents /p PSFSamplePackageFixup.msix
```

Затем подпишите ее.

```ps
signtool sign /a /v /fd sha256 /f ExportedSigningCertificate.pfx PSFSamplePackageFixup.msix
```

Дополнительные сведения см. в разделе [как для создания сертификата для подписи пакета](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/how-to-create-a-package-signing-certificate) и [подписать пакет с помощью signtool](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/how-to-sign-a-package-using-signtool)

С помощью PowerShell, установите пакет.

>[!NOTE]
> Не забудьте сначала удаление пакета.

```ps
powershell Add-MSIXPackage .\PSFSamplePackageFixup.msix
```

Запустите приложение и наблюдения за поведением с применяется исправление среды выполнения.  Повторите шаги упаковки при необходимости и диагностики.

### <a name="use-the-trace-fixup"></a>Используйте исправить трассировки

Альтернативный метод для диагностики проблем совместимости с упакованного приложения является использование исправить трассировки. Эта библиотека DLL входит в состав Инструмент и предоставляет подробное представление диагностики поведения приложения, аналогично монитор процессов.  Специально предназначен для отображения проблем совместимости приложений.  Чтобы использовать исправить трассировки, добавить DLL-ФАЙЛ пакета, добавьте следующий фрагмент config.json и затем упаковывать и установить приложение.

```json
{
    "dll": "TraceFixup.dll",
    "config": {
        "traceLevels": {
            "filesystem": "allFailures"
        }
    }
}
```

По умолчанию исправить трассировки отфильтровывает ошибки, которые могут считаться «ожидается».  Например приложения могут попытаться безусловно удалять файл без проверить, если он уже существует, игнорируя результат. Это имеет сожалению вследствие, некоторые непредвиденных сбоев может получить отфильтрованы, поэтому в приведенном выше примере мы зарегистрироваться для получения всех сбоев из функций файловой системы. Это необходимо, так как мы знаем из перед, происходит сбой попытки для чтения из файла Config.txt с сообщения «файл не найден». Это происходит сбой, часто observed и предполагается, что обычно не Непредвиденная. На практике это скорее оптимальный вариант для запуска фильтрации только для непредвиденных сбоев и затем возврат к всплывающему все сбои при наличии проблемы, которые по-прежнему не удается определить.

По умолчанию выходных данных трассировки исправить отправляется в присоединенного отладчика. В этом примере мы не собираетесь присоединить отладчик и используйте вместо [DebugView](https://docs.microsoft.com/en-us/sysinternals/downloads/debugview) программа от компании SysInternals, чтобы просмотреть свой вывод. После запуска приложения, мы видим те же ошибки как и раньше, который будет указывать нам по направлению к же исправлений среды выполнения.

![Файл TraceShim не найден](images/desktop-to-uwp/traceshim_filenotfound.png)

![Отказано в доступе TraceShim](images/desktop-to-uwp/traceshim_accessdenied.png)

## <a name="debug-extend-or-create-a-runtime-fix"></a>Отладка, расширить или создать исправление среды выполнения

Visual Studio можно использовать для отладки исправление среды выполнения, расширение среды выполнения исправление или создать ее с нуля. Вам потребуется выполните следующие действия, чтобы добиться успеха.

> [!div class="checklist"]
> * Добавьте проект упаковки
> * Добавление проекта для выполнения исправления
> * Добавление проекта, который запускает исполняемый средства запуска Инструмент
> * Настройки проекта упаковки

Когда все будет готово, решение будет выглядеть следующим образом.

![Завершенное решение](images/desktop-to-uwp/runtime-fix-project-structure.png)

Давайте рассмотрим каждый проект в этом примере.

| Проект | Описание |
|-------|-----------|
| DesktopApplicationPackage | Этот проект основан на [проект упаковки приложения Windows](desktop-to-uwp-packaging-dot-net.md) , и оно выводит пакета MSIX. |
| Runtimefix | Это библиотека C++ Dynamic-Linked проект, который содержит одну или несколько функций замены, которые служат исправление среды выполнения. |
| PSFLauncher | Это пустой проект C++. Этот проект является местом для сбора файлов распространяемого среды выполнения платформы поддержки пакета. Он выводит исполняемого файла. Этот исполняемый файл — первое, который выполняется при запуске решения. |
| WinFormsDesktopApplication | Этот проект содержит исходный код классического приложения. |

Чтобы взглянуть на полный пример, который содержит все эти типы проектов, см. в разделе [PSFSample](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/samples/PSFSample/).

Рассмотрим шаги для создания и настройки каждого из этих проектов в вашем решении.

### <a name="create-a-package-solution"></a>Создайте пакет решение

Если вы не уже решение для классического приложения, создайте новое **Пустое решение** в Visual Studio.

![Пустое решение](images/desktop-to-uwp/blank-solution.png)

Кроме того, может потребоваться добавить любые приложения проектов у вас имеются.

### <a name="add-a-packaging-project"></a>Добавьте проект упаковки

Если у вас еще нет **Проект упаковки приложения для Windows**, создайте его и добавьте его в свое решение.

![Шаблон проекта пакета](images/desktop-to-uwp/package-project-template.png)

Дополнительные сведения о проект упаковки приложения Windows см. в разделе [пакета приложения с помощью Visual Studio](desktop-to-uwp-packaging-dot-net.md).

В **Обозревателе решений**щелкните правой кнопкой мыши проект упаковки, выберите **Изменить**и затем добавить в нижней части файла проекта:

```xml
<Target Name="PSFRemoveSourceProject" AfterTargets="ExpandProjectReferences" BeforeTargets="_ConvertItems">
<ItemGroup>
  <FilteredNonWapProjProjectOutput Include="@(_FilteredNonWapProjProjectOutput)">
  <SourceProject Condition="'%(_FilteredNonWapProjProjectOutput.SourceProject)'=='<your runtime fix project name goes here>'" />
  </FilteredNonWapProjProjectOutput>
  <_FilteredNonWapProjProjectOutput Remove="@(_FilteredNonWapProjProjectOutput)" />
  <_FilteredNonWapProjProjectOutput Include="@(FilteredNonWapProjProjectOutput)" />
</ItemGroup>
</Target>
```

### <a name="add-project-for-the-runtime-fix"></a>Добавление проекта для выполнения исправления

Добавьте в решение проект C++ **Библиотеки динамической компоновки (DLL)** .

![Библиотека времени выполнения исправления](images/desktop-to-uwp/runtime-fix-library.png)

Щелкните правой кнопкой мыши, проекта, а затем выберите **Свойства**.

На страницах свойств, найдите поле **Стандартный язык C++** , а затем в раскрывающемся списке рядом с этого поля, выберите **ISO C ++ 17 Standard (/ std: c ++ 17)** параметр.

![ISO 17 параметр](images/desktop-to-uwp/iso-option.png)

Щелкните правой кнопкой мыши проект и выберите в контекстном меню, параметр **Управление пакетами Nuget** . Убедитесь, что параметр **источник пакета** — это ко **всем** или **nuget.org**.

Щелкните значок «параметры», затем этого поля.

Найдите *Инструмент** Nuget пакет, а затем установите его для этого проекта.

![пакет NuGet](images/desktop-to-uwp/psf-package.png)

Если вы хотите отладки или расширить существующий исправление среды выполнения, добавьте файлы исправление среды выполнения, полученных с помощью рекомендации, описанные в разделе [найти исправление среды выполнения](#find) в этом руководстве.

Если вы планируете создавать новое исправление, ничего не добавляют в этот проект просто еще. Мы поможем вам добавлять нужные файлы в этот проект далее в этом руководстве. Сейчас мы продолжим настройку свое решение.

### <a name="add-a-project-that-starts-the-psf-launcher-executable"></a>Добавление проекта, который запускает исполняемый средства запуска Инструмент

Добавьте проект C++ **Пустой проект** в решение.

![Пустой проект](images/desktop-to-uwp/blank-app.png)

Добавьте пакет Nuget **Инструмент** этот проект с помощью же рекомендации, описанные в предыдущем разделе.

Откройте на страницах свойств проекта, а также в странице " **Общие** параметры", значение свойства **Имя целевого** ``PSFLauncher32`` или ``PSFLauncher64`` в зависимости от архитектуры приложения.

![Справочник по Инструмент запуска](images/desktop-to-uwp/shim-exe-reference.png)

Добавьте ссылку на проект исправление среды выполнения проект в вашем решении.

![исправление справке среды выполнения](images/desktop-to-uwp/reference-fix.png)

Щелкните правой кнопкой мыши ссылку, а затем в окне " **Свойства** " Примените эти значения.

| Свойство | Значение |
|-------|-----------|
| Копировать локальные | True |
| Копировать локально вспомогательные сборки | True |
| Выходные данные сборки ссылки | True |
| Использовать библиотеки из зависимостей | False |
| Входные данные зависимостей библиотеки ссылки | False |

### <a name="configure-the-packaging-project"></a>Настройки проекта упаковки

В проекте упаковки щелкните правой кнопкой мыши папку **Приложения** и выберите **Добавить ссылку**.

![Добавление ссылки на проект](images/desktop-to-uwp/add-reference-packaging-project.png)

Выберите проект запуска Инструмент и проект классического приложения, а затем нажмите кнопку « **ОК** ».

![Проект классического приложения](images/desktop-to-uwp/package-project-references.png)

>[!NOTE]
> Если для вашего приложения нет исходного кода, просто выберите Инструмент запуска проекта. Мы покажем, как для ссылки на ваш исполняемый файл при создании файла конфигурации.

В узел **приложения** щелкните правой кнопкой мыши Инструмент средства запуска приложений и выберите **задать в качестве точки входа**.

![Задание точки входа](images/desktop-to-uwp/set-startup-project.png)

Добавьте в файл с именем ``config.json`` в свой проект упаковки, затем скопируйте и вставьте следующий текст json в файл. Задайте свойство **Действия пакета** для **содержимого**.

```json
{
    "applications": [
        {
            "id": "",
            "executable": "",
            "workingDirectory": ""
        }
    ],
    "processes": [
        {
            "executable": "",
            "fixups": [
                {
                    "dll": "",
                    "config": {
                    }
                }
            ]
        }
    ]
}
```

Предоставляет значение для каждого ключа. Руководствуйтесь в этой таблице.

| Массив | key | Значение |
|-------|-----------|-------|
| Приложения | id |  Используйте значение `Id` атрибут `Application` в манифесте пакета. |
| Приложения | исполняемый | Пакет относительный путь исполняемого файла, который вы хотите начать. В большинстве случаев это значение можно получить из файл манифеста пакета перед внесением изменений. Это значение `Executable` атрибут `Application` элемента. |
| Приложения | workingDirectory | (Необязательно) Путь package-relative для использования в качестве рабочий каталог приложения, которое запускается. Если это значение не задано, операционная система использует `System32` каталог как рабочий каталог приложения. |
| процессы | исполняемый | В большинстве случаев это будет имя `executable` настроено выше с расширением путь и файл удален. |
| исправления | Библиотека DLL | Пакет относительный путь к исправить библиотеки DLL для загрузки. |
| исправления | конфигурации | (Необязательно) Элементы управления, как ведет себя исправить DLL. Точный формат это значение зависит от на основе исправить, исправить как каждого исправления может интерпретировать этот «большой двоичный объект», так как оно будет. |

Когда все будет готово, ваш ``config.json`` файл будет выглядеть примерно следующим образом.

```json
{
  "applications": [
    {
      "id": "DesktopApplication",
      "executable": "DesktopApplication/WinFormsDesktopApplication.exe",
      "workingDirectory": "WinFormsDesktopApplication"
    }
  ],
  "processes": [
    {
      "executable": ".*App.*",
      "fixups": [ { "dll": "RuntimeFix.dll" } ]
    }
  ]
}

```

>[!NOTE]
> `applications`, `processes`, И `fixups` ключи являются массивами. Это означает, что можно использовать файл config.json более одного приложения, процесс и исправить DLL.

### <a name="debug-a-runtime-fix"></a>Отладка исправление среды выполнения

В Visual Studio нажмите клавишу F5, чтобы запустить отладчик.  Первое, что запускает — это Инструмент запуска приложения, который в свою очередь, запускает целевой классического приложения.  Для отладки классического приложения целевого объекта, вам придется вручную присоединиться к процессу классического приложения, выбрав **Отладка**->**присоединиться к процессу**, а затем выбрав процесса приложения. Чтобы разрешить отладку приложения .NET с помощью среды выполнения собственной исправление DLL, выберите типы управляемый и машинный код (Отладка в смешанном режиме).  

После того как вы установите, точки прерывания рядом с строк кода можно задать в коде классического приложения и проекта исправление среды выполнения. Если у вас не исходный код в приложение, вы сможете задать точки прерывания только рядом с строк кода в проекте исправление среды выполнения.

>[!NOTE]
> Хотя Visual Studio предоставляет простой разработки и отладки взаимодействия, существуют некоторые ограничения, поэтому далее в этом руководстве мы обсудим другие методы отладки, которые можно применить.

## <a name="create-a-runtime-fix"></a>Создание исправление среды выполнения

Если не существует еще среды выполнения устранить проблемы, что вы хотите разрешить, можно создать новый исправление среды выполнения, написание замены функций и любые данные конфигурации в том числе, имеет смысл. Давайте взглянем на каждой части.

### <a name="replacement-functions"></a>Замена функции

Во-первых определите вызовы завершаться сбоем, если приложение выполняется в контейнере MSIX функций. Затем вы можете создать замены функции, которые вы хотите диспетчера среды выполнения для вызова вместо. Это дает возможность заменить поведение, которое соответствует правилам среды выполнения современных реализации функции.

В Visual Studio откройте проект исправление среды выполнения, созданный ранее в этом руководстве.

Объявите ``FIXUP_DEFINE_EXPORTS`` макрос, а затем добавьте оператор include для `fixup_framework.h` в верхней части каждой. Файл CPP, где вы планируете добавить в файл Default.js функции вашей среды выполнения исправления.

```c++
#define FIXUP_DEFINE_EXPORTS
#include <fixup_framework.h>
```

>[!IMPORTANT]
>Убедитесь, что `FIXUP_DEFINE_EXPORTS` макрос отображается перед инструкции include.

Создать функцию, которая имеет ту же подпись, функции, кто имеет поведение, вы хотите изменить. Ниже приведен пример функции, которая заменяет `MessageBoxW` функции.

```c++
auto MessageBoxWImpl = &::MessageBoxW;
int WINAPI MessageBoxWFixup(
    _In_opt_ HWND hwnd,
    _In_opt_ LPCWSTR,
    _In_opt_ LPCWSTR caption,
    _In_ UINT type)
{
    return MessageBoxWImpl(hwnd, L"SUCCESS: This worked", caption, type);
}

DECLARE_FIXUP(MessageBoxWImpl, MessageBoxWFixup);
```

Вызов `DECLARE_FIXUP` сопоставляет `MessageBoxW` функции к новой функции замены. Если приложение пытается вызвать `MessageBoxW` функции, он будет вызывать функцию замены вместо.

#### <a name="protect-against-recursive-calls-to-functions-in-runtime-fixes"></a>Защиту от рекурсивный вызовы функций в среде выполнения исправления

Вы можете при необходимости применить `reentrancy_guard` тип вашего функции, которые защиту от рекурсивный вызовы функций в исправлений среды выполнения.

Например, можно создать функцию для замены `CreateFile` функции. Реализация может вызывать `CopyFile` функции, но реализация `CopyFile` может вызвать функцию `CreateFile` функции. Это может привести к цикл бесконечное рекурсивный вызовов `CreateFile` функции.

Дополнительные сведения о `reentrancy_guard` см. в разделе [authoring.md](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/Authoring.md)

### <a name="configuration-data"></a>Данные конфигурации

Если вы хотите добавить данные конфигурации для вашей среды выполнения исправления, вы можете добавить его к ``config.json``. Таким образом, вы можете использовать `FixupQueryCurrentDllConfig` легко проанализировать эти данные. В этом примере анализирует логическое значение и строковое значение из этого файла конфигурации.

```c++
if (auto configRoot = ::FixupQueryCurrentDllConfig())
{
    auto& config = configRoot->as_object();

    if (auto enabledValue = config.try_get("enabled"))
    {
        g_enabled = enabledValue->as_boolean().get();
    }

    if (auto logPathValue = config.try_get("logPath"))
    {
        g_logPath = logPathValue->as_string().wstring();
    }
}
```

## <a name="other-debugging-techniques"></a>Другие методы отладки

Хотя Visual Studio предоставляет простой разработки и отладки взаимодействия, существуют некоторые ограничения.

Во-первых, отладки F5 запускает приложение путем развертывания свободных файлов из путь к папке макета пакета, а не Установка из .msix или пакета AppX.  Папка макета обычно не имеют те же ограничения безопасности как в папку установленного пакета. Таким образом воспроизвести пакетов путь доступа обслуживании ошибки до применение исправлений среды выполнения не возможно.

Чтобы устранить эту проблему, используйте .msix / развертывания пакета .appx, а не F5 свободных файлов развертывания.  Чтобы создать .msix или файл пакета .appx использовать служебную программу [MakeMSIX](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/make-appx-package--makeappx-exe-) из пакета Windows SDK, как описано выше. Или, из в Visual Studio, щелкните правой кнопкой мыши узел проекта приложения и выберите **хранилище**->**Создание пакетов приложения**.

Другая проблема с помощью Visual Studio является то, что он не встроенную поддержку для присоединения к любой дочерние процессы, запущенные в отладчике.   Это затрудняет для отладки логики в пути запуска целевого приложения, которое необходимо вручную подключить с помощью Visual Studio после запуска.

Чтобы решить эту проблему, используйте отладчику, который поддерживает дочерний процесс прикрепить.  Обратите внимание, что это обычно не можно прикрепить к целевого приложения отладчик just in time (JIT).  Это связано с большинством методов JIT предполагает запуск отладчика вместо целевого приложения, через раздел реестра ImageFileExecutionOptions.  Это препятствует detouring механизм, используемый PSFLauncher.exe, чтобы внедрить FixupRuntime.dll целевого приложения.  Отладчик WinDbg, в состав [Средств отладки для Windows](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index)и берутся из [Пакета Windows SDK](https://developer.microsoft.com/en-US/windows/downloads/windows-10-sdk), прикрепите к сообщению поддерживает дочернего процесса.  Он также теперь поддерживает непосредственно [Запуск и отладка приложения UWP](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-a-uwp-app-using-windbg#span-idlaunchinganddebuggingauwpappspanspan-idlaunchinganddebuggingauwpappspanspan-idlaunchinganddebuggingauwpappspanlaunching-and-debugging-a-uwp-app).

Для отладки запуска целевого приложения как дочерний процесс, запустить ``WinDbg``.

```ps
windbg.exe -plmPackage PSFSampleWithFixup_1.0.59.0_x86__7s220nvg1hg3m -plmApp PSFSample
```

В ``WinDbg`` запрос, включение отладки дочерних и задавать точки останова.

```ps
.childdbg 1
g
```

(выполняться, пока целевое приложение запускается и разбивает на отладчик)

```ps
sxe ld fixup.dll
g
```

(выполнение до исправление, которое загружается DLL)

```ps
bp ...
```

>[!NOTE]
> [PLMDebug](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/plmdebug) также может использоваться для присоединения отладчика к приложению после запуска, а также добавляется в [Средства отладки для Windows](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index).  Тем не менее он является более сложным в использовании, чем прямая поддержка теперь предоставляемые WinDbg.

## <a name="support-and-feedback"></a>Поддержка и отзывы

**Поиск ответов на вопросы**

Есть вопросы? Задайте их на Stack Overflow. Наша команда следит за этими [тегами](http://stackoverflow.com/questions/tagged/project-centennial+or+desktop-bridge). Вы также можете задать нам вопросы [здесь](https://social.msdn.microsoft.com/Forums/en-US/home?filter=alltypes&sort=relevancedesc&searchTerm=%5BDesktop%20Converter%5D).
