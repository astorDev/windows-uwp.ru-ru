---
author: normesta
Description: Fix issues that prevent your desktop application from running in an MSIX container
Search.Product: eADQiWindows 10XVcnh
title: Исправление ошибок, которые препятствуют отображению приложения для настольных компьютеров с под управлением в контейнере MSIX
ms.author: normesta
ms.date: 07/02/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 46d5705233af9e8254b9ac89a2d6e9891e90701f
ms.sourcegitcommit: 753dfcd0f9fdfc963579dd0b217b445c4b110a18
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/27/2018
ms.locfileid: "2861261"
---
# <a name="apply-runtime-fixes-to-an-msix-package-by-using-the-package-support-framework"></a>Применить исправления среды выполнения к пакету MSIX с помощью пакета поддержки платформы

Платформа поддержки пакетов — это набор открытым кодом, которые помогут вам применить исправления существующее приложение win32 при отсутствии доступа к исходному коду, чтобы его можно запускать в контейнере MSIX. Платформа поддержки пакетов помогает следуйте рекомендациям современных среда приложения.

Чтобы создать структуру пакета поддержки, мы выполнять технологии [задержек](https://www.microsoft.com/en-us/research/project/detours) , которая является открытым кодом, разработанная с Microsoft Research (MSR), а также с помощью API в режиме одобрения администратором и подключение.

Платформы является открытым кодом lightweight, и ее использовании для устранения проблем приложений быстро. Он также дает возможность обратитесь к сообщества по всему миру и построение на основе инвестиции других участников.

## <a name="a-quick-look-inside-of-the-package-support-framework"></a>Краткий обзор внутри платформа поддержки пакетов

Платформа поддержки пакетов содержит исполняемый файл, среда выполнения диспетчера DLL-Библиотеку и набор исправлений среды выполнения.

![Платформа поддержки пакетов](images/desktop-to-uwp/package-support-framework.png)

Вот как это работает. Вы создадите файла конфигурации, который указывает fix(s), который будет использоваться для приложения. Выберите будет изменен пакета для указания на оболочки совместимости запуска исполняемого файла.

Когда пользователь запускает приложение, запуска оболочки совместимости — это первый исполняемый файл, запускающий. Считывает файл конфигурации и вставляет fix(s) времени выполнения и среды выполнения диспетчера библиотеки DLL в процессе приложений.

![Ввод данных DLL пакета поддержки Framework](images/desktop-to-uwp/package-support-framework-2.png)

Диспетчер времени выполнения применяет исправление при необходимости для выполнения внутри контейнера MSIX приложения.

Это руководство поможет идентифицировать проблемы совместимости приложений и для поиска, применения и расширения среды выполнения исправления, их устранения.

<a id="identify" />

## <a name="identify-packaged-application-compatibility-issues"></a>Идентифицировать проблемы совместимости фасованных приложения

Во-первых создайте пакет для вашего приложения. Затем установите и запустите его наблюдать за его поведением. Вы можете получить сообщения об ошибках, которые могут помочь вам определить проблемы совместимости. [Монитор процессов](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) также можно использовать для обнаружения проблем.  Распространенные проблемы, которые относятся к приложения предположения относительно разрешения рабочий каталог и программы путь.

### <a name="using-process-monitor-to-identify-an-issue"></a>Использование процесс монитор для обнаружения неполадок

[Монитор процессов](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) — это мощное служебной программы для наблюдение за файла приложения и операции реестра и их результаты.  Это помогает понять проблемы совместимости приложений.  После открытия монитора процесс, добавьте фильтр (фильтр > Фильтр...) для включения только события исполняемый файл приложения.

![Фильтр ProcMon приложения](images/desktop-to-uwp/procmon_app_filter.png)

Появится список событий. Многие из этих событий для слово **УСПЕХА** будет отображаться в столбце **результатов** .

![ProcMon событий](images/desktop-to-uwp/procmon_events.png)

При необходимости можно отфильтровать события для отображения только только ошибки.

![Исключить ProcMon успеха](images/desktop-to-uwp/procmon_exclude_success.png)

Если предполагается ошибка доступа файловой системы, выполните поиск неудачных событий, которые приведены в разделе System32/SysWOW64 или путь к файлу пакета. Фильтры также здесь также может помочь. Запустите в нижней части этого списка и прокрутить вверх. Последним возникли неполадки, которые отображаются в нижней части этого списка. Не забывайте большинство ошибок, которые содержат строки, например «доступ запрещен» и «/ путь не найден» без применения вещей, которые выглядят подозрительные. [PSFSample](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/samples/PSFSample/) имеет две проблемы. Вы можете увидеть эти проблемы в списке, который отображается на следующем рисунке.

![ProcMon Config.txt](images/desktop-to-uwp/procmon_config_txt.png)

В первой проблемы, которое отображается на рисунке приложения не удается чтение из файла «Config.txt», расположенного в папке «C:\Windows\SysWOW64». Маловероятно, что приложение пытается напрямую Справочник по этому пути. Скорее всего она пытается прочитать из этого файла с помощью относительный путь, и по умолчанию «System32/SysWOW64» — это рабочий каталог приложения. Это предполагает, что приложение ожидает текущий рабочий каталог иметь значение где-нибудь в пакете. Поиск внутри appx можно увидеть, что файл существует в том же каталоге, что и исполняемый файл.

![Config.txt приложения](images/desktop-to-uwp/psfsampleapp_config_txt.png)

Вторая проблема отображается на следующем рисунке.

![Файл журнала ProcMon](images/desktop-to-uwp/procmon_logfile.png)

В этом выпуске приложения не удается записать файл журнала его путь к пакету. Предположить, что может быть полезен, оболочка файлов в режиме одобрения администратором.

<a id="find" />

## <a name="find-a-runtime-fix"></a>Найдите исправление среды выполнения

Инструмент содержит среды выполнения исправления, которые можно использовать прямо сейчас, такие как оболочки совместимости в режиме одобрения администратором файла.

### <a name="file-redirection-shim"></a>Оболочки совместимости файлов в режиме одобрения администратором

Чтобы перенаправлять попытки записи или чтения данных в каталог, который не будет доступен из приложения, которое выполняется в контейнере MSIX можно использовать [Оболочки совместимости файлов в режиме одобрения администратором](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/develop/FileRedirectionShim) .

К примеру Если приложение записывает в файл журнала, который находится в одном каталоге с исполняемый файл приложения, можно использовать [Оболочки совместимости файлов в режиме одобрения администратором](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/develop/FileRedirectionShim) для создания этого файла журнала в другом месте, например в хранилище данных локальных приложений.

### <a name="runtime-fixes-from-the-community"></a>Среда выполнения исправления материалы сообщества

Убедитесь, что для просмотра материалов сообщества на страницу [репозиториев](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/develop) . Существует возможность, что другими разработчиками исправления неполадок похожих и предоставления общего доступа исправление времени выполнения.

## <a name="apply-a-runtime-fix"></a>Исправление, среда выполнения

Можно применить средство среды выполнения с несколько простых средств из пакета SDK Windows и, выполнив следующие действия.

> [!div class="checklist"]
> * Создайте папку пакета макета
> * Получение файлов пакета поддержки Framework
> * Добавить их в пакет
> * Изменение манифеста пакета
> * Создание файла конфигурации

Давайте проходят через каждой задачи.

### <a name="create-the-package-layout-folder"></a>Создайте папку пакета макета

Если уже имеется файл .appx можно распакуйте его содержимое в папку макета, который будет использоваться в качестве промежуточной области для пакета.  Для этого из **x64 собственные средства командной строки для VS 2017**, или вручную с помощью пакета SDK папку Bin в путь исполняемого поиска.

```
makeappx unpack /p PSFSamplePackage_1.0.60.0_AnyCPU_Debug.appx /d PackageContents

```

Это позволит получить выглядеть, как показано ниже.

![Структура пакета](images/desktop-to-uwp/package_contents.png)

Если у вас нет .appx файла со, можно создать пакет папки и файлы с нуля.

### <a name="get-the-package-support-framework-files"></a>Получение файлов пакета поддержки Framework

Пакет Nuget Инструмент можно получить с помощью Visual Studio. Вы также можно получить с помощью средства командной строки автономных Nuget.

#### <a name="get-the-package-by-using-visual-studio"></a>Получение пакета с помощью Visual Studio

В Visual Studio щелкните правой кнопкой мыши узел ваше решение или проект и выберите одну из команд Управление пакетами Nuget.  Поиск **Microsoft.PackageSupportFramework** или **Инструмент** для поиска пакет на Nuget.org. Затем установите его.

#### <a name="get-the-package-by-using-the-command-line-tool"></a>Получение пакета с помощью средства командной строки

Установите средство командной строки Nuget из этого расположения: https://www.nuget.org/downloads. В командной строке Nuget выполните следующую команду:

```
nuget install Microsoft.PackageSupportFramework
```

### <a name="add-the-package-support-framework-files-to-your-package"></a>Добавление файлов пакета поддержки Framework в пакет

Добавьте необходимые библиотеки DLL 32-разрядных и 64-разрядная версия Инструмент и исполняемые файлы каталога пакета. Руководствуйтесь следующей таблицей. Также необходимо включить исправлений среды выполнения, необходимые. В нашем примере мы должны исправление среды выполнения файла в режиме одобрения администратором.

| Исполняемый файл приложения является x64 | Исполняемый файл приложения является x86 |
|-------------------------------|-----------|
| [ShimLauncher64.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimLauncher/readme.md) |  [ShimLauncher32.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimLauncher/readme.md) |
| [ShimRuntime64.dll](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRuntime/readme.md) | [ShimRuntime32.dll](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRuntime/readme.md) |
| [ShimRunDll64.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRunDll/readme.md) | [ShimRunDll32.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRunDll/readme.md) |

Содержимое пакета теперь должен выглядеть примерно следующим образом.

![Двоичные файлы пакета](images/desktop-to-uwp/package_binaries.png)

### <a name="modify-the-package-manifest"></a>Изменение манифеста пакета

Откройте манифест пакета в текстовом редакторе, а затем установите `Executable` атрибут `Application` элемент имя исполняемого файла запуска оболочки совместимости.  Если вы знаете architecture конечного приложения, установите соответствующую версию ShimLauncher32.exe или ShimLauncher64.exe.  В противном случае ShimLauncher32.exe будут работать в любом случае.  Вот пример.

```xml
<Package ...>
  ...
  <Applications>
    <Application Id="PSFSample"
                 Executable="ShimLauncher32.exe"
                 EntryPoint="Windows.FullTrustApplication">
      ...
    </Application>
  </Applications>
</Package>
```

### <a name="create-a-configuration-file"></a>Создание файла конфигурации

Создание имени файла ``config.json``и сохраните этот файл в корневую папку своего пакета. Измените идентификатор объявленные приложения файл config.json для указания на исполняемый файл, который вы только что заменен. С помощью базы знаний, полученные от использования монитор процессов, можно также задать рабочий каталог также а используется оболочки совместимости в режиме одобрения администратором файлов для перенаправления операции чтения/записи в файлы с расширением LOG относительно пакета в каталоге «PSFSampleApp».

```json
{
    "applications": [
        {
            "id": "PSFSample",
            "executable": "PSFSampleApp/PSFSample.exe",
            "workingDirectory": "PSFSampleApp/"
        }
    ],
    "processes": [
        {
            "executable": "PSFSample",
            "shims": [
                {
                    "dll": "FileRedirectionShim.dll",
                    "config": {
                        "redirectedPaths": {
                            "packageRelative": [
                                {
                                    "base": "PSFSampleApp/",
                                    "patterns": [
                                        ".*\\.log"
                                    ]
                                }
                            ]
                        }
                    }
                }
            ]
        }
    ]
}
```
Далее приводится руководство по config.json схемы:

| Массив | key | Значение |
|-------|-----------|-------|
| Приложения | id |  Используйте значение `Id` атрибут `Application` элемент в манифесте пакета. |
| Приложения | исполняемый файл | Пакет относительный путь исполняемого файла, которое требуется выполнить. В большинстве случаев это значение можно получить из файла манифеста пакета перед внесением изменений. Это значение `Executable` атрибут `Application` элемент. |
| Приложения | workingDirectory | (Необязательно) Пакет относительный путь для использования в качестве рабочий каталог приложения, которое запускает. Если это значение не задано, операционная система использует `System32` каталог как рабочий каталог приложения. |
| процессы | исполняемый файл | В большинстве случаев это будет имя `executable` настройки, над удалены расширения файла и путь. |
| режимы совместимости | библиотеки DLL | Путь относительно веб-пакет .appx оболочки совместимости для загрузки. |
| режимы совместимости | конфигурации | (Необязательно) Определяет, как ведет себя dl оболочки совместимости. Точный формат это значение может изменяться на основе оболочки совместимости с оболочки совместимости как каждого оболочки совместимости воспринимает «blob», насколько это требуется. |

`applications`, `processes`, И `shims` используются массивы разделы. Это означает, что файл config.json можно использовать для указания более одного приложения, процесс и оболочки совместимости DLL-Библиотеку.


### <a name="package-and-test-the-app"></a>Пакет и тестирования приложения

Создайте пакет.

```
makeappx pack /d PackageContents /p PSFSamplePackageFixup.appx
```

Затем подписать его.

```
signtool sign /a /v /fd sha256 /f ExportedSigningCertificate.pfx PSFSamplePackageFixup.appx
```

Для получения дополнительных сведений см [порядок создания пакета сертификата для подписи](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/how-to-create-a-package-signing-certificate) и [подпись пакета с использованием signtool](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/how-to-sign-a-package-using-signtool)

С помощью PowerShell, необходимо установите пакет.

>[!NOTE]
> Не забудьте сначала удаления пакета.

```
powershell Add-AppxPackage .\PSFSamplePackageFixup.appx
```

Запустите приложение и проверьте работу с применить исправление времени выполнения.  Повторите шаги упаковки при необходимости и диагностики.

### <a name="use-the-trace-shim"></a>Использование оболочки совместимости трассировки

Альтернативный способ диагностики проблем совместимости фасованных приложения является использование оболочки совместимости трассировки. Эта DLL-Библиотека входит в состав Инструмент и содержит подробные диагностические сведения о поведение приложения, следующий процесс монитор.  Предназначенную Показать проблем совместимости приложений.  Чтобы использовать оболочки совместимости трассировки, добавить DLL-ФАЙЛ пакета, добавьте следующий фрагмент config.json и затем создание пакета и установить приложение.

```json
{
    "dll": "TraceShim.dll",
    "config": {
        "traceLevels": {
            "filesystem": "allFailures"
        }
    }
}
```

По умолчанию оболочки совместимости трассировки отфильтровывает ошибки, можно считать «ожидаемый».  Например приложения мог попытаться безусловное ветвление удаление файла без проверки, если он уже существует, без учета результат. Это имеет вследствие сожалению, некоторые непредвиденные сбои могут получить отфильтрованы, поэтому в приведенном выше примере мы необязательно для получения всех ошибок из функций файловой системы. Для этого мы знаем из перед, попытка чтения из файла Config.txt выдает сообщение «файл не найден». Это ошибки, часто наблюдаемая и предполагается, что обычно не непредвиденные. На практике это скорее всего превосходно для начала фильтрации только на непредвиденные сбои и затем возврата к всех ошибок при возникновении неполадок, по-прежнему не может быть определен.

По умолчанию выходные данные оболочки совместимости трассировки отправляется присоединенным. В данном примере мы не следует прикрепить отладчик и вместо этого используйте программу [DebugView](https://docs.microsoft.com/en-us/sysinternals/downloads/debugview) из SysInternals для просмотра выходных данных. После запуска приложения, можно увидеть те же ошибки как раньше, какой бы точке "мне нравится" достигло предельного же исправления времени выполнения.

![Файл TraceShim не найден](images/desktop-to-uwp/traceshim_filenotfound.png)

![Отказано в доступе TraceShim](images/desktop-to-uwp/traceshim_accessdenied.png)

## <a name="debug-extend-or-create-a-runtime-fix"></a>Отладка, расширения и создания исправление среды выполнения

Visual Studio можно использовать для отладки исправление среды выполнения, расширения среды выполнения исправление или создать новый. Вам потребуется выполнить эти действия для успешного выполнения.

> [!div class="checklist"]
> * Добавление упаковки проекта
> * Добавление проекта для исправления, среда выполнения
> * Добавление проекта, который запускает службу исполняемый запуска оболочки совместимости
> * Настройка проекта упаковки

После этого, решение будет выглядеть примерно следующим образом.

![Завершите работу решения](images/desktop-to-uwp/runtime-fix-project-structure.png)

Давайте взглянем на каждый из проектов в этом примере.

| Проект | Описание |
|-------|-----------|
| DesktopApplicationPackage | Этот проект основано на [проекте упаковки приложений Windows](desktop-to-uwp-packaging-dot-net.md) и выводится MSIX пакет. |
| Runtimefix | Это проект библиотеки Dynamic-Linked C++, содержащий одну или несколько функций замены, которые используются в качестве исправление среды выполнения. |
| ShimLauncher | Это пустой проект C++. Этот проект — это место для размещения файлов распространяемый среды выполнения платформы пакет поддержки. Он выводит исполняемый файл. Этот исполняемый файл — это первое, на котором выполняется при запуске решения. |
| WinFormsDesktopApplication | Этот проект содержит исходный код приложения для настольных систем. |

Чтобы просмотреть полный пример, содержащий все эти типы проектов, обратитесь к разделу [PSFSample](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/samples/PSFSample/).

Рассмотрим действия для создания и настройки каждого из этих проектов в решении.


### <a name="create-a-package-solution"></a>Создание пакета решения

Если у вас нет уже решения для приложения для настольных компьютеров, создайте новое **Пустое решение** в Visual Studio.

![Пустое решение](images/desktop-to-uwp/blank-solution.png)

Можно также добавить любой, у вас есть проектов приложений.

### <a name="add-a-packaging-project"></a>Добавление упаковки проекта

Если у вас еще нет **Упаковки проекта Windows-приложения**, создайте его и добавьте его в решение.

![Пакет шаблона проекта](images/desktop-to-uwp/package-project-template.png)

Дополнительные сведения о проекте упаковки приложений Windows содержатся в разделе [пакет приложения с помощью Visual Studio](desktop-to-uwp-packaging-dot-net.md).

В **Обозревателе решений**щелкните правой кнопкой мыши проект упаковки, выберите команду **Изменить**и затем добавить в конец файла проекта:

```
<Target Name="PSFRemoveSourceProject" AfterTargets="ExpandProjectReferences" BeforeTargets="_ConvertItems">
<ItemGroup>
  <FilteredNonWapProjProjectOutput Include="@(_FilteredNonWapProjProjectOutput)">
  <SourceProject Condition="'%(_FilteredNonWapProjProjectOutput.SourceProject)'=='<your runtime fix project name goes here>'" />
  </FilteredNonWapProjProjectOutput>
  <_FilteredNonWapProjProjectOutput Remove="@(_FilteredNonWapProjProjectOutput)" />
  <_FilteredNonWapProjProjectOutput Include="@(FilteredNonWapProjProjectOutput)" />
</ItemGroup>
</Target>
```

### <a name="add-project-for-the-runtime-fix"></a>Добавление проекта для исправления, среда выполнения

Добавьте в решение проект C++ **Библиотеки динамической компоновки (DLL)** .

![Библиотека времени выполнения исправления](images/desktop-to-uwp/runtime-fix-library.png)

Щелкните правой кнопкой мыши, project, а затем выберите **Свойства**.

На страницах свойств найдите поле **Стандартного языка C++** и выберите в раскрывающемся списке рядом с полем этого поля, **C ++ 17 стандарту ISO (/ std:c ++ 17)** параметр.

![ISO 17 параметр](images/desktop-to-uwp/iso-option.png)

Щелкните правой кнопкой мыши проект и выберите в контекстном меню выберите параметр **Управление пакетами Nuget** . Убедитесь, что параметр **источник пакета** для **всех** или **nuget.org**.

Далее щелкните значок параметры этого поля.

Поиск *Инструмент** Nuget упаковать и затем установите для этого проекта.

![NuGet-пакет](images/desktop-to-uwp/psf-package.png)

Если вы хотите отладки или расширение существующего исправление среды выполнения, добавьте файлы исправление среды выполнения, которые можно получить с помощью в статье описано в разделе [Поиск исправление времени выполнения](#find) в этом руководстве.

Если планируется создание новой исправление, ничего не добавляют в этот проект пока. Мастер поможет добавьте нужные файлы в этот проект позже в этом руководстве. Пока мы будем продолжить настройку решения.

### <a name="add-a-project-that-starts-the-shim-launcher-executable"></a>Добавление проекта, который запускает службу исполняемый запуска оболочки совместимости

Добавьте проект C++ **Пустой проект** в решение.

![Пустой проект](images/desktop-to-uwp/blank-app.png)

Добавление пакета Nuget **Инструмент** в этот проект с помощью одной инструкции, описанных в предыдущем разделе.

Открыть страницы свойств для проекта, а также на странице **Общие** параметры свойства **Конечного имя** ``ShimLauncher32`` или ``ShimLauncher64`` в зависимости от архитектуры приложения.

![Справочник по запуска оболочки совместимости](images/desktop-to-uwp/shim-exe-reference.png)

Добавьте ссылку проекта в проект исправление времени выполнения в решении.

![Справочник по исправление среды выполнения](images/desktop-to-uwp/reference-fix.png)

Щелкните правой кнопкой мыши ссылки, а затем примените эти значения в окне **Свойства** .

| Свойство | Значение |
|-------|-----------|-------|
| Копирование локального | True |
| Копировать локально вспомогательные сборки | True |
| Справочник по сборке вывода | True |
| Зависимостей | False |
| Исходные данные зависимости ссылок библиотеки | False |

### <a name="configure-the-packaging-project"></a>Настройка проекта упаковки

В проекте упаковки щелкните правой кнопкой мыши папку **Приложения** и выберите **Добавить ссылку**.

![Добавление ссылки на проект](images/desktop-to-uwp/add-reference-packaging-project.png)

Выберите проект запуска оболочки совместимости и проекта приложения для настольных систем и затем нажмите кнопку **ОК** .

![Проект классического приложения](images/desktop-to-uwp/package-project-references.png)

>[!NOTE]
> Если у вас нет исходный код для приложения, просто выберите проект запуска оболочки совместимости. Мы покажем, как добавить ссылку исполняемый файл, при создании файла конфигурации.

В узел **приложения** щелкните правой кнопкой мыши приложение запуска оболочки совместимости и нажмите кнопку **задать в качестве точки входа**.

![Задание точки входа](images/desktop-to-uwp/set-startup-project.png)

Добавьте в файл с именем ``config.json`` в проекте упаковки, затем скопируйте и вставьте в файл следующий текст json. Значение свойства **Action пакет** **содержимого**.

```json
{
    "applications": [
        {
            "id": "",
            "executable": "",
            "workingDirectory": ""
        }
    ],
    "processes": [
        {
            "executable": "",
            "shims": [
                {
                    "dll": "",
                    "config": {
                    }
                }
            ]
        }
    ]
}
```
Укажите значение для каждого ключа. Используйте эту таблицу в качестве руководства.

| Массив | key | Значение |
|-------|-----------|-------|
| Приложения | id |  Используйте значение `Id` атрибут `Application` элемент в манифесте пакета. |
| Приложения | исполняемый файл | Пакет относительный путь исполняемого файла, которое требуется выполнить. В большинстве случаев это значение можно получить из файла манифеста пакета перед внесением изменений. Это значение `Executable` атрибут `Application` элемент. |
| Приложения | workingDirectory | (Необязательно) Пакет относительный путь для использования в качестве рабочий каталог приложения, которое запускает. Если это значение не задано, операционная система использует `System32` каталог как рабочий каталог приложения. |
| процессы | исполняемый файл | В большинстве случаев это будет имя `executable` настройки, над удалены расширения файла и путь. |
| режимы совместимости | библиотеки DLL | Путь относительно веб-пакет загрузки DLL-Библиотеки оболочки совместимости. |
| режимы совместимости | конфигурации | (Необязательно) Определяет, как ведет себя dl оболочки совместимости. Точный формат это значение может изменяться на основе оболочки совместимости с оболочки совместимости как каждого оболочки совместимости воспринимает «blob», насколько это требуется. |

После завершения, вашей ``config.json`` файла будет выглядеть примерно следующим образом.

```json
{
  "applications": [
    {
      "id": "DesktopApplication",
      "executable": "DesktopApplication/WinFormsDesktopApplication.exe",
      "workingDirectory": "WinFormsDesktopApplication"
    }
  ],
  "processes": [
    {
      "executable": ".*App.*",
      "shims": [ { "dll": "RuntimeFix.dll" } ]
    }
  ]
}

```

>[!NOTE]
> `applications`, `processes`, И `shims` используются массивы разделы. Это означает, что файл config.json можно использовать для указания более одного приложения, процесс и оболочки совместимости DLL-Библиотеку.

### <a name="debug-a-runtime-fix"></a>Отладка исправление среды выполнения

В Visual Studio нажмите клавишу F5, чтобы запустить отладчик.  Первое, что запускает — это приложения запуска оболочки совместимости, который в свою очередь, запускает конечного приложения рабочего стола.  Отладка рабочего стола конечного приложения, необходимо будет вручную присоединиться к процессу приложения для настольных систем, выбрав **отладки**->**Присоединение к процессу**, а затем выбрав процесс приложений. Чтобы разрешить отладку приложений .NET с исправление собственный среды выполнения DLL-Библиотеку, выберите типы управляемого и машинного кода (Отладка в смешанном режиме).  

После настройки это, можно задать точках останова рядом с полем строки кода в код приложения для настольных систем и исправление проекта среды выполнения. Если у вас нет исходный код для приложения, можно задавать точки останова только рядом с полем строки кода в проекте исправление времени выполнения.

>[!NOTE]
> Visual Studio предоставляет простой разработки и отладки, существуют некоторые ограничения, поэтому позже в этом руководстве мы рассмотрим другие методы, которые можно применить.

## <a name="create-a-runtime-fix"></a>Создание исправление среды выполнения

Если не существует, но при этом среды выполнения устранить проблемы, что требуется разрешить, вы можете создать новый исправление среды выполнения, создание замены функций и включая все данные конфигурации, который имеет смысл. Давайте взглянем на каждой части.

### <a name="replacement-functions"></a>Замена функции

Во-первых определите функции звонков с ошибкой при запуске приложения в контейнере MSIX. Затем можно создать замены функции, на которые нацелены диспетчеру среды выполнения вместо этого вызов. Это дает возможность реализации функции замените поведение, соответствующие правилам современных среда.

В Visual Studio откройте проект исправление среды выполнения, созданный ранее в этом руководстве.

Объявите ``SHIM_DEFINE_EXPORTS`` макрос и затем добавьте инструкции include для `shim_framework.h` вверху каждого из них. Файл CPP, который планируется добавить функции исправление среды выполнения.

```c++
#define SHIM_DEFINE_EXPORTS
#include <shim_framework.h>
```
>[!IMPORTANT]
>Убедитесь, что `SHIM_DEFINE_EXPORTS` макрос отображается перед инструкции include.

Создание функции, сигнатура функции, кто имеет поведение, который требуется изменить. Ниже приведен пример функции, которая заменяет `MessageBoxW` функции.

```c++
auto MessageBoxWImpl = &::MessageBoxW;
int WINAPI MessageBoxWShim(
    _In_opt_ HWND hwnd,
    _In_opt_ LPCWSTR,
    _In_opt_ LPCWSTR caption,
    _In_ UINT type)
{
    return MessageBoxWImpl(hwnd, L"SUCCESS: This worked", caption, type);
}

DECLARE_SHIM(MessageBoxWImpl, MessageBoxWShim);
```

Вызов `DECLARE_SHIM` сопоставляет `MessageBoxW` функции к новой функции замены. Когда приложение пытается вызвать `MessageBoxW` функции, он вызовет функцию замены вместо этого.

#### <a name="protect-against-recursive-calls-to-functions-in-runtime-fixes"></a>Обеспечивает защиту от рекурсивных вызовов функций в исправлениях среды выполнения

При необходимости можно применить `reentrancy_guard` типа вашей функции, которая обеспечивает защиту от рекурсивных вызовов функций в исправлениях времени выполнения.

Например, можно создать функцию замены для `CreateFile` функции. Реализация может вызывать `CopyFile` функции, но реализация `CopyFile` может вызывать функцию `CreateFile` функции. Это может привести к бесконечный рекурсивный цикл вызовов `CreateFile` функции.

Для получения дополнительных сведений о `reentrancy_guard` увидеть [authoring.md](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/Authoring.md)

### <a name="configuration-data"></a>Данные о конфигурации

Если вы хотите добавить данные конфигурации для вашей среды выполнения исправление, рассмотрите возможность добавления его к ``config.json``. Таким образом, можно использовать `ShimQueryCurrentDllConfig` для легко анализа данных. В этом примере разбор boolean и строковые значения из файла конфигурации.

```c++
if (auto configRoot = ::ShimQueryCurrentDllConfig())
{
    auto& config = configRoot->as_object();

    if (auto enabledValue = config.try_get("enabled"))
    {
        g_enabled = enabledValue->as_boolean().get();
    }

    if (auto logPathValue = config.try_get("logPath"))
    {
        g_logPath = logPathValue->as_string().wstring();
    }
}
```

## <a name="other-debugging-techniques"></a>Другие методы отладки

Хотя Visual Studio предоставляет простой разработки и отладки взаимодействия, существуют некоторые ограничения.

Во-первых отладки F5 запускает приложение, развертывание свободные файлы из путь к папке макет пакета, вместо установки из пакета .appx.  Структура папки обычно не имеет те же ограничения безопасности папки установленного пакета. В результате для воспроизведения ошибки отказ доступа пакет путь до установки исправления среды выполнения не возможно.

Чтобы решить эту проблему, используйте .appx пакет развертывания, а не F5 свободного файла развертывания.  Чтобы создать файл пакета .appx, программа [MakeAppx](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/make-appx-package--makeappx-exe-) из пакета SDK Windows, как описано выше. Или, из среды Visual Studio, щелкните правой кнопкой мыши узел проекта приложения и выберите **хранилище**->**Создания пакетов приложений**.

Другой проблемы с использованием Visual Studio является то, что она не встроенная поддержка для присоединения к все дочерние процессы, запущенные в отладчике.   Это усложняет для отладки логики в путь загрузки конечного приложения, который необходимо вручную присоединить с помощью Visual Studio после запуска.

Чтобы решить эту проблему, используйте отладчик, поддерживающего дочерний процесс с присоединением.  Обратите внимание на то, что это обычно невозможно присоединение отладчика (Требованию) в времени для конечного приложения.  Это, поскольку большинство Требованию приемы вовлечение запуск отладчика вместо конечного приложения, с помощью раздела реестра ImageFileExecutionOptions.  Это нарушает detouring механизм, используемый ShimLauncher.exe для вставки ShimRuntime.dll на конечное приложение.  WinDbg, включенных в [Средства отладки](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index), а также получить из пакета [Windows SDK](https://developer.microsoft.com/en-US/windows/downloads/windows-10-sdk)поддерживает дочернего процесса присоединения.  Он также теперь поддерживает непосредственно [Запуск и отладка приложения UWP](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-a-uwp-app-using-windbg#span-idlaunchinganddebuggingauwpappspanspan-idlaunchinganddebuggingauwpappspanspan-idlaunchinganddebuggingauwpappspanlaunching-and-debugging-a-uwp-app).

Отладка запуска целевого приложения как дочерний процесс, запустите ``WinDbg``.

```
windbg.exe -plmPackage PSFSampleWithFixup_1.0.59.0_x86__7s220nvg1hg3m -plmApp PSFSample
```

В ``WinDbg`` запрос, включить дочерние отладки и задавать точки останова.

```
.childdbg 1
g
```
(выполнение, пока конечное приложение запускается и отладчика)

```
sxe ld fixup.dll
g
```
(выполнение до исправления загрузке DLL)

```
bp ...
```

>[!NOTE]
> [PLMDebug](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/plmdebug) можно также использовать подключение отладчика к приложению при запуске, а также включены в [Средства отладки](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index).  Тем не менее более сложных по сравнению с Непосредственная поддержка теперь предоставлено WinDbg.

## <a name="support-and-feedback"></a>Поддержка и отзывы

**Поиск ответов на вопросы**

Есть вопросы? Задайте их на Stack Overflow. Наша команда следит за этими [тегами](http://stackoverflow.com/questions/tagged/project-centennial+or+desktop-bridge). Вы также можете задать нам вопросы [здесь](https://social.msdn.microsoft.com/Forums/en-US/home?filter=alltypes&sort=relevancedesc&searchTerm=%5BDesktop%20Converter%5D).
