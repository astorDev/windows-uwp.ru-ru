---
author: normesta
Description: Fix issues that prevent your desktop application from running in an MSIX container
Search.Product: eADQiWindows 10XVcnh
title: Устранение проблем, которые не классического приложения от запуска в контейнере MSIX
ms.author: normesta
ms.date: 07/02/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: d4b4cae2e135f7a66cd68192faabeffdb309a909
ms.sourcegitcommit: d10fb9eb5f75f2d10e1c543a177402b50fe4019e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/12/2018
ms.locfileid: "4566842"
---
# <a name="apply-runtime-fixes-to-an-msix-package-by-using-the-package-support-framework"></a>Применение исправления среды выполнения для пакета MSIX с помощью платформы поддержки пакета

Платформа поддержки пакета — комплекту с открытым исходным кодом, которая позволяет применять исправления существующие приложения win32 при отсутствии доступа к исходному коду, чтобы оно могло выполняться в контейнере MSIX. Платформа поддержки пакетов помогает приложения следуйте рекомендациям современные среды.

Дополнительные сведения см. в разделе [Платформа поддержки пакетов](https://docs.microsoft.com/windows/msix/package-support-framework-overview).

Это руководство поможет вам для идентификации проблем совместимости приложений, и для поиска, применяются и расширения среды выполнения исправления, их устранения.

<a id="identify" />

## <a name="identify-packaged-application-compatibility-issues"></a>Определяем проблемы совместимости, упакованные приложения

Во-первых создайте пакет для вашего приложения. Установите его и выполняется проверка его поведения. Может появиться сообщения об ошибках, которые помогают выявить проблемы совместимости. Можно также использовать [Монитор процессов](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) по выявлению проблем.  Распространенные проблемы связаны с приложения предположения относительно разрешения рабочий каталог и программа пути.

### <a name="using-process-monitor-to-identify-an-issue"></a>С помощью монитора процесс для идентификации проблемы

[Монитор процессов](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) — это мощное служебная программа для наблюдения файл приложения и операции и их результаты.  Это может помочь вам понять проблем совместимости приложений.  После открытия процесса монитора, добавьте фильтр (фильтр > Фильтр …) для включения только события исполняемый файл приложения.

![Фильтр ProcMon приложения](images/desktop-to-uwp/procmon_app_filter.png)

Появится список событий. Для многих из этих событий слово **Успех** будут отображаться в столбце **результат** .

![События ProcMon](images/desktop-to-uwp/procmon_events.png)

При необходимости вы можете отфильтровать события, чтобы отображать только ошибки.

![Успех исключить ProcMon](images/desktop-to-uwp/procmon_exclude_success.png)

Если вы подозреваете ошибки доступа файловой системы, поиск сбой события, которые относятся к System32/SysWOW64 или путь к файлу пакета. Фильтры также поможет здесь слишком. Запустите в нижней части списка и прокрутку вверх. Недавно произошли ошибки, которые отображаются в нижней части списка. Обратите внимание, большинство ошибок, содержащих строки, такие как «доступ запрещен» и «путь/имя не найдено» и игнорировать вещей, которые выглядят как подозрительные. [PSFSample](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/samples/PSFSample/) имеет два проблемы. Вы можете увидеть эти проблемы в списке, который отображается на следующем рисунке.

![ProcMon Config.txt](images/desktop-to-uwp/procmon_config_txt.png)

В первой проблема, которая отображается в это изображение сбой приложения для чтения из файла «Config.txt», который находится в папке «C:\Windows\SysWOW64». Маловероятно, что приложение пытается ссылаться на этот путь напрямую. Скорее всего его пытаются чтение из этого файла с помощью относительный путь, и по умолчанию «System32/SysWOW64» — это рабочий каталог приложения. Это предполагает, что приложение ожидает текущий рабочий каталог значение где-то в пакете. Ищете внутри appx, мы видим, что файл существует в том же каталоге, что и исполняемый файл.

![Config.txt приложения](images/desktop-to-uwp/psfsampleapp_config_txt.png)

Вторая проблема отображается на следующем рисунке.

![Файл журнала ProcMon](images/desktop-to-uwp/procmon_logfile.png)

В этом выпуске приложения происходит сбой для записи файл журнала его путь к пакету. Это предположить, что исправление перенаправление файлов может помочь.

<a id="find" />

## <a name="find-a-runtime-fix"></a>Найдите исправление среды выполнения

Инструмент содержит исправления среды выполнения, которые можно использовать прямо сейчас, такие как исправить перенаправление файлов.

### <a name="file-redirection-fixup"></a>Исправление перенаправление файла

[Исправление перенаправление файлов](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/develop/FileRedirectionShim) можно использовать для перенаправления попытки записи или чтения данных в каталоге, который не доступен из приложения, которое выполняется в контейнере MSIX.

Например если приложение выполняет запись в файл журнала, который находится в том же каталоге исполняемого приложения, можно использовать [Исправления перенаправление файлов](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/develop/FileRedirectionShim) для создания этого файла журнала в другом месте, таких как локальное хранилище данных приложения.

### <a name="runtime-fixes-from-the-community"></a>Среда выполнения исправления от сообщества

Убедитесь, что для просмотра взносы сообщества на нашу страницу [GitHub](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/develop) . Это возможно, что другие разработчики была устранена проблема, сходные с вашими и предоставили исправление среды выполнения.

## <a name="apply-a-runtime-fix"></a>Исправление среды выполнения

Можно применить существующий исправление среды выполнения, с помощью несколько простых средств из пакета Windows SDK и, выполнив следующие действия.

> [!div class="checklist"]
> * Создайте папку макета пакета
> * Получение файлов пакета поддержки инфраструктуры
> * Добавление их в пакет
> * Изменение манифеста пакета
> * Создание файла конфигурации

Давайте пройти все задачи.

### <a name="create-the-package-layout-folder"></a>Создайте папку макета пакета

Если у вас уже есть файл .msix (или AppX-файл), можно распаковать его содержимое в папку макета, который будет выступать в качестве промежуточной области для пакета.  Вы можете сделать это в **x64 собственные средства командной строки для Visual STUDIO 2017**, или вручную с помощью пакета SDK bin путь в путь исполняемого поиска.

```
makemsix unpack /p PSFSamplePackage_1.0.60.0_AnyCPU_Debug.msix /d PackageContents

```

Это даст вам что-то, что выглядит следующим образом.

![Макет пакета](images/desktop-to-uwp/package_contents.png)

Если у вас нет .msix (или AppX-файл) файл начать с, можно создать папку пакета и файлы с нуля.

### <a name="get-the-package-support-framework-files"></a>Получение файлов пакета поддержки инфраструктуры

Вы можете получить пакет Nuget Инструмент с помощью Visual Studio. Вы также можете получить с помощью средства командной строки автономный Nuget.

#### <a name="get-the-package-by-using-visual-studio"></a>Получите пакет с помощью Visual Studio

В Visual Studio щелкните правой кнопкой мыши узел вашего проекта или решения и выберите одну из команд Управление пакетами Nuget.  Поиск **Microsoft.PackageSupportFramework** или **Инструмент** поиска пакета Nuget.org. Затем установите его.

#### <a name="get-the-package-by-using-the-command-line-tool"></a>Получите пакет с помощью средства командной строки

Установить средство командной строки Nuget из этого расположения: https://www.nuget.org/downloads. Из командной строки Nuget, выполните следующую команду:

```
nuget install Microsoft.PackageSupportFramework
```

### <a name="add-the-package-support-framework-files-to-your-package"></a>Добавление в пакет файлов пакета поддержки Framework

Добавьте необходимые 32-разрядные и 64-разрядных Инструмент DLL-файлы и исполняемые файлы в каталог пакета. Руководствуйтесь следующей таблицей. Также необходимо включить все исправления среды выполнения, которые необходимо. В нашем примере нам нужно исправить файл перенаправления среды выполнения.

| Исполняемый файл приложения — это x64 | Исполняемый файл приложения — это x86 |
|-------------------------------|-----------|
| [PSFLauncher64.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimLauncher/readme.md) |  [PSFLauncher32.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimLauncher/readme.md) |
| [PSFRuntime64.dll](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRuntime/readme.md) | [PSFRuntime32.dll](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRuntime/readme.md) |
| [PSFRunDll64.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRunDll/readme.md) | [PSFRunDll32.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRunDll/readme.md) |

Содержимое пакета теперь должен выглядеть примерно следующим образом.

![Двоичные файлы пакета](images/desktop-to-uwp/package_binaries.png)

### <a name="modify-the-package-manifest"></a>Изменение манифеста пакета

Откройте манифест пакета в текстовом редакторе, а затем установите `Executable` атрибута `Application` элементу имя исполняемого файла Инструмент запуска.  Если вы знаете архитектуре целевого приложения, выберите соответствующую версию, PSFLauncher32.exe или PSFLauncher64.exe.  В противном случае PSFLauncher32.exe будут работать во всех случаях.  Вот пример.

```xml
<Package ...>
  ...
  <Applications>
    <Application Id="PSFSample"
                 Executable="PSFLauncher32.exe"
                 EntryPoint="Windows.FullTrustApplication">
      ...
    </Application>
  </Applications>
</Package>
```

### <a name="create-a-configuration-file"></a>Создание файла конфигурации

Создание имени файла ``config.json``и сохранить этот файл в корневую папку пакета. Измените объявленный идентификатор config.json файла для исполняемого файла, который только что заменить. С помощью знания, полученные с помощью процесса монитора, вы можете также задать рабочий каталог как также использовать исправления перенаправление файлов для перенаправления операции чтения/записи файлы log package-relative в каталоге «PSFSampleApp».

```json
{
    "applications": [
        {
            "id": "PSFSample",
            "executable": "PSFSampleApp/PSFSample.exe",
            "workingDirectory": "PSFSampleApp/"
        }
    ],
    "processes": [
        {
            "executable": "PSFSample",
            "fixups": [
                {
                    "dll": "FileRedirectionFixup.dll",
                    "config": {
                        "redirectedPaths": {
                            "packageRelative": [
                                {
                                    "base": "PSFSampleApp/",
                                    "patterns": [
                                        ".*\\.log"
                                    ]
                                }
                            ]
                        }
                    }
                }
            ]
        }
    ]
}
```
Ниже приведена руководство по схеме config.json.

| Массив | key | Значение |
|-------|-----------|-------|
| Приложения | id |  Используйте значение `Id` атрибута `Application` в манифесте пакета. |
| Приложения | исполняемые | Пакет относительный путь исполняемого файла, который вы хотите начать. В большинстве случаев можно получить это значение в файл манифеста пакета, прежде чем вносить изменения. Это значение `Executable` атрибута `Application` элемента. |
| Приложения | workingDirectory | (Необязательно) Путь относительно пакета для использования в качестве рабочий каталог приложения, которое запускается. Если это значение не задано, операционная система использует `System32` каталог как рабочий каталог приложения. |
| процессы | исполняемые | В большинстве случаев это будет имя `executable` настроено выше с расширением путь и файл удален. |
| исправления | Библиотека DLL | Пакет относительный путь к исправления,.msix/.appx для загрузки. |
| исправления | конфигурации | (Необязательно) Определяет, как ведет себя рассылки исправления. Точный формат это значение зависит от на основе исправления, исправление, как каждого исправления может интерпретировать этот «большой двоичный объект», так как оно будет. |

`applications`, `processes`, И `fixups` ключи являются массивами. Это означает, что можно использовать файл config.json более одного приложения, процесс и исправить DLL.


### <a name="package-and-test-the-app"></a>Пакет и тестирования приложения

Затем создайте пакет.

```
makeappx pack /d PackageContents /p PSFSamplePackageFixup.msix
```

Затем подпишите ее.

```
signtool sign /a /v /fd sha256 /f ExportedSigningCertificate.pfx PSFSamplePackageFixup.msix
```

Дополнительные сведения см. в разделе [Создание сертификата для подписи пакета](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/how-to-create-a-package-signing-certificate) и [Подписание пакета, с помощью signtool](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/how-to-sign-a-package-using-signtool)

С помощью PowerShell, установите пакет.

>[!NOTE]
> Не забудьте удалить пакет.

```
powershell Add-MSIXPackage .\PSFSamplePackageFixup.msix
```

Запустите приложение и проверьте работу с применяется исправление среды выполнения.  Повторите действия упаковки при необходимости и диагностики.

### <a name="use-the-trace-fixup"></a>Использование трассировки исправления

Альтернативный метод для диагностики проблем с совместимостью упакованного приложения — использовать исправления трассировки. Эта библиотека DLL входит в состав Инструмент и предоставляет подробное представление диагностики поведения приложения, как монитор процесса.  Специально разработан для отображения проблем совместимости приложений.  Чтобы использовать исправления трассировки, добавить DLL-ФАЙЛ пакета, добавьте следующий фрагмент вашего config.json и затем упаковывать и установить приложение.

```json
{
    "dll": "TraceFixup.dll",
    "config": {
        "traceLevels": {
            "filesystem": "allFailures"
        }
    }
}
```

По умолчанию исправить трассировки отфильтровывает ошибки, которые могут считаться «ожидается».  Например приложения могут попытаться безусловно удаление файла без проверки, если он уже существует, игнорируя результат. Это имеет нежелательным результат, некоторые непредвиденных сбоев может получить отфильтрованы, поэтому в приведенном выше примере мы зарегистрироваться для получения всех сбоев из функций файловой системы. Это необходимо, так как мы знаем из перед, происходит сбой попытки для чтения из файла Config.txt с сообщения «файл не найден». Это происходит сбой, часто возникающие и предполагается, что обычно не непредвиденных. На практике это скорее всего для начала фильтрации только для непредвиденных сбоев, а затем возврат к всплывающему все ошибки при наличии проблемы, которые по-прежнему не удается определить.

По умолчанию выходные данные трассировки исправление отправляется в присоединенного отладчика. В этом примере мы не нужно присоединить отладчик и используйте вместо [DebugView](https://docs.microsoft.com/en-us/sysinternals/downloads/debugview) программу из SysInternals, чтобы просмотреть свой вывод. После запуска приложения, можно увидеть те же ошибки как и раньше, какой бы момент нам по направлению к же исправления среды выполнения.

![Файл TraceShim не найден](images/desktop-to-uwp/traceshim_filenotfound.png)

![Отказано в доступе TraceShim](images/desktop-to-uwp/traceshim_accessdenied.png)

## <a name="debug-extend-or-create-a-runtime-fix"></a>Отладка, расширить или создать исправление среды выполнения

Можно использовать Visual Studio для отладки исправление среды выполнения, расширение среды выполнения исправления или создать ее с нуля. Необходимо выполнить следующие действия, чтобы добиться успеха.

> [!div class="checklist"]
> * Добавьте проект упаковки
> * Добавление проекта для выполнения исправления
> * Добавление проекта, который запускает исполняемый средства запуска Инструмент
> * Настройки проекта упаковки

Когда все будет готово, решение будет выглядеть следующим образом.

![Завершенное решение](images/desktop-to-uwp/runtime-fix-project-structure.png)

Давайте рассмотрим каждый проект в этом примере.

| Проект | Описание |
|-------|-----------|
| DesktopApplicationPackage | Этот проект основан на [проект упаковки приложения Windows](desktop-to-uwp-packaging-dot-net.md) , и он выводит пакета MSIX. |
| Runtimefix | Это библиотека C++ Dynamic-Linked проект, который содержит один или несколько функции замены, которые служат в качестве исправление среды выполнения. |
| PSFLauncher | Это пустой проект C++. Этот проект является местом для сбора файлов среды выполнения распространяемый пакет поддержки инфраструктуры. Он выводит исполняемого файла. Этот исполняемый файл — первое, который выполняется при запуске решения. |
| WinFormsDesktopApplication | Этот проект содержит исходный код классического приложения. |

Рассмотрим полный пример, который содержит все эти типы проектов, см. в разделе [PSFSample](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/samples/PSFSample/).

Рассмотрим шаги для создания и настройки каждого из этих проектов в вашем решении.


### <a name="create-a-package-solution"></a>Создание пакета решения

Если вы не уже решение для классического приложения, создайте новое **Пустое решение** в Visual Studio.

![Пустое решение](images/desktop-to-uwp/blank-solution.png)

Можно также добавить любые приложения проектов у вас имеются.

### <a name="add-a-packaging-project"></a>Добавьте проект упаковки

Если у вас еще нет **Проект упаковки приложения для Windows**, создайте его и добавьте его в свое решение.

![Шаблон проекта пакета](images/desktop-to-uwp/package-project-template.png)

Дополнительные сведения о проект упаковки приложения Windows см. в разделе [пакета приложения с помощью Visual Studio](desktop-to-uwp-packaging-dot-net.md).

В **Обозревателе решений**щелкните правой кнопкой мыши проект упаковки, выберите **Изменить**и затем добавить в нижней части файла проекта:

```
<Target Name="PSFRemoveSourceProject" AfterTargets="ExpandProjectReferences" BeforeTargets="_ConvertItems">
<ItemGroup>
  <FilteredNonWapProjProjectOutput Include="@(_FilteredNonWapProjProjectOutput)">
  <SourceProject Condition="'%(_FilteredNonWapProjProjectOutput.SourceProject)'=='<your runtime fix project name goes here>'" />
  </FilteredNonWapProjProjectOutput>
  <_FilteredNonWapProjProjectOutput Remove="@(_FilteredNonWapProjProjectOutput)" />
  <_FilteredNonWapProjProjectOutput Include="@(FilteredNonWapProjProjectOutput)" />
</ItemGroup>
</Target>
```

### <a name="add-project-for-the-runtime-fix"></a>Добавление проекта для выполнения исправления

Добавьте в решение проект C++ **Библиотек динамической компоновки (DLL)** .

![Библиотеки среды выполнения исправления](images/desktop-to-uwp/runtime-fix-library.png)

Щелкните правой кнопкой мыши, проект, а затем выберите **Свойства**.

На страницах свойств найти **Стандартный язык C++** поле и выберите в раскрывающемся списке рядом с этого поля, **ISO C ++ 17 Standard (/ std: c ++ 17)** параметр.

![ISO 17 параметр](images/desktop-to-uwp/iso-option.png)

Щелкните правой кнопкой мыши проект и выберите в контекстном меню выберите вариант **Управление пакетами Nuget** . Убедитесь, что **все** или **nuget.org**параметр **источника пакета** .

Щелкните значок «параметры», затем этого поля.

Найдите *Инструмент** Nuget пакета, а затем установите его для этого проекта.

![пакет NuGet](images/desktop-to-uwp/psf-package.png)

Если вы хотите отладки или расширить существующий исправление среды выполнения, добавьте файлы исправление среды выполнения, полученных с помощью рекомендации, описанные в разделе [найти исправление среды выполнения](#find) в этом руководстве.

Если вы планируете создавать новое исправление, ничего не добавляют в этот проект просто еще. Мы поможем вам добавить нужные файлы в проект далее в этом руководстве. Сейчас мы продолжим настройку свое решение.

### <a name="add-a-project-that-starts-the-psf-launcher-executable"></a>Добавление проекта, который запускает исполняемый средства запуска Инструмент

Добавьте проект C++ **Пустой проект** в решение.

![Пустой проект](images/desktop-to-uwp/blank-app.png)

Добавьте пакет Nuget **Инструмент** для этого проекта с помощью одной рекомендации, описанные в предыдущем разделе.

Откройте на страницах свойств проекта и на странице " **Общие** параметры", значение свойства **Имя целевого** ``PSFLauncher32`` или ``PSFLauncher64`` в зависимости от архитектуры приложения.

![Справочник по Инструмент запуска](images/desktop-to-uwp/shim-exe-reference.png)

Добавьте ссылку на проект исправление среды выполнения проект в вашем решении.

![исправление справке среды выполнения](images/desktop-to-uwp/reference-fix.png)

Щелкните правой кнопкой мыши ссылку, а затем в окне " **Свойства** " Примените эти значения.

| Свойство | Значение |
|-------|-----------|
| Копирование локальных | True |
| Копировать локально вспомогательные сборки | True |
| Выходные данные сборки ссылки | True |
| Зависимостей | False |
| Входные данные зависимостей библиотеки ссылки | False |

### <a name="configure-the-packaging-project"></a>Настройки проекта упаковки

В проекте упаковки щелкните правой кнопкой мыши папку **Приложения** и выберите **Добавить ссылку**.

![Добавление ссылки на проект](images/desktop-to-uwp/add-reference-packaging-project.png)

Выберите проект запуска Инструмент и проект классического приложения, а затем нажмите кнопку « **ОК** ».

![Проект классического приложения](images/desktop-to-uwp/package-project-references.png)

>[!NOTE]
> Если нет исходного кода для вашего приложения, просто выберите Инструмент запуска проекта. Мы покажем, как для ссылки исполняемый файл при создании файла конфигурации.

В узле **приложения** щелкните правой кнопкой мыши Инструмент средства запуска приложений и выберите **задать в качестве точки входа**.

![Задание точки входа](images/desktop-to-uwp/set-startup-project.png)

Добавьте в файл с именем ``config.json`` в свой проект упаковки, затем скопируйте и вставьте следующий текст json в файл. Задайте свойство **Действия пакета** для **содержимого**.

```json
{
    "applications": [
        {
            "id": "",
            "executable": "",
            "workingDirectory": ""
        }
    ],
    "processes": [
        {
            "executable": "",
            "fixups": [
                {
                    "dll": "",
                    "config": {
                    }
                }
            ]
        }
    ]
}
```
Предоставляет значение для каждого ключа. Руководствуйтесь в этой таблице.

| Массив | key | Значение |
|-------|-----------|-------|
| Приложения | id |  Используйте значение `Id` атрибута `Application` в манифесте пакета. |
| Приложения | исполняемые | Пакет относительный путь исполняемого файла, который вы хотите начать. В большинстве случаев можно получить это значение в файл манифеста пакета, прежде чем вносить изменения. Это значение `Executable` атрибута `Application` элемента. |
| Приложения | workingDirectory | (Необязательно) Путь относительно пакета для использования в качестве рабочий каталог приложения, которое запускается. Если это значение не задано, операционная система использует `System32` каталог как рабочий каталог приложения. |
| процессы | исполняемые | В большинстве случаев это будет имя `executable` настроено выше с расширением путь и файл удален. |
| исправления | Библиотека DLL | Пакет относительный путь, чтобы исправить библиотеки DLL для загрузки. |
| исправления | конфигурации | (Необязательно) Определяет, как ведет себя исправления DLL. Точный формат это значение зависит от на основе исправления, исправление, как каждого исправления может интерпретировать этот «большой двоичный объект», так как оно будет. |

Когда все будет готово к ``config.json`` файл будет выглядеть примерно следующим образом.

```json
{
  "applications": [
    {
      "id": "DesktopApplication",
      "executable": "DesktopApplication/WinFormsDesktopApplication.exe",
      "workingDirectory": "WinFormsDesktopApplication"
    }
  ],
  "processes": [
    {
      "executable": ".*App.*",
      "fixups": [ { "dll": "RuntimeFix.dll" } ]
    }
  ]
}

```

>[!NOTE]
> `applications`, `processes`, И `fixups` ключи являются массивами. Это означает, что можно использовать файл config.json более одного приложения, процесс и исправить DLL.

### <a name="debug-a-runtime-fix"></a>Отладка исправление среды выполнения

В Visual Studio нажмите клавишу F5, чтобы запустить отладчик.  Первое, что запускает — это Инструмент запуска приложения, который в свою очередь, запускает целевой классического приложения.  Для отладки классического приложения целевого объекта, вам придется вручную присоединиться к процессу классического приложения, выбрав **отладки**->**присоединиться к процессу**, а затем выбрав процесса приложения. Чтобы разрешить отладку приложения .NET с помощью среды выполнения собственной исправление DLL, выберите типы управляемый и машинный код (Отладка в смешанном режиме).  

После того как вы установите, точки прерывания рядом с строк кода можно задать в коде классического приложения и исправление проекта среды выполнения. Если для вашего приложения нет исходного кода, вы сможете задать точки прерывания только рядом с строки кода в проекте исправление среды выполнения.

>[!NOTE]
> Visual Studio предоставляет простой разработки и отладки взаимодействия, существуют некоторые ограничения, поэтому далее в этом руководстве мы обсудим другие методы отладки, которые можно применить.

## <a name="create-a-runtime-fix"></a>Создание среды выполнения исправления

Если не существует еще среды выполнения устранить проблему, необходимо устранить, можно создать новый исправление среды выполнения, написание замены функций и любые данные конфигурации в том числе, имеет смысл. Давайте рассмотрим каждой части.

### <a name="replacement-functions"></a>Замена функции

Во-первых определите вызовы завершаться сбоем, если приложение выполняется в контейнере MSIX функций. Затем вы можете создать замены функции, которые вы хотите диспетчера среды выполнения для вызова вместо. Это дает возможность реализации функции Заменить поведение, которое соответствует правилам современные среды.

В Visual Studio откройте проект исправление среды выполнения, созданный ранее в этом руководстве.

Объявите ``FIXUP_DEFINE_EXPORTS`` макрос, а затем добавьте оператор include для `fixup_framework.h` в верхней части каждой. Файл CPP, где вы планируете функции исправление среды выполнения.

```c++
#define FIXUP_DEFINE_EXPORTS
#include <fixup_framework.h>
```
>[!IMPORTANT]
>Убедитесь, что `FIXUP_DEFINE_EXPORTS` макрос отображается перед инструкции include.

Создать функцию, которая имеет ту же подпись, функции, кто имеет поведение, которую требуется изменить. Ниже приведен пример функции, которая заменяет `MessageBoxW` функции.

```c++
auto MessageBoxWImpl = &::MessageBoxW;
int WINAPI MessageBoxWFixup(
    _In_opt_ HWND hwnd,
    _In_opt_ LPCWSTR,
    _In_opt_ LPCWSTR caption,
    _In_ UINT type)
{
    return MessageBoxWImpl(hwnd, L"SUCCESS: This worked", caption, type);
}

DECLARE_FIXUP(MessageBoxWImpl, MessageBoxWFixup);
```

Вызов `DECLARE_FIXUP` сопоставляет `MessageBoxW` функции к новой функции замены. Если приложение пытается вызвать `MessageBoxW` функции, он будет вызывать функцию замены вместо.

#### <a name="protect-against-recursive-calls-to-functions-in-runtime-fixes"></a>Защиту от рекурсивный вызовы функций в среде выполнения исправления

Вы можете при необходимости применить `reentrancy_guard` тип вашего функций, защиту от рекурсивный вызовы функций в среде выполнения исправления.

Например, можно создать функцию для замены `CreateFile` функции. Реализация может вызывать `CopyFile` функции, но реализация `CopyFile` может вызвать функцию `CreateFile` функции. Это может привести к цикл бесконечное рекурсивный вызовов `CreateFile` функции.

Дополнительные сведения о `reentrancy_guard` см. в разделе [authoring.md](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/Authoring.md)

### <a name="configuration-data"></a>Данные конфигурации

Если вы хотите добавить данные конфигурации для вашей среды выполнения исправления, вы можете добавить его к ``config.json``. Таким образом, вы можете использовать `FixupQueryCurrentDllConfig` легко проанализировать эти данные. В этом примере анализирует значение boolean и строки из этого файла конфигурации.

```c++
if (auto configRoot = ::FixupQueryCurrentDllConfig())
{
    auto& config = configRoot->as_object();

    if (auto enabledValue = config.try_get("enabled"))
    {
        g_enabled = enabledValue->as_boolean().get();
    }

    if (auto logPathValue = config.try_get("logPath"))
    {
        g_logPath = logPathValue->as_string().wstring();
    }
}
```

## <a name="other-debugging-techniques"></a>Другие методы отладки

Хотя Visual Studio предоставляет простой разработки и отладки взаимодействия, существуют некоторые ограничения.

Во-первых, отладки F5 запускает приложение путем развертывания свободных файлов из путь к папке макета пакета, а не Установка из .msix / пакета AppX.  Папка макета обычно не имеют те же ограничения безопасности папки установленного пакета. Таким образом может оказаться невозможно воспроизвести пакетов путь доступа отказ ошибки до применения исправления среды выполнения.

Чтобы устранить эту проблему, используйте .msix / развертывание пакета AppX-файл, а не F5 свободных файлов развертывания.  Чтобы создать .msix или файл пакета .appx использовать служебную программу [MakeMSIX](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/make-appx-package--makeappx-exe-) из пакета Windows SDK, как описано выше. Или, из в Visual Studio, щелкните правой кнопкой мыши узел проекта приложения и выберите **хранилище**->**Создание пакетов приложений**.

Другая проблема с помощью Visual Studio является то, что он не встроенную поддержку для присоединения к все дочерние процессы, запущенные в отладчике.   Это затрудняет для отладки логики в пути запуска целевого приложения, которое необходимо вручную подключить с помощью Visual Studio после запуска.

Чтобы решить эту проблему, присоединить использовать отладчик, который поддерживает дочернего процесса.  Обратите внимание, что это обычно не можно прикрепить отладчик just in time (JIT) для целевого приложения.  Это связано с большинством методов JIT включают запуск отладчика вместо конечным приложением, через раздел реестра ImageFileExecutionOptions.  Это препятствует detouring механизм, используемый PSFLauncher.exe для внедрения FixupRuntime.dll в целевого приложения.  Отладчик WinDbg, в состав [Средств отладки для Windows](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index)и берутся из [Пакета Windows SDK](https://developer.microsoft.com/en-US/windows/downloads/windows-10-sdk), присоедините поддерживает дочернего процесса.  Он также теперь поддерживает непосредственно [Запуск и отладка приложения UWP](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-a-uwp-app-using-windbg#span-idlaunchinganddebuggingauwpappspanspan-idlaunchinganddebuggingauwpappspanspan-idlaunchinganddebuggingauwpappspanlaunching-and-debugging-a-uwp-app).

Отладка загрузки целевого приложения как дочерний процесс, запустите ``WinDbg``.

```
windbg.exe -plmPackage PSFSampleWithFixup_1.0.59.0_x86__7s220nvg1hg3m -plmApp PSFSample
```

В ``WinDbg`` запрос, включение отладки дочерних и задавать точки останова.

```
.childdbg 1
g
```
(выполняться, пока приложение запускается и отладчика)

```
sxe ld fixup.dll
g
```
(выполнение до загрузки DLL исправления)

```
bp ...
```

>[!NOTE]
> [PLMDebug](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/plmdebug) также может использоваться для присоединения к приложения при запуске отладчика, а также входит в [Средства отладки для Windows](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index).  Тем не менее является более сложным в использовании, чем прямая поддержка, теперь предоставляемые WinDbg.

## <a name="support-and-feedback"></a>Поддержка и отзывы

**Поиск ответов на вопросы**

Есть вопросы? Задайте их на Stack Overflow. Наша команда следит за этими [тегами](http://stackoverflow.com/questions/tagged/project-centennial+or+desktop-bridge). Вы также можете задать нам вопросы [здесь](https://social.msdn.microsoft.com/Forums/en-US/home?filter=alltypes&sort=relevancedesc&searchTerm=%5BDesktop%20Converter%5D).

