---
author: normesta
Description: Fix issues that prevent your desktop application from running in an MSIX container
Search.Product: eADQiWindows 10XVcnh
title: Устранение проблем, которые запрещают запуск в контейнере MSIX классического приложения
ms.author: normesta
ms.date: 07/02/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 7e5119696498156d36ec63b16b1d76c00b03f4df
ms.sourcegitcommit: 4f6dc806229a8226894c55ceb6d6eab391ec8ab6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/20/2018
ms.locfileid: "4091614"
---
# <a name="apply-runtime-fixes-to-an-msix-package-by-using-the-package-support-framework"></a>Применить исправления среды выполнения к пакету MSIX с помощью платформа поддержки пакетов

Платформа поддержки пакета — комплекту с открытым исходным кодом, который позволяет применить исправления существующие приложения win32 при отсутствии доступа к исходному коду, так, чтобы оно могло выполняться в контейнере MSIX. Платформа поддержки пакетов помогает следуйте рекомендациям среды современные среды выполнения приложения.

Дополнительные сведения см. в разделе [Платформа поддержки пакетов](https://docs.microsoft.com/windows/msix/package-support-framework-overview).

Это руководство поможет вам для идентификации проблем совместимости приложений, и для поиска, применения и расширение среды выполнения исправления, их устранения.

<a id="identify" />

## <a name="identify-packaged-application-compatibility-issues"></a>Выявлять проблемы совместимости упакованного приложения

Во-первых создайте пакет для вашего приложения. Затем, установите его, запустить его и проверка его поведения. Может появиться сообщения об ошибках, которые помогают выявить проблемы совместимости. [Монитор процессов](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) также можно использовать для выявления проблем.  Распространенные проблемы связаны с приложения предположений о разрешениях рабочий каталог и программы путь.

### <a name="using-process-monitor-to-identify-an-issue"></a>Использование монитора процесс для определения проблемы

[Монитор процессов](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) — это мощное служебная программа для наблюдение операции реестра и файл приложения и их результаты.  Это может помочь вам понять проблем совместимости приложений.  После открытия монитор процессов, добавьте фильтр (фильтр > Фильтр …) для включения только события от исполняемый файл приложения.

![Фильтр ProcMon приложения](images/desktop-to-uwp/procmon_app_filter.png)

Появится список событий. Для многих из этих событий слово **Успех** будет отображаться в столбце **результат** .

![События ProcMon](images/desktop-to-uwp/procmon_events.png)

При необходимости вы можете отфильтровать события, чтобы отображать только ошибки.

![Успех ProcMon Exclude](images/desktop-to-uwp/procmon_exclude_success.png)

Если вы подозреваете сбой доступ к файловой системе, поиск неудачных событий, которые относятся к System32/SysWOW64 или путь к файлу пакета. Фильтры также поможет здесь слишком. Запустите в нижней части этого списка и прокрутку вверх. Недавно произошли ошибки, которые отображаются в нижней части этого списка. Обратите внимание, большинство ошибок, содержащих строки, такие как «доступ запрещен» и «путь/имя не найдено» и игнорировать вещей, которые выглядят как подозрительные. [PSFSample](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/samples/PSFSample/) имеет два проблемы. Вы можете увидеть эти проблемы в списке, который отображается на следующем изображении.

![ProcMon Config.txt](images/desktop-to-uwp/procmon_config_txt.png)

В первом проблема, которая отображается в это изображение приложения происходит сбой для чтения из файла «Config.txt», который находится в папке «C:\Windows\SysWOW64». Маловероятно, что приложение пытается ссылаться на этот путь напрямую. Скорее всего его пытаются считываются из этого файла с помощью относительный путь, и по умолчанию «System32/SysWOW64» — это рабочий каталог приложения. Это предполагает, что приложение ожидает его текущий рабочий каталог для значение где-то в пакете. Ищете внутри appx, мы видим, что файл существует в том же каталоге, что и исполняемый файл.

![Config.txt приложения](images/desktop-to-uwp/psfsampleapp_config_txt.png)

Вторая проблема отображается на следующем изображении.

![Файл журнала ProcMon](images/desktop-to-uwp/procmon_logfile.png)

В этом выпуске приложения происходит сбой для записи файл журнала его путь к пакету. Это предположить, что может помочь оболочка перенаправление файлов.

<a id="find" />

## <a name="find-a-runtime-fix"></a>Найдите исправление среды выполнения

Инструмент содержит исправления среды выполнения, которые можно использовать прямо сейчас, например оболочку перенаправление файлов.

### <a name="file-redirection-shim"></a>Перенаправление оболочку файла

Можно использовать [Файл перенаправления оболочку](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/develop/FileRedirectionShim) для перенаправления попытки записи или чтения данных в каталоге, который не доступен из приложения, которое выполняется в контейнере MSIX.

Например если ваше приложение записывает данные в файл журнала, в том же каталоге, как исполняемые вашего приложения, можно использовать [Файл перенаправления оболочку](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/develop/FileRedirectionShim) для создания этого файла журнала в другом месте, таких как локальное хранилище данных приложения.

### <a name="runtime-fixes-from-the-community"></a>Среда выполнения исправления от сообщества

Не забудьте изучить взносы сообщества на нашу страницу [GitHub](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/develop) . Это возможно, что другие разработчики была устранена проблема, сходные с вашими и предоставили исправление среды выполнения.

## <a name="apply-a-runtime-fix"></a>Исправление, среды выполнения

Можно применить существующий исправление среды выполнения с помощью несколько простых средств из пакета Windows SDK и, выполнив следующие действия.

> [!div class="checklist"]
> * Создайте папку макета пакета
> * Получение файлов платформа поддержки пакетов
> * Добавление их в пакет
> * Изменение манифеста пакета
> * Создание файла конфигурации

Давайте пройти все задачи.

### <a name="create-the-package-layout-folder"></a>Создайте папку макета пакета

Если у вас уже есть файл .appx, его содержимое можно распаковать в папку макета, который будет служить промежуточной области для пакета.  Вы можете сделать это в **x64 собственные средства командной строки для VS 2017**, или вручную с помощью в SDK Bin в пути исполняемого поиска.

```
makeappx unpack /p PSFSamplePackage_1.0.60.0_AnyCPU_Debug.appx /d PackageContents

```

Это даст вам то, что выглядит следующим образом.

![Макет пакета](images/desktop-to-uwp/package_contents.png)

Если у вас нет файл .appx начать с, можно создать папку пакета и файлы с нуля.

### <a name="get-the-package-support-framework-files"></a>Получение файлов платформа поддержки пакетов

Вы можете получить пакет Nuget Инструмент с помощью Visual Studio. Вы также можете получить с помощью средства командной строки автономный Nuget.

#### <a name="get-the-package-by-using-visual-studio"></a>Получите пакет с помощью Visual Studio

В Visual Studio щелкните правой кнопкой мыши узел вашего решения или проекта и выберите одну из команд Управление пакетами Nuget.  Поиск **Microsoft.PackageSupportFramework** или **Инструмент** поиска пакета Nuget.org. Затем установите его.

#### <a name="get-the-package-by-using-the-command-line-tool"></a>Получите пакет с помощью средства командной строки

Установить средство командной строки Nuget из этого расположения: https://www.nuget.org/downloads. Затем с помощью Nuget командной строки, выполните следующую команду:

```
nuget install Microsoft.PackageSupportFramework
```

### <a name="add-the-package-support-framework-files-to-your-package"></a>Добавление файлов платформа поддержки пакетов в пакет

Добавьте необходимые 32-разрядные и 64-разрядные библиотеки DLL Инструмент и исполняемые файлы каталога пакета. Руководствуйтесь следующей таблицей. Также необходимо включить все исправления среды выполнения, которые необходимо. В нашем примере нам нужно исправить файл перенаправления среды выполнения.

| Исполняемый файл приложения — x64 | Исполняемый файл приложения — x86 |
|-------------------------------|-----------|
| [ShimLauncher64.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimLauncher/readme.md) |  [ShimLauncher32.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimLauncher/readme.md) |
| [ShimRuntime64.dll](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRuntime/readme.md) | [ShimRuntime32.dll](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRuntime/readme.md) |
| [ShimRunDll64.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRunDll/readme.md) | [ShimRunDll32.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRunDll/readme.md) |

Содержимое пакета теперь должен выглядеть примерно следующим образом.

![Двоичные файлы пакета](images/desktop-to-uwp/package_binaries.png)

### <a name="modify-the-package-manifest"></a>Изменение манифеста пакета

Откройте манифест пакета в текстовом редакторе, а затем установите `Executable` атрибут `Application` элементу имя исполняемого файла средства запуска оболочки.  Если вы знаете архитектуре целевого приложения, выберите нужную версию, ShimLauncher32.exe или ShimLauncher64.exe.  В противном случае ShimLauncher32.exe будут работать во всех случаях.  Вот пример.

```xml
<Package ...>
  ...
  <Applications>
    <Application Id="PSFSample"
                 Executable="ShimLauncher32.exe"
                 EntryPoint="Windows.FullTrustApplication">
      ...
    </Application>
  </Applications>
</Package>
```

### <a name="create-a-configuration-file"></a>Создание файла конфигурации

Создание имени файла ``config.json``и сохраните этот файл в корневую папку пакета. Измените объявленный идентификатор config.json файла, чтобы указать исполняемый файл, который вы только что заменены на. С помощью знания, полученная в результате с помощью процесса монитора, вы можете также задать рабочий каталог как также используется оболочку перенаправление файлов для перенаправления операций чтения/записи в файлы с расширением LOG package-relative в каталоге «PSFSampleApp».

```json
{
    "applications": [
        {
            "id": "PSFSample",
            "executable": "PSFSampleApp/PSFSample.exe",
            "workingDirectory": "PSFSampleApp/"
        }
    ],
    "processes": [
        {
            "executable": "PSFSample",
            "shims": [
                {
                    "dll": "FileRedirectionShim.dll",
                    "config": {
                        "redirectedPaths": {
                            "packageRelative": [
                                {
                                    "base": "PSFSampleApp/",
                                    "patterns": [
                                        ".*\\.log"
                                    ]
                                }
                            ]
                        }
                    }
                }
            ]
        }
    ]
}
```
Ниже приведена руководство по схеме config.json.

| Массив | key | Значение |
|-------|-----------|-------|
| Приложения | id |  Используйте значение `Id` атрибут `Application` в манифесте пакета. |
| Приложения | исполняемые | Package-relative путь к исполняемому файлу, который вы хотите начать. В большинстве случаев это значение можно получить из файл манифеста пакета перед внесением изменений. Это значение `Executable` атрибут `Application` элемента. |
| Приложения | workingDirectory | (Необязательно) Путь package-relative для использования в качестве рабочий каталог приложения, которое запускается. Если это значение не задано, операционная система использует `System32` каталог как рабочий каталог приложения. |
| процессы | исполняемые | В большинстве случаев это будет имя `executable` настроено выше с расширением путь и файл удален. |
| оболочками | Библиотека DLL | Пакет относительный путь к .appx оболочку для загрузки. |
| оболочками | конфигурации | (Необязательно) Элементы управления, как ведет себя рассылки оболочку. Точный формат это значение зависит от на основе оболочку, оболочку как каждого оболочку может интерпретировать этот «большой двоичный объект» насколько это требуется. |

`applications`, `processes`, И `shims` ключи являются массивами. Это означает, что можно использовать файл config.json более одного приложения, процесс и оболочку DLL.


### <a name="package-and-test-the-app"></a>Пакет и тестирования приложения

Затем создайте пакет.

```
makeappx pack /d PackageContents /p PSFSamplePackageFixup.appx
```

Затем подпишите ее.

```
signtool sign /a /v /fd sha256 /f ExportedSigningCertificate.pfx PSFSamplePackageFixup.appx
```

Дополнительные сведения см. в разделе [как для создания сертификата для подписи пакета](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/how-to-create-a-package-signing-certificate) и [подписать пакет с помощью signtool](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/how-to-sign-a-package-using-signtool)

С помощью PowerShell, установите пакет.

>[!NOTE]
> Не забудьте сначала удаление пакета.

```
powershell Add-AppxPackage .\PSFSamplePackageFixup.appx
```

Запустите приложение и наблюдения за поведением с применить исправление среды выполнения.  Повторите действия упаковку при необходимости и диагностики.

### <a name="use-the-trace-shim"></a>Используйте оболочку трассировки

Альтернативный метод для диагностики проблем с совместимостью упакованного приложения является использование оболочку трассировки. Эта библиотека DLL входит в состав Инструмент и предоставляет подробное представление диагностики поведения приложения, аналогично монитор процессов.  Специально разработан для отображения проблем совместимости приложений.  Чтобы использовать оболочку трассировки, добавить DLL-ФАЙЛ пакета, добавьте следующий фрагмент config.json и затем упаковывать и установить приложение.

```json
{
    "dll": "TraceShim.dll",
    "config": {
        "traceLevels": {
            "filesystem": "allFailures"
        }
    }
}
```

По умолчанию оболочку трассировки отфильтровывает ошибки, которые могут считаться «ожидается».  Например приложения могут попытаться безусловно удалить файл, не выполняется проверка, если он уже существует, игнорируя результат. Это имеет сожалению вследствие, некоторые непредвиденных сбоев может получить отфильтрованы, поэтому в приведенном выше примере мы зарегистрироваться для получения всех сбоев из функций файловой системы. Это необходимо, так как мы знаем из перед, происходит сбой попытки для чтения из файла Config.txt с сообщения «файл не найден». Это происходит сбой, часто observed и предполагается, что обычно не непредвиденных. На практике это скорее всего начать свой фильтрации только для непредвиденных сбоев, а затем возврат к всплывающему все ошибки при наличии проблемы, которые по-прежнему не удается определить.

По умолчанию выходные данные трассировки оболочку отправляется в присоединенного отладчика. В этом примере мы не следует прикрепить отладчик и используйте вместо [DebugView](https://docs.microsoft.com/en-us/sysinternals/downloads/debugview) программа из компании SysInternals, чтобы просмотреть свой вывод. После запуска приложения, мы видим те же ошибки как и раньше, какой бы момент нам по направлению к же исправления среды выполнения.

![Файл TraceShim не найден](images/desktop-to-uwp/traceshim_filenotfound.png)

![Отказано в доступе TraceShim](images/desktop-to-uwp/traceshim_accessdenied.png)

## <a name="debug-extend-or-create-a-runtime-fix"></a>Отладка, расширить или создать исправление среды выполнения

Visual Studio можно использовать для отладки исправление среды выполнения, расширение среды выполнения исправление или создать ее с нуля. Необходимо выполнить следующие действия, чтобы добиться успеха.

> [!div class="checklist"]
> * Добавьте проект упаковки
> * Добавление проекта для выполнения исправления
> * Добавление проекта, который запускает исполняемый средства запуска оболочки
> * Настройки проекта упаковки

Когда все будет готово, решение будет выглядеть следующим образом.

![Завершенное решение](images/desktop-to-uwp/runtime-fix-project-structure.png)

Давайте взглянем на каждый проект в этом примере.

| Проект | Описание |
|-------|-----------|
| DesktopApplicationPackage | Этот проект основан на [проект упаковки приложения Windows](desktop-to-uwp-packaging-dot-net.md) , и он выводит MSIX пакета. |
| Runtimefix | Это проект библиотеки Dynamic-Linked C++, который содержит одну или несколько функций замены, которые служат исправление среды выполнения. |
| ShimLauncher | Это пустой проект C++. Этот проект является местом для сбора файлов распространяемого среды выполнения платформы поддержки пакета. Он выводит исполняемого файла. Этот исполняемый файл — первое, который выполняется при запуске решения. |
| WinFormsDesktopApplication | Этот проект содержит исходный код классического приложения. |

Чтобы взглянуть на полный пример со всеми этими типами проектов, см. в разделе [PSFSample](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/samples/PSFSample/).

Рассмотрим шаги для создания и настройки каждого из этих проектов в вашем решении.


### <a name="create-a-package-solution"></a>Создайте пакет решение

Если вы не уже решение для классического приложения, создайте новое **Пустое решение** в Visual Studio.

![Пустое решение](images/desktop-to-uwp/blank-solution.png)

Можно также добавить любые приложения проектов у вас имеются.

### <a name="add-a-packaging-project"></a>Добавьте проект упаковки

Если у вас еще нет **Проект упаковки приложения для Windows**, создайте его и добавьте его в свое решение.

![Шаблон проекта пакета](images/desktop-to-uwp/package-project-template.png)

Дополнительные сведения о проект упаковки приложения Windows см. в разделе [пакета приложения с помощью Visual Studio](desktop-to-uwp-packaging-dot-net.md).

В **Обозревателе решений**щелкните правой кнопкой мыши проект упаковки, выберите **Изменить**и затем добавить в нижней части файла проекта:

```
<Target Name="PSFRemoveSourceProject" AfterTargets="ExpandProjectReferences" BeforeTargets="_ConvertItems">
<ItemGroup>
  <FilteredNonWapProjProjectOutput Include="@(_FilteredNonWapProjProjectOutput)">
  <SourceProject Condition="'%(_FilteredNonWapProjProjectOutput.SourceProject)'=='<your runtime fix project name goes here>'" />
  </FilteredNonWapProjProjectOutput>
  <_FilteredNonWapProjProjectOutput Remove="@(_FilteredNonWapProjProjectOutput)" />
  <_FilteredNonWapProjProjectOutput Include="@(FilteredNonWapProjProjectOutput)" />
</ItemGroup>
</Target>
```

### <a name="add-project-for-the-runtime-fix"></a>Добавление проекта для выполнения исправления

Добавьте в решение проект C++ **Библиотеки динамической компоновки (DLL)** .

![Библиотека времени выполнения исправления](images/desktop-to-uwp/runtime-fix-library.png)

Щелкните правой кнопкой мыши, проекта, а затем выберите **Свойства**.

На страницах свойств, найдите поле **Стандартный язык C++** , а затем в раскрывающемся списке рядом с этого поля, выберите **ISO C ++ 17 Standard (/ std: c ++ 17)** вариант.

![ISO 17 параметр](images/desktop-to-uwp/iso-option.png)

Щелкните правой кнопкой мыши проект и выберите в контекстном меню, параметр **Управление пакетами Nuget** . Убедитесь, что **исходный пакет** был установлен для **всех** или **nuget.org**.

Затем щелкните значок «параметры» этого поля.

Найдите *Инструмент** Nuget пакет, а затем установите его для этого проекта.

![пакет NuGet](images/desktop-to-uwp/psf-package.png)

Если вы хотите отладки или расширить существующий исправление среды выполнения, добавьте файлы исправление среды выполнения, полученных с помощью рекомендации, описанные в разделе [найти исправление среды выполнения](#find) данного руководства.

Если вы планируете создавать новое исправление, ничего не добавляют в этот проект просто еще. Мы поможем вам добавлять нужные файлы в этот проект далее в этом руководстве. Сейчас мы продолжим настройку свое решение.

### <a name="add-a-project-that-starts-the-shim-launcher-executable"></a>Добавление проекта, который запускает исполняемый средства запуска оболочки

Добавьте проект C++ **Пустой проект** в решение.

![Пустой проект](images/desktop-to-uwp/blank-app.png)

Добавьте пакет Nuget **Инструмент** этот проект с помощью же рекомендации, описанные в предыдущем разделе.

Откройте страницы свойств для проекта и на странице " **Общие** параметры", присвойте свойству **Конечное имя** значение ``ShimLauncher32`` или ``ShimLauncher64`` в зависимости от архитектуры приложения.

![Справочник по средство запуска оболочки](images/desktop-to-uwp/shim-exe-reference.png)

Добавьте ссылку проекта в проект исправление среды выполнения в вашем решении.

![исправление справке среды выполнения](images/desktop-to-uwp/reference-fix.png)

Щелкните правой кнопкой мыши ссылку, а затем в окне " **Свойства** " Примените эти значения.

| Свойство | Значение |
|-------|-----------|-------|
| Копировать локальные | True |
| Копировать локально вспомогательные сборки | True |
| Выходные данные сборки ссылки | True |
| Использовать библиотеки из зависимостей | False |
| Входные данные зависимостей библиотеки ссылки | False |

### <a name="configure-the-packaging-project"></a>Настройки проекта упаковки

В проекте упаковки щелкните правой кнопкой мыши папку **Приложения** и выберите **Добавить ссылку**.

![Добавление ссылки на проект](images/desktop-to-uwp/add-reference-packaging-project.png)

Выберите проект средства запуска оболочки и проект классического приложения, а затем нажмите кнопку « **ОК** ».

![Проект классического приложения](images/desktop-to-uwp/package-project-references.png)

>[!NOTE]
> Если у вас не исходный код в приложение, просто выберите проекта средства запуска оболочки. Мы покажем, как для ссылки исполняемый файл при создании файла конфигурации.

В узле **приложения** щелкните правой кнопкой мыши приложение средства запуска оболочки и выберите **задать в качестве точки входа**.

![Задание точки входа](images/desktop-to-uwp/set-startup-project.png)

Добавьте в файл с именем ``config.json`` в свой проект упаковки, затем скопируйте и вставьте следующий текст json в файл. Присвойте свойству **Действие пакета** для **содержимого**.

```json
{
    "applications": [
        {
            "id": "",
            "executable": "",
            "workingDirectory": ""
        }
    ],
    "processes": [
        {
            "executable": "",
            "shims": [
                {
                    "dll": "",
                    "config": {
                    }
                }
            ]
        }
    ]
}
```
Предоставляет значение для каждого ключа. Руководствуйтесь в этой таблице.

| Массив | key | Значение |
|-------|-----------|-------|
| Приложения | id |  Используйте значение `Id` атрибут `Application` в манифесте пакета. |
| Приложения | исполняемые | Package-relative путь к исполняемому файлу, который вы хотите начать. В большинстве случаев это значение можно получить из файл манифеста пакета перед внесением изменений. Это значение `Executable` атрибут `Application` элемента. |
| Приложения | workingDirectory | (Необязательно) Путь package-relative для использования в качестве рабочий каталог приложения, которое запускается. Если это значение не задано, операционная система использует `System32` каталог как рабочий каталог приложения. |
| процессы | исполняемые | В большинстве случаев это будет имя `executable` настроено выше с расширением путь и файл удален. |
| оболочками | Библиотека DLL | Пакет относительный путь к оболочку библиотеки DLL для загрузки. |
| оболочками | конфигурации | (Необязательно) Элементы управления, как ведет себя рассылки оболочку. Точный формат это значение зависит от на основе оболочку, оболочку как каждого оболочку может интерпретировать этот «большой двоичный объект» насколько это требуется. |

Когда все будет готово, ваш ``config.json`` файл будет выглядеть примерно следующим образом.

```json
{
  "applications": [
    {
      "id": "DesktopApplication",
      "executable": "DesktopApplication/WinFormsDesktopApplication.exe",
      "workingDirectory": "WinFormsDesktopApplication"
    }
  ],
  "processes": [
    {
      "executable": ".*App.*",
      "shims": [ { "dll": "RuntimeFix.dll" } ]
    }
  ]
}

```

>[!NOTE]
> `applications`, `processes`, И `shims` ключи являются массивами. Это означает, что можно использовать файл config.json более одного приложения, процесс и оболочку DLL.

### <a name="debug-a-runtime-fix"></a>Отладка исправление среды выполнения

В Visual Studio нажмите клавишу F5, чтобы запустить отладчик.  Первое, что запускает — это средства запуска приложений оболочку, в свою очередь, запускающий целевой классического приложения.  Для отладки классического приложения цели, вам придется вручную подключаться к процессу классического приложения, выбрав **Отладка**->**присоединиться к процессу**, а затем выбрав процесса приложения. Чтобы разрешить отладку приложения .NET с помощью среды выполнения собственной исправление DLL, выберите типы управляемый и машинный код (Отладка в смешанном режиме).  

После того как вы установите, точки прерывания рядом с строк кода можно задать в коде классического приложения и исправление проекта среды выполнения. Если у вас не исходный код в приложение, вы сможете задать точки прерывания только рядом с строк кода в проекте исправление среды выполнения.

>[!NOTE]
> Хотя Visual Studio предоставляет простой разработки и отладки взаимодействия, существуют некоторые ограничения, поэтому далее в этом руководстве мы обсудим другие методы отладки, которые можно применить.

## <a name="create-a-runtime-fix"></a>Создание исправление среды выполнения

Если не существует еще среды выполнения устранить проблемы, что вам нужно решить, можно создать новый исправление среды выполнения, написание замены функций и любые данные конфигурации в том числе это имеет смысл. Давайте взглянем на каждой части.

### <a name="replacement-functions"></a>Замена функции

Во-первых определите вызовы завершаться сбоем, если приложение выполняется в контейнере MSIX функций. Затем вы можете создать замену функции, которые хотели бы диспетчеру среды для вместо вызова. Это дает возможность заменить поведение, которое соответствует правилам среды выполнения современных реализации функции.

В Visual Studio откройте проект исправление среды выполнения, который вы создали ранее в этом руководстве.

Объявите ``SHIM_DEFINE_EXPORTS`` макрос, а затем добавьте оператор include для `shim_framework.h` в верхней части каждой. Файл CPP, где вы планируете добавить в файл Default.js функции вашей среды выполнения исправления.

```c++
#define SHIM_DEFINE_EXPORTS
#include <shim_framework.h>
```
>[!IMPORTANT]
>Убедитесь, что `SHIM_DEFINE_EXPORTS` макрос отображается перед инструкции include.

Создать функцию, которая имеет ту же подпись функции кто имеет поведение, которую требуется изменить. Ниже приведен пример функции, которая заменяет `MessageBoxW` функции.

```c++
auto MessageBoxWImpl = &::MessageBoxW;
int WINAPI MessageBoxWShim(
    _In_opt_ HWND hwnd,
    _In_opt_ LPCWSTR,
    _In_opt_ LPCWSTR caption,
    _In_ UINT type)
{
    return MessageBoxWImpl(hwnd, L"SUCCESS: This worked", caption, type);
}

DECLARE_SHIM(MessageBoxWImpl, MessageBoxWShim);
```

Вызов `DECLARE_SHIM` сопоставляет `MessageBoxW` функции к новой функции замены. Если приложение пытается вызвать `MessageBoxW` функции, он будет вызывать функцию замены вместо.

#### <a name="protect-against-recursive-calls-to-functions-in-runtime-fixes"></a>Защиту от рекурсивный вызовы функций в среде выполнения исправления

Вы можете при необходимости применить `reentrancy_guard` тип вашего функций, которые защиту от рекурсивный вызовы функций в среде выполнения исправления.

Например, можно создать функцию замены для `CreateFile` функции. Реализация может вызывать `CopyFile` функции, но реализация `CopyFile` может вызвать функцию `CreateFile` функции. Это может привести к цикл бесконечное рекурсивный вызовов `CreateFile` функции.

Дополнительные сведения о `reentrancy_guard` см. в разделе [authoring.md](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/Authoring.md)

### <a name="configuration-data"></a>Данные конфигурации

Если вы хотите добавить данные конфигурации для вашей среды выполнения исправление, вы можете добавить его к ``config.json``. Таким образом, вы можете использовать `ShimQueryCurrentDllConfig` легко проанализировать эти данные. В этом примере анализирует значение boolean и строки из этого файла конфигурации.

```c++
if (auto configRoot = ::ShimQueryCurrentDllConfig())
{
    auto& config = configRoot->as_object();

    if (auto enabledValue = config.try_get("enabled"))
    {
        g_enabled = enabledValue->as_boolean().get();
    }

    if (auto logPathValue = config.try_get("logPath"))
    {
        g_logPath = logPathValue->as_string().wstring();
    }
}
```

## <a name="other-debugging-techniques"></a>Другие методы отладки

Хотя Visual Studio предоставляет простой разработки и отладки взаимодействия, существуют некоторые ограничения.

Во-первых отладки F5 запускает приложение путем развертывания свободных файлов из путь к папке макета пакета, а не Установка из пакета AppX.  Папка макета обычно не имеют те же ограничения безопасности папки установленного пакета. Таким образом может оказаться невозможно воспроизвести пакетов путь доступа отказ ошибки до применения исправление среды выполнения.

Чтобы устранить эту проблему, используйте развертывания пакета .appx, а не развертывания свободных файлов F5.  Чтобы создать файл пакета .appx, используйте служебную программу [MakeAppx](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/make-appx-package--makeappx-exe-) из пакета Windows SDK, как описано выше. Или, из в Visual Studio, щелкните правой кнопкой мыши узел проекта приложения и выберите **хранилище**->**Создание пакетов приложений**.

Другая проблема с помощью Visual Studio является то, что он не встроенную поддержку для присоединения к все дочерние процессы, запущенные в отладчике.   Это затрудняет для отладки логики в пути запуска целевого приложения, которое необходимо вручную подключить с помощью Visual Studio после запуска.

Чтобы устранить эту проблему, используйте отладчику, который поддерживает дочерний процесс прикрепить.  Обратите внимание, что это обычно не можно прикрепить отладчик just in time (JIT) для целевого приложения.  Это связано с большинством методов JIT предполагает запуск отладчика вместо целевого приложения, через раздел реестра ImageFileExecutionOptions.  Это препятствует detouring механизм, используемый ShimLauncher.exe для внедрения ShimRuntime.dll в целевого приложения.  Отладчик WinDbg, в состав [Средств отладки для Windows](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index), а также получить с помощью [Пакета SDK для Windows](https://developer.microsoft.com/en-US/windows/downloads/windows-10-sdk), прикрепите к сообщению поддерживает дочернего процесса.  Он также теперь поддерживает непосредственно [Запуск и отладка приложения UWP](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-a-uwp-app-using-windbg#span-idlaunchinganddebuggingauwpappspanspan-idlaunchinganddebuggingauwpappspanspan-idlaunchinganddebuggingauwpappspanlaunching-and-debugging-a-uwp-app).

Для отладки запуска целевого приложения как дочерний процесс, запустить ``WinDbg``.

```
windbg.exe -plmPackage PSFSampleWithFixup_1.0.59.0_x86__7s220nvg1hg3m -plmApp PSFSample
```

В ``WinDbg`` запрос, включение отладки дочерних и задавать точки останова.

```
.childdbg 1
g
```
(выполняться, пока целевое приложение запускается и входит в отладчик)

```
sxe ld fixup.dll
g
```
(выполнение до исправление, которое загружается DLL)

```
bp ...
```

>[!NOTE]
> [PLMDebug](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/plmdebug) также может использоваться для присоединения к приложения при запуске отладчика, а также добавляется в [Средства отладки для Windows](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index).  Тем не менее оно является более сложным в использовании, чем прямая поддержка теперь предоставляемые WinDbg.

## <a name="support-and-feedback"></a>Поддержка и отзывы

**Поиск ответов на вопросы**

Есть вопросы? Задайте их на Stack Overflow. Наша команда следит за этими [тегами](http://stackoverflow.com/questions/tagged/project-centennial+or+desktop-bridge). Вы также можете задать нам вопросы [здесь](https://social.msdn.microsoft.com/Forums/en-US/home?filter=alltypes&sort=relevancedesc&searchTerm=%5BDesktop%20Converter%5D).
