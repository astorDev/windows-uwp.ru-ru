---
author: normesta
Description: Fix issues that prevent your desktop application from running in an MSIX container
Search.Product: eADQiWindows 10XVcnh
title: Устранение проблем, которые не классического приложения от запуска в контейнере MSIX
ms.author: normesta
ms.date: 07/02/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: d4b4cae2e135f7a66cd68192faabeffdb309a909
ms.sourcegitcommit: 106aec1e59ba41aae2ac00f909b81bf7121a6ef1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/15/2018
ms.locfileid: "4620985"
---
# <a name="apply-runtime-fixes-to-an-msix-package-by-using-the-package-support-framework"></a>Применение исправлений среды выполнения для пакета MSIX с помощью платформа поддержки пакетов

Платформа поддержки пакета — комплекту с открытым исходным кодом, которая позволяет применять исправления существующие приложения win32 при отсутствии доступа к исходному коду, чтобы оно могло выполняться в контейнере MSIX. Платформа поддержки пакетов помогает приложения следуйте рекомендациям современные среды.

Дополнительные сведения см. в разделе [Платформа поддержки пакетов](https://docs.microsoft.com/windows/msix/package-support-framework-overview).

Это руководство поможет вам определить проблем совместимости приложений и найти, применяются и расширение среды выполнения исправления, их устранения.

<a id="identify" />

## <a name="identify-packaged-application-compatibility-issues"></a>Определяем проблемы совместимости, упакованные приложения

Во-первых создайте пакет для вашего приложения. Затем установить его, запустить его и проверка его поведения. Может появиться сообщения об ошибках, которые помогают выявить проблемы совместимости. Можно также использовать [Монитор процессов](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) для выявления проблем.  Распространенные проблемы связаны с приложения предположений о разрешениях рабочий каталог и программы путь.

### <a name="using-process-monitor-to-identify-an-issue"></a>Использование монитора процесс для определения проблемы

[Монитор процессов](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) — это мощное служебная наблюдение файл приложения и операции и его результаты.  Это может помочь вам понять проблем совместимости приложений.  После открытия монитор процессов, добавьте фильтр (фильтр > Фильтр …) для включения только события от исполняемый файл приложения.

![Фильтр ProcMon приложения](images/desktop-to-uwp/procmon_app_filter.png)

Появится список событий. Для многих из этих событий слово **Успех** будет отображаться в столбце **результат** .

![События ProcMon](images/desktop-to-uwp/procmon_events.png)

При необходимости вы можете отфильтровать события, чтобы отображать только сбоев.

![Успех ProcMon Exclude](images/desktop-to-uwp/procmon_exclude_success.png)

Если вы подозреваете сбоя доступ к файловой системе, поиск сбой события, которые относятся к System32/SysWOW64 или путь к файлу пакета. Фильтры также поможет здесь слишком. Запустите в нижней части списка и прокрутку вверх. Недавно произошли ошибки, которые отображаются в нижней части списка. Не забывайте большинство ошибок, которые содержать строки, такие как «доступ запрещен» и «путь/имя не найдено» и игнорировать вещей, которые выглядят как подозрительные. [PSFSample](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/samples/PSFSample/) имеет два проблемы. Вы можете увидеть эти проблемы в списке, который отображается на следующем рисунке.

![ProcMon Config.txt](images/desktop-to-uwp/procmon_config_txt.png)

В первой проблема, которая отображается в это изображение приложения происходит сбой для чтения из файла «Config.txt», который находится в папке «C:\Windows\SysWOW64». Маловероятно, что приложение пытается ссылаться на этот путь напрямую. Скорее всего его пытаются считываются из этого файла с помощью относительный путь, и по умолчанию «System32/SysWOW64» является рабочий каталог приложения. Это предполагает, что приложение ожидает текущий рабочий каталог значение где-то в пакете. Ищете внутри appx, мы видим, что файл существует в том же каталоге, что и исполняемый файл.

![Config.txt приложения](images/desktop-to-uwp/psfsampleapp_config_txt.png)

Вторая проблема отображается на следующем рисунке.

![Файл журнала ProcMon](images/desktop-to-uwp/procmon_logfile.png)

В этом выпуске приложения происходит сбой для записи файл журнала его путь к пакету. Это предположить, что исправление перенаправление файлов может помочь.

<a id="find" />

## <a name="find-a-runtime-fix"></a>Найдите исправление среды выполнения

Инструмент содержит исправлений среды выполнения, которые можно использовать прямо сейчас, такие как исправить перенаправление файлов.

### <a name="file-redirection-fixup"></a>Исправление перенаправление файлов

[Исправление перенаправление файлов](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/develop/FileRedirectionShim) можно использовать для перенаправления попытки записи или чтения данных в каталоге, который не доступен из приложения, которое выполняется в контейнере MSIX.

Например если приложение записывает в файл журнала, который находится в том же каталоге приложений исполняемый, можно использовать [Исправить перенаправление файлов](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/develop/FileRedirectionShim) для создания этого файла журнала в другом месте, таких как локальное хранилище данных приложения.

### <a name="runtime-fixes-from-the-community"></a>Среда выполнения исправления от сообщества

Не забудьте изучить взносы сообщества на нашу страницу [GitHub](https://github.com/Microsoft/MSIX-PackageSupportFramework/tree/develop) . Это возможно, что другие разработчики была устранена проблема, сходные с вашими и предоставили исправление среды выполнения.

## <a name="apply-a-runtime-fix"></a>Применение исправлений среды выполнения

Можно применить средство среды выполнения с помощью несколько простых средств Windows SDK и, выполнив следующие действия.

> [!div class="checklist"]
> * Создайте папку макета пакета
> * Получение файлов платформа поддержки пакетов
> * Добавление их в пакет
> * Изменение манифеста пакета
> * Создание файла конфигурации

Давайте пройти все задачи.

### <a name="create-the-package-layout-folder"></a>Создайте папку макета пакета

Если у вас уже есть файл .msix (или AppX-файл), можно распаковать его содержимое в папку макета, который будет служить промежуточной области для пакета.  Вы можете сделать это в **x64 собственные средства командной строки для VS 2017**, или вручную с помощью в SDK Bin в пути исполняемого поиска.

```
makemsix unpack /p PSFSamplePackage_1.0.60.0_AnyCPU_Debug.msix /d PackageContents

```

Это даст вам то, что выглядит следующим образом.

![Макет пакета](images/desktop-to-uwp/package_contents.png)

Если у вас нет файла .msix (или AppX-файл) со, можно создать папку пакета и файлы с нуля.

### <a name="get-the-package-support-framework-files"></a>Получение файлов платформа поддержки пакетов

Вы можете получить пакет Nuget Инструмент с помощью Visual Studio. Вы также можете получить с помощью средства командной строки автономный Nuget.

#### <a name="get-the-package-by-using-visual-studio"></a>Получите пакет с помощью Visual Studio

В Visual Studio щелкните правой кнопкой мыши узел вашего решения или проекта и выберите одну из команд Управление пакетами Nuget.  Поиск **Microsoft.PackageSupportFramework** или **Инструмент** поиска пакета Nuget.org. Затем установите его.

#### <a name="get-the-package-by-using-the-command-line-tool"></a>Получите пакет с помощью средства командной строки

Установить средство командной строки Nuget из этого расположения: https://www.nuget.org/downloads. Затем с помощью Nuget командной строки, выполните следующую команду:

```
nuget install Microsoft.PackageSupportFramework
```

### <a name="add-the-package-support-framework-files-to-your-package"></a>Добавление файлов платформа поддержки пакетов в пакет

Добавьте необходимые 32-разрядные и 64-разрядных Инструмент DLL-файлы и исполняемые файлы в каталог пакета. Руководствуйтесь следующей таблицей. Также необходимо включить исправлений среды выполнения, которые необходимо. В нашем примере нам нужна исправление среды выполнения перенаправление файлов.

| Исполняемый файл приложения — это x64 | Исполняемый файл приложения — это x86 |
|-------------------------------|-----------|
| [PSFLauncher64.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimLauncher/readme.md) |  [PSFLauncher32.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimLauncher/readme.md) |
| [PSFRuntime64.dll](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRuntime/readme.md) | [PSFRuntime32.dll](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRuntime/readme.md) |
| [PSFRunDll64.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRunDll/readme.md) | [PSFRunDll32.exe](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/ShimRunDll/readme.md) |

Содержимое пакета теперь должен выглядеть примерно следующим образом.

![Двоичные файлы пакета](images/desktop-to-uwp/package_binaries.png)

### <a name="modify-the-package-manifest"></a>Изменение манифеста пакета

Откройте манифест пакета в текстовом редакторе, а затем установите `Executable` атрибута `Application` элемента к имени Инструмент запуска исполняемого файла.  Если вы знаете архитектуре целевого приложения, выберите нужную версию, PSFLauncher32.exe или PSFLauncher64.exe.  В противном случае PSFLauncher32.exe будут работать во всех случаях.  Вот пример.

```xml
<Package ...>
  ...
  <Applications>
    <Application Id="PSFSample"
                 Executable="PSFLauncher32.exe"
                 EntryPoint="Windows.FullTrustApplication">
      ...
    </Application>
  </Applications>
</Package>
```

### <a name="create-a-configuration-file"></a>Создание файла конфигурации

Создать имя файла ``config.json``и сохраните этот файл в корневую папку пакета. Измените объявленный идентификатор config.json файла для исполняемого файла, который вы только что заменены на. С помощью знания, полученные из с помощью процесса монитора, вы можете также задать рабочий каталог как также использовать исправить перенаправление файлов для перенаправления операций чтения/записи в файлы с расширением LOG package-relative в каталоге «PSFSampleApp».

```json
{
    "applications": [
        {
            "id": "PSFSample",
            "executable": "PSFSampleApp/PSFSample.exe",
            "workingDirectory": "PSFSampleApp/"
        }
    ],
    "processes": [
        {
            "executable": "PSFSample",
            "fixups": [
                {
                    "dll": "FileRedirectionFixup.dll",
                    "config": {
                        "redirectedPaths": {
                            "packageRelative": [
                                {
                                    "base": "PSFSampleApp/",
                                    "patterns": [
                                        ".*\\.log"
                                    ]
                                }
                            ]
                        }
                    }
                }
            ]
        }
    ]
}
```
Ниже приведена руководство по схеме config.json.

| Массив | key | Значение |
|-------|-----------|-------|
| Приложения | id |  Используйте значение `Id` атрибута `Application` в манифесте пакета. |
| Приложения | исполняемые | Пакет относительный путь исполняемого файла, который вы хотите начать. В большинстве случаев это значение можно получить из файл манифеста пакета перед внесением изменений. Это значение `Executable` атрибута `Application` элемента. |
| Приложения | workingDirectory | (Необязательно) Package-relative путь для использования в качестве рабочий каталог приложения, которое запускается. Если это значение не задано, операционная система использует `System32` каталог как рабочий каталог приложения. |
| процессы | исполняемые | В большинстве случаев это будет имя `executable` настроено выше с расширением путь и файл удален. |
| исправления | Библиотека DLL | Пакет относительный путь для исправления,.msix/.appx для загрузки. |
| исправления | конфигурации | (Необязательно) Элементы управления, как ведет себя рассылки исправления. Точный формат это значение зависит от на основе исправить, исправления как каждого исправления может интерпретировать этот «большой двоичный объект» насколько это требуется. |

`applications`, `processes`, И `fixups` ключи являются массивами. Это означает, что можно использовать файл config.json более одного приложения, процесс и исправить DLL.


### <a name="package-and-test-the-app"></a>Пакет и тестирования приложения

Затем создайте пакет.

```
makeappx pack /d PackageContents /p PSFSamplePackageFixup.msix
```

Затем подпишите ее.

```
signtool sign /a /v /fd sha256 /f ExportedSigningCertificate.pfx PSFSamplePackageFixup.msix
```

Дополнительные сведения см. в разделе [как для создания сертификата для подписи пакета](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/how-to-create-a-package-signing-certificate) и [подписать пакет с помощью signtool](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/how-to-sign-a-package-using-signtool)

С помощью PowerShell, необходимо установите пакет.

>[!NOTE]
> Не забудьте удалить пакет.

```
powershell Add-MSIXPackage .\PSFSamplePackageFixup.msix
```

Запустите приложение и проверьте работу с применяется исправление среды выполнения.  Повторите шаги упаковки при необходимости и диагностики.

### <a name="use-the-trace-fixup"></a>Используйте исправление трассировки

Альтернативный метод для диагностики проблем с совместимостью упакованного приложения является использование исправить трассировки. Эта библиотека DLL входит в состав Инструмент и предоставляет подробное представление диагностики поведения приложения, аналогично монитор процессов.  Специально разработан для отображения проблем совместимости приложений.  Чтобы использовать исправления трассировки, добавить DLL-ФАЙЛ пакета, добавьте следующий фрагмент config.json и затем упаковывать и установить приложение.

```json
{
    "dll": "TraceFixup.dll",
    "config": {
        "traceLevels": {
            "filesystem": "allFailures"
        }
    }
}
```

По умолчанию исправить трассировки отфильтровывает ошибки, которые могут считаться «ожидается».  Например приложения могут попытаться безусловно удалить файл, не выполняется проверка, если он уже существует, игнорируя результат. Это имеет нежелательным вследствие, некоторые непредвиденных сбоев может получить отфильтрованы, поэтому в приведенном выше примере мы зарегистрироваться для получения всех сбоев из функций файловой системы. Это необходимо, так как мы знаем из, прежде чем, попытка чтения из файла Config.txt завершается ошибкой, сообщение «файл не найден». Это происходит сбой, часто по всему и предполагается, что обычно не непредвиденных. На практике это скорее оптимальный вариант для начала фильтрации только для непредвиденных сбоев, а затем возврат к всплывающему все сбои при наличии проблемы, которые по-прежнему не удается определить.

По умолчанию выходные данные трассировки исправление отправляется в присоединенного отладчика. В этом примере мы не следует прикрепить отладчик и используйте вместо [DebugView](https://docs.microsoft.com/en-us/sysinternals/downloads/debugview) программа от компании SysInternals, чтобы просмотреть свой вывод. После запуска приложения, мы видим те же ошибки как и раньше, какой бы момент нам по направлению к же исправлений среды выполнения.

![Файл TraceShim не найден](images/desktop-to-uwp/traceshim_filenotfound.png)

![Отказано в доступе TraceShim](images/desktop-to-uwp/traceshim_accessdenied.png)

## <a name="debug-extend-or-create-a-runtime-fix"></a>Отладка, расширить или создать исправление среды выполнения

Visual Studio можно использовать для отладки исправление среды выполнения, расширение среды выполнения исправления или создать ее с нуля. Необходимо выполнить следующие действия, чтобы добиться успеха.

> [!div class="checklist"]
> * Добавьте проект упаковки
> * Добавление проекта для выполнения исправления
> * Добавление проекта, который запускает исполняемый средства запуска Инструмент
> * Настройки проекта упаковки

Когда все будет готово, решение будет выглядеть следующим образом.

![Завершенное решение](images/desktop-to-uwp/runtime-fix-project-structure.png)

Давайте взглянем на каждый проект в этом примере.

| Проект | Описание |
|-------|-----------|
| DesktopApplicationPackage | Этот проект основана на [проект упаковки приложения Windows](desktop-to-uwp-packaging-dot-net.md) и выводит его пакета MSIX. |
| Runtimefix | Это библиотека C++ Dynamic-Linked проект, который содержит одну или несколько функций замены, которые служат исправление среды выполнения. |
| PSFLauncher | Это пустой проект C++. Этот проект является местом для сбора файлов среды выполнения распространяемый пакет поддержки инфраструктуры. Он выводит исполняемый файл. Этот исполняемый файл — первое, который выполняется при запуске решения. |
| WinFormsDesktopApplication | Этот проект содержит исходный код классического приложения. |

Чтобы взглянуть на полный пример, который содержит все эти типы проектов, см. в разделе [PSFSample](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/samples/PSFSample/).

Рассмотрим шаги для создания и настройки каждого из этих проектов в вашем решении.


### <a name="create-a-package-solution"></a>Создание пакета решения

Если вы не уже решение для классического приложения, создайте новое **Пустое решение** в Visual Studio.

![Пустое решение](images/desktop-to-uwp/blank-solution.png)

Можно также добавить любые приложения проектов у вас имеются.

### <a name="add-a-packaging-project"></a>Добавьте проект упаковки

Если у вас еще нет **Проект упаковки приложения для Windows**, создайте его и добавьте его в свое решение.

![Шаблон проекта пакета](images/desktop-to-uwp/package-project-template.png)

Дополнительные сведения о проект упаковки приложения Windows см. в разделе [пакета приложения с помощью Visual Studio](desktop-to-uwp-packaging-dot-net.md).

В **Обозревателе решений**щелкните правой кнопкой мыши проект упаковки, выберите **Изменить**и затем добавить в нижней части файла проекта:

```
<Target Name="PSFRemoveSourceProject" AfterTargets="ExpandProjectReferences" BeforeTargets="_ConvertItems">
<ItemGroup>
  <FilteredNonWapProjProjectOutput Include="@(_FilteredNonWapProjProjectOutput)">
  <SourceProject Condition="'%(_FilteredNonWapProjProjectOutput.SourceProject)'=='<your runtime fix project name goes here>'" />
  </FilteredNonWapProjProjectOutput>
  <_FilteredNonWapProjProjectOutput Remove="@(_FilteredNonWapProjProjectOutput)" />
  <_FilteredNonWapProjProjectOutput Include="@(FilteredNonWapProjProjectOutput)" />
</ItemGroup>
</Target>
```

### <a name="add-project-for-the-runtime-fix"></a>Добавление проекта для выполнения исправления

Добавьте в решение проект C++ **Библиотек динамической компоновки (DLL)** .

![Библиотека времени выполнения исправления](images/desktop-to-uwp/runtime-fix-library.png)

Щелкните правой кнопкой мыши, проекта, а затем выберите **Свойства**.

На страницах свойств найдите поле **Стандартный язык C++** , а затем в раскрывающемся списке рядом с этого поля, выберите **ISO C ++ 17 Standard (/ std: c ++ 17)** вариант.

![ISO 17 параметр](images/desktop-to-uwp/iso-option.png)

Щелкните правой кнопкой мыши проект и выберите в контекстном меню выберите вариант **Управление пакетами Nuget** . Убедитесь, что **исходный пакет** был установлен для **всех** или **nuget.org**.

Щелкните значок «параметры», затем этого поля.

Найдите *Инструмент** Nuget пакет, а затем установите его для этого проекта.

![пакет NuGet](images/desktop-to-uwp/psf-package.png)

Если вы хотите отладки или расширить существующий исправление среды выполнения, добавьте файлы исправление среды выполнения, полученных с помощью рекомендации, описанные в разделе [найти исправление среды выполнения](#find) в этом руководстве.

Если вы планируете создавать новое исправление, ничего не добавляют в этот проект просто еще. Мы поможем вам добавлять нужные файлы в этот проект далее в этом руководстве. Сейчас мы продолжим настройку свое решение.

### <a name="add-a-project-that-starts-the-psf-launcher-executable"></a>Добавление проекта, который запускает исполняемый средства запуска Инструмент

Добавьте проект C++ **Пустой проект** в решение.

![Пустой проект](images/desktop-to-uwp/blank-app.png)

Добавьте пакет Nuget **Инструмент** в этот проект с помощью одного рекомендации, описанные в предыдущем разделе.

Откройте на страницах свойств проекта и на странице " **Общие** параметры", значение свойства **Имя целевого** ``PSFLauncher32`` или ``PSFLauncher64`` в зависимости от архитектуры приложения.

![Справочник по запуска Инструмент](images/desktop-to-uwp/shim-exe-reference.png)

Добавьте проект ссылку на проект исправление среды выполнения в вашем решении.

![исправление справке среды выполнения](images/desktop-to-uwp/reference-fix.png)

Щелкните правой кнопкой мыши ссылку, а затем в окне " **Свойства** " Примените эти значения.

| Свойство | Значение |
|-------|-----------|
| Копировать локальные | True |
| Копировать локально вспомогательные сборки | True |
| Выходные данные сборки ссылки | True |
| Использовать библиотеки из зависимостей | False |
| Входные данные зависимостей библиотеки ссылки | False |

### <a name="configure-the-packaging-project"></a>Настройки проекта упаковки

В проекте упаковки щелкните правой кнопкой мыши папку **Приложения** и выберите **Добавить ссылку**.

![Добавление ссылки на проект](images/desktop-to-uwp/add-reference-packaging-project.png)

Выберите проект запуска Инструмент и проект классического приложения, а затем нажмите кнопку « **ОК** ».

![Проект классического приложения](images/desktop-to-uwp/package-project-references.png)

>[!NOTE]
> Если у вас не исходный код в приложение, достаточно выберите для запуска проекта Инструмент. Мы покажем, как для ссылки исполняемый файл при создании файла конфигурации.

В узел **приложения** щелкните правой кнопкой мыши Инструмент средства запуска приложений и выберите **задать в качестве точки входа**.

![Задание точки входа](images/desktop-to-uwp/set-startup-project.png)

Добавьте в файл с именем ``config.json`` в свой проект упаковки, затем скопируйте и вставьте следующий текст json в файл. Присвойте свойству **Действия пакета** для **содержимого**.

```json
{
    "applications": [
        {
            "id": "",
            "executable": "",
            "workingDirectory": ""
        }
    ],
    "processes": [
        {
            "executable": "",
            "fixups": [
                {
                    "dll": "",
                    "config": {
                    }
                }
            ]
        }
    ]
}
```
Предоставляет значение для каждого ключа. Руководствуйтесь в этой таблице.

| Массив | key | Значение |
|-------|-----------|-------|
| Приложения | id |  Используйте значение `Id` атрибута `Application` в манифесте пакета. |
| Приложения | исполняемые | Пакет относительный путь исполняемого файла, который вы хотите начать. В большинстве случаев это значение можно получить из файл манифеста пакета перед внесением изменений. Это значение `Executable` атрибута `Application` элемента. |
| Приложения | workingDirectory | (Необязательно) Package-relative путь для использования в качестве рабочий каталог приложения, которое запускается. Если это значение не задано, операционная система использует `System32` каталог как рабочий каталог приложения. |
| процессы | исполняемые | В большинстве случаев это будет имя `executable` настроено выше с расширением путь и файл удален. |
| исправления | Библиотека DLL | Пакет относительный путь для исправления библиотеки DLL для загрузки. |
| исправления | конфигурации | (Необязательно) Элементы управления, как ведет себя исправления DLL. Точный формат это значение зависит от на основе исправить, исправления как каждого исправления может интерпретировать этот «большой двоичный объект» насколько это требуется. |

Когда все будет готово, ваш ``config.json`` файл будет выглядеть примерно следующим образом.

```json
{
  "applications": [
    {
      "id": "DesktopApplication",
      "executable": "DesktopApplication/WinFormsDesktopApplication.exe",
      "workingDirectory": "WinFormsDesktopApplication"
    }
  ],
  "processes": [
    {
      "executable": ".*App.*",
      "fixups": [ { "dll": "RuntimeFix.dll" } ]
    }
  ]
}

```

>[!NOTE]
> `applications`, `processes`, И `fixups` ключи являются массивами. Это означает, что можно использовать файл config.json более одного приложения, процесс и исправить DLL.

### <a name="debug-a-runtime-fix"></a>Отладка исправление среды выполнения

В Visual Studio нажмите клавишу F5, чтобы запустить отладчик.  Первое, что запускает — это Инструмент запуска приложения, который в свою очередь, запускает целевой классического приложения.  Для отладки классического приложения целевого объекта, вам придется вручную подключаться к процессу классического приложения, выбрав **Отладка**->**присоединиться к процессу**, а затем выбрав процесса приложения. Чтобы разрешить отладку приложения .NET с исправлением среды выполнения собственной библиотеки DLL, выберите типы управляемый и машинный код (Отладка в смешанном режиме).  

После того как вы установите, точки прерывания рядом с строк кода можно задать в коде классического приложения и проекта исправление среды выполнения. Если у вас не исходный код в приложение, вы сможете задать точки прерывания только рядом с строк кода в проекте исправление среды выполнения.

>[!NOTE]
> Хотя Visual Studio предоставляет простой разработки и отладки взаимодействия, существуют некоторые ограничения, поэтому далее в этом руководстве мы обсудим другие методы отладки, которые можно применить.

## <a name="create-a-runtime-fix"></a>Создание среды выполнения исправления

Если не существует еще среды выполнения устранить проблемы, что вы хотите разрешить, можно создать новый исправление среды выполнения, написание замены функций и любые данные конфигурации в том числе это имеет смысл. Давайте взглянем на каждой части.

### <a name="replacement-functions"></a>Замена функции

Во-первых определите вызовы завершаться сбоем, если приложение выполняется в контейнере MSIX функций. Затем вы можете создать функции замены, которые хотели бы диспетчера среды выполнения для вызова вместо. Это дает возможность реализации функции Заменить поведение, которое соответствует правилам современные среды.

В Visual Studio откройте проект исправление среды выполнения, созданный ранее в этом руководстве.

Объявите ``FIXUP_DEFINE_EXPORTS`` макрос, а затем добавьте оператор include для `fixup_framework.h` в верхней части каждой. Файл CPP, где вы планируете добавить в файл Default.js функции вашей среды выполнения исправления.

```c++
#define FIXUP_DEFINE_EXPORTS
#include <fixup_framework.h>
```
>[!IMPORTANT]
>Убедитесь, что `FIXUP_DEFINE_EXPORTS` макрос отображается перед инструкции include.

Создать функцию, которая имеет ту же подпись, функции, кто имеет поведение, которую требуется изменить. Ниже приведен пример функции, которая заменяет `MessageBoxW` функции.

```c++
auto MessageBoxWImpl = &::MessageBoxW;
int WINAPI MessageBoxWFixup(
    _In_opt_ HWND hwnd,
    _In_opt_ LPCWSTR,
    _In_opt_ LPCWSTR caption,
    _In_ UINT type)
{
    return MessageBoxWImpl(hwnd, L"SUCCESS: This worked", caption, type);
}

DECLARE_FIXUP(MessageBoxWImpl, MessageBoxWFixup);
```

Вызов `DECLARE_FIXUP` сопоставляет `MessageBoxW` функции к новой функции замены. Если приложение пытается вызвать `MessageBoxW` функции, он будет вызывать функцию замены вместо.

#### <a name="protect-against-recursive-calls-to-functions-in-runtime-fixes"></a>Защиту от рекурсивный вызовы функций в среде выполнения исправления

Вы можете при необходимости применить `reentrancy_guard` тип вашего функций, защиту от рекурсивный вызовы функций в исправлений среды выполнения.

Например, можно создать функцию для замены `CreateFile` функции. Реализация может вызывать `CopyFile` функции, но реализация `CopyFile` может вызвать функцию `CreateFile` функции. Это может привести к цикл бесконечное рекурсивный вызовов `CreateFile` функции.

Дополнительные сведения о `reentrancy_guard` см. в разделе [authoring.md](https://github.com/Microsoft/MSIX-PackageSupportFramework/blob/master/Authoring.md)

### <a name="configuration-data"></a>Данные конфигурации

Если вы хотите добавить данные конфигурации для вашей среды выполнения исправления, вы можете добавить его к ``config.json``. Таким образом, вы можете использовать `FixupQueryCurrentDllConfig` легко проанализировать эти данные. В этом примере анализирует значение boolean и строки из этого файла конфигурации.

```c++
if (auto configRoot = ::FixupQueryCurrentDllConfig())
{
    auto& config = configRoot->as_object();

    if (auto enabledValue = config.try_get("enabled"))
    {
        g_enabled = enabledValue->as_boolean().get();
    }

    if (auto logPathValue = config.try_get("logPath"))
    {
        g_logPath = logPathValue->as_string().wstring();
    }
}
```

## <a name="other-debugging-techniques"></a>Другие методы отладки

Хотя Visual Studio предоставляет простой разработки и отладки взаимодействия, существуют некоторые ограничения.

Во-первых, отладки F5 запускает приложение путем развертывания свободных файлов из путь к папке макета пакета, а не Установка из .msix / пакета AppX.  Папка макета обычно не имеет те же ограничения безопасности папки установленного пакета. Таким образом воспроизвести пакетов путь доступа отказ ошибки до применение исправлений среды выполнения не возможно.

Чтобы устранить эту проблему, используйте .msix / развертывание пакета AppX-файл, а не F5 свободных файлов развертывания.  Для создания .msix / файл пакета .appx служебная программа [MakeMSIX](https://docs.microsoft.com/en-us/windows/desktop/appxpkg/make-appx-package--makeappx-exe-) из пакета Windows SDK, как описано выше. Или, из в Visual Studio, щелкните правой кнопкой мыши узел проекта приложения и выберите **хранилище**->**Создание пакетов приложений**.

Другая проблема с помощью Visual Studio является то, что он не встроенную поддержку для присоединения к все дочерние процессы, запущенные в отладчике.   Это затрудняет для отладки логики в пути запуска целевого приложения, которое необходимо вручную подключить с помощью Visual Studio после запуска.

Чтобы устранить эту проблему, следует Используйте отладчик, поддерживаемые присоединение дочернего процесса.  Обратите внимание, что это обычно не можно прикрепить отладчик just in time (JIT) для целевого приложения.  Это связано с большинством методов JIT предполагает запуск отладчика вместо конечным приложением, через раздел реестра ImageFileExecutionOptions.  Это препятствует detouring механизм, используемый PSFLauncher.exe для внедрения FixupRuntime.dll в целевого приложения.  Отладчик WinDbg, в состав [Средств отладки для Windows](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index), а также получить с помощью [Пакета SDK для Windows](https://developer.microsoft.com/en-US/windows/downloads/windows-10-sdk), присоедините поддерживает дочернего процесса.  Он также теперь поддерживает непосредственно [Запуск и отладка приложения UWP](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-a-uwp-app-using-windbg#span-idlaunchinganddebuggingauwpappspanspan-idlaunchinganddebuggingauwpappspanspan-idlaunchinganddebuggingauwpappspanlaunching-and-debugging-a-uwp-app).

Для отладки запуска целевого приложения как дочерний процесс, запустить ``WinDbg``.

```
windbg.exe -plmPackage PSFSampleWithFixup_1.0.59.0_x86__7s220nvg1hg3m -plmApp PSFSample
```

В ``WinDbg`` запрос, включение отладки дочерних и задавать точки останова.

```
.childdbg 1
g
```
(выполняться, пока целевое приложение запускается и отладчика)

```
sxe ld fixup.dll
g
```
(выполнение до исправление, которое загружается DLL)

```
bp ...
```

>[!NOTE]
> [PLMDebug](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/plmdebug) также может использоваться для присоединения к приложения при запуске отладчика, а также добавляется в [Средства отладки для Windows](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index).  Тем не менее оно является более сложным в использовании, чем прямая поддержка теперь предоставляемые WinDbg.

## <a name="support-and-feedback"></a>Поддержка и отзывы

**Поиск ответов на вопросы**

Есть вопросы? Задайте их на Stack Overflow. Наша команда следит за этими [тегами](http://stackoverflow.com/questions/tagged/project-centennial+or+desktop-bridge). Вы также можете задать нам вопросы [здесь](https://social.msdn.microsoft.com/Forums/en-US/home?filter=alltypes&sort=relevancedesc&searchTerm=%5BDesktop%20Converter%5D).

