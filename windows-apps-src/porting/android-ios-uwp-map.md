#Сопоставление концепции приложений для Windows для разработчиков iOS и Android

Если вы — разработчик с навыками разработки или готовым кодом для Android и iOS, и хотите перейти на Windows 10 и универсальную платформу Windows (UWP), этот ресурс содержит всю необходимую информацию для сопоставления функций — и ваших знаний — между тремя платформами.

См. также информацию по портированию в разделе [Переход от iOS к UWP](ios-to-uwp-root.md).

## Пользовательский интерфейс

|  **Универсальное понятие** | **Android** | **iOS** | **Windows 10 UWP** |
|  ------ | ------ | ------ | ------ |
|  **Язык дизайна.** Набор соглашений, описывающих вид и работу приложений на платформе. | Руководство по **Android Material Design** содержит описание визуального языка для дизайнеров и разработчиков Android. | **Human Interface Guidelines** ("Руководство по пользовательскому интерфейсу") содержит рекомендации для дизайнеров и разработчиков iOS. | [
							В разделе **Проектирование приложений UWP для Windows**](https://dev.windows.com/design) показано, как создать приложение, которое превосходно выглядит на любых устройствах под управлением Windows 10. Здесь описаны основы проектирования пользовательского интерфейса, методы создания отзывчивого дизайна и представлен полный список подробных руководств.<br/> |
|  **Язык разметки пользовательского интерфейса.** Язык разметки, который отображает и описывает пользовательский интерфейс и его компоненты. Каждая платформа предоставляет программу как для визуального редактирования, так и для редактирования разметки.<br/> | **XML-макеты**, редактируемые с помощью **Android Studio** или **Eclipse**. | **XIB-файлы** и **раскадровки**, редактируемые с помощью средства **Interface Builder** в Xcode. | **[XAML-файлы](https://msdn.microsoft.com/library/windows/apps/xaml/mt185595.aspx)**, редактируемые с помощью **[Microsoft Visual Studio](https://www.visualstudio.com/)** и **[Blend для Visual Studio](https://msdn.microsoft.com/library/jj171012.aspx)**.<br/><br/>[Платформа XAML](https://msdn.microsoft.com/library/windows/apps/xaml/mt228259.aspx)<br/><br/>[Создание пользовательского интерфейса с помощью XAML](https://msdn.microsoft.com/library/windows/apps/xaml/mt228349.aspx)<br/><br/>[Определение макетов с помощью XAML](https://msdn.microsoft.com/library/windows/apps/xaml/mt228350.aspx) |
|  **Встроенные элементы управления пользовательского интерфейса.** Повторно используемые в системе элементы пользовательского интерфейса, такие как кнопки, элементы управления списками и текстом. | Предварительно настроенные классы **представлений** и **групп представлений**, называемые мини-приложениями, макетами, текстовыми полями, контейнерами, элементами управления датой и временем и сложными элементами управления. | **Представления** и **элементы управления** содержащиеся в библиотеке объектов Xcode и перечисленные в каталоге пользовательского интерфейса UIKit. Представления включают представления изображений, выбора и представления с прокруткой. Элементы управления: кнопки, элементы выбора даты и текстовые поля. | Платформа XAML предоставляет большой набор **встроенных элементов управления**, таких как кнопки, элементы управления списками, панели, текстовые элементы управления, панели команд, средства выбора, мультимедиа и рукописный ввод.<br/><br/>[Добавление элементов управления и обработка событий](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx) |
|  **Обработка событий элементов управления.** Описание логики, которая выполняется после активации событий в элементах управления пользовательского интерфейса. | **Обработчики событий** и **прослушиватели событий** добавляются в XML или программными средствами. | Элементы управления отправляют уведомления о **действиях** **целевым объектам**. | Методы для обработки событий элемента управления XAML можно определить в **файле кода программной части**, связанном со страницей XAML. **Обработчики событий** всегда создаются в коде. Но вы можете подключить обработчики к событиям как в разметке XAML, так и в коде.<br/><br/>[Добавление элементов управления и обработка событий](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx)<br/><br/>[Общие сведения о событиях и перенаправленных событиях](https://msdn.microsoft.com/library/windows/apps/xaml/mt185584.aspx) |
|  **Привязка данных.** Шаблон проектирования программного обеспечения, который обеспечивает отображение данных в пользовательском интерфейсе приложения и (дополнительно) синхронизацию с этими данными.  | Предоставляется **библиотека привязки данных** (все еще только в бета-версии). | В iOS отсутствует встроенная система привязки. Для привязки данных можно использовать **механизм наблюдения за значениями по ключам (KVO)**, как с помощью сторонней библиотеки, так и путем написания дополнительного кода. Элементы управления используют для получения данных подход "делегат/обратный вызов". | Платформа UWP обрабатывает **привязку данных** за вас. Расширение разметки **[{x:Bind}](https://msdn.microsoft.com/library/windows/apps/mt204783.aspx)** используется для высокопроизводительной привязки, а расширение разметки **[{Binding}](https://msdn.microsoft.com/library/windows/apps/mt204782.aspx)** — для предоставления большего количества функций. После этого достаточно просто настроить привязку, выбрав использование **односторонней привязки** для отображения в пользовательском интерфейсе значений из источника данных, или **двусторонней привязки** для наблюдения за значениями и обновления интерфейса при их изменении.<br/><br/>[Привязка данных](https://msdn.microsoft.com/library/windows/apps/mt210947.aspx) |
|  **Модель автоматизации пользовательского интерфейса.** Программный доступ к элементам пользовательского интерфейса, предназначенный для реализации в приложении специальных возможностей и выполнения автоматизированных сценариев тестирования, взаимодействующих с пользовательским интерфейсом. | **Текстовые метки** и значения атрибутов **contentDescription** и **hint** помогают обеспечить доступ средств автоматизации к элементам пользовательского интерфейса. Android Studio позволяет создавать тесты пользовательского интерфейса с помощью тестирующих платформ **UI Automator** и **Espresso**. | Инструмент **Automation** позволяет создавать автоматизированные сценарии тестирования пользовательского интерфейса, которые определяют элементы управления по параметрам **специальных возможностей** или по расположению элемента в **иерархии элементов**. | В UWP вы получаете программный доступ к встроенным элементам интерфейса с помощью **[модели автоматизации пользовательского интерфейса](https://msdn.microsoft.com/library/windows/apps/ee684076.aspx)**.<br/>**[Настраиваемые одноранговые классы автоматизации](https://msdn.microsoft.com/library/windows/apps/mt297667.aspx)** позволяют обеспечить поддержку автоматизации для ваших собственных настраиваемых классов пользовательского интерфейса. **
            [Проект закодированного тестом пользовательского интерфейса](https://msdn.microsoft.com/library/dd286726.aspx#VerifyingCodeUsingCUITCreate)** в Visual Studio позволяет автоматически протестировать все приложение через пользовательский интерфейс или провести изолированное тестирование пользовательского интерфейса. |
|  **Изменение внешнего вида элемента управления.** Изменение размера, цвета и других атрибутов. | Элементы управления имеют **свойства**, которые можно изменять с помощью средства "Designer", разметки XML или программными средствами. | Элементы управления имеют **атрибуты**, которые можно редактировать с помощью средства **Attributes Inspector** в Interface Builder или программно. | **Свойства** элементов управления можно изменять в разметке XAML или программным способом с помощью Visual Studio и Blend для Visual Studio.<br/><br/>[Добавление элементов управления и обработка событий](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx) |
|  **Многократно используемые стили отображения.** Применение многократно используемых визуальных изменений к нескольким элементам управления. | **Стили XML** — это наборы свойств, применяемых к одному или нескольким элементам управления. | iOS не имеет встроенной поддержки многократно используемых стилей отображения, однако протокол UIAppearance позволяет нескольким элементам управления иметь общие атрибуты. | Вы можете создавать многократно используемые **[стили](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.style.aspx)**, которые могут применяться к нескольким элементам управления и храниться в **[ResourceDictionary](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.resourcedictionary.aspx)** для повторного использования.<br/><br/>[Краткое руководство: настройка стиля элементов управления](https://msdn.microsoft.com/library/windows/apps/xaml/hh465381.aspx) |
|  **Редактирование визуальной структуры элементов управления.** Настройка визуальной структуры элемента управления, не ограничивающаяся простым изменением свойств или атрибутов, например перемещение текста флажка под флажок. | В Android не существует простого способа изменить визуальную структуру элементов управления. | В iOS не существует простого способа изменить визуальную структуру элементов управления. | Чтобы настроить визуальную структуру элемента управления, вы можете скопировать и изменить его **[шаблон элемента управления](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.controltemplate.aspx)** в разметке XAML.<br/><br/>[Краткое руководство. Шаблоны элементов управления](https://msdn.microsoft.com/library/windows/apps/xaml/hh465374.aspx)  |
|  **Встроенные сенсорные жесты.** Предоставление настраиваемой поддержки сенсорного ввода путем обработки высокоуровневых абстрагированных событий жестов, таких как касание и двойное касание, в представлениях и элементах управления. | Класс **GestureDetector** определяет основные сенсорные жесты, включая прокрутку, долгое нажатие, касание, двойное касание и смахивание. | Платформа UIKit предоставляет встроенные **распознаватели жестов** определяющие сенсорные жесты, включая касание, сжатие, сдвиг, прокрутку, поворот и долгое нажатие. | **Элементы пользовательского интерфейса** позволяют обрабатывать **статические события жестов**, включая касание, двойное касание, правое касание и удерживание, а также **динамические события жестов**, включая скольжение, прокрутку, вращение, сжатие и растяжение. События жестов являются **перенаправленными событиями** и могут обрабатываться родительскими объектами, содержащими дочерний элемент UIElement.<br/><br/>[Взаимодействия с помощью сенсорного ввода](https://msdn.microsoft.com/library/windows/apps/mt185617.aspx)<br/><br/>[Настраиваемые взаимодействия с пользователем — жесты, манипуляции и взаимодействия](https://msdn.microsoft.com/library/windows/apps/mt185599.aspx#gestures__manipulations__and_interactions) |

## Навигация и структура приложения

|  **Универсальное понятие** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Макеты.** Макет определяет структуру пользовательского интерфейса. | Макет состоит из **групп представлений**, таких как **LinearLayout** и **RelativeLayout**, которые могут иметь другие вложенные группы представлений и представления. | Макет состоит из объекта **UIViewController**, содержащего представления ** UIView**, которые могут быть вложенными.  | XAML предоставляет гибкую систему макетов, состоящую из **классов панелей макета**, таких как **[Canvas](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.canvas.aspx)**, **[Grid](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.grid.aspx)**, **[RelativePanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.relativepanel.aspx)** и **[StackPanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.stackpanel.aspx)** для создания статических и гибких макетов. **[Свойства](https://msdn.microsoft.com/library/ms171352.aspx)** используются для управления размером и положением элементов.<br/><br/>[Определение макетов с помощью XAML](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx)<br/> |
|  **Навигация между одноранговыми элементами.** Представление пользователю методов навигации между страницами, находящимися на одном уровне иерархии. | **Боковая навигация** осуществляется с помощью **вкладок**, **представлений прокрутки** и **навигационных секций**. | **Контроллеры панели вкладок**, **контроллеры разделенного представления** и **контроллеры представления страниц** обеспечивают навигацию между представлениями одного уровня иерархии. | С помощью **[вкладок и сводок](https://msdn.microsoft.com/library/windows/apps/dn997788.aspx)** можно отобразить постоянный список ссылок или вкладок над содержимым. The **[Панель навигации и комбинированный режим](https://msdn.microsoft.com/library/windows/apps/dn997787.aspx)** позволяют отображать список ссылок рядом с содержимым.<br/><br/>[Навигация](https://msdn.microsoft.com/library/windows/apps/mt187344.aspx)<br/><br/>[Одноранговая навигация между двумя страницами](https://msdn.microsoft.com/library/windows/apps/mt465735.aspx) |
|  **Иерархическая навигация.** Навигация между родительскими и дочерними страницами иерархии. | **Списки**, **сетки**, **кнопки** и другие элементы управления обеспечивают **нисходящую навигацию** при использовании объектов **Intent** для загрузки других классов **Activity**. | **Контроллеры навигации** позволяют пользователям выполнять переход между уровнями иерархии. | **[Главные разделы](https://msdn.microsoft.com/library/windows/apps/dn449149.aspx)** позволяют показать пользователю краткий обзор содержимого, который можно выбрать для перехода на дочерние страницы. **[Шаблон основных и подробных данных](https://msdn.microsoft.com/library/windows/apps/dn997765.aspx)** дает возможность выбирать из списка сводок элементов, отображаемых рядом с соответствующим разделом сведений.<br/><br/>[Навигация](https://msdn.microsoft.com/library/windows/apps/mt187344.aspx) |
|  **Навигация кнопки "Назад".** Переход назад в приложении. | Кнопки **Назад** и **Вверх** в панели действий обеспечивают **наследуемую** и **временную** навигацию с использованием **обратного стека**. | В **контроллер навигации** можно добавить кнопку перехода назад.<br/> | Вы можете легко обрабатывать нажатия аппаратной или программной кнопки "Назад" с помощью **[свойства обратного стека](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.frame.backstack.aspx)**, которое позволяет пользователям перемещаться по **журналу навигации**.<br/><br/>[Навигация кнопки "Назад"](https://msdn.microsoft.com/library/windows/apps/mt465734.aspx) |
|  **Экран-заставка.** Изображение, показываемое при запуске приложения и в основном использующееся для добавления фирменной символики. | Экран-заставка не предоставляется по умолчанию и реализуется посредством редактирования **фона темы** первой активности. | Приложения должны иметь **статическое изображение запуска** или **XIB-файл либо файл раскадровки запуска**. | Экран-заставка создается с помощью **изображения** и цветного фона. [Время отображения экрана-заставки можно увеличить](https://msdn.microsoft.com/library/windows/apps/mt187309.aspx).<br/><br/>[Добавление экрана-заставки](https://msdn.microsoft.com/library/windows/apps/mt187306.aspx)<br/><br/>[Рекомендации по экранам-заставкам](https://msdn.microsoft.com/library/windows/apps/hh465338.aspx) |

## Пользовательский ввод

|  **Универсальное понятие** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Голос.** Распознавание речи для голосового ввода и дополнительные голосовые возможности. | Голосовой ввод может обеспечиваться любым приложением, в котором реализован класс **RecognizerIntent**, таким как **Голосовой поиск Google**. Класс **SpeechRecognizer** позволяет приложениям использовать API распознавания речи Google. | Встроенные API распознавания речи и речевого ввода отсутствуют. | Можно использовать API **[распознавания речи](https://msdn.microsoft.com/library/windows/apps/mt185615.aspx)** для взаимодействия с приложением, выполняемым на переднем плане. Вы можете использовать голосовые **[взаимодействия с Cortana](https://msdn.microsoft.com/library/windows/apps/mt185598.aspx)** для запуска приложений на переднем плане или в фоновом режиме, а также для взаимодействия с фоновыми приложениями.<br/><br/>[Взаимодействия с помощью голосовых функций](https://msdn.microsoft.com/library/windows/apps/mt185614.aspx) |
|  **Настраиваемых пользовательский ввод.** Обработка ввода с клавиатуры, мыши, пера и других средств ввода. | Поддерживается взаимодействие с помощью **касаний**, **сенсорной панели**, **пера**, **мыши** и **клавиатуры**. Движение и ввод передается тем же способом, что и касание, но существует возможность получить дополнительные сведения об **устройстве ввода**. | Обеспечивается поддержка **сенсорного ввода**, **Apple Pencil** и ввода с аппаратной **клавиатуры**. | Поддерживается широкий набор взаимодействий, включая **[сенсорный ввод](https://msdn.microsoft.com/library/windows/apps/mt185617.aspx)**, взаимодействие с помощью **[сенсорной панели](https://msdn.microsoft.com/library/windows/apps/mt187313.aspx)**, **[пера](https://msdn.microsoft.com/library/windows/apps/mt187311.aspx)** с функцией рукописного ввода, **[мыши](https://msdn.microsoft.com/library/windows/apps/mt187308.aspx)** и **[клавиатуры](https://msdn.microsoft.com/library/windows/apps/mt185607.aspx)**. Ваши приложения могут обрабатывать данные, не зная, какое устройство ввода используется, а также при необходимости получать доступ к необработанным данным устройства ввода.<br/><br/>[Работа с данными указателя](https://msdn.microsoft.com/library/windows/apps/mt404610.aspx)<br/><br/>[Настраиваемые взаимодействия с пользователем](https://msdn.microsoft.com/library/windows/apps/mt185599.aspx) |

## Данные

|  **Универсальное понятие** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Локальные данные приложения.** Локальное хранение связанных с приложением параметров и файлов. | Локальные файлы можно сохранять с помощью методов **openFileOutput** и **openFileInput**. Для доступа к параметрам в файле **общих параметров** используется метод **getSharedPreferences**. | Локальные файлы можно сохранять в каталоге **Application Support**, доступ к которому осуществляется через класс **NSFileManager**. Параметры в файлах **параметров** доступны через класс **NSUserDefaults**. | Классы **[Windows.Storage](https://msdn.microsoft.com/library/windows/apps/xaml/br230562.aspx)** обеспечивают унифицированное хранение локальных данных. Параметры хранятся в виде объекта **[ApplicationDataContainer](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdatacontainer.aspx)**, доступ к которому осуществляется через свойство **[ApplicationData.LocalSettings](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdata.localsettings.aspx)**. Файлы хранятся в объекте **[StorageFolder](https://msdn.microsoft.com/library/windows/apps/windows.storage.storagefolder.aspx)**, доступ к которому осуществляется через свойство **[ApplicationData.LocalFolder](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdata.localfolder.aspx)**.<br/><br/>[Хранение и извлечение параметров и прочих данных приложения](https://msdn.microsoft.com/library/windows/apps/xaml/mt299098.aspx) |
|  **Сохранение в локальной базе данных.** Сохранение данных в реляционной базе данных с объектно-реляционными модулями сопоставления (ORM) (если применимо). | Предоставляется база данных **SQLite**. Встроенные ORM отсутствуют. Запросы SQL выполняются с помощью класса **SQLiteDatabase**. | Предоставляется база данных **SQLite**. **CoreData** — это встроенная платформа объектных графов, которая может использоваться с SQLite и предоставляет функции, сравнимые с ORM. | Данные можно хранить с помощью **SQLite**. **[Entity Framework](https://msdn.microsoft.com/library/windows/apps/xaml/mt592863.aspx)** — это встроенный объектно-реляционный модуль сопоставления, устраняющий необходимость в написании большого количества кода для доступа к данным и позволяющий с легкостью обращаться к базе данных без написания кода SQL. Запросы SQL выполняются непосредственно в [библиотеке SQLite](https://msdn.microsoft.com/library/windows/apps/xaml/mt592864.aspx).<br/><br/>[Доступ к данным](https://msdn.microsoft.com/library/windows/apps/xaml/mt592862.aspx) |
|  **Библиотеки HTTP для доступа к REST.** Встроенные библиотеки, которые позволяют связываться с веб-службами и веб-серверами с использованием HTTP(S).<br/> | Библиотеки HTTP **HttpURLConnection** и **Volley**. | **NSURLSession**, **NSURLConnection** и **NSURLDownload**. | Вы можете использовать встроенный API **[HttpClient](https://msdn.microsoft.com/library/windows/apps/xaml/windows.web.http.httpclient)** для доступа к основным функциями HTTP, включая команды GET, DELETE, PUT, POST, схемы проверки подлинности, SSL, файлы cookie и информация о ходе выполнения запроса. |
|  **Облачные службы резервного копирования.** Предоставляемые платформой службы резервного копирования данных приложений.  | **Backup manager** Android осуществляет резервное копирование данных приложений с помощью службы **Android Backup Service** .  | Пользователи могут настроить **резервное копирование iCloud**, в том числе для данных приложений. Приложения используют совместимые с iCloud данные **Core Data** и хранилища **iCloud key-value store** и **iCloud document storage**. | Любые данные приложения, которые вы сохраняете с помощью API перемещаемых **[ApplicationData](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.aspx)** (включая **[RoamingFolder](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.roamingfolder.aspx)** и [**RoamingSettings**](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.roamingsettings.aspx)), автоматически синхронизируются с облаком, а также с остальными устройствами пользователя. Синхронизация выполняется через учетную запись Майкрософт пользователя.<br/><br/>[Руководство по перемещаемым данным приложения](https://msdn.microsoft.com/library/windows/apps/hh465094.aspx) |
|  **Скачивание файлов по HTTP.** Скачивание больших и маленьких файлов по HTTP. | Для скачивания по протоколам HTTP и FTP используются **URLConnection** и **HTTPURLConnection**. Также можно использовать системный **диспетчер загрузки** для скачивания в фоновом режиме. | Для скачивания по протоколам HTTP и FTP можно использовать **NSURLSession** и **NSURLConnection**. | **
            [API фоновой передачи данных](https://msdn.microsoft.com/library/windows/apps/windows.networking.backgroundtransfer.aspx)** позволяет надежно передавать данные по протоколам HTTP(S) и FTP с учетом приостановки приложения и потерь подключения, а также регулировкой в зависимости от типа подключения и уровня заряда батареи. Для файлов меньшего размера рекомендуется использовать **[HttpClient](https://msdn.microsoft.com/library/windows/apps/windows.web.http.httpclient.aspx)**.<br/><br/>[Какую сетевую технологию выбрать?](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[Фоновая передача данных](https://msdn.microsoft.com/library/windows/apps/mt280377.aspx) |
|  **Сокеты.** Создание низкоуровневой датаграммы UDP и сокетов TCP для связи с другими устройствами с помощью собственного протокола. | Класс **Socket** class предоставляет сокеты TCP, а класс **DatagramSocket** — сокет UDP. | Классы **NSStream** и **CFStream** предоставляют сокеты TCP, а класс **CFSocket** — сокеты UDP. | Вы можете использовать класс **[DatagramSocket](https://msdn.microsoft.com/library/windows/apps/br241319)** для связи с использованием сокета датаграмм UDP и класс **[StreamSocket](https://msdn.microsoft.com/library/windows/apps/br226882)** для связи по протоколу TCP или Bluetooth RFCOMM.<br/><br/>[Основы работы в сети](https://msdn.microsoft.com/library/windows/apps/mt280233.aspx)<br/><br/>[Какую сетевую технологию выбрать?](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[Обзор сокетов](https://msdn.microsoft.com/library/windows/apps/mt280234.aspx) |
|  **WebSockets.** Обеспечение двусторонней связи между клиентом и сервером и передачи данных в реальном времени. | Встроенные библиотеки WebSockets в Android отсутствуют. | Встроенные библиотеки WebSockets в iOS отсутствуют. | Безопасные подключения к серверам с поддержкой Websocket можно установить с помощью класса **[MessageWebSocket](https://msdn.microsoft.com/library/windows/apps/windows.networking.sockets.messagewebsocket.aspx)** для передачи небольших сообщений с уведомлениями о получении и с помощью класса **[StreamWebSocket](https://msdn.microsoft.com/library/windows/apps/windows.networking.sockets.streamwebsocket.aspx)** для передачи больших двоичных файлов с возможностью считывания по разделам.<br/><br/>[Основы работы в сети](https://msdn.microsoft.com/library/windows/apps/mt280233.aspx)<br/><br/>[Какую сетевую технологию выбрать?](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[Обзор WebSockets](https://msdn.microsoft.com/library/windows/apps/mt186447.aspx) |
|  **Библиотеки OAuth.** Библиотеки OAuth, обеспечивающие доступ к сторонним поставщикам OAuth и управлению учетными записями, встроенному в платформу. | Универсальные библиотеки OAuth не предоставляются. Класс **GoogleAuthUtil** предоставляется для проверки подлинности OAuth с помощью служб Google Play.<br/> | Универсальные библиотеки OAuth не предоставляются. **Платформа учетных записей** предоставляет доступ к сохраненным на устройстве учетным записям пользователей, таких как учетные записи Facebook и Twitter. | Универсальная библиотека OAuth **[брокер веб-проверки подлинности](https://msdn.microsoft.com/library/windows/apps/mt270196.aspx)** позволяет подключаться к службам поставщиков сетевых удостоверений сторонних разработчиков. **
            [Хранилище учетных](https://msdn.microsoft.com/library/windows/apps/mt270189.aspx)** позволяет вашим пользователям сохранить учетные данные и использовать их на нескольких устройствах. Пространство имен **[Microsoft.Live](https://msdn.microsoft.com/library/windows/apps/dn896755.aspx)** позволяет с легкостью получать доступ к протоколу OAuth Live SDK для доступа к службам Майкрософт.<br/><br/>[Проверка подлинности и удостоверение пользователя](https://msdn.microsoft.com/library/windows/apps/mt270184.aspx)<br/><br/>[Документация по API Windows.Security.Authentication.Web documentation](https://msdn.microsoft.com/library/windows/apps/windows.security.authentication.web.aspx)<br/><br/>[Пример кода WebAuthenticationBroker](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/WebAuthenticationBroker) |

## Инструменты

|  **Универсальное понятие** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Интегрированная среда разработки** Набор инструментов, используемый для создания приложения. | **Android Studio** и **Eclipse**. Google рекомендует разработчикам использовать Android Studio. | **Xcode** | **
							В [Visual Studio](https://www.visualstudio.com/features/universal-windows-platform-vs.aspx)** и **[Blend для Visual Studio](https://msdn.microsoft.com/library/jj171012.aspx)** вы найдете все инструменты, необходимые для написания, проектирования, подключения, отладки, анализа, оптимизации и тестирования приложений UWP. Visual Studio также предоставляет **[эмуляторы](https://msdn.microsoft.com/library/windows/apps/mt188754.aspx)** устройств под управлением Windows 10, чтобы вы могли протестировать приложение на разнообразных эмулированных устройствах.<br/><br/>[Скачиваемые файлы и инструменты для UWP](https://dev.windows.com/downloads) |
|  **Организация кода.** Базовая структура папок приложения, часто создаваемая из начального шаблона. | Файл **AndroidManifest** file, папка **java** с исходными файлами, папка **res** с ресурсами, включая макеты и значения, сценарии сборки **Gradle** в Android Studio и сценарии сборки **Ant** в Eclipse. | Исходные и **вспомогательные файлы**, файлы **Info.plist**, **Main.storyboard** и **LaunchScreen.storyboard**. Изображения хранятся **библиотеках ресурсов**. | Приложение UWP содержит файлы XAML и файлы кода для вашего приложения под названием Example.xaml и Example.xaml.cs, различные изображения в **папке Assets**, начальную страницу (например, **MainPage.xaml** и **MainPage.xaml.cs**) и манифест.<br/><br/>[Создание приложения "Hello, world"](https://msdn.microsoft.com/library/windows/apps/dn765018.aspx) |

## Жизненный цикл приложения

|  **Универсальное понятие** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Жизненный цикл приложения.** Обработка событий при запуске, приостановке, возобновлении и закрытии приложения, обеспечивающая возможность сохранения и восстановления состояния приложения или выполнения других задач. | Каждая активность имеет собственный **жизненный цикл активности** с такими состояниями как **возобновлено**. **Обратные вызовы жизненного цикла**, такие как **onResume** реализуются в ваших **классах активности**. | **Жизненный цикл приложения** имеет такие состояния, как **приостановлено**. Такие методы, как **applicationDidEnterBackground:** реализуются в **объекте делегата приложения** для выполнения кода при изменении состояния. | Ваше приложение имеет **состояния выполнения** NotRunning, Activated, Running, Suspending, Suspended и Resuming.<br/><br/>Вы можете реализовать в приложении методы **[класса Application](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.aspx)** OnLaunched, OnActivated, Suspending и Resuming для выполнения кода при изменении состояния.<br/><br/>[Жизненный цикл приложения](https://msdn.microsoft.com/library/windows/apps/mt243287.aspx) |
|  **Фоновые задачи.** Задачи, которые выполняют фоновые операции и продолжают выполняться, когда приложение не находится на переднем плане. | Приложения могут запускать **службы**, выполняющие фоновые операции, когда приложение не находится на переднем плане. Службы имеют собственный **жизненный цикл** и регистрируются в манифесте. | **Фоновое выполнение** разрешено только для определенных типов задач.<br/><br/>Приложения объявляют **поддерживаемые фоновые задачи** в файле Info.plist с использованием **UIBackgroundModes**.<br/><br/>Система контролирует момент и продолжительность выполнения фоновых задач. | Вы можете создать фоновую задачу, реализовав интерфейс **[IBackgroundTask](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.ibackgroundtask.aspx)** и зарегистрировав задачу в манифесте приложения. Можно настроить выполнение задачи по [**таймеру**](https://msdn.microsoft.com/library/windows/apps/mt186458.aspx), [**системному триггеру**](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.systemtriggertype.aspx) и [**триггеру обслуживания**](https://msdn.microsoft.com/library/windows/apps/mt185632.aspx).<br/><br/>[Поддержка приложения с помощью фоновых задач](https://msdn.microsoft.com/library/windows/apps/mt299103.aspx)<br/><br/>[Создание и регистрация фоновой задачи](https://msdn.microsoft.com/library/windows/apps/mt299100.aspx)<br/><br/>[Руководство по работе с фоновыми задачами](https://msdn.microsoft.com/library/windows/apps/mt187310.aspx) |

## Производительность

|  **Универсальное понятие** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Рекомендации по повышению производительности.** Руководство по созданию быстрых и гибких приложений с ускоренным запуском и учетом уровня заряда батареи. | Android предоставляет обучающее руководство **Рекомендации по повышению производительности**. | iOS предоставляет документ **Обзор производительности**. | Вы можете ознакомиться с подробным **[Руководством по повышению производительности](https://msdn.microsoft.com/library/windows/apps/mt270266.aspx)**, описывающим такие темы, как планирование и измерение производительности, управление памятью, плавные анимации, эффективный доступ к файловой системе и инструменты для профилирования и производительности. |
|  **Оптимизация представлений для ускорения отклика интерфейса пользователя.** Повышение производительности путем оптимизации представлений. | Оптимизация **иерархий макетов** с помощью инструмента Hierarchy Viewer, **повторное использование макетов** и загрузка **представлений по требованию** — это методы обеспечения быстрого отклика потока пользовательского интерфейса и предотвращения появления диалоговых окон "Приложение не отвечает" (**ANR**).<br/> | Устранение проблем интерфейса посредством **закадровой отрисовки**, **режима смешивания слоев** и **растеризации** с помощью инструмента **Core Animation** помогает обеспечить быстроту отклика потока пользовательского интерфейса. | Вы можете легко **оптимизировать** **разметку** и **макеты** XAML, выполнив несколько простых действий. Методы включают уменьшение структуры макета, сокращение количества элементов и перерисовки. <br/><br/>[Обеспечение быстрого отклика потока пользовательского интерфейса](https://msdn.microsoft.com/library/windows/apps/mt185403.aspx)<br/><br/>[Оптимизация разметки XAML](https://msdn.microsoft.com/library/windows/apps/mt204779.aspx)<br/><br/>[Оптимизация макета XAML](https://msdn.microsoft.com/library/windows/apps/mt404609.aspx) |
|  **Потоки.** Использование потоков для обеспечения **скорости отклика интерфейса пользователя** и **параллельного выполнения нескольких задач**. | Использование потоков обеспечивается при помощи классов **Runnable**, **Handler**, **ThreadPoolExecutor** и класса **AsyncTask** на более высоком уровне. | Использование потоков обеспечивается при помощи класса **NSThread**, платформы **Grand Central Dispatch** и класса **NSOperation** на более высоком уровне. | Вы можете работать с потоками, отправляя **рабочие элементы** в **пул потоков** при помощи метода **[RunAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.threading.threadpool.runasync.aspx)**. Можно использовать таймер для отправки рабочего элемента, используя метод **[CreateTimer](https://msdn.microsoft.com/library/windows/apps/br230590.aspx)**, и создавать периодические рабочие элементы с помощью метода **[CreatePeriodicTimer](https://msdn.microsoft.com/library/windows/apps/br230589.aspx)**.<br/><br/>[Отправка рабочего элемента в пул потоков](https://msdn.microsoft.com/library/windows/apps/mt187339.aspx)<br/><br/>[Отправка рабочего элемента по таймеру](https://msdn.microsoft.com/library/windows/apps/mt187341.aspx)<br/><br/>[Создание периодического рабочего элемента](https://msdn.microsoft.com/library/windows/apps/mt187338.aspx)<br/><br/>[Рекомендации по использованию пула потоков](https://msdn.microsoft.com/library/windows/apps/mt187336.aspx) |
|  **Асинхронное программирование.** Предотвращение использования сложных потоков путем использования шаблонов асинхронного программирования для обеспечения быстроты отклика потока пользовательского интерфейса.  | Использование **потоков необходимо** для создания собственных асинхронных классов. Некоторые встроенные классы являются асинхронными. | Использование **потоков необходимо** для создания собственных асинхронных классов. Некоторые встроенные классы являются асинхронными. | Вы можете использовать асинхронные шаблоны, чтобы избежать блокировки главного потока при создании собственных API, например с помощью ключевых слов **Async** и **Await** в C# и Visual Basic. Возможно использование встроенных асинхронных API, имена которых заканчиваются на **Async**.<br/><br/>[Асинхронное программирование](https://msdn.microsoft.com/library/windows/apps/mt187335.aspx)<br/><br/>[Вызов асинхронных API в C# или Visual Basic](https://msdn.microsoft.com/library/windows/apps/mt187337.aspx) |
|  **Оптимизация представлений списков.** Встроенные шаблоны, помогающие оптимизировать списки данных, производительность которых зачастую снижается при отображении большого объема данных. | Во избежание повторного поиска представления используется шаблон проектирования **ViewHolder**, что позволяет использовать элементы интерфейса пользователя повторно. | Для повышения производительности **UITableView** можно применить различные виды оптимизации. Встроенные средства отсутствуют. | Вы можете использовать элементы управления [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx) и [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx), обеспечивающие **виртуализацию пользовательского интерфейса**, для более плавного выполнения сдвига и прокрутки и ускорения запуска. Вы также можете реализовать в источнике данных интерфейсы [IList](https://msdn.microsoft.com/library/windows/apps/system.collections.ilist.aspx) и [INotifyCollectionChanged](https://msdn.microsoft.com/library/windows/apps/system.collections.specialized.inotifycollectionchanged.aspx) для обеспечения **виртуализации данных** и дополнительного повышения производительности.<br/><br/>[Оптимизация пользовательского интерфейса ListView и GridView](https://msdn.microsoft.com/library/windows/apps/mt204776.aspx)<br/><br/>[Виртуализация данных ListView и GridView](https://msdn.microsoft.com/library/windows/apps/mt574120.aspx) |

## Получение дохода

|  **Универсальное понятие** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Покупки из приложения.** Возможности платформы, позволяющие пользователям совершать покупки в приложениях. | Службы Google предоставляют API **In-app Billing**. Продукты добавляются в **консоли разработчика Google Play**. Покупки из приложения реализуются с помощью библиотеки **Google Play Billing Library**. | Продукты добавляются в **iTunes Connect**. Покупки из приложения реализуются с помощью платформы **StoreKit**.<br/><br/>Покупка продуктов осуществляется посредством классов **SKMutablePayment** и **SKPaymentQueue**. | Внутренние продукты приложения создаются путем [добавление их в приложение и отправки в Магазин](https://msdn.microsoft.com/library/windows/apps/mt148551.aspx). <br/><br/>Для определения покупок из приложения используется **[класс CurrentApp](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.aspx)**. <br/><br/>Для отображения интерфейса, позволяющего пользователям приобретать продукты, используется класс **[CurrentApp.RequestProductPurchaseAsync](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.requestproductpurchaseasync.aspx)**.<br/><br/>[Поддержка покупок продуктов из приложения](https://msdn.microsoft.com/library/windows/apps/mt219684.aspx) |
|  **Покупки потребляемых внутренних продуктов приложения.** Внутренние продукты приложения, которые можно приобрести, использовать, а затем приобрести еще раз. | Покупка потребляемых продуктов обеспечивается путем совершения обычной покупки и ее потребления с помощью **consumePurchase**, что позволяет приобрести продукт, использовать его, а затем приобрести еще раз. | **Потребляемые продукты определяются** в iTunes Connect. | Поддержка потребляемых продуктов обеспечивается путем [указания типа продукта "Потребляемый" при отправке продукта](https://msdn.microsoft.com/library/windows/apps/mt148534.aspx) в Магазин. После совершения покупки потребляемого продукта вызывается метод **[CurrentApp.ReportConsumableFulfillmentAsync](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.reportconsumablefulfillmentasync.aspx)**, позволяющий пользователю получить доступ к продукту.<br/><br/>[Поддержка покупок потребляемых внутренних продуктов приложения](https://msdn.microsoft.com/library/windows/apps/mt219683.aspx) |
|  **Тестирование внутренних покупок приложения.** Возможность протестировать код внутренней покупки приложения без отправки приложения в Магазин. | Для тестирования используется **In-app Billing Sandbox**.  | Для тестирования используются **учетные записи тестировщиков Sandbox**. | Вы можете тестировать внутренние покупки приложения, просто используя класс **[CurrentAppSimulator](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentappsimulator.aspx)** вместо класса CurrentApp.<br/><br/> |
|  **Пробные версии.** Возможность ограничения количества доступного содержимого или отключения рекламы в зависимости от версии приложения. | Google Play **официально не поддерживает пробные версии приложений**. Поддержка пробных версий и отключения рекламы обеспечивается путем создания внутренней покупки приложения и выполнения соответствующего кода после подтверждения совершения покупки. | App Store **официально не поддерживает пробные версии**. Поддержка пробных версий и отключения рекламы обеспечивается путем создания внутренней покупки приложения и выполнения соответствующего кода после подтверждения совершения покупки. | Вы можете предлагать бесплатную пробную версию вашего приложения с помощью **[параметра "Бесплатная пробная версия"](https://msdn.microsoft.com/library/windows/apps/mt148548.aspx)** при отправке приложения в Магазин. Затем можно использовать свойство **[LicenseInformation.IsTrial](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.licenseinformation.istrial.aspx)** для проверки состояния пробной версии приложения и выполнения различных ветвей кода в зависимости от значения свойства. Для получения уведомления о том, что пользователь изменил статус пробной версии во время работы приложения, можно зарегистрировать обработчик [события LicenseChanged](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.licenseinformation.licensechanged).<br/><br/>[Исключение или ограничение функций в пробной версии](https://msdn.microsoft.com/library/windows/apps/mt219685.aspx) |

## Адаптация для нескольких платформ

|  **Универсальное понятие** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Адаптивный пользовательский интерфейс: гибкие макеты.** Поддержка нескольких размеров экрана различной высоты и ширины. | Гибкие макеты реализуются с помощью значений **wrap_content** и **match_parent** объектов LinearLayout или путем использования для выравнивания объектов RelativeLayout. | Гибкие макеты реализуются с помощью **адаптивной модели** с универсальными раскадровками, использующей функцию **Auto Layout** с такими **ограничениями** и **признаками**, как horizontalSizeClass и displayScale, применяемыми к контроллерами представлений. | Вы можете создать гибкий макет, используя **свойства макета** и **панели** фиксированного и динамически изменяемого размера.<br/><br/>[Определение макетов с помощью XAML — панели и свойства макета](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#layout_overview)<br/><br/>[Введение в адаптивный дизайн](https://msdn.microsoft.com/library/windows/apps/dn958435.aspx) |
|  **Адаптивный пользовательский интерфейс: специально разработанные макеты.** Поддержка нескольких размеров экрана с использованием отдельных целевых макетов. | Предоставление альтернативных файлов макета для различных конфигураций экрана в каталоге ресурсов с помощью **квалификаторов конфигурации**, таких как **small**, **large**, **ldpi** и **hdpi**, позволяет создавать отдельные макеты для экранов различных размеров и плотности пикселей. | Определите **отдельные раскадровки для iPhone и iPad**, чтобы адаптировать макеты универсального приложения для различных семейств устройств. | Вы можете создать специально разработанный макет, определив **отдельные файлы разметки XAML** для каждого семейства устройств.<br/><br/>[Определение макетов с помощью XAML — специально разработанные макеты](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#tailored_layouts) |
|  **Адаптивный пользовательский интерфейс: гибкие макеты** Обработка изменений размера экрана, таких как поворот и изменение размеров окна. | Гибкие макеты реализуются посредством **LinearLayout** и **RelativeLayout** или предоставления альтернативных файлов макета для различных ориентаций. | При изменении **размеров** или **признаков** представления применяются указанные в раскадровках **ограничения**. | Вы можете с легкостью адаптировать, перемещать, масштабировать, отображать и заменять разделы пользовательского интерфейса во время выполнения приложения в ответ на изменение размеров окна с помощью классов **[VisualState](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstate.aspx)**, **[VisualStateManager](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstatemanager.aspx)** и **[AdaptiveTrigger](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.adaptivetrigger.aspx)**.<br/><br/>[Определение макетов с помощью XAML — визуальные состояния и триггеры состояния](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#visual_states_and_state_triggers)<br/><br/>[Введение в адаптивный дизайн](https://msdn.microsoft.com/library/windows/apps/dn958435.aspx) |
|  **Поддержка различных возможностей устройств.** Использование расширенных аппаратных функций при сохранении поддержки не обладающих ими устройств. | Проверка функций устройства во время выполнения с помощью **PackageManager.hasSystemFeature** позволяет определить, можно ли выполнять аппаратно-зависимый код. | Не существует **единой проверки**, которую можно выполнить для определения функций устройства. Необходимо проверять наличие каждой функции для определения возможности выполнения аппаратно-зависимого кода. | Вы можете добавить к вашему пакету **SDK расширения платформы** для использования расширенных возможностей различных семейств устройств, включая телефоны, настольные устройства и оборудование IoT. Чтобы определить наличие типов и членов при выполнении, используется **[API ApiInformation.](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.aspx)** Типы и члены вызываются только при их наличии. |
|  **Поддержка различных возможностей устройств.** Использование расширенных аппаратных функций при сохранении поддержки не обладающих ими устройств. | В пакет приложения можно добавить библиотеку **Android Support Library** для обеспечения доступа к новым API в более старых версиях Android. Проверку уровня API во время выполнения можно произвести с помощью **Build.Version.SDK_INT**. | Для определения доступности API используются стандартные проверки среды выполнения, такие как метод **class**, определяющий, существует ли класс, и **respondsToSelector:** для проверки методов в классах.  | Вы можете использовать **[ApiInformation.IsApiContractPresent](https://msdn.microsoft.com/library/windows/apps/dn949005.aspx)** для проверки наличия контракта API с указанным основным и вспомогательным номером версии. Чтобы определить наличие типов и членов при выполнении, используется **[API ApiInformation.](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.aspx)** Типы и члены вызываются только при их наличии. |

## Уведомления

|  **Универсальное понятие** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Плитки и индикаторы событий.** Предоставление пользователям обновлений на начальном экране. | **Виджеты приложений** — это представления вашего приложения, которые могут быть размещены на начальном экране и получать периодические обновления. **Система индикаторов событий** в Android отсутствует. Системы, аналогичной плиткам, не существует. | **Плитки и мини-приложения** в iOS отсутствуют. К значку приложения можно добавить **индикатор событий** с номером, меняющимся при получении локального или удаленного уведомления. | Приложение имеет **плитку**, которую можно закрепить на начальном экране и использовать для отображения выбранного вами текста, изображений и **индикатора событий** с глифами и числами. Содержимое плитки можно обновлять из приложения через push-уведомления или по предопределенному расписанию. Плитки могут быть адаптивными и меняться в зависимости от места отображения.<br/><br/>[Создание плиток](https://msdn.microsoft.com/library/windows/apps/xaml/mt185605.aspx)<br/><br/>[Создание адаптивных плиток](https://msdn.microsoft.com/library/windows/apps/xaml/mt590880.aspx)<br/><br/>[Выбор способа доставки уведомлений](https://msdn.microsoft.com/library/windows/apps/xaml/mt187193.aspx)<br/><br/>[Руководство по плиткам и индикаторам событий](https://msdn.microsoft.com/library/windows/apps/xaml/hh465403.aspx) |
|  **Отображение уведомлений.** Типы отображаемых уведомлений. | Уведомления могут отображаться в **области уведомлений** и **секции уведомлений**. **Всплывающие уведомления** отображаются в небольшом перемещаемом окне. Можно добавить к уведомлениям действия, определив **PendingIntent**. | Всплывающие уведомления отображаются в виде **баннеров** и **предупреждений**. К **интерактивным уведомлениям** с помощью **UIMutableUserNotificationAction** можно добавить настраиваемые кнопки действий. | Вы можете создавать адаптивные **всплывающие уведомления**. Всплывающие уведомления можно определять в XML, добавляя визуальное содержимое и **действия** в виде кнопок, полей ввода и голосовых команд.<br/><br/>[Адаптивные и интерактивные всплывающие уведомления](https://msdn.microsoft.com/library/windows/apps/xaml/mt631604.aspx)<br/><br/>[Выбор способа доставки уведомлений](https://msdn.microsoft.com/library/windows/apps/xaml/mt187193.aspx)<br/><br/>[Руководство по всплывающим уведомлениям](https://msdn.microsoft.com/library/windows/apps/xaml/hh465391.aspx) |
|  **Планирование локальных уведомлений.** Локальные уведомления, отправляемые приложением в запланированное время. | Уведомления и действия определяются с помощью класса **NotificationCompat.Builder** и могут быть запланированы и обрабатываться в приложении с использованием классов **AlarmManager** и **BroadcastReceiver**. | Локальные уведомления создаются с помощью класса **UILocalNotification** и могут быть запланированы, используя метод **UILocalNotification.scheduleLocalNotification:**. | Запланировать всплывающее уведомление можно с помощью класса **[ScheduledToastNotification](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.scheduledtoastnotification.aspx)**. Можно отправить уведомление плитки из приложения с помощью **[класса TileNotification](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.tilenotification.aspx)** или создать расписание уведомления плитки с помощью класса [ScheduledTileNotification](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.scheduledtilenotification.aspx).<br/><br/>[Адаптивные и интерактивные всплывающие уведомления](https://msdn.microsoft.com/library/windows/apps/xaml/mt631604.aspx)<br/><br/>[Отправка локального уведомления на плитке](https://msdn.microsoft.com/library/windows/apps/xaml/mt593299.aspx) |
|  **Отправка push-уведомлений.** Уведомление, отправленное с сервера push-уведомлений и при необходимости обрабатываемое в приложении. | Поддержку push-уведомлений в Android обеспечивает **Google Cloud Messaging**. | Удаленные и push-уведомления предоставляются службой **Apple Push Notification service (APNs)**. | Вы получаете push-уведомления, отправленные **службой push-уведомлений Windows (WNS)**, следующих типов: плитка, всплывающее уведомление, индикатор события или необработанное уведомление. Вы можете использовать событие доставки уведомления [PushNotificationReceived](https://msdn.microsoft.com/library/windows/apps/xaml/windows.networking.pushnotifications.pushnotificationchannel.pushnotificationreceived.aspx) для получения уведомлений во время работы приложения.<br/><br/>[Обзор служб push-уведомлений Windows (WNS)](https://msdn.microsoft.com/library/windows/apps/xaml/mt187203.aspx)<br/><br/>[Общие сведения о необработанных уведомлениях](https://msdn.microsoft.com/library/windows/apps/xaml/mt187200.aspx) |

## Захват и отображение мультимедийного содержимого

|  **Универсальное понятие** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Захват мультимедиа.** Запись звука и визуального содержимого. | Используя такое **намерение**, как MediaStore.ACTION_VIDEO_CAPTURE можно производить захват мультимедиа с помощью встроенного приложения камеры. Использование **android.hardware.camera2** или библиотеки **камеры** позволяет реализовать пользовательский интерфейс камеры. API **MediaRecorder** можно использовать для записи звука. | **UIImagePickerController** обеспечивает захват видео и фотографий с помощью системного интерфейса. Классы **AVFoundation**, такие как **AVCaptureSession** обеспечивают прямой доступ к камере. <br/>Класс **AVAudioRecorder** обеспечивает запись звука. | Можно захватывать фотографии и видео с использованием встроенного пользовательского интерфейса камеры с помощью **[класса CameraCaptureUI](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.cameracaptureui.aspx)**. Вы можете взаимодействовать с камерой на низком уровне и записывать звук с помощью классов пространства имен **[Windows.Media.Capture](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.aspx)**, таких как **[MediaCapture API](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.mediacapture.aspx)**. <br/><br/>[Фото- и видеозахват с помощью CameraCaptureUI](https://msdn.microsoft.com/library/windows/apps/xaml/mt282142.aspx)<br/><br/>[Фото- и видеозахват с помощью MediaCapture](https://msdn.microsoft.com/library/windows/apps/xaml/mt243896.aspx) |
|  **Воспроизведение мультимедиа.** Воспроизведение звуковых и видеофайлов. | Для воспроизведения звуковых и видеофайлов используются классы **MediaPlayer** и **AudioManager**. | Для воспроизведения звуковых и видеофайлов используются **платформа AVKit**, **AVAudioPlayer** и **Media Player Framework**. | Вы можете использовать классы **[ MediaSource](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.core.mediasource.aspx)**, **[MediaElement](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.aspx)** и **[MediaPlayer](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplayer.aspx)** для воспроизведения звука и видео из таких источников, как локальные и удаленные файлы.<br/><br/>[Воспроизведение мультимедиа с помощью класса MediaSource](https://msdn.microsoft.com/library/windows/apps/xaml/mt592657.aspx) |
|  **Редактирование мультимедиа.** Составление новых файлов мультимедиа из существующих записей и применение специальных эффектов. | Для редактирования содержимого можно использовать такие низкоуровневые классы, как **MediaCodec**, **MediaMuxer** и **android.media.effect**. | Для редактирования содержимого можно использовать классы платформы **AV Foundation**, такие как **AVMutableComposition**, **AVMutableVideoComposition** и **AVMutableAudioMix**. | Вы можете использовать API **[Windows.Media.Editing](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.aspx)**, такие как **[MediaComposition](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.mediacomposition.aspx)** и **[MediaClip](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.mediaclip.aspx)** для создания композиций мультимедиа из звуковых и видеофайлов. Поддерживается добавление фото- и видеоналожений, группировка видеоклипов, добавление фоновых аудиодорожек и применение звуковых и видеоэффектов.<br/><br/>[Создание и редактирование мультимедиа](https://msdn.microsoft.com/library/windows/apps/mt204792.aspx) |

## Датчики

|  **Универсальное понятие** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Датчики.** Отслеживание перемещения и положения устройства, а также свойств окружающей среды. | Для доступа к аппаратным и программным датчикам используются такие классы **платформы датчиков**, как **SensorManager** и **SensorEvent**.  | Для доступа к необработанным и обработанным данным датчиков используется **платформа Core Motion**. | Вы можете использовать классы пространства имен **[Windows.Devices.Sensors](https://msdn.microsoft.com/library/windows/apps/windows.devices.sensors.aspx)** для доступа к показаниям датчиков и событиям, запускаемым при получении новых данных показаний от датчика.<br/><br/>[Датчики](https://msdn.microsoft.com/library/windows/apps/xaml/mt187358.aspx) |

## Местоположение и карты

|  **Универсальное понятие** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Местоположение** Определение **текущего** местоположения устройства и отслеживание **изменений**. | API местоположения служб Google Play предоставляют высокоуровневый доступ к **последнему известному местоположению** с помощью **единого определителя местоположения** посредством методов **getLastLocation** и **requestLocationUpdates**. Низкоуровневый доступ предоставляется в библиотеках Android с помощью **LocationManager**. | Для отслеживания местоположения устройства используются платформа **Core Location** и класс **CLLocationManager**. Метод **startUpdatingLocation** применяется для стандартного определения местоположения, **startMonitoringSignificantLocationChanges** — для определения **значительных изменений** местоположения. | Вы можете отслеживать местоположение с помощью классов пространства имен **[Windows.Devices.Geolocation](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.aspx)**. Используйте **[Geolocator.GetGeopositionAsync](https://msdn.microsoft.com/library/windows/apps/br225537.aspx)** для однократного считывания. Используйте **[Geolocator.PositionChanged](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geolocator.positionchanged.aspx)** для регулярного получения сведений о расположении по таймеру или уведомлений об изменении местоположения.<br/><br/>[Получение местоположения пользователя](https://msdn.microsoft.com/library/windows/apps/mt219698.aspx) |
|  **Отображение карт.** Отображение **интерактивной встроенной карты** и добавление **объектов на карту**. | Классы **GoogleMap**, **MapFragment** и **MapView** в **API Карт Google в Android** позволяют встраивать карты в приложения. Объекты могут отображаться на карте с помощью **маркеров** и настраиваемого класса **Marker**. | Карты встраиваются в приложения iOS с помощью класса **MKMapView** **платформы MapKit**. К приложениям можно добавлять **аннотации** для отображения объектов на карте с помощью классов объектов, таких как **MKPointAnnotation**, и классов представлений, таких как **MKPinAnnotationView**. | Вы можете внедрить в свое приложение карты с помощью встроенного элемента управления XAML **[MapControl](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapcontrol.aspx)**, обеспечивающего двумерные и трехмерные представления, а также представления Streetside. Можно добавлять объекты на карту с помощью вешек, изображений и фигур, используя классы **[MapIcon](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapicon.aspx)**, **[MapPolygon](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mappolygon.aspx)** и **[MapPolyline](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mappolyline.aspx)**.<br/><br/>[Отображение карт с помощью двумерных и трехмерных представлений, а также с помощью представлений Streetside](https://msdn.microsoft.com/library/windows/apps/mt219695.aspx)<br/><br/>[Отображение объектов на карте](https://msdn.microsoft.com/library/windows/apps/mt219696.aspx) |
|  **Создание геозон.** Отслеживание входа и выхода из определенного географического региона. | Геозоны отслеживаются с помощью **служб определения местоположения** в SDK служб Google Play. | Регионы отслеживаются посредством класса **CLCircularRegion** и регистрируются с помощью метода **CLLocationManager.startMonitoringForRegion:**. | Вы можете создавать геозоны с помощью класса **[Geofence](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geofencing.geofence.aspx)** и определять **отслеживаемые состояния**, такие как вход и выход из региона. Обработка геозон на переднем плане осуществляется с помощью класса **[GeofenceMonitor](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geofencing.geofencemonitor.aspx)**, а в фоновом режиме — с помощью **[фонового класса LocationTrigger background class](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.locationtrigger.aspx)**.<br/><br/>[Настройка геозоны](https://msdn.microsoft.com/library/windows/apps/mt219702.aspx) |
|  **Геокодирование и обратное геокодирование.** Преобразование адресов в географические расположения (геокодирование) и географических расположений в адреса (обратное геокодирование).<br/> | Для геокодирования и обратного геокодирования используется класс **Geocoder**. | Для геокодирования используется класс **CLGeocoder**. | Вы можете выполнять геокодирование с помощью **[класса MapLocationFinder](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.aspx)** в пространстве имен **[Windows.Services.Maps](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.aspx)**. Для геокодирования используется **[FindLocationsAsync](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.findlocationsasync.aspx)**, а для обратного геокодирования — **[FindLocationsAtAsync](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.findlocationsatasync.aspx)**.<br/><br/>[Выполнение геокодирования и обратного геокодирования](https://msdn.microsoft.com/library/windows/apps/mt219697.aspx) |
|  **Маршруты и направления.** Предоставление маршрутов, расстояний и направлений между двумя географическими расположениями. | Google предоставляет веб-службу **Google Maps Directions API**, которую можно использовать в Android, однако SDK не предоставляется. | Платформа Map Kit предоставляет API **MKDirections**, которое можно использовать для получения информации о маршруте и направлениях. | Вы можете сделать запрос пешеходного или автомобильного маршрута с помощью класса **[MapRouteFinder](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproutefinder.aspx)** в пространстве имен **[Windows.Services.Maps](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.aspx)**. Маршруты возвращаются в виде экземпляра **[MapRoute](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproute.aspx)**, который легко отобразить в MapControl. Направления возвращаются внутри объекта **[MapRouteManeuver](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproutemaneuver.aspx)**.<br/><br/>[Отображение маршрутов и направлений на карте](https://msdn.microsoft.com/library/windows/apps/mt219701.aspx) |

## Связь между приложениями

|  **Универсальное понятие** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Вызов другого приложения.** Запуск другого приложения и, при необходимости, общий доступ к данным (ссылкам, тексту, фотографиям, видео и файлам). | Для запуска другого приложения используется **неявное намерение** путем определения **действия** и необязательного определения данных в **намерении** и его вызова с помощью **startActivityForResult**.<br/> | Для предоставления доступа к данным приложения другому приложению можно использовать **расширения приложений**. **Схемы URL-адресов** позволяют передавать URL-адреса в другое приложение. | Вы можете запустить приложение с зарегистрированной схемой URI с помощью **[Launcher.LaunchUriAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchuriasync.aspx)** или использовать **[Launcher.LaunchUriForResultsAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchuriforresultsasync.aspx)** для запуска приложения для результатов и получения данных из запущенного приложения. Для передачи файла для обработки в другое приложение можно использовать метод **[Launcher.LaunchFileAsync](https://msdn.microsoft.com/library/windows/apps/hh701471.aspx)**.<br/><br/>Для легкого обмена данными между приложениями используются **контракты отправки данных**.<br/><br/>[Запуск приложения по умолчанию для URI](https://msdn.microsoft.com/library/windows/apps/mt228340.aspx)<br/><br/>[Запуск приложения для результатов](https://msdn.microsoft.com/library/windows/apps/mt269386.aspx)<br/><br/>[Запуск приложения по умолчанию для файла](https://msdn.microsoft.com/library/windows/apps/mt299102.aspx)<br/><br/>[Предоставление общего доступа к данным](https://msdn.microsoft.com/library/windows/apps/xaml/mt243293.aspx) |
|  **Разрешение вызова вашего приложения.** Возможность ответа вашего приложения на запрос из другого приложения. | Приложения регистрируют **активность обработки намерений** с **фильтром намерений** для ответа на неявные намерения других приложений. | Добавление в пакет **расширения приложения** позволяет обмениваться данными с другими приложениями. Приложения могут регистрировать **настраиваемую схему URL-адресов** с помощью ключа **CFBundleURLTypes** в файле Info.plist. | Вы можете зарегистрировать приложение в качестве обработчика по умолчанию для **имени схемы URI**, зарегистрировав **[протокол](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.activation.activationkind.aspx#Protocol)** в манифесте пакета и обновив обработчик событий **[Application.OnActivated](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.onactivated.aspx)** для дополнительного возврата результатов. Аналогичным образом вы можете зарегистрировать приложение в качестве обработчика по умолчанию для определенных типов файлов путем добавления объявления в манифест пакета и обработки события **[Application.OnFileActivated](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.onfileactivated.aspx)**.<br/><br/>Вы можете обрабатывать запросы контракта отправки данных, зарегистрировав приложение в манифесте в качестве получателя данных и обрабатывая событие **[Application.OnShareTargetActivated](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.application.onsharetargetactivated.aspx)**.<br/><br/>[Запуск приложения для результатов](https://msdn.microsoft.com/library/windows/apps/mt269386.aspx)<br/><br/>[Обработка активации файла](https://msdn.microsoft.com/library/windows/apps/mt269385.aspx)<br/><br/>[Получение данных](https://msdn.microsoft.com/library/windows/apps/xaml/mt243292.aspx) |
|  **Копирование и вставка.** Копирование и вставка текста и другого содержимого между приложениями. | Для реализации операций копирования и вставки можно использовать классы **ClipboardManager** и **ClipData** **платформы буфера обмена**. | Для реализации операций копирования и вставки можно использовать **UIPasteboard**, **UIMenuController** и **UIResponderStandardEditActions**. | Многие элементы управления XAML по умолчанию поддерживают копирование и вставку. Вы можете реализовать поддержку копирования и вставки самостоятельно с помощью классов **[DataPackage](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.datatransfer.datapackage.aspx)** и **[Clipboard](https://msdn.microsoft.com/library/windows/apps/xaml/windows.applicationmodel.datatransfer.clipboard.aspx)** в пространстве имен **[Windows.ApplicationModel.DataTransfer](https://msdn.microsoft.com/library/windows/apps/br205967)**.<br/><br/>[Копирование и вставка](https://msdn.microsoft.com/library/windows/apps/xaml/mt243291.aspx) |
|  **Перетаскивание.** Перетаскивание содержимого между приложениями. | Перетаскивание можно реализовать в рамках одного приложения с помощью платформы **Android drag/drop framework**. | Высокоуровневые API перетаскивания в iOS не предоставляются. | Вы можете реализовать возможности перетаскивания между приложениями UWP, из классического приложения в приложение UWP и из приложения UWP в классическое приложение. Поддержка перетаскивания реализовывается в классе UIElement с помощью свойств **[AllowDrop](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.allowdrop.aspx)** и **[CanDrag](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.candrag.aspx)** и событий **[DragOver](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.dragover.aspx)** и **[Drop](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.drop.aspx)**.<br/><br/>[Перетаскивание](https://msdn.microsoft.com/library/windows/apps/xaml/mt227651.aspx) |

## Проектирование программного обеспечения

|  **Универсальное понятие** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Шаблоны проектирования программного обеспечения.** Рекомендуемые для платформы шаблоны проектирования. | В Android отсутствуют рекомендованные или предоставленные формальные шаблоны, однако бета-версия платформы привязки данных может обеспечить более широкое использование шаблона **Model-View-ViewModel (MVVM)**. В ряде сторонних статей и платформ рекомендуется использовать подходы **model-view-presenter (MVP)** и **MVVM**. | **Model-View-Controller (MVC)** — распространенный шаблон, используемые в iOS и интегрированный в платформу. | При создании приложений UWP отсутствует ограничение по использованию определенного шаблона.<br/><br/>Вы можете использовать встроенный шаблон [привязки данных](https://msdn.microsoft.com/library/windows/apps/mt210947.aspx) для обеспечения четкого разделения задач, связанных с данными, и функций пользовательского интерфейса. При этом отсутствует необходимость в создании кода обработчиков событий пользовательского интерфейса, обновляющих значения свойств.<br/><br/>Вы можете расширить привязку данных в соответствии с шаблоном **Model-View-ViewModel (MVVM)** с помощью сторонних библиотек MVVM, таких как [MVVM Light Toolkit](https://mvvmlight.codeplex.com/), либо самостоятельно, отделив логику от кода программной части.<br/><br/>[Шаблон MVVM](https://msdn.microsoft.com/library/hh848246.aspx)<br/><br/>[Шаблоны проектов Visual Studio Template 10](https://github.com/Windows-XAML/Template10/wiki) |


<!--HONumber=Mar16_HO1-->


