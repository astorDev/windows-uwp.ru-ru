---
description: У вас есть два варианта разработки процесса переноса.
title: Перенос среды выполнения Windows 8.x в проект UWP
ms.assetid: 2dee149f-d81e-45e0-99a4-209a178d415a
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 1d398d1cb37bb57e39fc9202af36970aba3d8302
ms.sourcegitcommit: d38e2f31c47434cd6dbbf8fe8d01c20b98fabf02
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/06/2019
ms.locfileid: "70393613"
---
# <a name="porting-a-windows-runtime-8x-project-to-a-uwp-project"></a>Перенос среды выполнения Windows 8.x в проект UWP



У вас есть два варианта разработки процесса переноса. Первый — изменить копии существующих файлов проекта, в том числе манифест пакета приложения (для этого варианта см. сведения об обновлении файлов проекта в разделе [Перенос приложений на универсальную платформу Windows (UWP)](https://docs.microsoft.com/visualstudio/misc/migrate-apps-to-the-universal-windows-platform-uwp?view=vs-2015)). Другой вариант — создать новый проект Windows 10 в Visual Studio и скопировать в него файлы. В первом подпункте этого раздела описан второй вариант, но в остальной части раздела можно найти дополнительную информацию, применимую к обоим вариантам. Вы также можете выбрать вариант сохранения нового проекта Windows 10 в том же решении, что и существующие проекты, и совместно использовать файлы исходного кода с помощью общего проекта. Или можно сохранить новый проект в собственном решении и совместно использовать файлы кода с помощью функции связанных файлов в Visual Studio.

## <a name="create-the-project-and-copy-files-to-it"></a>Создайте проект и скопируйте в него файлы.

Эти действия касаются создания нового проекта Windows 10 в Visual Studio и копирования в него файлов. Некоторые подробности о том, сколько проектов будут созданы и какие файлы вы скопируете, зависят от факторов и решений, описанных в разделе [Если у вас универсальное приложение для версии 8.1](w8x-to-uwp-root.md) и последующих разделах. Предполагается наиболее простой случай.

1.  Запустите Microsoft Visual Studio 2015 и создайте проект пустого приложения (Windows Universal). Дополнительные сведения см. в статье быстрое [Использование приложения среда выполнения Windows 8. x с помощьюC#шаблонов C++(,, Visual Basic)](https://docs.microsoft.com/previous-versions/windows/apps/hh768232(v=win.10)). Новый проект выполняет сборку пакета приложения (APPX-файла), который будет работать на всех семействах устройств.
2.  В проекте универсального приложения для версии 8.1 определите все файлы исходного кода и файлы визуального актива, которые вы хотите использовать. С помощью проводника скопируйте модели, модели представления, визуальные активы, словари ресурсов, структуру папок и все остальное, что вы хотите повторно использовать, в новый проект. Скопируйте или создайте вложенные папки на диске по мере необходимости.
3.  Скопируйте также представления (например, файлы MainPage.xaml и MainPage.xaml.cs) в новый проекта. Напоминаем еще раз: создавайте новые вложенные папки по мере необходимости и удаляйте существующие представления из проекта. Но перед тем, как переписывать или удалять представление, созданное Visual Studio, сохраните его копию, так как она может оказаться полезной позднее. Первая фаза переноса универсального приложения для версии 8.1 сфокусирована на хорошем отображении и работе приложения на одном семействе устройств. Позже вы уделите внимание адаптации представлений ко всем форм-факторам и при необходимости добавите адаптивный код, чтобы использовать все возможности определенного семейства устройств.
4.  В **Обозревателе решений**убедитесь, что функция **Показать все файлы** включена. Выберите скопированные файлы, щелкните их правой кнопкой мыши и выберите **Включить в проект**. Это автоматически включит содержащиеся в них папки. Затем можно выключить параметр **Показать все файлы** , если требуется. Если вы предпочитаете альтернативный процесс, используйте команду **Добавить существующий элемент** после создания всех необходимых вложенных папок в **Обозревателе решений** Visual Studio. Дважды убедитесь, что **Действие при сборке** ваших визуальных активов установлено на **Содержимое** и **Копировать в выходной каталог** установлено на **Не копировать**.
5.  Возможно, на этом этапе будут возникать некоторые ошибки сборки. Но если вы знаете, что требуется изменить, вы можете использовать команду Visual Studio **Найти и заменить** для внесения массовых изменений в исходный код. В редакторе императивного кода Visual Studio используйте команды **Разрешить** и **Упорядочение Using** в контекстном меню для внесения более нацеленных изменений.

## <a name="maximizing-markup-and-code-reuse"></a>Максимальное использование существующей разметки и кода

Как вы узнаете, небольшой рефакторинг и добавление адаптивного кода (описывается ниже) позволят вам по максимуму использовать разметку и код, который работает на всех семействах устройств. Вот подробности.

-   Для файлов, которые используются на всех семействах устройств, не требуется никакой дополнительной обработки. Эти файлы будут использоваться приложением на всех семействах устройств. Сюда входят файлы разметки XAML, файлы императивного исходного кода и файлы ресурсов.
-   Ваше приложение может определять семейство устройств, на котором оно работает, и переходить в представление, созданное специально для такого семейства. Дополнительные сведения см. в разделе [Определение платформы, на которой работает приложение](w8x-to-uwp-input-and-sensors.md).
-   Если нет альтернативы, может оказаться полезным похожий метод — изменить имя файла разметки или файла **ResourceDictionary** (или папки, содержащей файл) на специальное имя, чтобы он автоматически загружался во время выполнения только при запуске приложения на определенном семействе устройств. Этот метод проиллюстрирован в примере [Bookstore1](w8x-to-uwp-case-study-bookstore1.md).
-   Вы можете удалить множество директив условной компиляции в исходном коде приложения универсального 8,1, если требуется только поддержка Windows 10. См. подраздел [Условная компиляция и адаптивный код](#conditional-compilation-and-adaptive-code) в этом разделе.
-   Чтобы использовать функции, которые доступны не на всех семействах устройств (например, принтеры, сканеры или кнопку камеры), можно написать адаптивный код. См. третий пример в подразделе [Условная компиляция и адаптивный код](#conditional-compilation-and-adaptive-code) в этом разделе.
-   Если вы хотите поддерживать Windows 8.1, Windows Phone 8,1 и Windows 10, то можете поддерживать три проекта в одном решении и совместно использовать код совместно с общим проектом. Кроме того, можно также совместно использовать файлы исходного кода в разных проектах. Порядок действий: в Visual Studio, щелкните правой кнопкой мыши проект в **Обозревателе решений**, выберите **Добавить существующий элемент**, выберите файлы для совместного использования и затем щелкните **Добавить как связь**. Храните файлы исходного кода в общей папке в файловой системе, в которой привязанные к ним проекты могут их видеть. И не забывайте добавлять их в систему управления версиями.
-   Сведения о повторном использовании на двоичном уровне, а не на уровне исходного кода см. [в разделе C# создание среда выполнения Windows компонентов в и Visual Basic](https://docs.microsoft.com/previous-versions/windows/apps/br230301(v=vs.140)). Существуют также переносимые библиотеки классов, которые поддерживают подмножество API-интерфейсов .NET, доступных в .NET Framework для Windows 8.1, Windows Phone 8,1 и приложений Windows 10 (.NET Core), а также полный .NET Framework. Сборки переносимой библиотеки классов совместимы на уровне двоичного кода со всеми этими платформами. Используйте Visual Studio для создания проекта, который использует переносимую библиотеку классов. См. раздел [Кроссплатформенная разработка с помощью переносимой библиотеки классов](https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library).

## <a name="extension-sdks"></a>Пакеты SDK расширения

Большая часть API-интерфейсов среды выполнения Windows, которые вызывает ваше универсальное приложение для версии 8.1, уже реализованы в наборе API-интерфейсов, известном как семейство универсальных устройств. Но некоторые из них реализованы в пакетах SDK расширения, и Visual Studio распознает только API, реализованные целевым семейством устройств вашего приложения или любыми пакетами SDK расширений, на которые вы ссылаетесь.

Если возникают ошибки компиляции, связанные с пространствами имен, типами или членами, которые не удается найти, это может оказаться причиной. Откройте раздел API в справочной документации по API и перейдите к разделу "Требования". Так вы определите целевое семейство устройств. Если это не ваше целевое семейство устройств, вам потребуется ссылка на SDK расширения для этого семейства устройств, чтобы сделать API доступным в проекте.

Щелкните **проект** &gt; **Добавить ссылку** &gt; **расширения** **универсальной &gt; Windows** и выберите соответствующий пакет SDK расширений. Например, если нужные API-интерфейсы доступны только для семейства мобильных устройств и они появились в версии 10.0.x.y, выберите **Windows Mobile Extensions для UWP**.

После этого следующая ссылка будет добавлена в файл проекта:

```XML
<ItemGroup>
    <SDKReference Include="WindowsMobile, Version=10.0.x.y">
        <Name>Windows Mobile Extensions for the UWP</Name>
    </SDKReference>
</ItemGroup>
```

Имя и номер версии соответствуют папкам в месте установки SDK. Например, данные выше соответствуют этому имени папки:

`\Program Files (x86)\Windows Kits\10\Extension SDKs\WindowsMobile\10.0.x.y`

Если ваше приложение не предназначено для семейства устройств, которое реализует API, вам необходимо использовать класс [**ApiInformation**](https://docs.microsoft.com/uwp/api/Windows.Foundation.Metadata.ApiInformation), чтобы проверить наличие API, прежде чем вызывать его (это называется адаптивным кодом). Это условие оценивается при каждом запуске приложения, но оно будет истинным только на устройствах, где этот API присутствует и, следовательно, доступен. Используйте пакеты SDK расширения и адаптивный код только после проверки существования универсального API. Некоторые примеры представлены в разделе ниже.

См. также раздел [Манифест пакета приложения](#app-package-manifest).

## <a name="conditional-compilation-and-adaptive-code"></a>Условная компиляция и адаптивный код

Если вы используете условную компиляцию (с C# директивами препроцессора), чтобы файлы кода работали как в Windows 8.1, так Windows Phone 8,1, теперь можно проанализировать условную компиляцию в свете работы по конвергенции, выполненной в Windows 10. Конвергенция означает, что в приложении Windows 10 некоторые условия можно удалить полностью. А другие условия изменить на проверки во время выполнения, как показано в примерах ниже.

**Примечание** .   если требуется поддержка Windows 8.1, Windows Phone 8,1 и Windows 10 в одном файле кода, то это тоже можно сделать. Если просмотреть проект Windows 10 на страницах свойств проекта, вы увидите, что проект определяет WINDOWS\_UAP в качестве символа условной компиляции. Это можно использовать в сочетании с приложением WINDOWS\_и WINDOWS\_PHONE\_. В этих примерах показан более простой случай удаления условной компиляции из универсального приложения 8,1 и замены эквивалентного кода для приложения Windows 10.

В первом примере показан шаблон использования API **PickSingleFileAsync** (относится только к Windows 8.1) и API **PickSingleFileAndContinue** (относится только к Windows Phone 8.1).

```csharp
#if WINDOWS_APP
    // Use Windows.Storage.Pickers.FileOpenPicker.PickSingleFileAsync
#else
    // Use Windows.Storage.Pickers.FileOpenPicker.PickSingleFileAndContinue
#endif // WINDOWS_APP
```

Windows 10 объединяется в API [**пикксинглефилеасинк**](https://docs.microsoft.com/uwp/api/windows.storage.pickers.fileopenpicker.picksinglefileasync) , поэтому код упрощает это:

```csharp
    // Use Windows.Storage.Pickers.FileOpenPicker.PickSingleFileAsync
```

В этом примере мы обрабатываем аппаратную кнопку "Назад", но только на Windows Phone.

```csharp
#if WINDOWS_PHONE_APP
        Windows.Phone.UI.Input.HardwareButtons.BackPressed += this.HardwareButtons_BackPressed;
#endif // WINDOWS_PHONE_APP

...

#if WINDOWS_PHONE_APP
    void HardwareButtons_BackPressed(object sender, Windows.Phone.UI.Input.BackPressedEventArgs e)
    {
        // Handle the event.
    }
#endif // WINDOWS_PHONE_APP
```

В Windows 10 событие кнопки назад является универсальным понятием. Кнопки перехода назад, реализованные аппаратно или программно, вызывают событие [**BackRequested**](https://docs.microsoft.com/uwp/api/windows.ui.core.systemnavigationmanager.backrequested), поэтому обрабатывать нужно только одно событие для всех кнопок.

```csharp
    Windows.UI.Core.SystemNavigationManager.GetForCurrentView().BackRequested +=
        this.ViewModelLocator_BackRequested;

...

private void ViewModelLocator_BackRequested(object sender, Windows.UI.Core.BackRequestedEventArgs e)
{
    // Handle the event.
}
```

Последний пример похож на предыдущий. Здесь мы обрабатываем аппаратную кнопку камеры, но опять же только в коде, скомпилированном в пакет приложения для Windows Phone.

```csharp
#if WINDOWS_PHONE_APP
    Windows.Phone.UI.Input.HardwareButtons.CameraPressed += this.HardwareButtons_CameraPressed;
#endif // WINDOWS_PHONE_APP

...

#if WINDOWS_PHONE_APP
void HardwareButtons_CameraPressed(object sender, Windows.Phone.UI.Input.CameraEventArgs e)
{
    // Handle the event.
}
#endif // WINDOWS_PHONE_APP
```

В Windows 10 Кнопка аппаратная камера является концепцией, определенной для семейства мобильных устройств. Поскольку один пакет приложения будет работать на всех устройствах, мы изменим условие времени компиляции на условие времени выполнения, что называется адаптивным кодом. Для этого мы используем класс [**ApiInformation**](https://docs.microsoft.com/uwp/api/Windows.Foundation.Metadata.ApiInformation), чтобы запрашивать во время выполнения сведения о наличии класса [**HardwareButtons**](https://docs.microsoft.com/uwp/api/Windows.Phone.UI.Input.HardwareButtons). Класс **HardwareButtons** определен в мобильном SDK расширения, поэтому нам потребуется добавить ссылку на этот SDK в наш проект для компиляции кода. Обратите внимание, что обработчик будет выполнен только на устройстве, на котором реализованы типы, определенные в мобильном SDK расширения. Это семейство мобильных устройств. Этот код эквивалентен коду универсального приложения для версии 8.1 тем, что используются только существующие функции, хотя это реализовано по-другому.

```csharp
    // Note: Cache the value instead of querying it more than once.
    bool isHardwareButtonsAPIPresent = Windows.Foundation.Metadata.ApiInformation.IsTypePresent
        ("Windows.Phone.UI.Input.HardwareButtons");

    if (isHardwareButtonsAPIPresent)
    {
        Windows.Phone.UI.Input.HardwareButtons.CameraPressed +=
            this.HardwareButtons_CameraPressed;
    }

    ...

private void HardwareButtons_CameraPressed(object sender, Windows.Phone.UI.Input.CameraEventArgs e)
{
    // Handle the event.
}
```

См. также раздел [Определение платформы, на которой работает приложение](w8x-to-uwp-input-and-sensors.md).

## <a name="app-package-manifest"></a>Манифест пакета приложения

В разделе [что изменилось в Windows 10](https://docs.microsoft.com/uwp/schemas/appxpackage/uapmanifestschema/what-s-changed-in-windows-10) перечислены изменения в справочнике по схеме манифеста пакета для Windows 10, включая добавленные, удаленные и измененные элементы. Справочную информацию по всем элементам, атрибутам и типам в схеме см. в разделе [Иерархия элементов](https://docs.microsoft.com/uwp/schemas/appxpackage/uapmanifestschema/root-elements). Если вы переносите приложение Магазина Windows Phone или если ваше приложение представляет собой обновление для приложения из Магазина Windows Phone, убедитесь, что элемент **pm:PhoneIdentity** соответствует тому, что указано в манифесте вашего предыдущего приложения (используйте те же идентификаторы GUID, которые были назначены приложению Магазином). Это гарантирует, что пользователи вашего приложения, переходящие на Windows 10, получат ваше новое приложение в качестве обновления, а не в качестве второй его копии. Более подробные сведения см. в справочном разделе [**pm:PhoneIdentity**](https://docs.microsoft.com/uwp/schemas/appxpackage/uapmanifestschema/element-pm-phoneidentity).

Параметры в проекте (включая любые ссылки на пакеты SDK расширения) определяют контактную зону API, которую может вызвать ваше приложение. Но манифест пакета приложения — это инструмент, который определяет фактический набор устройств, на которые клиенты смогут устанавливать приложение из Магазина. Подробнее см. в примерах в разделе [**TargetDeviceFamily**](https://docs.microsoft.com/uwp/schemas/appxpackage/uapmanifestschema/element-targetdevicefamily).

Манифест пакета приложения можно редактировать, чтобы устанавливать различные объявления, возможности и другие параметры, необходимые для некоторых функций. Для его изменения можно использовать редактор манифеста пакета приложения в Visual Studio. Если **Solution Explorer** (Обозреватель решений) не отображается, выберите его в меню **View** (Вид). Дважды щелкните файл **Package.appxmanifest**. Откроется окно редактора манифестов. Выберите соответствующую вкладку, чтобы внести изменения, а затем сохраните.

Следующий раздел называется [Устранение неполадок](w8x-to-uwp-troubleshooting.md).

## <a name="related-topics"></a>Статьи по теме

* [Разработка приложений для универсальная платформа Windows](https://docs.microsoft.com/visualstudio/cross-platform/develop-apps-for-the-universal-windows-platform-uwp?view=vs-2015)
* [Быстрое использование приложения среда выполнения Windows 8. x с помощью шаблоновC#( C++,, Visual Basic)](https://docs.microsoft.com/previous-versions/windows/apps/hh768232(v=win.10))
* [Создание компонентов среда выполнения Windows](https://docs.microsoft.com/previous-versions/windows/apps/hh441572(v=vs.140))
* [Кросс-платформенная разработка с помощью переносимой библиотеки классов](https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library)

