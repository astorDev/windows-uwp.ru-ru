---
author: eliotcowley
Description: "Разрабатывайте свое приложение таким образом, чтобы оно хорошо выглядело и функционировало на телевизоре."
title: "Проектирование для Xbox и телевизора"
ms.assetid: 780209cb-3e8a-4cf7-8f80-8b8f449580bf
label: Designing for Xbox and TV
template: detail.hbs
isNew: True
keywords: "Xbox, телевизор, просмотр на большом расстоянии, геймпад, пульт дистанционного управления, ввод, взаимодействие"
ms.author: elcowle
ms.date: 02/08/2017
ms.topic: article
ms.prod: windows
ms.technology: uwp
ms.openlocfilehash: 572073c2c577f3f6833b9cbee303875e378d6030
ms.sourcegitcommit: 909d859a0f11981a8d1beac0da35f779786a6889
translationtype: HT
---
# <a name="designing-for-xbox-and-tv"></a>Проектирование для Xbox и телевизора

Разрабатывайте приложение для универсальной платформы Windows (UWP) таким образом, чтобы оно хорошо выглядело и функционировало на Xbox One и на экране телевизора.

## <a name="overview"></a>Обзор

Универсальная платформа Windows позволяет создавать отличные приложения для самых разных устройств с Windows 10. Большинство функциональных возможностей, предоставляемых платформой UWP, позволяет приложениям использовать один и тот же пользовательский интерфейс на всех устройствах без проведения дополнительной работы. Однако настройка и оптимизация приложения для работы на Xbox One и телевизионных экранах требуют особого подхода.

Взаимодействие с телевизором с дивана на другом конце комнаты с помощью игрового контроллера или пульта ДУ называется **взаимодействием на большом расстоянии**. Такое название связано прежде всего с тем, что пользователь, как правило, находится на большом (3 м) расстоянии от экрана. Оно представляет определенные трудности, которые отсутствуют при *взаимодействии на расстоянии 0,5 м* или при работе за компьютером. Этот фактор следует учитывать, если вы разрабатываете приложение для Xbox One или любого другого устройства, которое выводит изображение на телеэкран, а для ввода использует игровой контроллер.

Не все действия, описанные в этой статье, необходимы для обеспечения работоспособности приложения при просмотре на большом расстоянии. Однако понимание этих принципов и принятие соответствующих решений позволят обеспечить более удобную работу с приложением и принять во внимание его особые требования. Выпуская приложение, обеспечивающее просмотр на большом расстоянии, следует учитывать следующие принципы проектирования.

### <a name="simple"></a>Простота

Проектирование для обеспечения возможности просмотра на большом расстоянии таит в себе ряд определенных трудностей. Разрешение и расстояние просмотра может затруднить обработку большого объема информации. Чтобы обеспечить простоту дизайна, сведите его по возможности к самым простым компонентам. Количество информации, отображаемое на телеэкране, должно быть сравнимо с тем, что вы видите на мобильном телефоне, а не на рабочем столе компьютера.

![Главный экран Xbox One](images/designing-for-tv/xbox-home-screen.png)

### <a name="coherent"></a>Ясность

Приложения UWP, предназначенные для просмотра на большом расстоянии, должны быть интуитивно понятными и простыми в использовании. Необходимо четко обозначать фокус, чтобы его невозможно было перепутать ни с чем другим. Расположите содержимое таким образом, чтобы перемещение по пространству экрана было прогнозируемым и согласованным. Предоставьте пользователям самый короткий путь к необходимым им элементам.

![Приложение "Кино" для Xbox One](images/designing-for-tv/xbox-movies-app.png)

_**Все фильмы, приведенные на снимке экрана, доступны в программе "Кино и ТВ (Майкрософт)".**_  

### <a name="captivating"></a>Увлечение

Большой экран обеспечивает самый удобный просмотр фильмов с эффектом полного погружения. Полноэкранное изображение, плавные движение, яркие цвета, изысканное оформление выведут ваши приложения на качественно новый уровень. Ваши приложения должны заметными и красивыми.

![Приложение Avatar для Xbox One](images/designing-for-tv/xbox-avatar-app.png)

### <a name="optimizations-for-the-10-foot-experience"></a>Оптимизация для просмотра на большом расстоянии

Итак, теперь вы знаете о принципах качественного проектирования приложений UWP для просмотра на большом расстоянии. Ознакомьтесь со следующим обзором и узнайте, как оптимизировать приложение и обеспечить удобную работу пользователей.

| Возможность        | Описание           |
| -------------------------------------------------------------- |--------------------------------|
| [Геймпад и пульт дистанционного управления](#gamepad-and-remote-control)      | Чтобы оптимизировать просмотр на большом расстоянии, убедитесь, что ваше приложение надлежащим образом поддерживает геймпад и пульт ДУ. Имеется ряд улучшений, связанных с геймпадом и пультом ДУ, которые можно внести для оптимизации взаимодействия пользователя с устройством, на котором его возможности ограничены. |
| [Перемещение фокуса по оси X и Y и взаимодействие](#xy-focus-navigation-and-interaction) | Платформа UWP обеспечивает **навигацию с фокусом по осям X и Y**, которая позволяет пользователю осуществлять навигацию по пользовательскому интерфейсу приложения. Однако это позволяет пользователю перемещаться только вверх, вниз, влево или вправо. Рекомендации по выполнению этих и других требований приведены в этом разделе. |
| [Режим мыши](#mouse-mode)|В некоторых пользовательских интерфейсах, например картах или поверхностях для рисования, навигация с фокусом по осям X и Y невозможна или непрактична. Для этих интерфейсов UWP предоставляет **режим мыши**, который позволяет свободно использовать геймпад / пульт ДУ для навигации, аналогичной использованию мыши на настольном компьютере.|
| [Визуальный элемент фокуса](#focus-visual)  | Визуальный элемент фокуса — это граница вокруг элемента пользовательского интерфейса, который в настоящее время находится в фокусе. Он позволяет пользователю ориентироваться и без труда перемещаться по пользовательскому интерфейсу. Если фокус не виден, пользователь может запутаться в элементах пользовательского интерфейса и счесть его неудобным.  |
| [Включение фокуса](#focus-engagement) | Настройка включения фокуса на элементе пользовательского интерфейса требует нажатия кнопки **А/выбор**, чтобы пользователь смог взаимодействовать с ним. Это помогает повысить удобство взаимодействия пользователя при работе с пользовательским интерфейсом вашего приложения.
| [Размер элемента пользовательского интерфейса](#ui-element-sizing)  | Универсальная платформа Windows использует показатели [масштабирования и количества эффективных пикселей](..\layout\design-and-ui-intro.md#effective-pixels-and-scaling) для масштабирования пользовательского интерфейса в соответствии с расстоянием до экрана. Понимание принципов масштабирования и применение их ко всему пользовательскому интерфейсу поможет оптимизировать приложение для просмотра на большом расстоянии.  |
|  [Безопасная область телевизора](#tv-safe-area) | По умолчанию платформа UWP автоматически избегает отображения элементов пользовательского интерфейса в небезопасных областях телевизионного экрана (области вблизи границ экрана). Однако это создает эффект черных полей (эффект экранного каше) вокруг пользовательского интерфейса. Чтобы ваше приложение полностью заполняло экран телевизора, необходимо изменить его таким образом, чтобы оно доходило до краев экрана телевизора, если последний поддерживает такую возможность. |
| [Цвета](#colors)  |  Платформа UWP поддерживает цветовые темы, а в приложении, использующем системную тему, на Xbox One будет по умолчанию применена **темная** схема. Если ваше приложение имеет специальные цветовую тему, необходимо помнить, что определенные цвета не подходят для телевизора, поэтому их следует избегать. |
| [Звук](../style/sound.md)    | Звуки играют ключевую роль при просмотре ТВ на большом расстоянии, позволяя пользователю погрузиться в происходящее на экране и предоставляя обратную связь. UWP поддерживает возможность, которая автоматически включит звуки для стандартных элементов управления, когда приложение работает на Xbox One. Узнайте больше о поддержке звуков, встроенной в UWP, а также о том, как ими пользоваться.    |
| [Руководство по элементам управления пользовательского интерфейса](#guidelines-for-ui-controls)  |  Имеется несколько элементов управления пользовательского интерфейса, которые хорошо работают на разных устройствах, но обладают некоторыми особенностями при использовании вместе с телевизором. Ознакомьтесь с рекомендациями по использованию этих элементов управления при разработке приложений, взаимодействие с которыми будет выполняться на большом расстоянии. |
| [Пользовательский триггер визуального состояния для Xbox](#custom-visual-state-trigger-for-xbox) | Чтобы адаптировать приложение UWP для просмотра на большом расстоянии, рекомендуется использовать пользовательский *триггер визуального состояния* для изменения макета, если приложение определяет, что оно было запущено на консоли Xbox.

> [!NOTE]
> Большинство фрагментов кода в этом разделе написаны на XAML/C#, но принципы и концепции применимы ко всем приложениям UWP. Если вы разрабатываете приложение UWP на HTML/JavaScript для Xbox, ознакомьтесь с великолепной библиотекой [TVHelpers](https://github.com/Microsoft/TVHelpers/wiki) на GitHub.

## <a name="gamepad-and-remote-control"></a>Геймпад и пульт дистанционного управления

Так же, как клавиатура и мышь на компьютере и сенсорный экран на телефоне и планшете, геймпад и пульт ДУ являются основными устройствами ввода при взаимодействии на большом расстоянии. В этом разделе описаны аппаратные кнопки и их предназначение. В разделах [Перемещение фокуса по оси X и Y и взаимодействие](#xy-focus-navigation-and-interaction) и [Режим мыши](#mouse-mode) вы узнаете, как оптимизировать приложение для использования этих устройств ввода.

Качество работы геймпадов и пультов ДУ по умолчанию зависит от того, насколько хорошо ваше приложение поддерживает клавиатуру. Хороший способ реализовать оптимальную поддержку геймпада / пульта ДУ в приложении — обеспечить поддержку клавиатуры на ПК, а затем протестировать его с геймпадом и пультом ДУ и выявить слабые места пользовательского интерфейса.

### <a name="hardware-buttons"></a>Аппаратные кнопки

В этом документе будут использоваться имена кнопок, указанные на следующей схеме.

![Схема расположения кнопок на геймпаде и пульте ДУ](images/designing-for-tv/hardware-buttons-gamepad-remote.png)

Как видно на схеме, имеется ряд кнопок, которые поддерживаются на геймпаде и не поддерживаются на пульте ДУ и наоборот. Хотя для ускорения навигации и можно использовать кнопки, которые поддерживаются только одним устройством ввода, следует помнить, что их использование в критически важных случаях может привести к тому, что пользователь не сможет получить доступ к определенным частям пользовательского интерфейса.

В следующей таблице перечислены все аппаратные кнопки, поддерживаемые приложениями UWP, с указанием соответствующего устройства ввода.

| Кнопка                    | Геймпад   | Пульт ДУ    |
|---------------------------|-----------|-------------------|
| Кнопка A / выбор           | Да       | Да               |
| Кнопка B / назад             | Да       | Да               |
| Крестовина   | Да       | Да               |
| Кнопка меню               | Да       | Да               |
| Кнопка просмотра               | Да       | Да               |
| Кнопки X и Y           | Да       | Нет                |
| Левый джойстик                | Да       | Нет                |
| Правой джойстик               | Да       | Нет                |
| Левый и правый триггеры   | Да       | Нет                |
| Левый и правый бамперы    | Да       | Нет                |
| Кнопка OneGuide           | Нет        | Да               |
| Кнопка громкости             | Нет        | Да               |
| Кнопка канала            | Нет        | Да               |
| Кнопки управления мультимедиа     | Нет        | Да               |
| Кнопка выключения звука               | Нет        | Да               |

### <a name="built-in-button-support"></a>Встроенная поддержка кнопок

UWP автоматически сопоставляет существующее поведение при вводе с помощью клавиатуры с вводом с помощью геймпада и пульта ДУ. В следующей таблице представлены эти встроенные сопоставления.

| Клавиатура              | Геймпад / пульт ДУ                        |
|-----------------------|---------------------------------------|
| Клавиши со стрелками            | Крестовина (также левый джойстик на геймпаде)    |
| Пробел              | Кнопка A / выбор                       |
| Ввод                 | Кнопка A / выбор                       |
| Escape                | Кнопка B / назад*                        |

\* Если ни событие [KeyDown](https://msdn.microsoft.com/library/windows/apps/br208941.aspx), ни событие [KeyUp](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.keyup.aspx) кнопки "B" не обрабатываются приложением, запускается событие [SystemNavigationManager.BackRequested](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.systemnavigationmanager.backrequested.aspx), которое ведет к обратной навигации в приложении. Однако это необходимо реализовывать самостоятельно, как показано в следующем фрагменте кода.

```csharp
// This code goes in the MainPage class

public MainPage()
{
    this.InitializeComponent();

    // Handling Page Back navigation behaviors
    SystemNavigationManager.GetForCurrentView().BackRequested +=
        SystemNavigationManager_BackRequested;
}

private void SystemNavigationManager_BackRequested(
    object sender, 
    BackRequestedEventArgs e)
{
    if (!e.Handled)
    {
        e.Handled = this.BackRequested();
    }
}

public Frame AppFrame { get { return this.Frame; } }

private bool BackRequested()
{
    // Get a hold of the current frame so that we can inspect the app back stack
    if (this.AppFrame == null)
        return false;

    // Check to see if this is the top-most page on the app back stack
    if (this.AppFrame.CanGoBack)
    {
        // If not, set the event to handled and go back to the previous page in the
        // app.
        this.AppFrame.GoBack();
        return true;
    }
    return false;
}
```

Кроме того, контекстные меню в приложениях UWP на Xbox One можно открывать нажатием кнопки **Меню**. Дополнительные сведения см. в разделе [CommandBar и ContextFlyout](#commandbar-and-contextflyout).

### <a name="accelerator-support"></a>Поддержка горячих клавиш

Горячие клавиши — это те кнопки, которые можно использовать для повышения скорости навигации по пользовательскому интерфейсу. Однако эти кнопки могут быть уникальными для того или иного устройства ввода, поэтому следует помнить, что не все пользователи смогут воспользоваться этими функциями. Фактически геймпад в настоящее время является единственным устройством ввода, которое поддерживает функции ускорения для приложений UWP на устройстве Xbox One.

В следующей таблице указаны встроенные в UWP функции поддержки горячих клавиш, а также возможности, которые вы можете реализовать самостоятельно. Используйте эти возможности в своем пользовательском интерфейсе для обеспечения согласованной и удобной работы пользователей.

| Тип взаимодействия   | Клавиатура   | Геймпад      | Встроенная функция для  | Рекомендуется для |
|---------------|------------|--------------|----------------|------------------|
| Страница вверх/вниз  | Страница вверх/вниз | Левый и правый триггеры | [CalendarView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.calendarview.aspx), [ListBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listbox.aspx), [ListViewBase](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.aspx), [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx), `ScrollViewer`, [Selector](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.primitives.selector.aspx), [LoopingSelector](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.primitives.loopingselector.aspx), [ComboBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.combobox.aspx), [FlipView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.flipview.aspx) | Представления, поддерживающие вертикальную прокрутку
| Страница влево/вправо | Нет | Левый и правый бамперы | [Pivot](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.pivot.aspx), [ListBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listbox.aspx), [ListViewBase](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.aspx), [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx), `ScrollViewer`, [Selector](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.primitives.selector.aspx), [LoopingSelector](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.primitives.loopingselector.aspx), [FlipView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.flipview.aspx) | Представления, поддерживающие горизонтальную прокрутку
| Увеличение/уменьшение масштаба        | Ctrl +/- | Левый и правый триггеры | Нет | `ScrollViewer`, представления, поддерживающие увеличение и уменьшение масштаба |
| Открыть/закрыть панель навигации | Нет | Просмотр | Нет | Панели навигации |
| [Поиск](#search-experience) | Нет | Кнопка Y | Нет | Ярлык для функции основного поиска в приложении |

## <a name="xy-focus-navigation-and-interaction"></a>Перемещение фокуса по осям X и Y и взаимодействие

Если ваше приложение поддерживает корректное перемещение фокуса с помощью клавиатуры, оно будет поддерживать геймпад и пульт ДУ. Навигация с помощью клавиш со стрелками соответствует использованию **крестовины** (в том числе **левого мини-джойстика** на геймпаде), а взаимодействие с элементами управления пользовательского интерфейса — использованию клавиши **Ввод/Выбор** (см. раздел [Геймпад и пульт ДУ](#gamepad-and-remote-control)) 

Многие события и свойства используются как клавиатурой, так и геймпадом &mdash; оба устройства применяются для запуска событий `KeyDown` и `KeyUp`. Также оба устройства применяются для перехода только к тем элементам управления, которые обладают свойствами `IsTabStop="True"` и `Visibility="Visible"`. Руководство по проектированию управления с помощью клавиатуры см. в разделе [Взаимодействие с клавиатурой](keyboard-interactions.md).

Если поддержка клавиатуры реализована надлежащим образом, ваше приложение будет работать достаточно стабильно. Однако может понадобиться выполнить ряд дополнительных задач для поддержки всех сценариев. Подумайте об особых требованиях своего приложения, чтобы обеспечить максимально удобную работу пользователя.

> [!IMPORTANT]
> Для приложений UWP, запускаемых на Xbox One, режим мыши включен по умолчанию. Чтобы отключить режим мыши и включить перемещение фокуса по оси X и Y, задайте параметр `Application.RequiresPointerMode=WhenRequested`.

### <a name="debugging-focus-issues"></a>Отладка проблем с фокусировкой

Вызвав метод [FocusManager.GetFocusedElement](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.input.focusmanager.getfocusedelement.aspx), можно узнать, какой элемент в настоящий момент находится в фокусе. Этот метод полезно использовать, когда местоположение визуального элемента фокуса является неочевидным. Эти сведения можно регистрировать в окне вывода Visual Studio следующим образом:

```csharp
page.GotFocus += (object sender, RoutedEventArgs e) =>
{
    FrameworkElement focus = FocusManager.GetFocusedElement() as FrameworkElement;
    if (focus != null)
    {
        Debug.WriteLine("got focus: " + focus.Name + " (" + 
            focus.GetType().ToString() + ")");
    }
};
```

Есть три распространенных причины некорректной работы перемещения фокуса по оси X и Y.

* Неправильно задано свойство [IsTabStop](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.control.istabstop.aspx) или [Visibility](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.visibility.aspx).
* Фактический размер элемента управления с фокусом больше, чем вы думаете &mdash; перемещение фокуса по оси X и Y проверяет общий размер элемента управления (свойства [ActualWidth](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.frameworkelement.actualwidth.aspx) и [ActualHeight](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.frameworkelement.actualheight.aspx)), а не его часть, на которой отображается нечто заслуживающее внимания.
* Один фокусируемый элемент управления расположен поверх другого &mdash; перемещение фокуса по оси X и Y не поддерживает перекрывающиеся элементы управления.

Если перемещение фокуса по оси X и Y не стало работать ожидаемым образом после устранения этих проблем, можно вручную указать элемент для фокусировки путем вызова метода, описанного в разделе [Переопределение навигации по умолчанию](#overriding-the-default-navigation).

Если перемещение фокуса по оси X и Y работает правильно, но визуальный элемент фокуса не отображается, причиной этого может быть одна из следующих проблем.

* Шаблон элемента управления был изменен и в него не был добавлен визуальный элемент фокуса. Установите значение `UseSystemFocusVisuals="True"` или добавьте визуальный элемент фокуса вручную.
* Фокус был смещен путем вызова `Focus(FocusState.Pointer)`. Параметр [FocusState](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.focusstate.aspx) управляет тем, как изменяется визуальный элемент фокуса. Как правило, этому параметру следует задавать значение `FocusState.Programmatic`, что позволит отображаться визуальному элементу фокуса, если он отображался ранее, и оставаться скрытым, если он был до этого скрыт.

В оставшейся части этого раздела содержится описание распространенных проблем проектирования при использовании перемещения фокуса по оси X и Y, а также приведены некоторые способы их устранения.

### <a name="inaccessible-ui"></a>Недоступный пользовательский интерфейс

Поскольку перемещение фокуса по оси X и Y ограничивает пользователя направлениями "Вверх", "Вниз", "Влево" и "Вправо", могут возникнуть случаи, когда части пользовательского интерфейса останутся недоступными. На следующей схеме приведен пример компоновки пользовательского интерфейса, не поддерживающей перемещения фокуса по оси X и Y. Обратите внимание, что элемент посередине не доступен при использовании геймпада / пульта ДУ, так как приоритетной является вертикальная и горизонтальная навигация. Средний элемент никогда не получит достаточно высокого приоритета для получения фокуса.

![Элементы в четырех углах и недоступный элемент посередине](images/designing-for-tv/2d-navigation-best-practices-ui-layout-to-avoid.png)

Если по какой-либо причине изменение пользовательского интерфейса невозможно, воспользуйтесь одним из методов, которые обсуждаются в следующем разделе, чтобы переопределить поведение фокуса по умолчанию.

### <a name="overriding-the-default-navigation"></a>Переопределение навигации по умолчанию

Хотя универсальная платформа Windows стремится обеспечить удобство навигации пользователя с помощью крестовины / левого джойстика, невозможно гарантировать поведение, которое было бы оптимизировано под цели вашего приложения. Лучшим способом оптимизации навигации в приложении является его тестирование с использованием геймпада и проверка доступности каждого элемента пользовательского интерфейса с учетом различных сценариев использования приложения. Если в приложении необходимо реализовать поведение, которого невозможно добиться с помощью имеющихся возможностей перемещения фокуса по оси X и Y, ознакомьтесь с приведенными в следующем разделе рекомендациями, чтобы переопределить поведение и иметь возможность размещать фокус на логическом элементе.

В следующем фрагменте кода показано, как переопределить поведение при перемещении фокуса по оси X и Y по умолчанию.

```xml
<StackPanel>
    <Button x:Name="MyBtnLeft" 
            Content="Search" />
    <Button x:Name="MyBtnRight" 
            Content="Delete"/>
    <Button x:Name="MyBtnTop" 
            Content="Update" />
    <Button x:Name="MyBtnDown" 
            Content="Undo" />
    <Button Content="Home"  
            XYFocusLeft="{x:Bind MyBtnLeft}" 
            XYFocusRight="{x:Bind MyBtnRight}"
            XYFocusDown="{x:Bind MyBtnDown}"
            XYFocusUp="{x:Bind MyBtnTop}" />
</StackPanel>
```

В этом случае при переходе фокуса к кнопке `Home` и навигации пользователя влево, фокус перемещается к кнопке `MyBtnLeft`. Если пользователь переходит вправо, фокус перемещается к кнопке `MyBtnRight` и т. д.

Чтобы не допустить перемещения фокуса от элемента управления в определенном направлении, используйте свойство `XYFocus*` для указания на тот же самый элемент управления.

```xml
<Button Name="HomeButton"  
        Content="Home"  
        XYFocusLeft ="{x:Bind HomeButton}" />
```

С помощью свойств `XYFocus` родительский элемент управления может обеспечить принудительную навигацию дочерних элементов, когда следующий кандидат на получение фокуса оказывается за пределами его визуального дерева, если дочерний элемент, находящийся в фокусе, не использует то же самое свойство `XYFocus`.

```xml
<StackPanel Orientation="Horizontal" Margin="300,300">
    <UserControl XYFocusRight="{x:Bind ButtonThree}">
        <StackPanel>
            <Button Content="One"/>
            <Button Content="Two"/>
        </StackPanel>
    </UserControl>
    <StackPanel>
        <Button x:Name="ButtonThree" Content="Three"/>
        <Button Content="Four"/>
    </StackPanel>
</StackPanel> 
```

Если в примере выше фокус получает `Button` 2 и пользователь переходит вправо, следующим кандидатом на получение фокуса становится `Button` 4. Однако фокус перемещается на `Button` 3, поскольку родительский элемент `UserControl` обеспечивает его принудительный переход при выходе за пределы визуального дерева.

### <a name="path-of-least-clicks"></a>Путь с наименьшим количеством нажатий

Попробуйте свести к минимуму количество нажатий, необходимое для выполнения наиболее распространенных задач. В следующем примере [TextBlock](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.textblock.aspx) располагается между кнопкой **воспроизведения** (которая изначально имеет фокус) и часто используемым элементом, так что между приоритетными задачами размещается лишний элемент.

![Рекомендации по обеспечению пути навигации с наименьшим количеством нажатий](images/designing-for-tv/2d-navigation-best-practices-provide-path-with-least-clicks.png)

В следующем примере [TextBlock](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.textblock.aspx) расположен над кнопкой **воспроизведения**. Простая реорганизация пользовательского интерфейса, при которой ненужные элементы не размещаются между приоритетными задачами, значительно повысит удобство использования приложения.

![TextBlock находится над кнопкой воспроизведения и больше не располагается между приоритетными задачами](images/designing-for-tv/2d-navigation-best-practices-provide-path-with-least-clicks-2.png)

### <a name="commandbar-and-contextflyout"></a>CommandBar и ContextFlyout

При использовании [CommandBar](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.commandbar.aspx) следует помнить, что имеется проблема прокрутки списка, которая была упомянута в разделе [Проблема: элементы пользовательского интерфейса, размещенные после длинного списка/сетки](#problem-ui-elements-located-after-long-scrolling-list-grid). На следующем рисунке показан макет пользовательского интерфейса с `CommandBar` под списком/сеткой. Пользователю нужно полностью прокрутить список/сетку, чтобы достичь `CommandBar`.

![CommandBar под списком/сеткой](images/designing-for-tv/2d-navigation-best-practices-commandbar-and-contextflyout.png)

Что если поместить `CommandBar` *над* списком/сеткой? Хотя пользователю, который прокрутил список/сетку, понадобится прокрутить их обратно, чтобы достичь `CommandBar`, это потребует меньше усилий, чем в случае предыдущей конфигурации. Обратите внимание: предполагается, что исходный фокус приложения помещается рядом или над `CommandBar`. Этот подход не будет столь же удобен, если исходный фокус располагается под списком/сеткой. Если эти элементы `CommandBar` являются глобальными элементами действия, которые не нужно использовать слишком часто (например, кнопка **Синхронизировать**), их можно разместить над списком/сеткой.

Несмотря на то, что элементы `CommandBar` невозможно расположить вертикально, их размещение вдоль направления прокрутки (например, слева или справа от вертикально прокручиваемого списка или сверху или снизу от горизонтально прокручиваемого списка) является еще одним вариантом компоновки пользовательского интерфейса, который можно применять.

Если ваше приложение содержит объект `CommandBar`, элементы которого должны быть доступны пользователям, возможно, их стоит разместить внутри [ContextFlyout](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.contextflyout.aspx) и удалить их из `CommandBar`. `ContextFlyout` является свойством объекта [UIElement](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.aspx), а также представляет собой [контекстное меню](../controls-and-patterns/dialogs-popups-menus.md), связанное с этим элементом. При работе на компьютере щелчком правой кнопкой мыши на элементе со свойством `ContextFlyout` выводится соответствующее ему контекстное меню. При работе на Xbox One это происходит при нажатии кнопки **Меню**, когда фокус находится на таком элементе.

<!--The following XAML code demonstrates a simple `ContextFlyout`:

```xml
<Button HorizontalAlignment="Center"
        Content="Context Flyout">
    <Button.ContextFlyout>
        <MenuFlyout>
            <MenuFlyoutItem Text="Item 1"/>
        </MenuFlyout>
    </Button.ContextFlyout>
</Button>
```

In the above example, when you press the **Menu** button while the [Button](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.button.aspx) has focus, the context menu appears with the menu item labeled **Item 1**.

`ContextFlyout` takes any element of type [FlyoutBase](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.primitives.flyoutbase.aspx); however, most of the time you will likely use [Flyout](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.flyout.aspx) or [MenuFlyout](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.menuflyout.aspx).

Alternatively, you can listen for the [ContextRequested](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.contextrequested.aspx) event, which occurs when the user has completed a context input gesture (pressing the **Menu** button). In this case you can, in the code-behind, create the context menu, attach it to the **UIElement**, and show the flyout when the event is raised.

The following C# code demonstrates a simple example of this:

```csharp
MenuFlyout myFlyout = new MenuFlyout();
MenuFlyoutItem item1 = new MenuFlyoutItem();
item1.Text = "Item 1";
myFlyout.Items.Add(item1);
MyButton.ContextFlyout = myFlyout;

private void MyButton_ContextRequested(UIElement sender, ContextRequestedEventArgs args)
{
    Point point = new Point(0, 0);
    if (args.TryGetPosition(sender, out point)
    {
        myFlyout.ShowAt(sender, point);
    }
    else
    {
        myFlyout.ShowAt(sender as FrameworkElement);
    }
}
```
> **Note** Don't use both of these options, as `ContextFlyout` already handles the `ContextRequested` event.-->

### <a name="ui-layout-challenges"></a>Проблемы компоновки пользовательского интерфейса

Использовать некоторые макеты пользовательского интерфейса сложнее вследствие особенностей перемещения фокуса по оси X и Y, поэтому их применение следует оценивать в зависимости от ситуации. Несмотря на отсутствие единственного правильного способа, решение зависит от вас и особых нужд вашего приложения. Однако существует ряд методов, которые можно использовать для упрощения работы с телевизором.

Чтобы лучше понять эти методы, рассмотрим вымышленное приложение, которое продемонстрирует ряд проблем и методов их решения.

> [!NOTE]
> Это вымышленное приложение служит для демонстрации проблем, связанных с пользовательским интерфейсом, и возможных способов их решения и не предназначено для демонстрации возможностей упрощения работы пользователей в каком-либо приложении.

Ниже приведено вымышленное приложение для покупки недвижимости, которое показывает список доступных для продажи домов с картой, описанием объекта и прочими данными. В этом приложении имеется три проблемы, которые можно устранить с помощью следующих методов:

- [изменение макета пользовательского интерфейса;](#ui-rearrange)
- [включение фокуса;](#engagement)
- [режим мыши.](#mouse-mode)

![Вымышленное приложение для покупки недвижимости](images/designing-for-tv/2d-focus-navigation-and-interaction-real-estate-app.png)

#### Проблема: элементы пользовательского интерфейса, размещенные после длинного списка/сетки <a name="problem-ui-elements-located-after-long-scrolling-list-grid"></a>

Объект [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx), приведенный на следующем рисунке, является очень длинным списком прокрутки. Если [включение](#focus-engagement) *не* является обязательным для `ListView`, то при переходе пользователя к списку фокус переводится на первый элемент списка. Чтобы пользователь перешел к кнопке **Назад** или **Далее**, ему необходимо перебрать все элементы в списке. В таких случаях, когда пользователю необходимо перебирать все элементы списка (список недостаточно короткий) и когда пользовательский интерфейс становится неудобным, возможно, следует использовать другие варианты.

![Приложение для покупки недвижимости: чтобы добраться до кнопок под списком из 50элементов, необходимо 51нажатие](images/designing-for-tv/2d-focus-navigation-and-interaction-real-estate-app-list.png)

#### <a name="solutions"></a>Решения

**Изменение макета пользовательского интерфейса <a name="ui-rearrange"></a>**

Если исходный фокус не находится в нижней части страницы, элементы пользовательского интерфейса, размещенные над длинным списком прокрутки, станут более доступны, если поместить их под списком. Если новый макет подходит для других устройств, изменение компоновки для всех семейств устройств вместо внесения специальных изменений в пользовательский интерфейс только для Xbox One может стать менее затратным решением. Кроме того, размещение элементов пользовательского интерфейса поперек направления прокрутки (то есть горизонтально относительно вертикального списка прокрутки или вертикально относительно горизонтального списка прокрутки) обеспечит более удобный к ним доступ.

![Приложение для покупки недвижимости: размещение кнопок над длинным списком прокрутки](images/designing-for-tv/2d-focus-navigation-and-interaction-ui-rearrange.png)

**Включение фокуса <a name="engagement"></a>**

Если включение является *обязательным*, весь при фокусировке выделяется весь объект `ListView`. Пользователь сможет перейти к следующему доступному для фокусировки элементу, не переходя к содержимому списка. Дополнительные сведения о том, какие элементы управления поддерживают включение и как их использовать см. в разделе [Включение фокуса](#focus-engagement).

![Приложение для покупки недвижимости: обязательное включение, позволяющее перейти к кнопкам "Назад"/"Далее" с помощью одного нажатия](images/designing-for-tv/2d-focus-navigation-and-interaction-engagement.png)

#### <a name="problem-scrollviewer-without-any-focusable-elements"></a>Проблема: ScrollViewer без доступных для фокусировки элементов

Поскольку перемещение фокуса по оси X и Y основано на переходе к одному доступному для фокусировки элементу за раз, объект [ScrollViewer](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.scrollviewer.aspx), который не содержит каких-либо доступных элементов (например, объект только с текстом, как в этом примере), может привести к тому, что пользователь не сможет просмотреть все содержимое `ScrollViewer`. Решения для этого и других похожих сценариев приведены в разделе [Включение фокуса](#focus-engagement).

![Приложение для покупки недвижимости: ScrollViewer только с текстом](images/designing-for-tv/2d-focus-navigation-and-interaction-scrollviewer.png)

#### <a name="problem-free-scrolling-ui"></a>Проблема: пользовательский интерфейс со свободной прокруткой

Если приложение требует свободной прокрутки пользовательского интерфейса, например в случае поверхности рисования или, как в этом примере, карты, перемещение фокуса по оси X и Y попросту не работает. В этих случаях можно включить [режим мыши](#mouse-mode), чтобы разрешить пользователю свободно перемещаться внутри элемента пользовательского интерфейса.

![Сопоставление элемента пользовательского интерфейса с использованием режима мыши](images/designing-for-tv/map-mouse-mode.png)

## <a name="mouse-mode"></a>Режим мыши

Как описано в разделе [Перемещение фокуса по оси X и Y и взаимодействие](#xy-focus-navigation-and-interaction), на Xbox One фокус перемещается по оси X и Y, позволяя пользователю переходить от одного элемента управления к другому в обоих направлениях по вертикали и горизонтали. Однако некоторые элементы управления, такие как [WebView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webview.aspx) и [MapControl](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapcontrol.aspx), требуют взаимодействия, аналогичного работе с мышью, когда пользователи могут свободно перемещать указатель внутри границ элемента управления. Имеются также приложения, в которых пользователю было бы разумно иметь возможность перемещать указатель по всей странице с помощью геймпада / пульта ДУ, как при работе с мышью на ПК.

В этих сценариях следует обеспечить работу указателя (режим мыши) на всей странице или в границах элемента управления. Например, ваше приложение может содержать страницу с элементом управления `WebView`, который использует режим мыши только внутри этого элемента и перемещение фокуса по оси X и Y во всех остальных областях экрана. Чтобы запросить указатель, следует определить, когда его требуется использовать: **при взаимодействии с элементом управления или страницей** либо **при перемещении фокуса на страницу**.

> [!NOTE] 
> Запрос указателя при получении элементом управления фокуса не поддерживается.

При выполнении приложений XAML и размещенных веб-приложений на Xbox One режим мыши включается по умолчанию для всего приложения. Настоятельно рекомендуется отключать режим мыши и оптимизировать приложение для работы с перемещением фокуса по оси X и Y. Для этого свойству `Application.RequiresPointerMode` необходимо задать значение `WhenRequested`, чтобы режим мыши активировался только при его вызове элементом управления или страницей.

Чтобы реализовать это в приложении XAML, используйте в классе `App` следующий фрагмент кода. 

```csharp
public App() 
{
    this.InitializeComponent();
    this.RequiresPointerMode = 
        Windows.UI.Xaml.ApplicationRequiresPointerMode.WhenRequested;
    this.Suspending += OnSuspending;
}
```

Дополнительные сведения, в том числе пример кода для HTML/JavaScript, см. в разделе [Отключение режима мыши](../xbox-apps/how-to-disable-mouse-mode.md).

На следующей схеме показаны сопоставления кнопок для геймпада/пульта ДУ в режиме мыши.

![Сопоставления кнопок для геймпада/пульта ДУ в режиме мыши](images/designing-for-tv/mouse-mode.png)

> [!NOTE]
> Режим мыши поддерживается только на консоли Xbox One с геймпадом/пультом ДУ. В случае других семейств устройств и типов ввода он игнорируется без отображения каких-либо сообщений.

Используйте свойство `RequiresPointer`, чтобы включить режим мыши для элемента управления или страницы. `RequiresPointer` поддерживает три значения: `Never` (значение по умолчанию), `WhenEngaged` и `WhenFocused`.

> [!NOTE]
> `RequiresPointer` — это новый, еще не задокументированный API. 

<!--TODO: Link to doc-->

### <a name="activating-mouse-mode-on-a-control"></a>Активация режима мыши для элемента управления

Если пользователь взаимодействует с элементом управления с помощью `RequiresPointer="WhenEngaged"`, режим мыши остается активным на протяжении периода взаимодействия. В следующем фрагменте кода показан простой объект `MapControl`, который активирует режим мыши при начале взаимодействия.

```xml
<Page>
    <Grid>
        <MapControl IsEngagementRequired="true" 
                    RequiresPointer="WhenEngaged"/>
    </Grid>
</Page> 
```

> [!NOTE]
> Если элемент управления активирует режим мыши при начале взаимодействия, он также должен требовать выполнения условия `IsEngagementRequired="true"`. В противном случае режим мыши активирован не будет.

Если элемент управления работает в режиме мыши, вложенные элементы управления также будут работать в режиме мыши. Запрошенный режим дочерних объектов будет игнорироваться&mdash;так как ситуация, когда родительский объект находится в режиме мыши, а дочерние объекты работают в другом режиме, невозможна.

Кроме того, запрошенный режим элемента управления проверяется только при получении фокуса, поэтому если элемент уже имеет фокус, режим не меняется динамически.

### <a name="activating-mouse-mode-on-a-page"></a>Активация режима мыши на странице

Если на странице имеется свойство `RequiresPointer="WhenFocused"`, режим мыши будет активирован для всей страницы при получении ею фокуса. В следующем фрагменте кода показано предоставление странице этого свойства.

```xml
<Page RequiresPointer="WhenFocused">
    ...
</Page> 
```

> [!NOTE]
> Значение `WhenFocused` поддерживается только для объектов [Page](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.page.aspx). Если попытаться задать это значение для элемента управления, возникнет исключение.

### <a name="disabling-mouse-mode-for-full-screen-content"></a>Отключение режима мыши для полноэкранного содержимого

Обычно при отображении видео или других типов содержимого в полноэкранном режиме следует скрыть курсор, потому что он может отвлекать пользователя. Этот сценарий применяется, когда приложение использует режим мыши в остальных случаях, но когда необходимо скрыть указатель при отображении полноэкранного содержимого. Для этого полноэкранное содержимое нужно поместить на собственную страницу `Page` и выполнить следующие действия.

1. В объекте `App` установите параметр `RequiresPointerMode="WhenRequested"`.
2. Для каждого объекта `Page`, *за исключением* объекта `Page` для полноэкранного режима, установите параметр `RequiresPointer="WhenFocused"`.
3. Для объекта `Page` для полноэкранного режима установите параметр `RequiresPointer="Never"`.

Таким образом курсор не будет отображаться при отображении полноэкранного содержимого.

## <a name="focus-visual"></a>Визуальный элемент фокуса

Визуальный элемент фокуса — это граница вокруг элемента пользовательского интерфейса, который в настоящее время находится в фокусе. Он позволяет пользователю ориентироваться и без труда перемещаться по пользовательскому интерфейсу.

Благодаря обновлению визуального элемента и различным параметрам его настройки разработчики могут быть уверены, что один и тот же визуальный элемент фокуса будет корректно работать на компьютерах и устройствах Xbox One, а также на любых других устройствах с Windows 10, которые поддерживают клавиатуру и геймпад / пульт ДУ.

Хотя один и тот же визуальный элемент фокуса можно использовать на различных платформах, контекст его использования при просмотре на большом расстоянии несколько отличается. Предполагается, что пользователь не уделяет особого внимания всей площади экрана телевизора, поэтому важно, что текущий выделенный элемент всегда был отчетливо виден. Это позволит избавить пользователя от долгих поисков элемента.

Важно помнить, что визуальный элемент фокуса по умолчанию отображается при использовании геймпада или пульта ДУ, но *не* клавиатуры. Поэтому даже если вы не реализовали его, он будет отображаться при запуске приложения на Xbox One.

### <a name="initial-focus-visual-placement"></a>Исходное положение визуального элемента фокуса

При запуске приложения или перехода к странице поместите фокус на элементе пользовательского интерфейса, который воспринимается как первый элемент, с которым пользователь может выполнить какие-либо действия. Например, в приложении для обработки фотографий фокус можно поместить на первом элементе галереи, а при переходе к подробному представлению композиции в музыкальном приложении — на кнопке воспроизведения. Это позволит упростить воспроизведение музыки.

Попробуйте разместить исходный фокус в левом верхнем углу приложения (или в правом верхнем углу при направлении движения справа налево). Большинство пользователей смотрят сначала в этот угол, так как именно отсюда начинается перемещение по содержимому приложения.

### <a name="making-focus-clearly-visible"></a>Четкое выделение фокуса

Визуальный элемент фокуса всегда должен быть виден на экране, чтобы пользователь без лишних поисков мог продолжить работу с того места, на котором он остановился. Аналогичным образом, элемент, отображаемый на экране, всегда должен быть доступен для фокусировки &mdash; поэтому, например, не следует использовать всплывающие окна, содержащие только текст и не содержащие элементов, которым можно передать фокус.

Исключением из этого правила является взаимодействие пользователя с интерфейсом в полноэкранном режиме, например просмотр видеозаписей или изображений, когда отображение визуального элемента фокуса является неуместным.

### <a name="customizing-the-focus-visual"></a>Настройка визуального элемента фокуса

Если требуется настроить визуальный элемент фокуса, это можно сделать путем изменения свойств, связанных с визуальным элементом фокуса каждого элемента управления. Есть несколько подобных свойств, которые можно использовать для персонализации приложения.

Вы даже можете отказаться от использования системных визуальных элементов фокуса, нарисовав собственные, используя для этого визуальные состояния. Дополнительные сведения см. в разделе [VisualState](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstate.Aspx).

### <a name="light-dismiss-overlay"></a>Наложение с исчезновением

Чтобы привлечь внимание пользователя к элементам интерфейса, с которыми он работает в настоящее время, используя игровой контроллер или пульт ДУ, при запуске приложения на Xbox One платформа UWP автоматически добавляет "дымку", закрывающую области вне интерфейса всплывающего окна. Для этого не требуется какой-либо дополнительной работы, однако об этом стоит помнить при проектировании пользовательского интерфейса. Чтобы включить или отключить слой дымки, можно задать свойство `LightDismissOverlayMode` для любого объекта `FlyoutBase`. Значением по умолчанию этого свойства является `Auto`. Это значит, что оно активировано на Xbox и отключено в других местах. Дополнительные сведения см. в разделе [Модальность и исчезновение](../controls-and-patterns/menus.md).

## <a name="focus-engagement"></a>Включение фокуса

Включение фокуса призвано упростить использование геймпада или пульта ДУ при взаимодействии с приложением. 

> [!NOTE]
> Настройка включения фокуса не влияет на работу клавиатуры и другие устройства ввода.

Если свойство `IsFocusEngagementEnabled` в объекте [FrameworkElement](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.frameworkelement.aspx) имеет значение `True`, элемент управления помечается как требующий включения фокуса. Это означает, что пользователь должен нажать кнопку **A/выбор**, чтобы включить элемент управления и начать с ним взаимодействовать. После завершения работы можно нажать кнопку **B/Назад**, чтобы отключить элемент управления и перейти к другому.

> [!NOTE]
> `IsFocusEngagementEnabled` — это новый, еще не задокументированный API.

### <a name="focus-trapping"></a>Захват фокуса

Захват фокуса происходит, когда пользователь пытается выполнить переход между элементами интерфейса приложения, но "застревает" на одном из них. При этом перемещение за пределы этого элемента затруднено или невозможно.

В следующем примере показан пользовательский интерфейс, создающий захват фокуса.

![Кнопки слева и справа от горизонтального ползунка](images/designing-for-tv/focus-engagement-focus-trapping.png)

Если пользователь хочет перейти от левой кнопки к правой, логично предположить, что для этого нужно только дважды нажать "Вправо" на крестовине или два раза передвинуть левый джойстик. Однако если ползунок [Slider](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.slider.aspx) не требует включения, произойдет следующее: если пользователь нажмет "Вправо" в первый раз, фокус сместится на `Slider`, а повторное нажатие приведет к перемещению указателя ползунка `Slider`. Пользователь продолжит перемещать маркер вправо и не сможет достичь кнопки.

Данную проблему можно обойти двумя способами. Первый — это создание другого макета, аналогичного примеру приложения для покупки недвижимости в разделе [Перемещение фокуса по оси X и Y и взаимодействие](#xy-focus-navigation-and-interaction), где мы переместили кнопки **Назад** и **Далее** над объектом `ListView`. Размещение элементов управления вертикально, а не горизонтально, как показано на следующем изображении, позволит решить эту проблему.

![Кнопки над и под горизонтальным ползунком](images/designing-for-tv/focus-engagement-focus-trapping-2.png)

Теперь пользователь может переходить к каждому элементу управления, нажимая "Вверх" и "Вниз" на крестовине или левом джойстике. При переходе фокуса к объекту `Slider`, можно нажать "Влево" и "Вправо" для перемещения маркера `Slider` в необходимое положение.

Другой подход к решению этой проблемы — обязательное включение объекта `Slider`. Если задать значение `IsFocusEngagementEnabled="True"`, это приведет к следующему.

![Обязательное включение фокуса на ползунке, которое позволит пользователю перейти к кнопке справа](images/designing-for-tv/focus-engagement-slider.png)

Если объект `Slider` требует включения фокуса, пользователь может перейти к кнопке справа, просто нажав дважды "Вправо" на крестовине / левом джойстике. Это замечательное решение, поскольку оно не требует настройки пользовательского интерфейса и приводит к ожидаемому результату.

### <a name="items-controls"></a>Элементы управления

Помимо элемента управления [Slider](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.slider.aspx), существуют другие элементы управления, для которых может потребоваться включения фокуса, например:

- [ListBox;](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listbox.aspx)
- [ListView;](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx)
- [GridView;](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx)
- [FlipView.](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.flipview)

В отличие от элемента управления `Slider`, они не захватывают фокус. Однако если они содержат большой объем данных, эти элементы управления могут привести к проблемам, связанным с удобством использования. Ниже приведен пример элемента `ListView`, содержащего большой объем данных.

![ListView с большим объемом данных, а также кнопки, расположенные над и под ним](images/designing-for-tv/focus-engagement-list-and-grid-controls.png)

Как и в примере с элементом `Slider`, давайте попытаемся перейти от кнопки сверху к кнопке снизу, используя геймпад / пульт ДУ. Фокус находится на верхней кнопке. Нажатие "Вниз" на крестовине или джойстике приведет к перемещению фокуса на первый элемент в `ListView` (Элемент 1). Когда пользователь снова нажмет "Вниз", фокус перейдет к следующему элементу в списке, а не к кнопке снизу. Чтобы перейти к кнопке, пользователь должен сначала перебрать все элементы в `ListView`. Если `ListView` содержит большой объем данных, это может оказаться очень неудобным, что создаст у пользователя плохое впечатление о приложении.

Чтобы устранить эту проблему, установите значение свойства `IsFocusEngagementEnabled="True"` объекта `ListView`. Это позволит сделать включение элемента обязательным. Это позволит пользователю быстро пропустить `ListView` простым нажатием кнопки "Вниз". Однако, пользователь не сможет прокрутить список или выбрать его элемент, не включив список с помощью кнопки **A/выбор** при получении им фокуса с последующим его отключением с помощью кнопки **B/назад**.

![ListView с обязательным включением](images/designing-for-tv/focus-engagement-list-and-grid-controls-2.png)

#### <a name="scrollviewer"></a>ScrollViewer

От этих элементов управления несколько отличается объект [ScrollViewer](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.scrollviewer.aspx). Он так же имеет собственные особенности, которые необходимо учитывать. Если у вас есть `ScrollViewer` с доступным для фокусировки содержимым, по умолчанию переход к `ScrollViewer` приведет к перемещению между его элементами. Как и в случае с `ListView`, необходимо перебрать все элементы `ScrollViewer`, чтобы выйти из этого элемента. 

Если `ScrollViewer` *не* имеет содержимого, доступного для фокусировки&mdash; например, содержит только текст&mdash; можно установить значение `IsFocusEngagementEnabled="True"`, чтобы пользователь мог включить объект `ScrollViewer` с помощью кнопки **A/выбор**. После включения элемента пользователь может прокрутить текст с помощью **крестовины / левого джойстика** и нажать кнопку **B/назад**, чтобы отключить фокус элемента.

Другой способ— установить значение `IsTabStop="True"` для `ScrollViewer`. В результате пользователю не придется включать элемент управления&mdash; а только перевести на него фокус и прокрутить с помощью **крестовины/левого джойстика**, если `ScrollViewer` не содержит элементов, доступных для фокусировки.

### <a name="focus-engagement-defaults"></a>Значения по умолчанию для включения фокуса

Некоторые элементы управления достаточно часто захватывают фокус, поэтому настройки по умолчанию должны требовать их обязательного включения. Для других элементов управления включение фокуса не является обязательным по умолчанию, однако оно может принести определенные преимущества. В следующей таблице перечислены эти элементы управления и их поведение по умолчанию при включении фокуса.

| Элемент управления               | Включение фокуса по умолчанию  |
|-----------------------|---------------------------|
| CalendarDatePicker    | Включено                        |
| FlipView              | Отключено                       |
| GridView              | Отключено                       |
| ListBox               | Отключено                       |
| ListView              | Отключено                       |
| ScrollViewer          | Отключено                       |
| SemanticZoom          | Отключено                       |
| Ползунок                | Включено                        |

Для всех прочих элементов управления UWP условие `IsFocusEngagementEnabled="True"` не меняет их поведения или визуального отображения.

## <a name="ui-element-sizing"></a>Размер элемента пользовательского интерфейса

Так как при просмотре на большом расстоянии пользователь использует пульт ДУ или геймпад и находится в нескольких метрах от экрана, имеется ряд факторов, связанных с интерфейсом, которые необходимо учесть при проектировании. Убедитесь, что пользовательский интерфейс имеет необходимую плотность содержимого, а также что он не перегружен и позволяет пользователю без труда перемещаться и выбирать нужные элементы. Помните: простота — это ключевой фактор.

### <a name="scale-factor-and-adaptive-layout"></a>Коэффициент масштабирования и адаптивный макет

**Коэффициент масштабирования** обеспечивает отображение правильного размера элементов пользовательского интерфейса на том устройстве, на котором работает приложение. На компьютере этот параметр регулируется с помощью ползунка и находится в следующем расположении: **Параметры > Система > Экран**. Этот же параметр используется и на телефоне, если устройство поддерживает его.

![Изменение размера текста, приложений и прочих элементов](images/designing-for-tv/ui-scaling.png) 

На Xbox One такого системного параметра нет, но для правильного отображения размера элементов пользовательского интерфейса UWP на телевизоре по умолчанию используется масштаб **200%** для приложений XAML и **150%** для приложений HTML. Если элементы пользовательского интерфейса имеют правильные размеры на других устройствах, они будут правильно отображаться и на экране телевизора. Xbox One отображает приложение в разрешении 1080p (1920 x 1080 пикселей). Поэтому при переносе приложения с других устройств, например компьютеров, убедитесь, что пользовательский интерфейс хорошо выглядит при разрешении 960 x 540 пикселей в масштабе 100% (или 1280 x 720 пикселей в масштабе 100% для приложений HTML), воспользовавшись [специальными возможностями](../layout/screen-sizes-and-breakpoints-for-responsive-design.md).

Проектирование для Xbox несколько отличается от проектирования для компьютера, так как необходимо работать только с одним разрешением — 1920 x 1080. Неважно, если разрешение телевизора выше&mdash;приложения UWP всегда будут масштабироваться до 1080p.

Правильные размеры ресурсов при значении 200% (или 150% для приложений HTML) также будут использоваться для вашего приложения при работе на Xbox One независимо от разрешения телевизора.

### <a name="content-density"></a>Плотность содержимого

При проектировании приложения помните, что пользователь будет смотреть на пользовательский интерфейс с некоторого расстояния и взаимодействовать с ним с помощью пульта ДУ или геймпада, навигация с помощью которых занимает больше времени, чем навигация с помощью мыши или сенсорного экрана.

#### <a name="sizes-of-ui-controls"></a>Размеры элементов управления пользовательского интерфейса

Интерактивные элементы пользовательского интерфейса должны иметь минимальную высоту 32 эффективных пикселя. Это значение по умолчанию для основных элементов управления UWP. При использовании масштаба 200 % оно обеспечивает видимость элементов пользовательского интерфейса с расстояния и позволяет снизить плотность содержимого. 

![Кнопка UWP в масштабе 100 % и 200 %](images/designing-for-tv/button-100-200.png)

#### <a name="number-of-clicks"></a>Количество нажатий

Для упрощения пользовательского интерфейса переход от одного края экрана телевизора до другого должен осуществляться за **шесть нажатий**. Помните, что здесь применим принцип **простоты**. Дополнительные сведения см. в разделе [Путь с наименьшим количеством нажатий](#path-of-least-clicks).

![6 значков поперек экрана](images/designing-for-tv/six-clicks.png)

### <a name="text-sizes"></a>Размеры шрифта

Чтобы пользовательский интерфейс был виден с расстояния, следуйте простым правилам, приведенным ниже.

* Основной текст и содержимое, предназначенное для чтения: как минимум 15 эффективных пикселей
* Второстепенный текст и вспомогательное содержимое: как минимум 12 эффективных пикселей

При использовании более крупного текста в пользовательском интерфейсе выберите размер, который не слишком ограничивает эффективную область экрана, и не занимает место, которое можно заполнить другим содержимым.

### <a name="opting-out-of-scale-factor"></a>Отказ от коэффициента масштабирования

Мы рекомендуем, чтобы ваше приложение поддерживало коэффициент масштабирования. Это позволит ему работать и корректно отображаться на всех устройствах. Однако можно отказаться от такого поведение и разработать весь пользовательский интерфейс в масштабе 100 %. Обратите внимание, что вы не можете изменить коэффициент масштабирования на значение, отличное от 100%.

В случае с приложениями XAML вы можете отказаться от коэффициента масштабирования, воспользовавшись следующим фрагментом кода.

```csharp
bool result = 
    Windows.UI.ViewManagement.ApplicationViewScaling.TrySetDisableLayoutScaling(true);
```

`result` сообщит вам о том, что вы успешно отказались от этой функции.

Дополнительные сведения, в том числе пример кода для HTML/JavaScript, см. в разделе [Отключение масштабирования](../xbox-apps/disable-scaling.md).

Обязательно рассчитайте подходящие размеры элементов пользовательского интерфейса, удвоив значения в *эффективных* пикселях, упомянутые в этом разделе, до значений в *фактических* пикселях (или умножив на 1,5 для приложений HTML).

## <a name="tv-safe-area"></a>Безопасная область телевизора

В силу исторических, а также технических обстоятельств, не все телевизоры поддерживают отображение на всем экране. По умолчанию платформа UWP не отображает содержимое пользовательского интерфейса в небезопасных областях телеэкрана, заполняя его только фоновым изображением страницы.

Небезопасная область телевизионного экрана обозначена на следующим изображением синим цветом.

![Небезопасная область телевизионного экрана](images/designing-for-tv/tv-unsafe-area.png)

Вы можете установить в качестве фонового изображения статический цвет, цвет темы или изображение, как показано в следующих фрагментах кода.

### <a name="theme-color"></a>Цвета темы

```xml
<Page x:Class="Sample.MainPage"
      Background="{ThemeResource ApplicationPageBackgroundThemeBrush}"/>
```

### <a name="image"></a>Изображение

```xml
<Page x:Class="Sample.MainPage"
      Background="\Assets\Background.png"/>
```

Вот как будет выглядеть ваше приложение без дополнительной работы.

![Безопасная область телевизора](images/designing-for-tv/tv-safe-area.png)

Это не самый оптимальный вариант, поскольку он приводит к появлению эффекта черных полей в приложении, где части пользовательского интерфейса, например панель навигации и сетка, выглядят обрезанными. Однако с помощью оптимизации можно расширить некоторые части пользовательского интерфейса до краев экрана, чтобы создать более кинематографическое представление.

### <a name="drawing-ui-to-the-edge"></a>Отрисовка пользовательского интерфейса до краев

Мы рекомендуем использовать определенные элементы пользовательского интерфейса для расширения до краев экрана. Это усилит эффект погружения. Сюда входят средства прокрутки [ScrollViewer](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.scrollviewer.aspx), [навигационные панели](../controls-and-patterns/nav-pane.md) и панели команд [CommandBar](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.commandbar.aspx).

С другой стороны, также важно, чтобы интерактивные элементы и текст никогда не доходили до краев экрана. Это позволит избежать их обрезки на некоторых телевизорах. Мы рекомендуем использовать в 5 % области вдоль краев экрана только некритичное визуальное оформление. Как уже упоминалось в разделе [Размер элементов пользовательского интерфейса](#ui-element-sizing), приложение UWP использующее коэффициент масштабирования Xbox One по умолчанию (200 %), будет использовать область 960 x 540 эффективных пикселей. Поэтому следует избегать размещения критически важных элементов пользовательского интерфейса в следующих областях:

- 27 эффективных пикселей от верхнего и нижнего краев;
- 48 эффективных пикселей от левого и правого краев.

В следующих разделах приведены инструкции по расширению пользовательского интерфейса до краев экрана.

#### <a name="core-window-bounds"></a>Границы основного окна

Для приложений UWP, ориентированных только на взаимодействие на большом расстоянии, использование границ основного окна является самым простым подходом.

В методе `OnLaunched` для `App.xaml.cs` добавьте следующий код.

```csharp
Windows.UI.ViewManagement.ApplicationView.GetForCurrentView().SetDesiredBoundsMode
    (Windows.UI.ViewManagement.ApplicationViewBoundsMode.UseCoreWindow);
```

Благодаря этой строке кода окно приложения будет расширено до границ экрана, поэтому вам придется переместить все интерактивные и важные элементы пользовательского интерфейса в безопасную область телеэкрана, которая была описана выше. Прозрачный пользовательский интерфейс, например контекстные меню, открытые поля со списком [ComboBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.combobox.aspx), автоматически будут оставаться в пределах безопасной области телевизионного экрана.

![Границы основного окна](images/designing-for-tv/core-window-bounds.png)

#### <a name="pane-backgrounds"></a>Фоновые изображения панелей 

Как правило, панели навигации помещаются вдоль границ экрана, поэтому фоновое изображение должно выходить за границы безопасной области. Это позволит избежать появления странных пропусков. Это можно сделать путем простого изменения цвета фона панели навигации на цвет фона приложения.

Использование границ основного окна, как описано выше, позволяет отрисовывать пользовательский интерфейс до краев экрана, однако после этого следует использовать положительные поля для содержимого [SplitView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.splitview.aspx), чтобы оно оставалось в безопасной области телевизионного экрана.

![Панель навигации, расширенная до краев экрана](images/designing-for-tv/tv-safe-areas-2.png)

Здесь фон панели навигации расширен до краев экрана, а элементы навигации находятся в пределах безопасной области телевизионного экрана. Содержимое `SplitView` (в данном случае сетка элементов) было расширено до нижней части экрана, поэтому оно отображается непрерывно, тогда как верхняя часть сетки все еще находится в пределах безопасной области телевизионного экрана. (Подробнее о том, как это сделать см. в разделе [Прокрутка концов списков и сеток](#scrolling-ends-of-lists-and-grids)).

Следующий фрагмент кода позволяет достичь этого эффекта.

```xml
<SplitView x:Name="RootSplitView"
           Margin="48,0,48,0">
    <SplitView.Pane>
        <ListView x:Name="NavMenuList"
                  ContainerContentChanging="NavMenuItemContainerContentChanging"
                  ItemContainerStyle="{StaticResource NavMenuItemContainerStyle}"
                  ItemTemplate="{StaticResource NavMenuItemTemplate}"
                  ItemInvoked="NavMenuList_ItemInvoked"
                  ItemsSource="{Binding NavMenuListItems}"/>
    </SplitView.Pane>
    <Frame x:Name="frame"
           Navigating="OnNavigatingToPage"
           Navigated="OnNavigatedToPage"/>
</SplitView>
```

[CommandBar](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.commandbar.aspx) — еще один пример панели, которая, как правило, располагается рядом с одним или несколькими краями приложения, поэтому на телеэкране фон этой панели должен достигать краев экрана. Кроме того, здесь, как правило, имеется кнопка **Дополнительно** в виде многоточия (...), на правой стороне экрана, которая должна оставаться в безопасной области. Ниже приведены несколько различных способов, позволяющих добиться нужного взаимодействия и визуальных эффектов.

**Вариант 1**. Сделайте фоновый цвет `CommandBar` прозрачным, или замените его на цвет, идентичный фоновому цвету страницы.

```xml
<CommandBar x:Name="topbar" 
            Background="{ThemeResource SystemControlBackgroundAltHighBrush}">
            ...
</CommandBar>
```

Этот приведет к тому, что визуально `CommandBar` будет располагаться на том же фоне, что и вся остальная страница. Таким образом фон будет непрерывно простираться до края экрана.

**Вариант 2**. Добавьте фоновый прямоугольник, заполненный тем же цветом, что и фон `CommandBar`, так, чтобы он размещался под `CommandBar` и на остальной части страницы.

```xml
<Rectangle VerticalAlignment="Top" 
            HorizontalAlignment="Stretch"      
            Fill="{ThemeResource SystemControlBackgroundChromeMediumBrush}"/>
<CommandBar x:Name="topbar" 
            VerticalAlignment="Top" 
            HorizontalContentAlignment="Stretch">
            ...
</CommandBar>
```

> [!NOTE]
> При использовании такого подхода следует помнить, что кнопка **Дополнительно** меняет при необходимости высоту открытого элемента `CommandBar`, позволяя отобразить подписи `AppBarButton` под соответствующими значками. Рекомендуется переместить подписи *вправо* от соответствующих значков во избежание такого изменения размеров. Дополнительные сведения см. в разделе [Подписи CommandBar](#commandbar-labels).

Оба этих подхода можно также применять к другим типам элементов управления, перечисленным в этом разделе.

#### <a name="scrolling-ends-of-lists-and-grids"></a>Прокрутка концов списков и сеток

Как правило, списки и сетки содержат больше элементов, чем одновременно может уместиться на экране. В этом случае рекомендуется расширить список или сетку до края экрана. Горизонтально прокручиваемые списки и сетки должны доходить до правого края, а вертикально прокручиваемые списки и сетки — до нижнего края экрана.

![Обрезка сетки по безопасной области телевизионного экрана](images/designing-for-tv/tv-safe-area-grid-cutoff.png)

Если список или сетка простираются подобным образом, важно обеспечить положение визуального фокуса и соответствующего элемента в пределах безопасной области телевизионного экрана.

![Фокус прокручиваемой сетки должен оставаться в пределах безопасной области экрана](images/designing-for-tv/scrolling-grid-focus.png)

Функциональные возможности платформы UWP позволяют удерживать визуальный элемент фокуса внутри видимых границ [VisibleBounds](https://msdn.microsoft.com/library/windows/apps/windows.ui.viewmanagement.applicationview.visiblebounds.aspx), однако необходимо увеличить расстояние до края, чтобы элементы списка/сетки можно было прокручивать в безопасной области. В частности, следует добавить положительное поле для [ItemsPresenter](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.itemspresenter.aspx) объектов [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx) или [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx), как показано в следующем фрагменте кода.

```xml
<Style x:Key="TitleSafeListViewStyle" 
       TargetType="ListView">
    <Setter Property="Template">
        <Setter.Value>
            <ControlTemplate TargetType="ListView">
                <Border BorderBrush="{TemplateBinding BorderBrush}" 
                        Background="{TemplateBinding Background}" 
                        BorderThickness="{TemplateBinding BorderThickness}">
                    <ScrollViewer x:Name="ScrollViewer"
                                  TabNavigation="{TemplateBinding TabNavigation}"
                                  HorizontalScrollMode="{TemplateBinding ScrollViewer.HorizontalScrollMode}"
                                  HorizontalScrollBarVisibility="{TemplateBinding ScrollViewer.HorizontalScrollBarVisibility}"
                                  IsHorizontalScrollChainingEnabled="{TemplateBinding ScrollViewer.IsHorizontalScrollChainingEnabled}"
                                  VerticalScrollMode="{TemplateBinding ScrollViewer.VerticalScrollMode}"
                                  VerticalScrollBarVisibility="{TemplateBinding ScrollViewer.VerticalScrollBarVisibility}"
                                  IsVerticalScrollChainingEnabled="{TemplateBinding ScrollViewer.IsVerticalScrollChainingEnabled}"
                                  IsHorizontalRailEnabled="{TemplateBinding ScrollViewer.IsHorizontalRailEnabled}"
                                  IsVerticalRailEnabled="{TemplateBinding ScrollViewer.IsVerticalRailEnabled}"
                                  ZoomMode="{TemplateBinding ScrollViewer.ZoomMode}"
                                  IsDeferredScrollingEnabled="{TemplateBinding ScrollViewer.IsDeferredScrollingEnabled}"
                                  BringIntoViewOnFocusChange="{TemplateBinding ScrollViewer.BringIntoViewOnFocusChange}"
                                  AutomationProperties.AccessibilityView="Raw">
                        <ItemsPresenter Header="{TemplateBinding Header}"
                                        HeaderTemplate="{TemplateBinding HeaderTemplate}"
                                        HeaderTransitions="{TemplateBinding HeaderTransitions}"
                                        Footer="{TemplateBinding Footer}"
                                        FooterTemplate="{TemplateBinding FooterTemplate}"
                                        FooterTransitions="{TemplateBinding FooterTransitions}"
                                        Padding="{TemplateBinding Padding}" 
                                        Margin="0,27,0,27"/>
                    </ScrollViewer>
                </Border>
            </ControlTemplate>
        </Setter.Value>
    </Setter>
</Style>
```

Предыдущий фрагмент кода следует разместить в ресурсах страницы или приложения, а затем получать к нему доступ следующим образом.

```xml
<Page>
    <Grid>
        <ListView Style="{StaticResource TitleSafeListViewStyle}"
                  ... />
```

> [!NOTE]
> Этот фрагмент кода предназначен специально для стиля `ListView`. Для стиля `GridView` задайте атрибут [TargetType](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.controltemplate.targettype.aspx) для [ControlTemplate](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.controltemplate.aspx) и [Style](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.style.aspx) равным `GridView`.

## <a name="colors"></a>Цвета

По умолчанию универсальная платформа Windows не изменяет цвета приложения. При этом имеется ряд улучшений, которые можно внести в набор цветов, используемый вашим приложением, которые позволят улучшить его отображение на экране телевизора.

### <a name="application-theme"></a>Тема приложения

Вы можете выбрать **тему приложения** (темную или светлую) в соответствии со стилем приложения или вообще отказаться от темы. Дополнительные сведения об общих рекомендациях по темам см. в разделе [Цветовые темы](../style/color.md).

Платформа UWP также позволяет приложениям динамически задавать тему на основе параметров системы, предоставляемых устройствами, на которых они работают. Несмотря на то, что платформа UWP всегда придерживается параметров темы, указанных пользователем, каждое устройство также предоставляет соответствующую тему по умолчанию. Вследствие особенностей устройства Xbox One, которое ориентировано больше на работу с *мультимедиа*, чем с *офисными документами*, по умолчанию используется темная системная тема. Если тема приложения основана на системных параметров, будьте готовы, что на Xbox One будет использоваться темная цветовая схема.

### <a name="accent-color"></a>Цвет элементов

Платформа UWP предоставляет удобный способ отображения **цвета элементов**, выбранного пользователем в системных параметрах.

На Xbox One можно выбрать пользовательский цвет, так же, как на компьютере можно выбрать цвет элементов. Если ваше приложение вызывает эти цвета элементов с помощью кистей или цветовых ресурсов, будет использоваться цвет, выбранный пользователем в параметрах системы. Обратите внимание, что цвета элементов на устройстве Xbox One применяются на уровне пользователя, а не всей системы.

Кроме того, следует обратить внимание на то, что набор пользовательских цветов на устройстве Xbox One отличается от цветов на ПК, телефонах и других устройствах. Частично это связано с тем, что данные цвета выбираются вручную для оптимизации просмотра на Xbox One на большом расстоянии с использованием тех же методов и стратегий, которые объясняются в этой статье.

Пока в вашем приложении используется ресурс кисти, например **SystemControlForegroundAccentBrush**, или ресурс цвета (**SystemAccentColor**), или же если цвета элементов вызываются напрямую через API [UIColorType.Accent*](https://msdn.microsoft.com/library/windows/apps/windows.ui.viewmanagement.uicolortype.aspx), эти цвета заменяются на цвета элементов, подходящие для телевизора. Цвета кистей высокой контрастности также берутся из системы, как на ПК и телефоне, однако при этом используются подходящие для телевизора цвета.

Дополнительные сведения о цветах элементов в целом, см. в разделе [Цвет элементов](../style/color.md#accent-color).

### <a name="color-variance-among-tvs"></a>Различие цветов на разных телевизорах

При проектировании приложений для телевизора следует помнить, что цвета по-разному отображаются на различных телевизорах. Не следует предполагать, что цвета будут выглядеть точно так же, как на вашем мониторе. Если для вашего приложения критичны незначительные отличия в цветах для обозначения частей пользовательского интерфейса, то следует помнить что цвета могут сливаться. Это может ввести пользователей в заблуждение. Попробуйте использовать цвета, которые достаточно различимы, чтобы пользователи могли четко их разделять независимо от используемого телевизора.

### <a name="tv-safe-colors"></a>Безопасные цвета для использования на телевизионных экранах

Цветовые значения RGB обозначают интенсивность красного, зеленого и синего цветов. Телевизоры не могут надлежащим образом отображать предельные значения интенсивности, поэтому следует избегать использования этих цветов при проектировании для просмотра на большом расстоянии. На некоторых экранах может возникнуть странный эффект чередования цветов, или же цвета могут выглядеть размытыми. Кроме того, цвета с высокой интенсивностью могут привести к помутнению (соседние пиксели начинают отрисовываться одним цветом). 

Существуют различные мнения о том, что считать безопасными для телевизионных экранов цветами, однако цвета в пределах значений RGB от 16 до 235 (или от 10 до EB в шестнадцатеричной системе) обычно можно использовать для телеэкранов.

![Диапазон безопасных цветов для телевизионных экранов](images/designing-for-tv/tv-safe-colors.png)

### <a name="fixing-tv-unsafe-colors"></a>Исправление цветов, не безопасных для телеэкранов

Индивидуальное исправление цветов, не безопасных для телевизионных экранов, с помощью регулировки значений RGB до безопасного диапазона, обычно называется **закреплением цветов**. Этот метод может подойти для приложения, которое не использует богатую цветовую палитру. Тем не менее, подобное закрепление цветов может стать причиной цветовых конфликтов, которые приведут к ухудшению взаимодействия на большом расстоянии.

Чтобы оптимизировать цветовую палитру для телевизора, мы рекомендуем использовать **масштабирование**, после того как с помощью закрепления цветов, ориентированного на их оптимизацию, вы убедитесь в их безопасности.

Сюда входит масштабирование всех значений RGB используемых цветов с применением определенного коэффициента для вывода их в диапазон, безопасный для телевизора. Масштабирование всех цветов приложения позволяет предотвратить конфликты и улучшает просмотр на большом расстоянии.

![Закрепление и масштабирование](images/designing-for-tv/clamping-vs-scaling.png)

### <a name="assets"></a>Ресурсы

При изменении цветов убедитесь, что ресурсы также обновляются соответствующим образом. Если приложение использует цвет в XAML, который должен выглядеть так же, как цвет ресурса, однако вы обновили только код XAML, ваши ресурсы будут иметь ненадлежащие цвета.

### <a name="uwp-color-sample"></a>Пример цвета UWP

[Цветовые темы UWP](../style/color.md) разработаны на основе фона приложения, который может быть или **черным** для темной темы, или **белым** для светлой темы. Так как ни черный, ни белый не являются безопасными для телевизионного экрана цветами, их необходимо исправить с помощью *закрепления*. После их исправления все остальные цвета необходимо скорректировать с помощью *масштабирования* для сохранения необходимой контрастности.

<!--[v-lcap to eliot]why is the above paragraph in the past tense?-->
<!--[elcowle] Because this is something that Microsoft had to do to the UWP color themes to accommodate TV-safe colors for Xbox. These themes are then provided in the below code sample.-->

В следующем фрагменте кода представлена цветовая тема, которая была оптимизирована для использования на телевизоре.

```xml
<Application.Resources>
    <ResourceDictionary>
        <ResourceDictionary.ThemeDictionaries>
            <ResourceDictionary x:Key="Default">
                <SolidColorBrush x:Key="ApplicationPageBackgroundThemeBrush" 
                                 Color="#FF101010"/>
                <Color x:Key="SystemAltHighColor">#FF101010</Color>
                <Color x:Key="SystemAltLowColor">#33101010</Color>
                <Color x:Key="SystemAltMediumColor">#99101010</Color>
                <Color x:Key="SystemAltMediumHighColor">#CC101010</Color>
                <Color x:Key="SystemAltMediumLowColor">#66101010</Color>
                <Color x:Key="SystemBaseHighColor">#FFEBEBEB</Color>
                <Color x:Key="SystemBaseLowColor">#33EBEBEB</Color>
                <Color x:Key="SystemBaseMediumColor">#99EBEBEB</Color>
                <Color x:Key="SystemBaseMediumHighColor">#CCEBEBEB</Color>
                <Color x:Key="SystemBaseMediumLowColor">#66EBEBEB</Color>
                <Color x:Key="SystemChromeAltLowColor">#FFDDDDDD</Color>
                <Color x:Key="SystemChromeBlackHighColor">#FF101010</Color>
                <Color x:Key="SystemChromeBlackLowColor">#33101010</Color>
                <Color x:Key="SystemChromeBlackMediumLowColor">#66101010</Color>
                <Color x:Key="SystemChromeBlackMediumColor">#CC101010</Color>
                <Color x:Key="SystemChromeDisabledHighColor">#FF333333</Color>
                <Color x:Key="SystemChromeDisabledLowColor">#FF858585</Color>
                <Color x:Key="SystemChromeHighColor">#FF767676</Color>
                <Color x:Key="SystemChromeLowColor">#FF1F1F1F</Color>
                <Color x:Key="SystemChromeMediumColor">#FF262626</Color>
                <Color x:Key="SystemChromeMediumLowColor">#FF2B2B2B</Color>
                <Color x:Key="SystemChromeWhiteColor">#FFEBEBEB</Color>
                <Color x:Key="SystemListLowColor">#19EBEBEB</Color>
                <Color x:Key="SystemListMediumColor">#33EBEBEB</Color>
            </ResourceDictionary>
            <ResourceDictionary x:Key="Light">
                <SolidColorBrush x:Key="ApplicationPageBackgroundThemeBrush" 
                                 Color="#FFEBEBEB" /> 
                <Color x:Key="SystemAltHighColor">#FFEBEBEB</Color>
                <Color x:Key="SystemAltLowColor">#33EBEBEB</Color>
                <Color x:Key="SystemAltMediumColor">#99EBEBEB</Color>
                <Color x:Key="SystemAltMediumHighColor">#CCEBEBEB</Color>
                <Color x:Key="SystemAltMediumLowColor">#66EBEBEB</Color>
                <Color x:Key="SystemBaseHighColor">#FF101010</Color>
                <Color x:Key="SystemBaseLowColor">#33101010</Color>
                <Color x:Key="SystemBaseMediumColor">#99101010</Color>
                <Color x:Key="SystemBaseMediumHighColor">#CC101010</Color>
                <Color x:Key="SystemBaseMediumLowColor">#66101010</Color>
                <Color x:Key="SystemChromeAltLowColor">#FF1F1F1F</Color>
                <Color x:Key="SystemChromeBlackHighColor">#FF101010</Color>
                <Color x:Key="SystemChromeBlackLowColor">#33101010</Color>
                <Color x:Key="SystemChromeBlackMediumLowColor">#66101010</Color>
                <Color x:Key="SystemChromeBlackMediumColor">#CC101010</Color>
                <Color x:Key="SystemChromeDisabledHighColor">#FFCCCCCC</Color>
                <Color x:Key="SystemChromeDisabledLowColor">#FF7A7A7A</Color>
                <Color x:Key="SystemChromeHighColor">#FFB2B2B2</Color>
                <Color x:Key="SystemChromeLowColor">#FFDDDDDD</Color>
                <Color x:Key="SystemChromeMediumColor">#FFCCCCCC</Color>
                <Color x:Key="SystemChromeMediumLowColor">#FFDDDDDD</Color>
                <Color x:Key="SystemChromeWhiteColor">#FFEBEBEB</Color>
                <Color x:Key="SystemListLowColor">#19101010</Color>
                <Color x:Key="SystemListMediumColor">#33101010</Color>
            </ResourceDictionary> 
        </ResourceDictionary.ThemeDictionaries>
    </ResourceDictionary>
</Application.Resources>
```

> [!NOTE]
> Цвета светлых тем **SystemChromeMediumLowColor** и **SystemChromeMediumLowColor** специально являются одинаковыми, а не представляют собой результат закрепления. 

> [!NOTE]
> Шестнадцатеричные значения цветов указываются в формате **ARGB** (альфа, красный, зеленый, синий).

Не рекомендуется использовать безопасные для телеэкрана цвета на мониторе, способном отображать полный диапазон без закрепления, так как цвета будут выглядеть размытыми. Вместо этого загрузите словарь ресурсов (предыдущий пример), если приложение работает на устройстве Xbox, но *не* на других платформах. В методе `OnLaunched` для `App.xaml.cs` добавьте следующую проверку.

```csharp
if (IsTenFoot)
{ 
    this.Resources.MergedDictionaries.Add(new ResourceDictionary 
    { 
        Source = new Uri("ms-appx:///TenFootStylesheet.xaml") 
    }); 
}
```

> [!NOTE] 
> Определение переменной `IsTenFoot` выполняется в [пользовательском триггере визуального состояния для Xbox](#custom-visual-state-trigger-for-xbox).

Это обеспечит корректное отображение цветов на всех устройствах и повысит качество, а также эстетическую привлекательность пользовательского интерфейса.

## <a name="guidelines-for-ui-controls"></a>Руководство по элементам управления пользовательского интерфейса

Имеется несколько элементов управления пользовательского интерфейса, которые хорошо работают на разных устройствах, но обладают некоторыми особенностями при использовании вместе с телевизором. Ознакомьтесь с рекомендациями по использованию этих элементов управления при разработке приложений, взаимодействие с которыми будет выполняться на большом расстоянии.

### <a name="pivot-control"></a>Элемент управления Pivot

Элемент управления [Pivot](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.pivot.aspx) обеспечивает возможность быстрого перемещения между представлениями в приложении путем выбора различных заголовков и вкладок. Элемент управления подчеркивает все заголовки с фокусом, что позволяет проще понять, какой заголовок в данный момент выбран при использовании геймпада/пульта ДУ. 

![Подчеркивание с помощью сводки](images/designing-for-tv/pivot-underline.png)

<!--By default, when you navigate to a `Pivot`, one of the [PivotItem](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.pivotitem.aspx)s will get focus. However, you can show focus around all the headers by setting `Pivot.HeaderFocusVisualPlacement="ItemHeaders"`.

![Pivot focus around headers](images/designing-for-tv/pivot-headers-focus.png)-->

Вы можете задать свойству [Pivot.IsHeaderItemsCarouselEnabled](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.pivot.isheaderitemscarouselenabled.aspx) значение `true`, чтобы сводки всегда находились в одном положении, вместо того чтобы заголовок выбранной сводки перемещался на первое место. Это особенно удобно в случае больших экранов, например экранов телевизоров, так как перенос заголовков может отвлекать пользователей. Если все заголовки сводок не помещаются на экране, клиенты смогут просматривать другие заголовки с помощью полосы прокрутки. Но для максимального удобства взаимодействия вам следует убедиться, что они все помещаются на экране. Дополнительные сведения см. в разделе [Вкладки и сводки](../controls-and-patterns/tabs-pivot.md).

<!--If you find it necessary to wrap headers, you can set it so that it doesn't show the selected header in the left-most position, like it does by default. When you set `Pivot.IsHeaderItemsCarouselEnabled="False"`, the selected header will move left by the minimal amount required to become fully visible. This is the recommended approach for 10-foot design.

![Pivot headers carousel disabled](images/designing-for-tv/pivot-headers-carousel.png)-->

### <a name="navigation-pane"></a>Панель навигации

Панель навигации (также называемая *кнопка-гамбургер*) представляет собой элемент управления навигацией, часто используемый в приложениях UWP. Как правило, это панель с несколькими вариантами выбора в меню в виде списка, использующегося для перенаправления пользователя на различные страницы. Обычно эта панель отображается в свернутом состоянии для экономии пространства и пользователь может открыть ее, нажав соответствующую кнопку. 

В то время как с навигационными панелями очень удобно взаимодействовать с помощью мыши и сенсорного ввода, работа с ними с помощью геймпада/пульта ДУ несколько затруднена, так как пользователю приходится перемещать указатель к кнопке, чтобы открыть панель. Поэтому для открытия навигационной панели рекомендуется программировать кнопку **Просмотр**, а также реализовывать возможность ее открытия путем перемещения указателя устройства ввода в левую часть страницы. Так пользователь сможет без труда получать доступ к содержимому панели. Дополнительные сведения о том, как ведут себя навигационные панели на экранах различных размеров, а также рекомендации по навигации с помощью геймпада/пульта ДУ см. в разделе [Панели навигации](../controls-and-patterns/nav-pane.md).

### <a name="commandbar-labels"></a>Подписи CommandBar

Подписи полезно размещать справа от значков на панели [CommandBar](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.commandbar.aspx) для уменьшения ее высоты и сохранения согласованности ее структуры. Это можно сделать, задав свойству [CommandBar.DefaultLabelPosition](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.commandbar.defaultlabelposition.aspx) значение `CommandBarDefaultLabelPosition.Right`.

![Панель CommandBar с подписями, расположенными справа от значков](images/designing-for-tv/commandbar.png)

Также, когда это свойство задано, подписи будут отображаться постоянно, что хорошо подходит для взаимодействия с экраном на большом расстоянии, так как пользователю приходится делать меньше щелчков для выполнения необходимой операции. Эту модель также можно успешно реализовать и на других типах устройств.

<!--When there isn't enough space in the window to fit all of the `AppBarButton`s, buttons move into an overflow menu, which is accessed by selecting the "..." button. This happens dynamically as the screen resizes. This generally shouldn't be a problem for TV because the screen size is so large, but if you find that you have overflow buttons, you can specify which appear first using the `AppBarButton.DynamicOverflowOrder` property.

![CommandBar with overflow commands](images/designing-for-tv/commandbar-overflow.png)-->

### <a name="tooltip"></a>Всплывающая подсказка

Элемент управления [Tooltip](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.tooltip.aspx) предоставляет дополнительные сведения об элементе пользовательского интерфейса при наведении на него указателя мыши или при его нажатии и удержании. При использовании геймпада и пульта ДУ элемент `Tooltip` отображается после получения элементом фокуса, остается на экране в течение краткого времени, а затем исчезает. Это поведение может отвлекать, если используется слишком много элементов `Tooltip`. Пытайтесь избегать использования `Tooltip` при проектировании приложений для телевизора.

### <a name="button-styles"></a>Стили кнопок

Несмотря на то, что стандартные кнопки UWP хорошо подходят для телевизоров, некоторые визуальные стили кнопок привлекают больше внимания к пользовательскому интерфейсу. Поэтому, возможно, их следовало бы использовать на всех платформах, особенно на устройствах, рассчитанных на просмотр на большом расстоянии, для которых четкое указание фокуса особенно удобно. Дополнительные сведения об этих стилях см. в разделе [Кнопки](../controls-and-patterns/buttons.md).

### <a name="nested-ui-elements"></a>Вложенные элементы пользовательского интерфейса

Вложенные элементы пользовательского интерфейса предоставляет вложенные активные элементы, заключенные в контейнерном элементе пользовательского интерфейса. При этом вложенный элемент и контейнер могут принимать фокус независимо друг от друга.

Вложенные элементы пользовательского интерфейса подходят для некоторых методов ввода, но не всегда удобны при использовании геймпада и пульта ДУ, где фокус перемещается по осям X и Y. Следуйте рекомендациям в этой статье, чтобы оптимизировать ваш пользовательский интерфейс для просмотра на большом расстоянии и обеспечить пользователю удобство доступа ко всем активным элементам. Одно из распространенных решений заключается в размещении вложенных элементов пользовательского интерфейса в `ContextFlyout` (см. раздел [CommandBar и ContextFlyout](#commandbar-and-contextflyout)).

Подробнее о вложенных элементах пользовательского интерфейса см. в разделе [Вложенные элементы пользовательского интерфейса в элементах списка](../controls-and-patterns/nested-ui.md).

### <a name="mediatransportcontrols"></a>MediaTransportControls

Элемент [MediaTransportControls](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediatransportcontrols.aspx) позволяет пользователям работать с файлами мультимедиа, предоставляя им стандартные возможности взаимодействия, к которым относится воспроизведение, приостановка, включение скрытых субтитров и многое другое. Этот элемент управления является свойством [MediaPlayerElement](https://msdn.microsoft.com/library/windows/apps/Windows.UI.Xaml.Controls.MediaPlayerElement.aspx) и поддерживает 2 варианта макета: *однострочный* и *двухстрочный*. В однострочном макете, ползунок и все кнопки воспроизведения располагаются в ряд, при этом кнопка воспроизведения и паузы находится слева от ползунка. В двухстрочном макете ползунок занимает отдельную строку, а кнопки воспроизведения находятся под ним. При проектировании для взаимодействия на большом расстоянии необходимо использовать двухстрочный макет, поскольку он больше подходит для навигации с помощью геймпада. Чтобы реализовать двухстрочный макет, установите параметр `IsCompact="False"` элемента `MediaTransportControls` в свойстве [TransportControls](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.transportcontrols.aspx) элемента управления `MediaPlayerElement`.

```xml
<MediaPlayerElement x:Name="mediaPlayerElement1"  
                    Source="Assets/video.mp4" 
                    AreTransportControlsEnabled="True">
    <MediaPlayerElement.TransportControls>
        <MediaTransportControls IsCompact="False"/>
    </MediaPlayerElement.TransportControls>
</MediaPlayerElement>
```  

Дополнительные сведения о добавлении мультимедиа в приложение см. в разделе [Воспроизведение мультимедиа](../controls-and-patterns/media-playback.md).

> ![ПРИМЕЧАНИЕ] Элемент `MediaPlayerElement` доступен только в Windows 10 версии 1607 и более поздних. При разработке приложения для более ранней версии Windows 10 нужно использовать [MediaElement](https://msdn.microsoft.com/library/windows/apps/br242926). Приведенные выше рекомендации применяются также к `MediaElement`. Доступ к свойству `TransportControls` осуществляется таким же образом.

### <a name="search-experience"></a>Параметры поиска

Поиск содержимого является одной из наиболее часто используемых на большом расстоянии функций. Если ваше приложение поддерживает возможности поиска, полезно предоставлять пользователю быстрый доступ к этой функции с использованием кнопки **Y** на геймпаде для ускоренного перехода к ней.

Большинство пользователей, скорее всего, уже знают об этой возможности быстрого перехода, но при желании вы можете добавить иконку **Y** в пользовательский интерфейс, чтобы указать, что пользователи могут нажимать эту кнопку для доступа к функции поиска. При добавлении этой подсказки следует использовать символ из шрифта **Segoe Xbox MDL2 Symbol** (`&#xE3CC;` для приложений XAML, `\E426` для приложений HTML) для обеспечения единообразия оболочки Xbox и других приложений.

> [!NOTE]
> Так как шрифт **Segoe Xbox MDL2 Symbol** доступен только на Xbox, этот символ будет неправильно отображаться на компьютере. Но после развертывания на Xbox он будет отображаться на телевизоре.

Поскольку кнопка **Y** доступна только на геймпаде, не забудьте предоставить другие методы доступа к функции поиска, например кнопки в пользовательском интерфейсе. Иначе некоторые пользователи не смогут получать доступ к этой функции.

При работе на большом расстоянии пользователям зачастую удобнее работать с полноэкранным интерфейсом поиска из-за ограниченного места на экране. Независимо от того, применяете ли вы полноэкранную или занимающую часть экрана функцию поиска, рекомендуется сразу же открывать экранную клавиатуру, когда пользователь обращается к поиску, чтобы она была доступна для ввода поисковых запросов.

## <a name="custom-visual-state-trigger-for-xbox"></a>Пользовательский триггер визуального состояния для Xbox

Чтобы адаптировать приложение UWP для просмотра на большом расстоянии, рекомендуется изменять макет, если приложение определяет, что оно было запущено на консоли Xbox. Например, это можно сделать с помощью пользовательского *триггера визуального состояния*. Триггеры визуального состояния полезнее всего использовать при выполнении редактирования в **Blend для Visual Studio**. В следующем фрагменте кода показано, как создать триггер визуального состояния для Xbox.

```xml
<VisualStateManager.VisualStateGroups>
    <VisualStateGroup>
        <VisualState>
            <VisualState.StateTriggers>
                <triggers:DeviceFamilyTrigger DeviceFamily="Windows.Xbox"/>
            </VisualState.StateTriggers>
            <VisualState.Setters>
                <Setter Target="RootSplitView.OpenPaneLength" 
                        Value="368"/>
                <Setter Target="RootSplitView.CompactPaneLength" 
                        Value="96"/>
                <Setter Target="NavMenuList.Margin" 
                        Value="0,75,0,27"/>
                <Setter Target="Frame.Margin" 
                        Value="0,27,48,27"/>
                <Setter Target="NavMenuList.ItemContainerStyle" 
                        Value="{StaticResource NavMenuItemContainerXboxStyle}"/>
            </VisualState.Setters>
        </VisualState>
    </VisualStateGroup>
</VisualStateManager.VisualStateGroups>
```

Чтобы создать триггер, добавьте в приложение следующий класс. Это класс, на который ранее ссылался код XAML.

```csharp
class DeviceFamilyTrigger : StateTriggerBase
{
    private string _currentDeviceFamily, _queriedDeviceFamily;

    public string DeviceFamily
    {
        get
        {
            return _queriedDeviceFamily;
        }
        
        set
        {
            _queriedDeviceFamily = value;
            _currentDeviceFamily = AnalyticsInfo.VersionInfo.DeviceFamily;
            SetActive(_queriedDeviceFamily == _currentDeviceFamily);
        }
    }
}
```

После добавления пользовательского триггера ваше приложение автоматически будет изменять макет в соответствии с инструкциями в коде XAML, если оно обнаружит, что было запущено на консоли Xbox One.

Другим способом проверить, выполняется ли ваше приложение на Xbox, является добавление в код соответствующей переменной с последующим внесением необходимых изменений. Для проверки того, выполняется ли ваше приложение на Xbox, можно использовать следующую простую переменную.

```csharp
bool IsTenFoot = (Windows.System.Profile.AnaylticsInfo.VersionInfo.DeviceFamily == 
                    "Windows.Xbox");
```

После выполнения этой проверки в блок кода пользовательского интерфейса можно внести необходимые изменения. Соответствующий фрагмент кода см. в разделе [Пример цвета UWP](#uwp-color-sample).

## <a name="summary"></a>Резюме

Процесс проектирования взаимодействия пользователя с ТВ при просмотре на большом расстоянии имеет свои особенности, которые нужно учитывать, и вследствие наличия которых он отличается от процесса проектирования для других платформ. Несмотря на то, что можно, конечно, осуществить непосредственный перенос приложения UWP на Xbox One и оно будет работать, приложение не будет априори оптимизировано для просмотра на большом расстоянии, что может привести к разочарованию пользователя. Выполнение рекомендаций в этой статье гарантирует, что ваше приложение будет работать на телевизоре так же хорошо, как и на любой другой платформе.

## <a name="related-articles"></a>Связанные разделы

- [Азбука устройств для приложений универсальной платформы Windows (UWP)](device-primer.md)
- [Взаимодействие с помощью геймпада и пульта дистанционного управления](gamepad-and-remote-interactions.md)
- [Звук в приложениях UWP](../style/sound.md)
