---
author: joannaleecy
title: Определение основного игрового объекта
description: Давайте подробнее рассмотрим игровой объект и механизм реализации правил взаимодействия с внутриигровым миром.
ms.assetid: 6afeef84-39d0-cb78-aa2e-2e42aef936c9
ms.author: joanlee
ms.date: 10/24/2017
ms.topic: article
keywords: windows 10, uwp, игры, основной объект
ms.localizationpriority: medium
ms.openlocfilehash: b94d7139f35b3a18edd66af9959a0958d0bdcbc1
ms.sourcegitcommit: ed0304b8a214c03b8aab74b8ef12c9f82b8e3c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/19/2018
ms.locfileid: "7279087"
---
# <a name="define-the-main-game-object"></a>Определение основного игрового объекта

После того, как размещены базовая структура примера игры и реализован конечный автомат, обрабатывающий высокоуровневые пользователя и поведение системы, вам потребуется изучить правила и механизмы, включить образец игры в игру. Давайте рассмотрим, сведения о основного объекта образца игры и как механизм взаимодействия с игрового мира игры правила.

>[!Note]
>Если вы еще не скачали последний код для игры из этого примера, перейдите в раздел [Пример игры Direct3D](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/Simple3DGameDX). Этот пример является частью большой коллекции примеров функций UWP. Указания по скачиванию этого примера приводятся в разделе [Получение примеров UWP из GitHub](https://docs.microsoft.com/windows/uwp/get-started/get-uwp-app-samples).

## <a name="objective"></a>Цель

Узнайте, как применять основные методы разработки базовые реализации правил игры и механизмы для игры UWP на базе DirectX.

## <a name="main-game-object"></a>Основной игровой объект

В этом примере игры __Simple3DGame__ является класс главного объекта игры. В методе __App::Load__ создается экземпляр объекта __Simple3DGame__ .

Объект класса __Simple3DGame__ :
* Указывает, реализация логики игрового процесса
* Содержит методы, которые обмениваются данными:
    * Изменения состояния игры, чтобы конечный автомат, определенные в структуре приложения.
    * Изменения состояния игры из приложения на сам объект игры.
    * Сведения для обновления пользовательского интерфейса (наложения и отображения экранных элементов) игры, анимации и физики (динамики).

    >[!Note]
    >Обновление графики обрабатывается классом __GameRenderer__ , который содержит методы для получения и использования ресурсы графического устройства, используемые в игре. Дополнительные сведения см. в разделе [платформа отрисовки I: введение в отрисовку](tutorial--assembling-the-rendering-pipeline.md).

* Служит контейнером для данных, определяющих сеанс в игры, уровень или время существования в зависимости от того, как определить игру на высоком уровне. В этом случае данные состояния игры обозначают время существования игры и инициализируется один раз, когда пользователь запускает игры.

Чтобы просмотреть данные, определенные в этом объекте класса и методов, перейдите на [объект Simple3DGame](#simple3dgame-object).

## <a name="initialize-and-start-the-game"></a>Инициализация и запуск игры

При запуске игры пользователем игровой объект должен инициализировать ее состояние, создать и добавить наложенное изображение, задать переменные для отслеживания результатов игрока и создать экземпляры объектов, из которых будут строиться уровни. В этом примере это делается при создании нового экземпляра __GameMain__ в [__App::Load__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/App.cpp#L115-L123). 

Игровой объект __Simple3DGame__создается в конструкторе __GameMain__ . Затем инициализируется с помощью метода [__Simple3DGame::Initialize__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L54-L250) во время [асинхронного создания задачи в конструктор __GameMain__ ](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameMain.cpp#L65-L74).

### <a name="simple3dgameinitialize-method"></a>Метод Simple3DGame::Initialize

Пример игры настраивает следующих компонентов в игровой объект:

* Создается новый объект воспроизведения звука.
* Создаются массивы для графических примитивов игры, в том числе для примитивов уровней, боеприпасов и препятствий.
* Создается расположение для хранения данных состояния игры с именем *Game*, которое помещается в расположение хранилища параметров данных приложения, определенное в [**ApplicationData::Current**](https://msdn.microsoft.com/library/windows/apps/br241619).
* Создаются таймер игры и исходный игровой точечный рисунок наложения.
* Создается новая камера с определенным набором представлений и параметров проекции.
* Устройство ввода (контроллер) устанавливается с теми же углами наклона и поворота, что и камера, чтобы у игрока было полное (1 к 1) соответствие между исходной позицией управления и положением камеры.
* Создается и активируется объект проигрывателя. Мы используем объект-сферу для определения приближения игрока к стенам и препятствиям и для предохранения камеры от начало помещается в положение, которое может разрушить погружения в игру.
* Создается примитив мира игры.
* Создаются цилиндрические препятствия.
* Создаются и нумеруются мишени (объекты**Face**).
* Создаются сферы боеприпасов.
* Создаются уровни.
* Загружается наивысший результат.
* Загружается любое из ранее сохраненных состояний игры.

Теперь в игре есть экземпляры всех основных компонентов: мира, игрока, препятствий, мишеней и сфер боеприпасов. В ней также есть экземпляры уровней, которые представляют собой конфигурации всех вышеперечисленных компонентов, и задано их поведение на каждом уровне. Давайте рассмотрим, каким образом игра создает уровни.

## <a name="build-and-load-game-levels"></a>Создание и загрузка уровнями игры

Большая часть сложной работы выполняется уровня при выполнении построения выполняется в файлах __Level.h/.cpp__ , находящийся в папке __GameLevels__ примера решения. Так как он основное внимание уделяется особые реализации, мы не раскрываются их здесь. Важно лишь знать, что код каждого уровня выполняется как отдельный объект __LevelN__. Если вы хотите расширить игру, можно создать объект **уровень** , который принимает назначенным номером в качестве параметра и случайным образом помещает препятствиями и целями. Или, может быть загружать данные конфигурации уровня из файла ресурсов или даже из Интернета.

## <a name="define-the-game-play"></a>Определение игрового процесса

Теперь у нас есть все компоненты для создания игры. Уровни берется память из примитивы и готовы для проигрывателя, чтобы начать взаимодействие с.

Лучшие игры языке незамедлительно реагировать на данные, вводимые пользователем, выдавая мгновенную обратную связь. Это справедливо для любого типа, игры, twitch действий, в режиме реального времени шутеры от первого лица захватывающих глубоко, соблюдать очередь.

### <a name="simple3dgamerungame-method"></a>Метод Simple3DGame::RunGame

При воспроизведении уровня, игра находится в состоянии __Dynamics__ . 

[__GameMain::Update__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameMain.cpp#L261-L329) представляет собой цикл основного обновления, который обновляет состояние приложения один раз на кадр, как показано ниже. В цикле обновления он вызывает метод [__Simple3DGame::RunGame__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L337-L418) для обработки работы, если игра находится в состоянии __Dynamics__ .

```cpp
// Updates the application state once per frame.
void GameMain::Update()
{
    m_controller->Update(); //the controller instance has its own update loop.

    switch (m_updateState)
    {
        //...

    case UpdateEngineState::Dynamics:
        if (m_controller->IsPauseRequested())
        {
            //...
        }
        else
        {
            GameState runState = m_game->RunGame(); //when playing a level, the game is in the Dynamics state. Work is handled by Simple3DGame::RunGame method.
            switch (runState)
            {
                
      //...
```
          
[__Simple3DGame::RunGame__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L337-L418) обрабатывает набор данных, который определяет текущее состояние игры для текущей итерации цикла игры.

Логика потоком игры в __RunGame__:
*  Метод обновляет таймер, который отсчитывает секунды, пока игрок не завершит прохождение уровня, и проверяет, не истекло ли время прохождения. Это одно из правил игры: Если время истекло и всех конечных объектов не были снимок, это игра завершена.
*  Если время истекло, метод устанавливает состояние игры **TimeExpired** и возвращает его методу **Update** из предыдущего кода.
*  Если время еще не закончилось, метод запрашивает у контроллера движения-наблюдения обновление положения камеры, в частности обновление угла зрения нормальной проекции от плана камеры (куда смотрит игрок). Кроме того, запрашивается расстояние, на которое переместился угол по сравнению с предыдущим опросом контроллера.
*  Камера обновляется с учетом новых данных, полученных от контроллера движения-наблюдения.
*  Обновляется динамика игры (анимации и поведение объектов в игровом мире, которые не зависят от игрока). В этом примере игры метод [__UpdateDynamics()__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L436-L856) вызывается для обновления движение сфер боеприпасов, которые были задействованы, анимация колонн и перемещение мишеней. Дополнительные сведения см. в разделе [обновление игрового мира](#update-the-game-world).
*  Метод проверяет, выполнен ли критерий успешного прохождения уровня. Если да, то он определяет итоговый счет для этого уровня и проверяет, не является ли уровень последним (из шести). Если уровень последний, то метод возвращает состояние игры **GameComplete**; в противном случае он возвращает состояние игры __LevelComplete__.
*  Если уровень не пройден, метод устанавливает состояние игры __Active__ и возвращает его.

## <a name="update-the-game-world"></a>Обновление игрового мира

В этом примере при запуске игры, [__Simple3DGame::UpdateDynamics()__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L436-L856) метод вызывается из метода [__Simple3DGame::RunGame__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L337-L418) (который вызывается из [__GameMain::Update__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameMain.cpp#L261-L329)) для обновления объектов, которые отображаются в сцене игры.

В цикле __UpdateDynamics__ вызывать методы, которые используются для установки игрового мира в движение, независимо от игрока ввода, создавать современные методы взаимодействия, игры и сделать уровень *ожила*. Сюда входят графики, которая должна быть и запущена анимация выполняет цикл для оживления о живого, изменчивый мир, даже в том случае, если нет не игрока. Например swaying на ветру, волны cresting вдоль Берег, волны курения и инопланетные монстры растяжение и передвигать деревья. Динамика также включает в себя взаимодействие между объектами, включая столкновения сферы игрока с окружающим миром или летящих выстрелов с препятствиями и целями.

Цикл игры всегда должно поддерживать обновление игрового мира, является ли он основан на игровой логики, в физических алгоритмах или будь то просто случайные, когда игра специально приостановлена. 

В нашем примере игры этот принцип называется *динамикой*. Она отвечает за подъем и падение колонн, а также за движение и физическое поведение сфер при выстрелах. 

### <a name="simple3dgameupdatedynamics-method"></a>Метод Simple3DGame::UpdateDynamics 

Этот метод отвечает за четыре группы вычислений.

* Позиции летящих выстрелов в игровом пространстве.
* Анимация препятствий в виде колонн.
* Контакт игрока с границами игрового мира.
* Столкновения сфер выстрелов с препятствиями, целями, другими выстрелами и объектами мира.

Анимация препятствий— это цикл, определенный в файле **Animate.h/.cpp**. Поведение выстрелов и все столкновения определяются упрощенными физическими алгоритмами, содержащимися в коде и параметризованными наборами глобальных констант игрового мира, включая гравитацию и свойства материалов. Все вычисления производятся в координатном пространстве игрового мира.

### <a name="review-the-flow"></a>Просмотрите поток

Теперь, когда мы обновить все объекты в сцене и рассчитывается все столкновения, необходимо использовать эти сведения для соответствующих визуально. 

После завершения __GameMain::Update()__ текущей итерации игрового цикла игра немедленно вызывает __Render()__ объектов данных и создания новой сцены для отображения для игрока, как показано ниже. Затем давайте рассмотрим отрисовку.

```cpp
void GameMain::Run()
{
    while (!m_windowClosed)
    {
        if (m_visible)
        {
            switch (m_updateState)
            {
            case UpdateEngineState::Deactivated:
            case UpdateEngineState::TooSmall:
                // ...
                // otherwise fall through and do normal processing to get the rendering handled.
            default:
                CoreWindow::GetForCurrentThread()->Dispatcher->ProcessEvents(CoreProcessEventsOption::ProcessAllIfPresent);
                Update(); // GameMain::Update calls Simple3DGame::RunGame() if game is in Dynamics state, uses Simple3DGame::UpdateDynamics() to update game world.
                m_renderer->Render(); //Render() is called immediately after the Update() loop
                m_deviceResources->Present();
                m_renderNeeded = false;
            }
        }
        else
        {
            CoreWindow::GetForCurrentThread()->Dispatcher->ProcessEvents(CoreProcessEventsOption::ProcessOneAndAllPending);
        }
    }
    m_game->OnSuspending();  // exiting due to window close.  Make sure to save state.
}
```

## <a name="render-the-game-worlds-graphics"></a>Отрисовка графики игрового мира

Мы рекомендуем, чтобы обновление графики в игре осуществлялось с максимально возможной частотой, в идеале— при каждой итерации игрового цикла. Игра обновляется при каждом повторении цикла, независимо от действий игрока. Таким образом обеспечивается плавность отображения анимаций и поведения объектов. Представьте себе сцену с текущей водой, которая движется только при нажатии кнопки. Это было бы невероятно скучное зрелище. В хорошей игре все выглядит плавно и гладко.

Повторно вызовите игровой цикл, как показано выше на [__GameMain::Run__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameMain.cpp#L143-L202). Если главное окно программы видимо, но не прикреплено и не деактивировано, игра продолжает обновляться, отображая результаты обновлений. Метод [__отрисовки__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameRenderer.cpp#L474-L624) , который мы изучать теперь отображает состояние. Это делается сразу после вызова **обновления**, который включает **RunGame** для обновления состояния, которое было описано в предыдущем разделе.

Метод рисует трехмерную проекцию игрового мира, после чего накладывает поверх изображение Direct2D. По завершении он представляет для отображения окончательную цепочку буферов с объединенными буферами.

>[!Note]
>Существует два состояния пример наложенное изображение Direct2D: один где игра отображает игровую информацию наложения, содержащий растровое изображение меню приостановки, а где игра отображает обрезные прямоугольники для сенсорного экрана перемещением и обзором контроллер. Набранные очки отображаются в обоих состояниях. Подробнее: [Платформа отрисовки I: введение в отрисовку](tutorial--assembling-the-rendering-pipeline.md).

### <a name="gamerendererrender-method"></a>Метод GameRenderer::Render

```cpp
void GameRenderer::Render()
{
    bool stereoEnabled = m_deviceResources->GetStereoState();

    auto d3dContext = m_deviceResources->GetD3DDeviceContext();
    auto d2dContext = m_deviceResources->GetD2DDeviceContext();
   
        // ...
        if (m_game != nullptr && m_gameResourcesLoaded && m_levelResourcesLoaded)
        {
            // This section is only used after the game state has been initialized and all device
            // resources needed for the game have been created and associated with the game objects.
            //...
            auto objects = m_game->RenderObjects();
            for (auto object = objects.begin(); object != objects.end(); object++)
            {
                (*object)->Render(d3dContext, m_constantBufferChangesEveryPrim.Get()); // Renders the 3D objects
            }

        //...
        d3dContext->BeginEventInt(L"D2D BeginDraw", 1);
        d2dContext->BeginDraw(); //Start drawing the overlays
        
        // To handle the swapchain being pre-rotated, set the D2D transformation to include it.
        d2dContext->SetTransform(m_deviceResources->GetOrientationTransform2D());

        if (m_game != nullptr && m_gameResourcesLoaded)
        {
            // This is only used after the game state has been initialized.
            m_gameHud->Render(m_game); // Renders number of hits, shots, and time
        }

        if (m_gameInfoOverlay->Visible())
        {
            d2dContext->DrawBitmap(     // Renders the game overlay
                m_gameInfoOverlay->Bitmap(),
                m_gameInfoOverlayRect
                );
        }
        //...
    }
}
```

## <a name="simple3dgame-object"></a>Объект Simple3DGame

Доступны следующие методы и данные, которые определены в классе объект __Simple3DGame__ .

### <a name="methods"></a>Методы

Внутренние методы, определенные в **Simple3DGame** :

-   **Инициализация**: задает начальные значения глобальных переменных и инициализирует игровые объекты. Это рассматривается в разделе [инициализации и запуска игры](#initialize-and-start-the-game) .
-   **LoadGame**: Инициализирует новый уровень и начинает его загрузку.
-   **LoadLevelAsync**: запускает асинхронную задачу (Если вы не знакомы с асинхронные задачи, см. в разделе [Библиотеки параллельных шаблонов](https://docs.microsoft.com/cpp/parallel/concrt/parallel-patterns-library-ppl)) для инициализации уровня, а затем вызывает асинхронную задачу на обработчике для загрузки ресурсов уровней конкретного устройства. Данный метод выполняется в отдельном потоке; в результате из данного потока могут вызываться только методы [**ID3D11Device**](https://msdn.microsoft.com/library/windows/desktop/ff476379) (в противоположность методам [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385)). Все контекстные методы устройства вызываются в методе **FinalizeLoadLevel**.
-   **FinalizeLoadLevel**: завершает любую работу загрузку уровня должна выполняться в основном потоке. Включает любые вызовы контекстных ([**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385)) методов устройства в Direct3D 11.
-   **StartLevel**: запускает игру на новом уровне.
-   **PauseGame**: приостанавливает игру.
-   **RunGame**: выполняет итерацию игрового цикла. Данный метод вызывается из **App::Update** один раз при каждой итерации игрового цикла, если игра находится в состоянии **Active**.
-   **OnSuspending** и **OnResuming**: соответственно приостанавливает и возобновляет звук в игре.

И частные методы:

-   **LoadSavedState** и **SaveState**: загружает и сохраняет текущее состояние игры, соответственно.
-   **SaveHighScore** и **LoadHighScore**: соответственно сохраняет и загружает рекордный во всех играх.
-   **InitializeAmmo**: сбрасывает состояние каждого сферического объекта, используемого в качестве боеприпаса, до его исходного состояния в начале каждого раунда.
-   **UpdateDynamics**: это важный метод, так как все игровые объекты, зависимости от подпрограммами анимации, физики и дистанционного управления. Он является основой взаимодействия всех элементов игры. Это рассматривается в разделе [обновление игрового мира](#update-the-game-world) .

Остальные общие методы относятся к получающим методам, которые отображают в структуре приложения данные, относящиеся к игровому процессу и наложенному изображению.

### <a name="data"></a>Данные

В начале примера кода указаны четыре объекта, экземпляры которых обновляются при выполнении игрового цикла.

-   **MoveLookController** объект: представляет данные, вводимые пользователем. Подробнее: [Добавление элементов управления](tutorial--adding-controls.md).
-   **GameRenderer** объект: представляет обработчик Direct3D 11, производным от класса **DirectXBase** , который обрабатывает все объекты конкретного устройства и их прорисовкой. Дополнительные сведения см. в разделе [платформа отрисовки I](tutorial--assembling-the-rendering-pipeline.md).
-   **Аудио** объекта: управляет воспроизведением звука для игры. Дополнительные сведения см. в разделе [Добавление звука](tutorial--adding-sound.md).

Остальные игровые переменные содержат списки примитивов с их соответствующим количеством в игре, данные об игровом процессе и ограничения.

## <a name="next-steps"></a>Дальнейшие действия

Теперь, вам интересно, скорее всего, подсистема рендеринга: как вызовы методов __отрисовки__ для обновленных примитивов превращаются в пиксели на экране. Это рассматривается в двух частей &mdash; [платформа отрисовки I: введение в отрисовку](tutorial--assembling-the-rendering-pipeline.md) и [платформа отрисовки II: отрисовка игры](tutorial-game-rendering.md). Если вас больше интересует, каким образом обновить состояние игры с помощью элементов управления, ознакомьтесь с разделом [Добавление элементов управления](tutorial--adding-controls.md).
