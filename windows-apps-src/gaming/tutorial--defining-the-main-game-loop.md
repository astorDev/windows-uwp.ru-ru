---
title: Определение основного игрового объекта
description: Давайте подробнее рассмотрим игровой объект и механизм реализации правил взаимодействия с внутриигровым миром.
ms.assetid: 6afeef84-39d0-cb78-aa2e-2e42aef936c9
ms.date: 10/24/2017
ms.topic: article
keywords: windows 10, uwp, игры, основной объект
ms.localizationpriority: medium
ms.openlocfilehash: 96aefc8b053dd7490f47910ca5bb79989855e1a3
ms.sourcegitcommit: b034650b684a767274d5d88746faeea373c8e34f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2019
ms.locfileid: "57651499"
---
# <a name="define-the-main-game-object"></a>Определение основного игрового объекта

После формирования макета базовой платформой образца игры и реализации конечного автомата, обрабатывающий высокого уровня пользователя и поведения системы, нужно будет проверить правила и механики, превратить пример игры в игры. Давайте взглянем на сведения об основной объект пример игры и как перевести правила игры в взаимодействия с игры всему миру.

>[!Note]
>Если вы еще не скачали последний код для игры из этого примера, перейдите в раздел [Пример игры Direct3D](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/Simple3DGameDX). Этот пример является частью большой коллекции примеров функций UWP. Указания по скачиванию этого примера приводятся в разделе [Получение примеров UWP из GitHub](https://docs.microsoft.com/windows/uwp/get-started/get-uwp-app-samples).

## <a name="objective"></a>Цель

Узнайте, как применять технологии разработки для реализации правила игры и механизмы для игры DirectX для универсальной платформы Windows.

## <a name="main-game-object"></a>Основной игровой объект

В этой игре образец __Simple3DGame__ — это класс основной объект игр. Экземпляр __Simple3DGame__ объект создается в __App::Load__ метод.

__Simple3DGame__ объекта класса:
* Указывает реализацию логики игровой процесс
* Содержит методы, которые обмениваются данными:
    * Изменения в состояние конечного автомата, определенные в структуре приложения, игры.
    * Изменения состояния игры из приложения к самому объекту игр.
    * Подробные сведения для обновления пользовательского интерфейса (наложения и hud-дисплея) игры, анимации и физики (dynamics).

    >[!Note]
    >Обновление графики обрабатывается __GameRenderer__ класс, который содержит методы для получения и использования ресурсов графики устройств, используемых в игре. Дополнительные сведения см. в разделе [платформу для отображения инструкции: Общие сведения о подготовке к просмотру](tutorial--assembling-the-rendering-pipeline.md).

* Служит в качестве контейнера для данных, который определяет сеанс в игры, уровня, или время существования, в зависимости от того, как определить свою игру на высоком уровне. В этом случае данные состояния игры в течение времени существования игры и инициализируется один раз, когда пользователь запускает игры.

Чтобы просмотреть методы и данные, определенные в этом объекте класса, перейдите к [Simple3DGame объект](#simple3dgame-object).

## <a name="initialize-and-start-the-game"></a>Инициализация и запуск игры

При запуске игры пользователем игровой объект должен инициализировать ее состояние, создать и добавить наложенное изображение, задать переменные для отслеживания результатов игрока и создать экземпляры объектов, из которых будут строиться уровни. В этом примере это делается, когда новый __GameMain__ экземпляр создается в [ __App::Load__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/App.cpp#L115-L123). 

Объект игр __Simple3DGame__, создается в __GameMain__ конструктор. Затем инициализируется с помощью [ __Simple3DGame::Initialize__ ](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L54-L250) метод во время [async создать задачу __GameMain__ конструктор](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameMain.cpp#L65-L74).

### <a name="simple3dgameinitialize-method"></a>Метод Simple3DGame::Initialize

Пример игры устанавливает следующие компоненты в объекте игр:

* Создается новый объект воспроизведения звука.
* Создаются массивы для графических примитивов игры, в том числе для примитивов уровней, боеприпасов и препятствий.
* Создается расположение для хранения данных состояния игры с именем *Game*, которое помещается в расположение хранилища параметров данных приложения, определенное в [**ApplicationData::Current**](https://msdn.microsoft.com/library/windows/apps/br241619).
* Создаются таймер игры и исходный игровой точечный рисунок наложения.
* Создается новая камера с определенным набором представлений и параметров проекции.
* Устройство ввода (контроллер) устанавливается с теми же углами наклона и поворота, что и камера, чтобы у игрока было полное (1 к 1) соответствие между исходной позицией управления и положением камеры.
* Создается и активируется объект проигрывателя. Мы используем объект сферы для обнаружения игрока с включением стен и препятствия и запретить получение помещаются в позиции, которые могут нарушить работу погружения камеры.
* Создается примитив мира игры.
* Создаются цилиндрические препятствия.
* Создаются и нумеруются мишени (объекты**Face**).
* Создаются сферы боеприпасов.
* Создаются уровни.
* Загружается наивысший результат.
* Загружается любое из ранее сохраненных состояний игры.

Теперь в игре есть экземпляры всех основных компонентов: мира, игрока, препятствий, мишеней и сфер боеприпасов. В ней также есть экземпляры уровней, которые представляют собой конфигурации всех вышеперечисленных компонентов, и задано их поведение на каждом уровне. Давайте рассмотрим, каким образом игра создает уровни.

## <a name="build-and-load-game-levels"></a>Построение и загрузка уровни игр

Большая часть тяжелой работы, для уровня конструкции, создается __Level.h/.cpp__ найти файлы в __GameLevels__ папке примера решения. Так как в ней описываются очень конкретной реализации, мы не раскрываются их здесь. Важно лишь знать, что код каждого уровня выполняется как отдельный объект __LevelN__. Если вы хотите расширить возможности игры, вы можете создать **уровень** объекта, который принимает назначенному номеру как параметр и случайным образом помещает препятствия и целевых объектов. Или, чтобы можно было загрузить настройки на уровне данных из файла ресурсов или даже в Интернете.

## <a name="define-the-game-play"></a>Определение технологии компьютерных игр

Теперь у нас есть все компоненты для создания игры. Уровни в памяти из примитивы, были построены и готовы для проигрывателя, чтобы начать взаимодействие с.

Лучшие игры указанное мгновенно реагировать на ввод данных игроком и дают немедленно наблюдаемые. Это верно для любого типа, игры, из twitch действия, в режиме реального времени первого лица стрелялки продуманный и Поочередный стратегии игры.

### <a name="simple3dgamerungame-method"></a>Метод Simple3DGame::RunGame

При воспроизведении уровнем, игра находится в __Dynamics__ состояния. 

[__GameMain::Update__ ](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameMain.cpp#L261-L329) является обновление основной цикл, который обновляет состояние приложения один раз за кадр, как показано ниже. В цикле обновления, он вызывает [ __Simple3DGame::RunGame__ ](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L337-L418) метод для обработки работы, если игра в __Dynamics__ состояния.

```cpp
// Updates the application state once per frame.
void GameMain::Update()
{
    m_controller->Update(); //the controller instance has its own update loop.

    switch (m_updateState)
    {
        //...

    case UpdateEngineState::Dynamics:
        if (m_controller->IsPauseRequested())
        {
            //...
        }
        else
        {
            GameState runState = m_game->RunGame(); //when playing a level, the game is in the Dynamics state. Work is handled by Simple3DGame::RunGame method.
            switch (runState)
            {
                
      //...
```
          
[__Simple3DGame::RunGame__ ](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L337-L418) обрабатывает набор данных, который определяет текущее состояние игру для текущей итерации цикла игры.

Игр логику потока в __RunGame__:
*  Метод обновляет таймер, который отсчитывает секунды, пока игрок не завершит прохождение уровня, и проверяет, не истекло ли время прохождения. Это одно из правил игры: когда закончится время и не снимались все целевые объекты, это неизбежному краху.
*  Если время истекло, метод устанавливает состояние игры **TimeExpired** и возвращает его методу **Update** из предыдущего кода.
*  Если время еще не закончилось, метод запрашивает у контроллера движения-наблюдения обновление положения камеры, в частности обновление угла зрения нормальной проекции от плана камеры (куда смотрит игрок). Кроме того, запрашивается расстояние, на которое переместился угол по сравнению с предыдущим опросом контроллера.
*  Камера обновляется с учетом новых данных, полученных от контроллера движения-наблюдения.
*  Обновляется динамика игры (анимации и поведение объектов в игровом мире, которые не зависят от игрока). В этом образце игр [ __UpdateDynamics()__ ](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L436-L856) метод вызывается для обновления движение ammo сфер, которые активна в данный момент, анимация опорный препятствия и перемещение целевых объектов. Дополнительные сведения см. в разделе [обновление игровой](#update-the-game-world).
*  Метод проверяет, выполнен ли критерий успешного прохождения уровня. Если да, то он определяет итоговый счет для этого уровня и проверяет, не является ли уровень последним (из шести). Если уровень последний, то метод возвращает состояние игры **GameComplete**; в противном случае он возвращает состояние игры __LevelComplete__.
*  Если уровень не пройден, метод устанавливает состояние игры __Active__ и возвращает его.

## <a name="update-the-game-world"></a>Обновления игры всему миру

В этом примере, когда Игра запущена [ __Simple3DGame::UpdateDynamics()__ ](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L436-L856) метод вызывается из [ __Simple3DGame::RunGame__ ](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L337-L418)метода (который вызывается из [ __GameMain::Update__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameMain.cpp#L261-L329)) для обновления объектов, которые подготавливаются к просмотру в сцене игр.

В __UpdateDynamics__ цикл, вызов методов, которые используются для задания игровой перемещаемые, независимо от ввод данных игроком, создание игры присутствия и уровня вернитесь *alive*. Сюда входят графики, который необходимо визуализировать и запущенная анимация циклов для связи с развитием на жизнь, со взбешенным мира, даже в том случае, если входных данных нет проигрывателя. Например деревья, swaying в wind волны cresting вдоль линий укрепить, курящих оборудования и инопланетного монстров растягивания и перемещения. Динамика также включает в себя взаимодействие между объектами, включая столкновения сферы игрока с окружающим миром или летящих выстрелов с препятствиями и целями.

Цикл игры всегда должен поддерживать обновление игровой ли он основан на логику игры, физических алгоритмов, или это просто random, за исключением случаев, когда игра специально приостановлена. 

В нашем примере игры этот принцип называется *динамикой*. Она отвечает за подъем и падение колонн, а также за движение и физическое поведение сфер при выстрелах. 

### <a name="simple3dgameupdatedynamics-method"></a>Метод Simple3DGame::UpdateDynamics 

Этот метод отвечает за четыре группы вычислений.

* Позиции летящих выстрелов в игровом пространстве.
* Анимация препятствий в виде колонн.
* Контакт игрока с границами игрового мира.
* Столкновения сфер выстрелов с препятствиями, целями, другими выстрелами и объектами мира.

Анимация препятствий — это цикл, определенный в файле **Animate.h/.cpp**. Поведение ammo и любые конфликты определяются алгоритмами упрощенный физики, указан в коде и параметризованные с помощью набора глобальные константы для игр мира, включая свойства гравитации и материалов. Все вычисления производятся в координатном пространстве игрового мира.

### <a name="review-the-flow"></a>Просмотреть поток

Теперь, когда обновленный все объекты на сцене и вычислить любые конфликты, нам нужно использовать эту информацию для рисования соответствующий визуальный элемент изменится. 

После __GameMain::Update()__ завершения текущей итерации цикла игры, немедленно вызывается __Render()__ чтобы извлечь обновленные данные объекта и создать новую сцену для представления в проигрыватель, в качестве здесь. Теперь давайте рассмотрим отрисовку.

```cpp
void GameMain::Run()
{
    while (!m_windowClosed)
    {
        if (m_visible)
        {
            switch (m_updateState)
            {
            case UpdateEngineState::Deactivated:
            case UpdateEngineState::TooSmall:
                // ...
                // otherwise fall through and do normal processing to get the rendering handled.
            default:
                CoreWindow::GetForCurrentThread()->Dispatcher->ProcessEvents(CoreProcessEventsOption::ProcessAllIfPresent);
                Update(); // GameMain::Update calls Simple3DGame::RunGame() if game is in Dynamics state, uses Simple3DGame::UpdateDynamics() to update game world.
                m_renderer->Render(); //Render() is called immediately after the Update() loop
                m_deviceResources->Present();
                m_renderNeeded = false;
            }
        }
        else
        {
            CoreWindow::GetForCurrentThread()->Dispatcher->ProcessEvents(CoreProcessEventsOption::ProcessOneAndAllPending);
        }
    }
    m_game->OnSuspending();  // exiting due to window close.  Make sure to save state.
}
```

## <a name="render-the-game-worlds-graphics"></a>Визуализация игровой графики

Мы рекомендуем, чтобы обновление графики в игре осуществлялось с максимально возможной частотой, в идеале — при каждой итерации игрового цикла. Игра обновляется при каждом повторении цикла, независимо от действий игрока. Таким образом обеспечивается плавность отображения анимаций и поведения объектов. Представьте себе сцену с текущей водой, которая движется только при нажатии кнопки. Это было бы невероятно скучное зрелище. В хорошей игре все выглядит плавно и гладко.

Отозвать цикл образца игры, как показано выше в [ __GameMain::Run__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameMain.cpp#L143-L202). Если главное окно программы видимо, но не прикреплено и не деактивировано, игра продолжает обновляться, отображая результаты обновлений. [ __Визуализации__ ](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameRenderer.cpp#L474-L624) метод, мы анализируемого теперь отображает представление этого состояния. Это необходимо сделать сразу после вызова **обновить**, который включает **RunGame** для обновления состояния, которые обсуждались в предыдущем разделе.

Метод рисует трехмерную проекцию игрового мира, после чего накладывает поверх изображение Direct2D. По завершении он представляет для отображения окончательную цепочку буферов с объединенными буферами.

>[!Note]
>Существует два состояния для элемента управления overlay Direct2D образца игры: один где игры отобразится наложение игр info, содержащий растровое изображение для меню «Пауза» и один, перекрестие вместе с прямоугольников для сенсорного экрана перемещения внешний вид, в которых отображаются игры контроллер. Набранные очки отображаются в обоих состояниях. Дополнительные сведения см. в разделе [платформу для отображения инструкции: Общие сведения о подготовке к просмотру](tutorial--assembling-the-rendering-pipeline.md).

### <a name="gamerendererrender-method"></a>Метод GameRenderer::Render

```cpp
void GameRenderer::Render()
{
    bool stereoEnabled = m_deviceResources->GetStereoState();

    auto d3dContext = m_deviceResources->GetD3DDeviceContext();
    auto d2dContext = m_deviceResources->GetD2DDeviceContext();
   
        // ...
        if (m_game != nullptr && m_gameResourcesLoaded && m_levelResourcesLoaded)
        {
            // This section is only used after the game state has been initialized and all device
            // resources needed for the game have been created and associated with the game objects.
            //...
            auto objects = m_game->RenderObjects();
            for (auto object = objects.begin(); object != objects.end(); object++)
            {
                (*object)->Render(d3dContext, m_constantBufferChangesEveryPrim.Get()); // Renders the 3D objects
            }

        //...
        d3dContext->BeginEventInt(L"D2D BeginDraw", 1);
        d2dContext->BeginDraw(); //Start drawing the overlays
        
        // To handle the swapchain being pre-rotated, set the D2D transformation to include it.
        d2dContext->SetTransform(m_deviceResources->GetOrientationTransform2D());

        if (m_game != nullptr && m_gameResourcesLoaded)
        {
            // This is only used after the game state has been initialized.
            m_gameHud->Render(m_game); // Renders number of hits, shots, and time
        }

        if (m_gameInfoOverlay->Visible())
        {
            d2dContext->DrawBitmap(     // Renders the game overlay
                m_gameInfoOverlay->Bitmap(),
                m_gameInfoOverlayRect
                );
        }
        //...
    }
}
```

## <a name="simple3dgame-object"></a>Объект Simple3DGame

Ниже приведены методы и данные, которые определены в __Simple3DGame__ класса объектов.

### <a name="methods"></a>Методы

Внутренние методы, определенные в **Simple3DGame** включают:

-   **Инициализировать**: Задает начальные значения глобальных переменных и инициализирует игровые объекты. Это рассматривается в [инициализации и запуска игры](#initialize-and-start-the-game) раздел.
-   **LoadGame**: Инициализирует новый уровень и начинает его загрузку.
-   **LoadLevelAsync**: При запуске асинхронной задачи (Если вы не знакомы с асинхронных задач, см. в разделе [библиотеку параллельных шаблонов](https://docs.microsoft.com/cpp/parallel/concrt/parallel-patterns-library-ppl)) инициализировать уровень, а затем вызвать асинхронной задачи в модуль подготовки отчетов для загрузки определенным ресурсам уровне устройства. Данный метод выполняется в отдельном потоке; в результате из данного потока могут вызываться только методы [**ID3D11Device**](https://msdn.microsoft.com/library/windows/desktop/ff476379) (в противоположность методам [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385)). Все контекстные методы устройства вызываются в методе **FinalizeLoadLevel**.
-   **FinalizeLoadLevel**: Завершает любую работу, чтобы обеспечить загрузку уровня на основном потоке. Включает любые вызовы контекстных ([**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385)) методов устройства в Direct3D 11.
-   **StartLevel**: Запускает игру на новом уровне.
-   **PauseGame**: Приостанавливает игру.
-   **RunGame**: Выполняет итерацию игрового цикла. Данный метод вызывается из **App::Update** один раз при каждой итерации игрового цикла, если игра находится в состоянии **Active**.
-   **OnSuspending** и **OnResuming**: Соответственно приостанавливает и возобновляет звук в игре.

И частные методы:

-   **LoadSavedState** и **SaveState**: Соответственно загружает и сохраняет текущее состояние игры.
-   **SaveHighScore** и **LoadHighScore**: Соответственно сохраняет и загружает рекордный результат во всех играх.
-   **InitializeAmmo**: Сбрасывает состояние каждого сферического объекта, используемого в качестве боеприпаса, до его исходного состояния в начале каждого раунда.
-   **UpdateDynamics**: Этот метод играет важную роль, обновляя все игровые объекты в соответствии со стандартными подпрограммами анимации, физикой и данными от элементов управления. Он является основой взаимодействия всех элементов игры. Это рассматривается в [обновление игровой](#update-the-game-world) раздел.

Остальные общие методы относятся к получающим методам, которые отображают в структуре приложения данные, относящиеся к игровому процессу и наложенному изображению.

### <a name="data"></a>Data (Данные)

В начале примера кода указаны четыре объекта, экземпляры которых обновляются при выполнении игрового цикла.

-   **MoveLookController** объекта: Представляет ввод данных игроком. Подробнее: [Добавление элементов управления](tutorial--adding-controls.md).
-   **GameRenderer** объекта: Представляет модуль подготовки отчетов Direct3D 11, производный от **DirectXBase** класс, который обрабатывает все объекты конкретного устройства и их подготовки к просмотру. Дополнительные сведения см. в разделе [платформу для отображения я](tutorial--assembling-the-rendering-pipeline.md).
-   **Аудио** объекта: Управляет воспроизведение звука для игры. Дополнительные сведения см. в разделе [добавление звука](tutorial--adding-sound.md).

Остальные игровые переменные содержат списки примитивов с их соответствующим количеством в игре, данные об игровом процессе и ограничения.

## <a name="next-steps"></a>Дальнейшие действия

К этому моменту, вам интересно, возможно, механизм отрисовки фактическое: как вызовы __визуализации__ методы на обновленные примитивы включится экрана в пикселях. Это рассматривается в два этапа &mdash; [платформу для отображения инструкции: Общие сведения о подготовке к просмотру](tutorial--assembling-the-rendering-pipeline.md) и [платформу для отображения II: Отрисовки игр](tutorial-game-rendering.md). Если вас больше интересует, каким образом обновить состояние игры с помощью элементов управления, ознакомьтесь с разделом [Добавление элементов управления](tutorial--adding-controls.md).
