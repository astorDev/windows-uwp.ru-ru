---
title: Определение основного игрового объекта
description: Теперь мы рассмотрим сведения о главном объекте примера игры и о том, как правила, которые он реализует, переводятся в взаимодействие со средой игры.
ms.assetid: 6afeef84-39d0-cb78-aa2e-2e42aef936c9
ms.date: 06/24/2020
ms.topic: article
keywords: windows 10, uwp, игры, основной объект
ms.localizationpriority: medium
ms.openlocfilehash: 9a6d087be6df93ee6798c29147f7fd1c820bd225
ms.sourcegitcommit: 20969781aca50738792631f4b68326f9171a3980
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/26/2020
ms.locfileid: "85409563"
---
# <a name="define-the-main-game-object"></a>Определение основного игрового объекта

> [!NOTE]
> Эта статья является частью серии руководств по [созданию простой универсальная платформа Windows (UWP) с помощью DirectX](tutorial--create-your-first-uwp-directx-game.md) . В разделе этой ссылки задается контекст для ряда.

После того как вы выделили базовую платформу для примера игры и реализовали конечный автомат, который обрабатывает поведение пользователей и системы высокого уровня, необходимо изучить правила и механику, которые блокируют игру в игре. Давайте взглянем на детали основного объекта игры и о том, как преобразовать правила игры в взаимодействия со средой игры.

## <a name="objectives"></a>Задачи

- Узнайте, как применять основные методы разработки для реализации правил игры и механики для игры DirectX UWP.

## <a name="main-game-object"></a>Основной игровой объект

В **Simple3DGameDX** примере игры **Simple3DGame** является классом основного объекта Game. Экземпляр **Simple3DGame** создается, косвенно, через метод **app:: Load** .

Ниже приведены некоторые функции класса **Simple3DGame** .

- Содержит реализацию логики игрового процесса.
- Содержит методы, передающие эти сведения.
  - Изменяет состояние игры на конечный автомат, определенный в платформе приложений.
  - Изменяет состояние игры с приложения на саму игру.
  - Сведения об обновлении пользовательского интерфейса игры (наложение и отображение заголовков), анимации и физических (Dynamics).
  > [!NOTE]
  > Обновление графики обрабатывается классом **гамерендерер** , который содержит методы для получения и использования ресурсов графических устройств, используемых игрой. Дополнительные сведения см. [в разделе Rendering Framework I: введение в подготовку к просмотру](tutorial--assembling-the-rendering-pipeline.md).
- Служит контейнером для данных, определяющих сеанс игры, уровень или время существования, в зависимости от того, как вы определяете игру на высоком уровне. В этом случае данные состояния игры находятся в течение времени существования игры и инициализируются один раз, когда пользователь запускает игру.

Чтобы просмотреть методы и данные, определенные этим классом, см. [класс Simple3DGame](#the-simple3dgame-class) ниже.

## <a name="initialize-and-start-the-game"></a>Инициализация и запуск игры

При запуске игры пользователем игровой объект должен инициализировать ее состояние, создать и добавить наложенное изображение, задать переменные для отслеживания результатов игрока и создать экземпляры объектов, из которых будут строиться уровни. В этом примере это делается при создании экземпляра **гамемаин** в **приложении:: Load**.

Объект Game типа **Simple3DGame**создается в конструкторе **Гамемаин:: гамемаин** . Затем он инициализируется с помощью метода **Simple3DGame:: Initialize** во время выполнения соподпрограмм **Гамемаин:: конструктинбаккграунд** Fire-and-забыть, который вызывается из **гамемаин:: гамемаин**.

### <a name="the-simple3dgameinitialize-method"></a>Метод Simple3DGame:: Initialize

Пример игры настраивает эти компоненты в объекте Game.

- Создается новый объект воспроизведения звука.
- Создаются массивы для графических примитивов игры, в том числе для примитивов уровней, боеприпасов и препятствий.
- Создается расположение для хранения данных состояния игры с именем *Game*, которое помещается в расположение хранилища параметров данных приложения, определенное в [**ApplicationData::Current**](/uwp/api/windows.storage.applicationdata.current).
- Создаются таймер игры и исходный игровой точечный рисунок наложения.
- Создается новая камера с определенным набором представлений и параметров проекции.
- Устройство ввода (контроллер) устанавливается с теми же углами наклона и поворота, что и камера, чтобы у игрока было полное (1 к 1) соответствие между исходной позицией управления и положением камеры.
- Создается и активируется объект проигрывателя. Объект Sphere используется для обнаружения близкого соперника к стенам и препятствиям, а также для того, чтобы камера могла размещаться в положении, которое может привести к нарушению погружения.
- Создается примитив мира игры.
- Создаются цилиндрические препятствия.
- Создаются и нумеруются мишени (объекты**Face**).
- Создаются сферы боеприпасов.
- Создаются уровни.
- Загружается наивысший результат.
- Загружается любое из ранее сохраненных состояний игры.

Игра теперь содержит экземпляры всех ключевых компонентов &mdash; мира, игрока, препятствий, целей и АММО шарик. В ней также есть экземпляры уровней, которые представляют собой конфигурации всех вышеперечисленных компонентов, и задано их поведение на каждом уровне. Теперь давайте посмотрим, как игра строится на уровнях.

## <a name="build-and-load-game-levels"></a>Сборка и загрузка уровней игры

Большая часть тяжелой работы по созданию уровня выполняется в `Level[N].h/.cpp` файлах, находящихся в папке **гамелевелс** примера решения. Так как основное внимание уделяется определенной реализации, мы не будем заставлять их здесь. Важно то, что код для каждого уровня выполняется как отдельный объект **уровня [N]** . Если вы хотите расширить игру, можно создать объект **уровня [N]** , который принимает назначенное число в качестве параметра и случайным образом помещает препятствия и цели. Кроме того, можно получить данные конфигурации уровня загрузки из файла ресурсов или даже из Интернета.

## <a name="define-the-gameplay"></a>Определение игрового процесса

На этом этапе у нас есть все компоненты, необходимые для разработки игры. Уровни были созданы в памяти на основе примитивов и готовы к тому, чтобы проигрыватель начал взаимодействовать с.

Лучшие игры мгновенно реагируют на проигрыватели и предоставляют немедленную обратную связь. Это справедливо для любого типа игры, от твитч-действий, в режиме реального времени и до продуманных компьютерных стратегий.

### <a name="the-simple3dgamerungame-method"></a>Метод Simple3DGame:: Рунгаме

Пока выполняется уровень игры, игра находится в состоянии **Dynamics** . 

**Гамемаин:: Update** — главный цикл обновления, который обновляет состояние приложения один раз для каждого кадра, как показано ниже. Цикл обновления вызывает метод **Simple3DGame:: рунгаме** для обработки работы, если игра находится в состоянии **Dynamics** .

```cppwinrt
// Updates the application state once per frame.
void GameMain::Update()
{
    // The controller object has its own update loop.
    m_controller->Update();

    switch (m_updateState)
    {
    ...
    case UpdateEngineState::Dynamics:
        if (m_controller->IsPauseRequested())
        {
            ...
        }
        else
        {
            // When the player is playing, work is done by Simple3DGame::RunGame.
            GameState runState = m_game->RunGame();
            switch (runState)
            {
                ...
```
          
**Simple3DGame:: рунгаме** обрабатывает набор данных, определяющий текущее состояние игры для текущей итерации цикла игры.

Ниже приведена логика потока игр в **Simple3DGame:: рунгаме**.

- Метод обновляет таймер, который подсчитывает количество секунд до завершения уровня, и проверяет, истек ли срок действия этого уровня. Это одно из правил игры &mdash; , когда закончится время ожидания, если не все целевые объекты были собраны.
- Если время истекло, метод задает состояние игры **тимикспиред** и возвращает методу **Update** в предыдущем коде.
- Если время остается, контроллер перемещения-поиска опрашивается на наличие обновления в положении камеры. в частности, обновление до угла представления нормального проецирования с плоскости камеры (где ищется игрок) и расстояния, в котором угол был перемещен с момента последнего опроса контроллера.
- Камера обновляется с учетом новых данных, полученных от контроллера движения-наблюдения.
- Обновляется динамика игры (анимации и поведение объектов в игровом мире, которые не зависят от игрока). В этом примере игры вызывается метод **Simple3DGame:: упдатединамикс** , чтобы обновить движение АММО шарик, которое было запущено, анимацию основных препятствий и перемещение целевых объектов. Дополнительные сведения см. [в разделе Обновление мира игры](#update-the-game-world).
- Метод проверяет, выполнены ли условия для успешного завершения уровня. Если это так, он завершает оценку уровня и проверяет, является ли этот уровень последним (of 6). Если это последний уровень, метод возвращает состояние игры **гаместате:: гамекомплете** ; в противном случае возвращается состояние игры **гаместате:: левелкомплете** .
- Если уровень не завершен, метод устанавливает состояние игры в **гаместате:: Active**и возвращает.

## <a name="update-the-game-world"></a>Обновление мира игры

В этом примере при запуске игры метод **Simple3DGame:: упдатединамикс** вызывается из метода **Simple3DGame:: рунгаме** (который вызывается из **гамемаин:: Update**) для обновления объектов, отображаемых в игровой сцене.

Такой цикл, как **упдатединамикс** , вызывает любые методы, которые используются для настройки игры в движении, независимо от входных данных игрока, для создания впечатляющих игр и обеспечения активности уровня. К ним относятся графические объекты, которые необходимо визуализировать, и выполнение циклов анимации для динамического мира даже при отсутствии входных данных проигрывателя. В игре, которая может включать в себя деревья со встроенными презентациями, крестинг вдоль укрепление линий, станков Курение и инопланетянин монстров растяжения и перемещения. Динамика также включает в себя взаимодействие между объектами, включая столкновения сферы игрока с окружающим миром или летящих выстрелов с препятствиями и целями.

За исключением случаев приостановки игры, цикл игры должен продолжать обновлять мир игры; зависит ли это от логики игры, физических алгоритмов или от того, является ли это простое случайным.

В демонстрационной игре этот принцип называется *Dynamics*, он охватывает подъем и падение препятствий, а также движения и физического поведения АММО шарик по мере их запуска и движения.

### <a name="the-simple3dgameupdatedynamics-method"></a>Метод Simple3DGame:: Упдатединамикс 

Этот метод работает с четырьмя наборами вычислений.

- Позиции летящих выстрелов в игровом пространстве.
- Анимация препятствий в виде колонн.
- Контакт игрока с границами игрового мира.
- Столкновения сфер выстрелов с препятствиями, целями, другими выстрелами и объектами мира.

Анимация препятствий происходит в цикле, определенном в файлах исходного кода **анимации Animation. h/. cpp** . Поведение АММО и любых конфликтов определяются упрощенными аппаратными алгоритмами, предоставленными в коде и параметризованными набором глобальных констант для игры, включая свойства тяжести и материала. Все вычисления производятся в координатном пространстве игрового мира.

### <a name="review-the-flow"></a>Проверка последовательности

Теперь, когда мы обновили все объекты в сцене и вычислили все конфликты, необходимо использовать эти сведения для отрисовки соответствующих визуальных изменений. 

После того как **гамемаин:: Update** завершил текущую итерацию цикла игры, пример немедленно вызывает **Гамерендерер:: Render** для получения обновленных данных объекта и создания новой сцены, которая будет представлена проигрывателю, как показано ниже.

```cppwinrt
void GameMain::Run()
{
    while (!m_windowClosed)
    {
        if (m_visible)
        {
            switch (m_updateState)
            {
            case UpdateEngineState::Deactivated:
            case UpdateEngineState::TooSmall:
                ...
                // Otherwise, fall through and do normal processing to perform rendering.
            default:
                CoreWindow::GetForCurrentThread().Dispatcher().ProcessEvents(
                    CoreProcessEventsOption::ProcessAllIfPresent);
                // GameMain::Update calls Simple3DGame::RunGame. If game is in Dynamics
                // state, uses Simple3DGame::UpdateDynamics to update game world.
                Update();
                // Render is called immediately after the Update loop.
                m_renderer->Render();
                m_deviceResources->Present();
                m_renderNeeded = false;
            }
        }
        else
        {
            CoreWindow::GetForCurrentThread().Dispatcher().ProcessEvents(
                CoreProcessEventsOption::ProcessOneAndAllPending);
        }
    }
    m_game->OnSuspending();  // Exiting due to window close, so save state.
}
```

## <a name="render-the-game-worlds-graphics"></a>Визуализация графического мира игры

Рекомендуется часто выполнять обновление графики в игре, в идеале, так часто, как это происходит в основном цикле игры. По мере итерации цикла состояние игры обновляется, с вводом или без ввода проигрывателя. Это позволяет плавно отображать вычисляемые анимации и поведения. Представьте себе, что у нас есть простая сцена воды, которая была перемещена только при нажатии игроком кнопки. Это не было бы реалистичным; хорошая игра выглядит плавно и непрерывно.

Вспомним цикл игры примера, как показано выше в **гамемаин:: Run**. Если главное окно игры видимо, а не привязано или отключено, игра продолжит обновлять и визуализировать результаты этого обновления. Метод **гамерендерер:: Render** , который мы рассмотрим далее, визуализирует представление этого состояния. Это выполняется сразу после вызова **гамемаин:: Update**, который включает **Simple3DGame:: рунгаме** в состояние обновления, как описано в предыдущем разделе.

**Гамерендерер:: Render** рисует проекцию трехмерного мира, а затем рисует наложение Direct2D поверх него. По завершении он представляет для отображения окончательную цепочку буферов с объединенными буферами.

> [!NOTE]
> Существует два состояния для Direct2D наложения игры &mdash; , на которой в игре отображается наложение "сведения об игре", которая содержит точечный рисунок для меню пауза, а второй — в игре отображаются перекрестные и прямоугольники для контроллера пальца. Набранные очки отображаются в обоих состояниях. Подробнее: [Платформа отрисовки I: введение в отрисовку](tutorial--assembling-the-rendering-pipeline.md).

### <a name="the-gamerendererrender-method"></a>Метод Гамерендерер:: Render

```cppwinrt
void GameRenderer::Render()
{
    bool stereoEnabled{ m_deviceResources->GetStereoState() };

    auto d3dContext{ m_deviceResources->GetD3DDeviceContext() };
    auto d2dContext{ m_deviceResources->GetD2DDeviceContext() };

    ...
        if (m_game != nullptr && m_gameResourcesLoaded && m_levelResourcesLoaded)
        {
            // This section is only used after the game state has been initialized and all device
            // resources needed for the game have been created and associated with the game objects.
            ...
            for (auto&& object : m_game->RenderObjects())
            {
                object->Render(d3dContext, m_constantBufferChangesEveryPrim.get());
            }
        }

        d3dContext->BeginEventInt(L"D2D BeginDraw", 1);
        d2dContext->BeginDraw();

        // To handle the swapchain being pre-rotated, set the D2D transformation to include it.
        d2dContext->SetTransform(m_deviceResources->GetOrientationTransform2D());

        if (m_game != nullptr && m_gameResourcesLoaded)
        {
            // This is only used after the game state has been initialized.
            m_gameHud.Render(m_game);
        }

        if (m_gameInfoOverlay.Visible())
        {
            d2dContext->DrawBitmap(
                m_gameInfoOverlay.Bitmap(),
                m_gameInfoOverlayRect
                );
        }
        ...
    }
}
```

## <a name="the-simple3dgame-class"></a>Класс Simple3DGame

Это методы и элементы данных, определяемые классом **Simple3DGame** .

### <a name="member-functions"></a>Функции элементов

К открытым функциям — членам, определенным в **Simple3DGame** , относятся следующие.

- **Инициализация**. Задает начальные значения глобальных переменных и инициализирует игровые объекты. Это описано в разделе [Инициализация и запуск игры](#initialize-and-start-the-game) .
- **LoadGame**. Инициализирует новый уровень и начинает его загрузку.
- **LoadLevelAsync**. Соподпрограмма, которая инициализирует уровень, а затем вызывает еще одну соподпрограмму модуля подготовки, чтобы загрузить ресурсы уровня для конкретного устройства. Данный метод выполняется в отдельном потоке; в результате из данного потока могут вызываться только методы [**ID3D11Device**](/windows/desktop/api/d3d11/nn-d3d11-id3d11device) (в противоположность методам [**ID3D11DeviceContext**](/windows/desktop/api/d3d11/nn-d3d11-id3d11devicecontext)). Все контекстные методы устройства вызываются в методе **FinalizeLoadLevel**. Если вы не знакомы с асинхронным программированием, см. статью [Параллельные и асинхронные операции с C++/WinRT](/windows/uwp/cpp-and-winrt-apis/concurrency).
- **FinalizeLoadLevel**. Завершает любую работу, чтобы обеспечить загрузку уровня на основном потоке. Включает любые вызовы контекстных ([**ID3D11DeviceContext**](/windows/desktop/api/d3d11/nn-d3d11-id3d11devicecontext)) методов устройства в Direct3D 11.
- **StartLevel**. Запускает игрового процесса для нового уровня.
- **PauseGame**. Приостанавливает игру.
- **RunGame**. Выполняет итерацию игрового цикла. Данный метод вызывается из **App::Update** один раз при каждой итерации игрового цикла, если игра находится в состоянии **Active**.
- **OnSuspending** и **OnResuming**. Приостановите или возобновите звук игры соответственно.

Ниже приведены закрытые функции членов.

- **LoadSavedState** и **SaveState**. Загрузить или сохранить текущее состояние игры соответственно.
- **Лоадхигхскоре** и **савехигхскоре**. Загрузка и сохранение высокой оценки в играх соответственно.
- **InitializeAmmo**. Сбрасывает состояние каждого сферического объекта, используемого в качестве боеприпаса, до его исходного состояния в начале каждого раунда.
- **UpdateDynamics**. Это важный метод, поскольку он обновляет все игровые объекты на основе стандартных подпрограмм анимации, физикы и управления входными данными. Он является основой взаимодействия всех элементов игры. Это описано в разделе [обновление мира игры](#update-the-game-world) .

Другие открытые методы — это метод доступа к свойству, который возвращает сведения о игрового процесса и оверлея для платформы приложений для отображения.

### <a name="data-members"></a>Элементы данных

Эти объекты обновляются по мере выполнения цикла игры.

- Объект **мовелукконтроллер** . Представляет входные данные проигрывателя. Подробнее: [Добавление элементов управления](tutorial--adding-controls.md).
- Объект **гамерендерер** . Представляет модуль подготовки Direct3D 11, который обрабатывает все объекты конкретного устройства и их отрисовку. Дополнительные сведения см. в разделе [Rendering Framework I](tutorial--assembling-the-rendering-pipeline.md).
- **Звуковой** объект. Управляет воспроизведением звука для игры. Дополнительные сведения см. в разделе [Добавление звука](tutorial--adding-sound.md).

Остальные переменные игры содержат списки примитивов и их соответствующие объемы в игре, а также данные и ограничения игры.

## <a name="next-steps"></a>Следующие шаги

Мы еще не говорим о фактическом механизме визуализации &mdash; того, как вызовы методов **отрисовки** в обновленных примитивах преобразуются в пиксели на экране. Эти аспекты рассматриваются в разделе визуализация в двух частях &mdash; [I: введение в визуализацию](tutorial--assembling-the-rendering-pipeline.md) и [отрисовку Framework II: Визуализация игр](tutorial-game-rendering.md). Если вы больше заинтересованы в том, как проигрыватель управляет обновлением состояния игры, см. раздел [Добавление элементов управления](tutorial--adding-controls.md).
