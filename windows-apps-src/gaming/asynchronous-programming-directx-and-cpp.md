---
title: Асинхронное программирование (DirectX и C++)
description: В данной статье рассматриваются различные вопросы использования асинхронного программирования и потоковой модели с DirectX.
ms.assetid: 17613cd3-1d9d-8d2f-1b8d-9f8d31faaa6b
ms.date: 02/08/2017
ms.topic: article
keywords: Windows 10, uwp, игры, асинхронное программирование, directx
ms.localizationpriority: medium
ms.openlocfilehash: 3fc2722c8db40aaabd4313dac60f676b93478d69
ms.sourcegitcommit: ac7f3422f8d83618f9b6b5615a37f8e5c115b3c4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/29/2019
ms.locfileid: "66369044"
---
# <a name="asynchronous-programming-directx-and-c"></a>Асинхронное программирование (DirectX и C++)



В данной статье рассматриваются различные вопросы использования асинхронного программирования и потоковой модели с DirectX.

## <a name="async-programming-and-directx"></a>Асинхронное программирование и DirectX


Если вы только изучаете DirectX или даже уже имеете достаточный опыт в нем, предусмотрите размещение всех своих графических конвейеров в одном потоке. В каждой заданной сцене игры имеются общие ресурсы, такие как точечные рисунки, шейдеры и другие ресурсы, которые требуют монопольного доступа. Эти же ресурсы требуют, чтобы вы синхронизировали доступ к ним среди параллельных потоков. Визуализация является сложным процессом для распараллеливания среди нескольких потоков.

Однако если ваша игра достаточно сложная или вы хотите улучшить ее быстродействие, вы можете использовать асинхронное программирование для распараллеливания некоторых компонентов, не относящихся к вашему конвейеру отрисовки. Ваше приложение может воспользоваться преимуществами возможностей современного оборудования, многоядерных и гиперпотоковых ЦП. Обеспечить это можно также благодаря асинхронному программированию для разработки некоторых компонентов вашей игры, которым не требуется прямой доступ к контексту устройств Direct3D, например:

-   файловый ввод-вывод
-   физика
-   искусственный интеллект
-   сеть
-   звук
-   элементы управления
-   компоненты пользовательского интерфейса, написанные на XAML

Ваше приложение может оперировать этими компонентами при работе с несколькими параллельными потоками. Файловый ввод-вывод, особенно с загрузкой ресурсов, выполняется значительно эффективнее при асинхронной загрузке, поскольку ваша игра или приложение могут находиться в интерактивном состоянии, пока загружаются или передаются в потоковом режиме несколько (или несколько сотен) мегабайт ресурсов. Самый простой способ создания и управления этими потоками — это использование [библиотеки параллельных шаблонов](https://docs.microsoft.com/cpp/parallel/concrt/parallel-patterns-library-ppl) и шаблона **task**, содержащегося в пространстве имен **concurrency**, которое определено в PPLTasks.h. Использование [библиотеки параллельных шаблонов](https://docs.microsoft.com/cpp/parallel/concrt/parallel-patterns-library-ppl) обеспечивает непосредственное преимущество при использовании многоядерных и гиперпотоковых ЦП и может улучшить все показатели, включая воспринимаемое время загрузки, задержки и запаздывание, которые сопровождают вычисления с большой нагрузкой на ЦП или сеть.

> **Примечание**    приложения в Windows платформа Универсальной, пользовательский интерфейс работает полностью в однопотоковое подразделение (STA). Если вы создаете пользовательский интерфейс для вашей игры DirectX с помощью [межпрограммного взаимодействия XAML](directx-and-xaml-interop.md), то доступ к элементам управления можно получить, только используя STA.

 

## <a name="multithreading-with-direct3d-devices"></a>Многопоточность с устройствами Direct3D


Многопоточность для контексты устройств доступна только в графических устройств, которые поддерживают более функциональный уровень Direct3D 11\_0 или более поздней версии. Однако можно повысить эффективность использования этого мощного графического процессора (GPU) на многих платформах, таких как выделенные игровые платформы. В простейшем случае можно отделить визуализацию наложения элементов HUD от визуализации сцен 3D и их проекции, а также сделать так, чтобы оба компонента использовали отдельные параллельные конвейеры. Для создания ресурсных объектов и управления ими (текстуры, сетки, шейдеры и другие ресурсы) оба потока должны использовать одинаковый контекст [**ID3D11DeviceContext**](https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11devicecontext), который является однопотоковым и требует реализации какого-либо механизма синхронизации (например, критические секции) для безопасного доступа к нему. В то время как можно создать отдельные списки команд для контекста устройства в различных потоках (для замедленной визуализации), невозможно воспроизвести эти списки команд одновременно на том же экземпляре **ID3D11DeviceContext**.

Теперь для создания объектов ресурса ваше приложение может также использовать объект [**ID3D11Device**](https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11device), который является надежным при реализации многопоточности. Итак, почему бы всегда не использовать **ID3D11Device** вместо [**ID3D11DeviceContext**](https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11devicecontext)? В настоящее время для некоторых графических интерфейсов недоступна поддержка драйверов, позволяющих реализовывать многопоточность. Можно запросить устройство и выяснить, поддерживает ли оно многопоточность, но если вы рассчитываете на более широкую аудиторию, то для управления объектом ресурса имеет смысл выбрать однопотоковый контекст **ID3D11DeviceContext**. Когда драйвер графического устройства не поддерживает многопоточность или списки команд, Direct3D 11 пытается получить синхронизированный доступ к контексту устройства изнутри, и если списки команд не поддерживаются, он обеспечивает программную реализацию. В результате вы можете написать многопотоковый код, который будет работать на платформах с графическими интерфейсами, где отсутствует поддержка драйверов для доступа к контексту многопоточного устройства.

Если приложение поддерживает раздельные потоки для обработки списков команд и для воспроизведения кадров, вы, возможно, захотите, чтобы графический процессор (GPU) оставался активным, обрабатывая списки команд при своевременном воспроизведении кадров без ощутимых перебоев или запаздывания. В этом случае можно использовать отдельный [ **ID3D11DeviceContext** ](https://docs.microsoft.com/windows/desktop/api/d3d11/nn-d3d11-id3d11devicecontext) для каждого потока, а также для совместного использования ресурсов (например, текстуры), создавая их с помощью D3D11\_РЕСУРСОВ\_Прочее \_Флаг SHARED. В этом сценарии [**ID3D11DeviceContext::Flush**](https://docs.microsoft.com/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-flush) должен вызываться в потоке обработки, чтобы завершить выполнение списка команд до вывода результатов обработки объекта ресурса в потоке воспроизведения.

## <a name="deferred-rendering"></a>Отложенная визуализация


Отложенная визуализация записывает графические команды в список команд для воспроизведения спустя некоторое время. Отложенная визуализация предназначена для поддержки визуализации в одном потоке при записи команд для визуализации в дополнительных потоках. После того как выполнение этих команд завершится, их можно выполнить в потоке, который создает окончательный объект воспроизведения (буфер кадров, текстуру или другие выходные данные в графическом формате).

Создайте отложенный контекст, используя объект [**ID3D11Device::CreateDeferredContext**](https://docs.microsoft.com/windows/desktop/api/d3d11/nf-d3d11-id3d11device-createdeferredcontext) (вместо объекта [**D3D11CreateDevice**](https://docs.microsoft.com/windows/desktop/api/d3d11/nf-d3d11-d3d11createdevice) или [**D3D11CreateDeviceAndSwapChain**](https://docs.microsoft.com/windows/desktop/api/d3d11/nf-d3d11-d3d11createdeviceandswapchain), создающих мгновенный контекст). Подробнее см. в разделе [Мгновенная и отложенная визуализация](https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render).

## <a name="related-topics"></a>См. также


* [Знакомство с многопоточностью в Direct3D 11](https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-intro)

 

 




