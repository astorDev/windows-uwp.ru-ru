---
author: mtoepke
title: "Асинхронное программирование (DirectX и C++)"
description: "В данной статье рассматриваются различные вопросы использования асинхронного программирования и потоковой модели с DirectX."
ms.assetid: 17613cd3-1d9d-8d2f-1b8d-9f8d31faaa6b
ms.author: mtoepke
ms.date: 02/08/2017
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: "Windows 10, uwp, игры, асинхронное программирование, directx"
ms.openlocfilehash: fe3798e475654d4d0ae7773ac26889906d40b3df
ms.sourcegitcommit: 909d859a0f11981a8d1beac0da35f779786a6889
ms.translationtype: HT
ms.contentlocale: ru-RU
---
# <a name="asynchronous-programming-directx-and-c"></a>Асинхронное программирование (DirectX и C++)


\[ Обновлено для приложений UWP в Windows 10. Статьи о Windows 8.x см. в [архиве](http://go.microsoft.com/fwlink/p/?linkid=619132) \]

В данной статье рассматриваются различные вопросы использования асинхронного программирования и потоковой модели с DirectX.

## <a name="async-programming-and-directx"></a>Асинхронное программирование и DirectX


Если вы только изучаете DirectX или даже уже имеете достаточный опыт в нем, предусмотрите размещение всех своих графических конвейеров в одном потоке. В каждой заданной сцене игры имеются общие ресурсы, такие как точечные рисунки, шейдеры и другие ресурсы, которые требуют монопольного доступа. Эти же ресурсы требуют, чтобы вы синхронизировали доступ к ним среди параллельных потоков. Визуализация является сложным процессом для распараллеливания среди нескольких потоков.

Однако если ваша игра достаточно сложная или вы хотите улучшить ее быстродействие, вы можете использовать асинхронное программирование для распараллеливания некоторых компонентов, не относящихся к вашему конвейеру отрисовки. Ваше приложение может воспользоваться преимуществами возможностей современного оборудования, многоядерных и гиперпотоковых ЦП. Обеспечить это можно также благодаря асинхронному программированию для разработки некоторых компонентов вашей игры, которым не требуется прямой доступ к контексту устройств Direct3D, например:

-   файловый ввод-вывод
-   физика
-   искусственный интеллект
-   сеть
-   звук
-   элементы управления
-   компоненты пользовательского интерфейса, написанные на XAML

Ваше приложение может оперировать этими компонентами при работе с несколькими параллельными потоками. Файловый ввод-вывод, особенно с загрузкой ресурсов, выполняется значительно эффективнее при асинхронной загрузке, поскольку ваша игра или приложение могут находиться в интерактивном состоянии, пока загружаются или передаются в потоковом режиме несколько (или несколько сотен) мегабайт ресурсов. Самый простой способ создания и управления этими потоками — это использование [библиотеки параллельных шаблонов](https://msdn.microsoft.com/library/dd492418.aspx) и шаблона **task**, содержащегося в пространстве имен **concurrency**, которое определено в PPLTasks.h. Использование [библиотеки параллельных шаблонов](https://msdn.microsoft.com/library/dd492418.aspx) обеспечивает непосредственное преимущество при использовании многоядерных и гиперпотоковых ЦП и может улучшить все показатели, включая воспринимаемое время загрузки, задержки и запаздывание, которые сопровождают вычисления с большой нагрузкой на ЦП или сеть.

> **Примечание**. В приложениях универсальной платформы Windows (UWP) пользовательский интерфейс полностью работает в однопотоковом подразделении (STA). Если вы создаете пользовательский интерфейс для вашей игры DirectX с помощью [межпрограммного взаимодействия XAML](directx-and-xaml-interop.md), то доступ к элементам управления можно получить, только используя STA.

 

## <a name="multithreading-with-direct3d-devices"></a>Многопоточность с устройствами Direct3D


Многопоточность для контекстов устройств доступна только применительно к графическим устройствам, которые поддерживают компонент Direct3D уровня 11\_0 и выше. Однако можно повысить эффективность использования этого мощного графического процессора (GPU) на многих платформах, таких как выделенные игровые платформы. В простейшем случае можно отделить визуализацию наложения элементов HUD от визуализации сцен 3D и их проекции, а также сделать так, чтобы оба компонента использовали отдельные параллельные конвейеры. Для создания ресурсных объектов и управления ими (текстуры, сетки, шейдеры и другие ресурсы) оба потока должны использовать одинаковый контекст [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385), который является однопотоковым и требует реализации какого-либо механизма синхронизации (например, критические секции) для безопасного доступа к нему. В то время как можно создать отдельные списки команд для контекста устройства в различных потоках (для замедленной визуализации), невозможно воспроизвести эти списки команд одновременно на том же экземпляре **ID3D11DeviceContext**.

Теперь для создания объектов ресурса ваше приложение может также использовать объект [**ID3D11Device**](https://msdn.microsoft.com/library/windows/desktop/ff476379), который является надежным при реализации многопоточности. Итак, почему бы всегда не использовать **ID3D11Device** вместо [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385)? В настоящее время для некоторых графических интерфейсов недоступна поддержка драйверов, позволяющих реализовывать многопоточность. Можно запросить устройство и выяснить, поддерживает ли оно многопоточность, но если вы рассчитываете на более широкую аудиторию, то для управления объектом ресурса имеет смысл выбрать однопотоковый контекст **ID3D11DeviceContext**. Когда драйвер графического устройства не поддерживает многопоточность или списки команд, Direct3D 11 пытается получить синхронизированный доступ к контексту устройства изнутри, и если списки команд не поддерживаются, он обеспечивает программную реализацию. В результате вы можете написать многопотоковый код, который будет работать на платформах с графическими интерфейсами, где отсутствует поддержка драйверов для доступа к контексту многопоточного устройства.

Если приложение поддерживает раздельные потоки для обработки списков команд и для воспроизведения кадров, вы, возможно, захотите, чтобы графический процессор (GPU) оставался активным, обрабатывая списки команд при своевременном воспроизведении кадров без ощутимых перебоев или запаздывания. В таком случае можно использовать отдельный контекст [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385) для каждого потока и предоставлять общий доступ к ресурсам (например, текстурам), создавая их с флагом D3D11\_RESOURCE\_MISC\_SHARED. В этом сценарии [**ID3D11DeviceContext::Flush**](https://msdn.microsoft.com/library/windows/desktop/ff476425) должен вызываться в потоке обработки, чтобы завершить выполнение списка команд до вывода результатов обработки объекта ресурса в потоке воспроизведения.

## <a name="deferred-rendering"></a>Отложенная визуализация


Отложенная визуализация записывает графические команды в список команд для воспроизведения спустя некоторое время. Отложенная визуализация предназначена для поддержки визуализации в одном потоке при записи команд для визуализации в дополнительных потоках. После того как выполнение этих команд завершится, их можно выполнить в потоке, который создает окончательный объект воспроизведения (буфер кадров, текстуру или другие выходные данные в графическом формате).

Создайте отложенный контекст, используя объект [**ID3D11Device::CreateDeferredContext**](https://msdn.microsoft.com/library/windows/desktop/ff476505) (вместо объекта [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082) или [**D3D11CreateDeviceAndSwapChain**](https://msdn.microsoft.com/library/windows/desktop/ff476083), создающих мгновенный контекст). Подробнее см. в разделе [Мгновенная и отложенная визуализация](https://msdn.microsoft.com/library/windows/desktop/ff476892).

## <a name="related-topics"></a>Связанные темы


* [Вводные сведения о многопоточности в Direct3D 11](https://msdn.microsoft.com/library/windows/desktop/ff476891)

 

 




