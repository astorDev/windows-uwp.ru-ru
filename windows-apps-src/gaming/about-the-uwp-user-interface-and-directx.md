---
author: mtoepke
title: Объект приложения и DirectX
description: В играх универсальной платформы Windows (UWP) с DirectX используется мало элементов и объектов интерфейса Windows.
ms.assetid: 46f92156-29f8-d65e-2587-7ba1de5b48a6
ms.author: mtoepke
ms.date: 02/08/2017
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp, directx, объект приложения
ms.localizationpriority: medium
ms.openlocfilehash: fcbe68516e3ad8b2643faf68900e3305f18e8bbf
ms.sourcegitcommit: 5dda01da4702cbc49c799c750efe0e430b699502
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/21/2018
ms.locfileid: "4118296"
---
# <a name="the-app-object-and-directx"></a>Объект приложения и DirectX



В играх универсальной платформы Windows (UWP) с DirectX используется мало элементов и объектов интерфейса Windows. Поскольку они выполняются на более низком уровне в стеке среды выполнения Windows, они должны взаимодействовать со структурой пользовательского интерфейса более фундаментальным способом: напрямую получая доступ и взаимодействуя с объектом приложения. Узнайте, когда и как происходит такое взаимодействие и как вы, как разработчик DirectX, можете эффективно использовать эту модель при разработке приложений UWP.

См. сведения о условия незнакомых графики или понятия, которые могут возникнуть при чтении [глоссарий графики Direct3D](../graphics-concepts/index.md) .

## <a name="the-important-core-user-interface-namespaces"></a>Важные основные пространства имен пользовательского интерфейса


Сначала отметим пространства имен среды выполнения Windows, которые необходимо включить (с помощью ключевого слова **using**) в приложение UWP. Рассмотрим подробнее.

-   [**Windows.ApplicationModel.Core**](https://msdn.microsoft.com/library/windows/apps/br205865)
-   [**Windows.ApplicationModel.Activation**](https://msdn.microsoft.com/library/windows/apps/br224766)
-   [**Windows.UI.Core**](https://msdn.microsoft.com/library/windows/apps/br208383)
-   [**Windows.System**](https://msdn.microsoft.com/library/windows/apps/br241814)
-   [**Windows.Foundation**](https://msdn.microsoft.com/library/windows/apps/br226021)

> **Примечание.** Если вы не разрабатываете приложение UWP, используйте компоненты пользовательского интерфейса, предоставленные в библиотеках и пространствах имен JavaScript или XAML, а не типы, предоставленные в этих пространствах имен.

 

## <a name="the-windows-runtime-app-object"></a>Объект приложения среды выполнения Windows


В приложении UWP необходимо получить поставщик окон или представлений, чтобы можно было получить представление и подключить собственную цепочку буферов (ваши буферы отображения). Такое представление также можно привязать к событиям окон для вашего запущенного приложения. Чтобы получить родительское окно для объекта приложения, определяемого типом [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225), создайте тип, реализующий интерфейс [**IFrameworkViewSource**](https://msdn.microsoft.com/library/windows/apps/hh700482), как это было сделано в предыдущем фрагменте кода.

Здесь описаны основные действия для получения окна с помощью основной структуры пользовательского интерфейса.

1.  Создайте тип, реализующий интерфейс [**IFrameworkView**](https://msdn.microsoft.com/library/windows/apps/hh700478). Это ваше представление.

    В этом типе определяются:

    -   Метод [**Initialize**](https://msdn.microsoft.com/library/windows/apps/hh700495), принимающий экземпляр класса [**CoreApplicationView**](https://msdn.microsoft.com/library/windows/apps/br225017) в качестве параметра. Чтобы получить экземпляр этого типа, вызовите метод [**CoreApplication.CreateNewView**](https://msdn.microsoft.com/library/windows/apps/dn297278). Объект приложения вызывает его при запуске приложения.
    -   Метод [**SetWindow**](https://msdn.microsoft.com/library/windows/apps/hh700509), принимающий экземпляр класса [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) в качестве параметра. Экземпляр этого типа можно получить, обратившись к свойству [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br225019) в новом экземпляре класса [**CoreApplicationView**](https://msdn.microsoft.com/library/windows/apps/br225017).
    -   Метод [**Load**](https://msdn.microsoft.com/library/windows/apps/hh700501), принимающий строку для точки входа в качестве единственного параметра. При вызове этого метода объект приложения предоставляет строку точки входа. На этом этапе настраиваются ресурсы. Здесь вы создаете ресурсы устройства. Объект приложения вызывает его при запуске приложения.
    -   Метод [**Run**](https://msdn.microsoft.com/library/windows/apps/hh700505), активирующий объект класса [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) и запускающий диспетчер событий окна. Объект приложения вызывает его при запуске процесса приложения.
    -   Метод [**Uninitialize**](https://msdn.microsoft.com/library/windows/apps/hh700523), очищающий ресурсы, которые настроены в вызове метода [**Load**](https://msdn.microsoft.com/library/windows/apps/hh700501). Объект приложения вызывает этот метод при закрытии приложения.

2.  Создайте тип, реализующий интерфейс [**IFrameworkViewSource**](https://msdn.microsoft.com/library/windows/apps/hh700482). Это ваш поставщик представлений.

    В этом типе определяются:

    -   Метод [**CreateView**](https://msdn.microsoft.com/library/windows/apps/hh700491), возвращающий экземпляр реализации [**IFrameworkView**](https://msdn.microsoft.com/library/windows/apps/hh700478), полученной в шаге 1.

3.  Передайте экземпляр поставщика представлений методу [**CoreApplication.Run**](https://msdn.microsoft.com/library/windows/apps/hh700469) из объекта **main**.

Учитывая эти основы, рассмотрим другие возможности, на которые требуется распространить этот подход.

## <a name="core-user-interface-types"></a>Основные типы пользовательского интерфейса


Здесь рассматриваются другие основные типы пользовательского интерфейса в среде выполнения Windows, которые могут быть полезны.

-   [**Windows.ApplicationModel.Core.CoreApplicationView**](https://msdn.microsoft.com/library/windows/apps/br225017)
-   [**Windows.UI.Core.CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225)
-   [**Windows.UI.Core.CoreDispatcher**](https://msdn.microsoft.com/library/windows/apps/br208211)

Такие типы позволяют получить доступ к представлению приложения, в частности, к битам, отвечающим за прорисовку содержимого родительского окна приложения и обработку событий, предназначенных для этого окна. Процесс окна приложения — это *однопотоковое подразделение приложения* (ASTA), изолированное и обрабатывающее все обратные вызовы.

Представление приложения создается поставщиком представления для окна приложения, и в большинстве случаев оно будет реализовано специальным пакетом платформы или самой системой, поэтому вам не нужно его реализовывать. Для DirectX необходимо реализовать тонкий поставщик представлений, как обсуждалось ранее. Между следующими компонентами и видами поведения существует особое взаимно однозначное соотношение:

-   представление приложения, соответствующее типу класса [**CoreApplicationView**](https://msdn.microsoft.com/library/windows/apps/br225017) и определяющее методы обновления окна.
-   ASTA, определение которого задает поведение приложения. В ASTA нельзя создать экземпляры типов с атрибутами COM STA.
-   Поставщик представлений, который приложение получает из системы или вашей реализации.
-   Родительское окно, представленное типом класса [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225).
-   Привлечение ресурсов для всех событий активации. У представлений и окон отдельные события активации.

Итак, объект приложения предоставляет фабрику поставщиков представлений. Для приложения он создает поставщик представлений и экземпляр родительского окна. Поставщик представлений определяет представление для родительского окна приложения. Теперь обсудим особенности данного представления и родительского окна.

## <a name="coreapplicationview-behaviors-and-properties"></a>Поведение и свойства класса CoreApplicationView


[**CoreApplicationView**](https://msdn.microsoft.com/library/windows/apps/br225017) представляет текущее представление приложения. Во время инициализации singleton-объект приложения создает представление приложения, ожидающее своей активации. Класс [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225), отображающий это представление, можно получить, обратившись к его свойству [**CoreApplicationView.CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br225019), а события активации и деактивации для этого представления можно обработать, зарегистрировав делегаты с помощью события [**CoreApplicationView.Activated**](https://msdn.microsoft.com/library/windows/apps/br225018).

## <a name="corewindow-behaviors-and-properties"></a>Поведение и свойства класса CoreWindow


Родительское окно (экземпляр класса [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225)) создается и передается поставщику представлений при инициализации объекта приложения. Если у приложения есть окно для отображения, оно его отображает; в противном случае просто инициализирует данное представление.

[**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) предоставляет несколько событий, характерных для поведения входного и основного окон. Такие события можно обрабатывать, регистрируя с их помощью собственные делегаты.

Для данного окна также можно получить диспетчер событий, обратившись к свойству [**CoreWindow.Dispatcher**](https://msdn.microsoft.com/library/windows/apps/br208264), предоставляющему экземпляр класса [**CoreDispatcher**](https://msdn.microsoft.com/library/windows/apps/br208211).

## <a name="coredispatcher-behaviors-and-properties"></a>Поведение и свойства класса CoreDispatcher


Для окна с типом класса [**CoreDispatcher**](https://msdn.microsoft.com/library/windows/apps/br208211) можно определить поведение потоков отправки событий. Для этого типа есть один особенно важный метод: метод [**CoreDispatcher.ProcessEvents**](https://msdn.microsoft.com/library/windows/apps/br208215), запускающий обработку событий окна. Вызов этого метода с неправильным параметром для приложения может привести к неожиданному поведению обработки событий любого рода.

| Параметр CoreProcessEventsOption                                                           | Описание                                                                                                                                                                                                                                  |
|------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [**CoreProcessEventsOption.ProcessOneAndAllPending**](https://msdn.microsoft.com/library/windows/apps/br208217) | Отправляет все доступные в настоящее время события в очереди. Если ожидающие события отсутствуют, ожидает следующее новое событие.                                                                                                                                 |
| [**CoreProcessEventsOption.ProcessOneIfPresent**](https://msdn.microsoft.com/library/windows/apps/br208217)     | Отправляет новое событие, если оно ожидает выполнения в очереди. Если ожидающие события отсутствуют, не ожидает вызова следующего нового события и немедленно возвращается.                                                                                          |
| [**CoreProcessEventsOption.ProcessUntilQuit**](https://msdn.microsoft.com/library/windows/apps/br208217)        | Ожидает новые события и отправляет все доступные события. Продолжает это поведение до тех пор, пока не будет закрыто окно или приложением не будет вызван метод [**Close**](https://msdn.microsoft.com/library/windows/apps/br208260) в экземпляре [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225). |
| [**CoreProcessEventsOption.ProcessAllIfPresent**](https://msdn.microsoft.com/library/windows/apps/br208217)     | Отправляет все доступные в настоящее время события в очереди. Если ожидающие события отсутствуют, немедленно возвращается.                                                                                                                                          |

 

В приложениях UWP, использующих DirectX, следует использовать параметр [**CoreProcessEventsOption.ProcessAllIfPresent**](https://msdn.microsoft.com/library/windows/apps/br208217), чтобы предотвратить срабатывание правил блокировки, которая может прервать обновление графики.

## <a name="asta-considerations-for-directx-devs"></a>Соображения относительно однопотокового подразделения приложения для разработчиков, использующих DirectX


Чтобы разместить представления пользовательского интерфейса, объект приложения, определяющий состояние вашего приложения UWP и DirectX во время выполнения, использует потоковую модель, которая называется однопотоковым подразделением приложения (ASTA). Если вы разрабатываете приложение UWP и DirectX, вы уже знакомы со свойствами однопотокового подразделения приложения, потому что любой поток, обрабатываемый из вашего приложения UWP и DirectX, должен использовать либо API [**Windows::System::Threading**](https://msdn.microsoft.com/library/windows/apps/br229642), либо [**CoreWindow::CoreDispatcher**](https://msdn.microsoft.com/library/windows/apps/br208211). (Можно получить объект [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) для однопотокового подразделения приложения, вызвав [**CoreWindow::GetForCurrentThread**](https://msdn.microsoft.com/library/windows/apps/hh701589) из своего приложения.)

Самое главное для вас как разработчика приложений UWP и DirectX — знать, что потоку вашего приложения необходимо позволить управлять потоками многопотокового подразделения, задав **Platform::MTAThread** в функции **main()**.

```cpp
[Platform::MTAThread]
int main(Platform::Array<Platform::String^>^)
{
    auto myDXAppSource = ref new MyDXAppSource(); // your view provider factory 
    CoreApplication::Run(myDXAppSource);
    return 0;
}
```

Когда объект для вашего приложения UWP и DirectX активизируется, он создает однопотоковое подразделение приложения, которое будет использоваться для представления пользовательского интерфейса. Новый поток однопотокового подразделения приложения вызывает фабрику поставщика представления, чтобы создать поставщика представления для объекта вашего приложения; в результате код этого поставщика будет выполняться в этом новом потоке.

Кроме того, любой поток, являющийся ответвлением от однопотокового подразделения приложения, должен быть в многопотоковом подразделении. Имейте в виду, что любые потоки многопотокового подразделения, которые вы создаете, могут создавать проблемы повторного входа и приводить к взаимоблокировкам.

Если вы занимаетесь адаптацией существующего кода для запуска его в потоке однопотокового подразделения приложения, имейте в виду следующее:

-   Примитивы ожидания, такие как [**CoWaitForMultipleObjects**](https://msdn.microsoft.com/library/windows/desktop/hh404144), ведут себя в однопотоковом подразделении приложения (ASTA) не так, как в однопотоковом подразделении (STA).
-   Модальный цикл вызова COM в ASTA работает иначе. Вы больше не можете получать посторонние вызовы, пока выполняется исходящий вызов. Например, следующее поведение создаст взаимоблокировку из ASTA (что немедленно приведет к сбою приложения):
    1.  ASTA вызывает объект MTA и передает указатель на интерфейс (P1).
    2.  Позже ASTA вызывает тот же самый объект MTA. Объект MTA вызывает P1 прежде, чем тот вернется в ASTA.
    3.  P1 не может войти в ASTA, поскольку тот блокируется во время осуществления постороннего вызова. Однако поток MTA блокируется, поскольку пытается осуществить вызов P1.

    Эту ситуацию можно разрешить следующими способами:
    -   с помощью шаблона **async**, определенного в библиотеке параллельных шаблонов (PPLTasks.h);
    -   вызовом метода [**CoreDispatcher::ProcessEvents**](https://msdn.microsoft.com/library/windows/apps/br208215) из однопотокового подразделения приложения вашего приложения (главного потока приложения), чтобы разрешить произвольные вызовы.

    Тем не менее нельзя полагаться на немедленную доставку несвязанных вызовов в однопотоковое подразделение приложения вашего приложения. Для получения дополнительной информации об асинхронных вызовах см. раздел [Асинхронное программирование на языке C++](https://msdn.microsoft.com/library/windows/apps/mt187334).

В общем, при разработке приложения UWP используйте объект [**CoreDispatcher**](https://msdn.microsoft.com/library/windows/apps/br208211) для объектов [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) и [**CoreDispatcher::ProcessEvents**](https://msdn.microsoft.com/library/windows/apps/br208215) приложения, чтобы обработать все потоки пользовательского интерфейса, а не пытайтесь самостоятельно создавать потоки многопотокового подразделения и управлять ими. Если вам нужен отдельный поток, которым вы не можете управлять с помощью объекта **CoreDispatcher**, используйте асинхронные шаблоны и следуйте указаниям, приведенным ранее, чтобы избежать проблем с повторным вхождением.

 

 




