---
author: mithom
title: Аркадный джойстик
description: Для обнаружения аркадных джойстиков и чтения их данных используйте API аркадных джойстиков Windows.Gaming.Input.
ms.assetid: 2E52232F-3014-4C8C-B39D-FAC478BA3E01
ms.author: wdg-dev-content
ms.date: 02/08/2017
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp, игры, аркадный джойстик, ввод
ms.openlocfilehash: b0411dcf1fd75ec7dc31d29a39e95f5c26073953
ms.sourcegitcommit: 909d859a0f11981a8d1beac0da35f779786a6889
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.locfileid: "223932"
---
# <a name="arcade-stick"></a>Аркадный джойстик

На этой странице приведены основные принципы программирования для аркадных джойстиков Xbox One с помощью [Windows.Gaming.Input.ArcadeStick][аркадный джойстик] и связанных API-интерфейсов для универсальной платформы Windows (UWP).

Изучив информацию на этой странице, вы узнаете:
* как составить список подключенных аркадных джойстиков и их пользователей;
* как определить, что аркадный джойстик был добавлен или удален;
* как считывать входные данные с одного или нескольких аркадных джойстиков;
* как аркадные джойстики функционируют в качестве устройства для навигации.


## <a name="arcade-stick-overview"></a>Обзор аркадного джойстика

Аркадные джойстики— это устройства ввода, позволяющие передать ощущение игры на стационарном игровом автомате и обладающие высокоточными цифровыми элементами управления. Аркадные джойстикиявляются идеальным устройством ввода для файтингов и других аркадных игр, а также подходят для любой игры, в которой используются полностью цифровые элементы управления. Поддержка аркадных джойстиков в приложениях UWP для Windows 10 и Xbox One реализована с помощью пространства имен [Windows.Gaming.Input][].

Аркадные джойстики Xbox One оснащены цифровым джойстиком, способным двигаться в 8 направлениях, шестью кнопками **действий** и двумя **специальными** кнопками; они являются полностью цифровыми устройствами ввода и не поддерживают аналоговые элементы управления и вибрацию. Аркадные джойстики Xbox One также оснащены кнопками **просмотра** и **меню**, используемыми для навигации по пользовательскому интерфейсу, они не предназначены для поддержки игровых команд и располагаются не так удобно, как кнопки джойстика.

### <a name="ui-navigation"></a>Навигация по пользовательскому интерфейсу

Чтобы облегчить задачу обеспечения поддержки множества разных устройств ввода для навигации по пользовательскому интерфейсу и сохранить единообразие используемых для этого элементов управления в разных играх и на разных устройствах, большинство _физических_ устройств ввода параллельно выполняют функцию отдельного _логического_ устройства ввода под названием [контроллер навигации по пользовательскому интерфейсу](ui-navigation-controller.md). Контроллер навигации по пользовательскому интерфейсу предоставляет стандартный набор элементов управления для команд навигации по пользовательскому интерфейсу на разных устройствах ввода.

Для использования аркадных джойстиков в качестве контроллера навигации по пользовательскому интерфейсу в них реализован [необходимый набор](ui-navigation-controller.md#required-set) команд навигации, заданных для джойстика и кнопок **просмотра**, **меню**, **действия 1** и **действия 2**.

| Команда навигации | Действие аркадного джойстика  |
| ------------------:| ------------------- |
|                 Вверх | Джойстик вверх            |
|               Вниз | Джойстик вниз          |
|               Влево | Джойстик влево          |
|              Вправо | Джойстик вправо         |
|               Просмотр | Кнопка просмотра         |
|               Меню | Кнопка меню         |
|             Принять | Кнопка действия 1     |
|             Отмена | Кнопка действия 2     |

Аркадные джойстикине поддерживают какие-либо [дополнительные наборы](ui-navigation-controller.md#optional-set) команд навигации.


## <a name="detect-and-track-arcade-sticks"></a>Обнаружение и отслеживание аркадных джойстиков

Аркадными джойстиками управляет система, поэтому их не требуется создавать или инициализировать. Система предоставляет список подключенных аркадных джойстиков и событий для уведомления о добавлении или удалении аркадного джойстика.

### <a name="the-arcade-sticks-list"></a>Список аркадных джойстиков

Класс [ArcadeStick][] предоставляет статическое свойство [ArcadeSticks][] — список подключенных аркадных джойстиков, доступный только для чтения. Так как вы можете быть заинтересованы в работе только с некоторыми подключенными аркадными джойстиками, рекомендуется создать собственную коллекцию джойстиков, а не осуществлять доступ к ним через свойство `ArcadeSticks`.

В следующем примере кода выполняется копирование всех подключенных аркадных джойстиков в новую коллекцию.
```cpp
auto myArcadeSticks = ref new Vector<ArcadeStick^>();

for (auto arcadestick : ArcadeStick::ArcadeSticks)
{
    // This code assumes that you're interested in all arcade sticks.
    myArcadeSticks->Append(arcadestick);
}
```

### <a name="adding-and-removing-arcade-sticks"></a>Добавление и удаление аркадных джойстиков

При добавлении или удалении аркадного джойстика возникают события [ArcadeStickAdded][] и [ArcadeStickRemoved][]. Вы можете зарегистрировать обработчики для этих событий, чтобы отслеживать подключенные в данный момент аркадные джойстики.

В следующем примере кода выполняется запуск отслеживания добавленного аркадного джойстика.
```cpp
ArcadeStick::ArcadeStickAdded += ref new EventHandler<ArcadeStick^>(Platform::Object^, ArcadeStick^ args)
{
    // This code assumes that you're interested in all new arcade sticks.
    myArcadeSticks->Append(args);
}
```

Следующий пример кода останавливает отслеживание удаленного аркадного джойстика.
```cpp
ArcadeStick::ArcadeStickRemoved += ref new EventHandler<ArcadeStick^>(Platform::Object^, ArcadeStick^ args)
{
    unsigned int indexRemoved;

    if(myArcadeSticks->IndexOf(args, &indexRemoved))
    {
        myArcadeSticks->RemoveAt(indexRemoved);
    }
}
```

### <a name="users-and-headsets"></a>Пользователи и гарнитуры

Каждый аркадный джойстик можно связать с учетной записью пользователя, чтобы соотнести его личность с игровым процессом. Также к аркадному джойстику можно подключить гарнитуру для реализации голосового чата или других внутриигровых возможностей. Дополнительные сведения о работе с пользователями и гарнитурами см. в разделах [Отслеживание пользователей и их устройств](input-practices-for-games.md#tracking-users-and-their-devices) и [Гарнитура](headset.md).


## <a name="reading-the-arcade-stick"></a>Чтение аркадных джойстиков

После выбора аркадного джойстика, с которым вы хотите работать, можно приступить к сбору данных, вводимых с его помощью. Тем не менее, в отличие от некоторых других типов вводимых данных, с которыми вы, возможно, уже знакомы, аркадные джойстики не передают данные об изменении состояния путем создания событий. Вместо этого необходимо регулярно считывать их текущее состояние, _опрашивая_ соответствующие устройства.

### <a name="polling-the-arcade-stick"></a>Опрос аркадного джойстика

В ходе опроса сохраняется моментальный снимок аркадного джойстика в конкретный момент времени. Этот подход к сбору данных ввода подходит для большинства игр, так как их логика, как правило, выполняется в рамках детерминированного цикла и не привязана к событиям. Также обычно проще интерпретировать игровые команды на основании данных ввода, собранных сразу, а не на основании большого количества единичных событий ввода данных, собранных с течением времени.

Опрос аркадного джойстика выполняется путем вызова функции [GetCurrentReading][], которая возвращает структуру [ArcadeStickReading][], содержащую состояние аркадного джойстика.

В следующем примере кода выполняется опрос аркадного джойстика на предмет его текущего состояния.
```cpp
auto arcadestick = myArcadeSticks[0];

ArcadeStickReading reading = arcadestick->GetCurrentReading();
```

Помимо состояния аркадного джойстика считанные данные содержат метку времени, указывающую точное время извлечения сведений о состоянии. Метку времени удобно использовать для обращения ко времени предыдущего события считывания данных или ко времени моделирования конкретного игрового момента.

### <a name="reading-the-buttons"></a>Считывание данных с кнопок

Все элементы управления аркадного джойстика— четыре направления джойстика, шесть кнопок **действий** и две **специальные** кнопки — предоставляют цифровые данные, указывающие на то, нажаты ли они (вниз) или отпущены (вверх). В целях обеспечения эффективности эти показания кнопок не указываются в виде отдельных логических значений. Вместо этого все они упаковываются в одно битовое поле, представляемое перечислением [ArcadeStickButtons][].

> **Примечание.**    Аркадные джойстики оснащаются дополнительными кнопками, используемыми для навигации по пользовательскому интерфейсу, такими как кнопки **просмотра** и **меню**. Эти кнопки не являются частью перечисления `ArcadeStickButtons`, и данные с них можно считать только при доступе к аркадному джойстику как к устройству навигации по пользовательскому интерфейсу. Дополнительные сведения см. в разделе [Устройство навигации по пользовательскому интерфейсу](ui-navigation-controller.md).

Значения кнопок считываются из свойства `Buttons` структуры [ArcadeStickReading][]. Так как это свойство представляет собой битовое поле, для изоляции значения кнопки, сведения о которой вам интересны, используется побитовая маскировка. Кнопка нажата (вниз), когда соответствующий бит установлен; в противном случае кнопка отпущена (вверх).

Следующий пример кода определяет, нажата ли кнопка действия 1.
```cpp
if (ArcadeStickButtons::Action1 == (reading.Buttons & ArcadeStickButtons::Action1))
{
    // Action 1 is pressed
}
```

Следующий пример кода определяет, отпущена ли кнопка действия 1.
```cpp
if (ArcadeStickButtons::None == (reading.Buttons & ArcadeStickButtons::Action1))
{
    // Action 1 is released (not pressed)
}
```

Иногда может потребоваться определить, когда кнопка переходит из нажатого состояния в отпущенное или наоборот, нажаты ли или отпущены кнопки (несколько) либо узнать особое расположение ряда кнопок (когда некоторые кнопки нажаты, а некоторые отпущены). Сведения о том, как определить эти условия, см. в разделах [Определение положений кнопки](input-practices-for-games.md#detecting-button-transitions) и [Определение сложных схем положений кнопок](input-practices-for-games.md#detecting-complex-button-arrangements).

## <a name="run-the-inputinterfacing-sample"></a>Запуск примера кода InputInterfacing

В примере кода [InputInterfacingUWP _(в центре GitHub)_](https://github.com/Microsoft/Xbox-ATG-Samples/tree/master/Samples/System/InputInterfacingUWP) показано, как использовать аркадные джойстики и различные типы устройств ввода вместе, а также представлено, как эти устройства ввода работают в качестве контроллеров навигации по пользовательскому интерфейсу.


## <a name="see-also"></a>См. также
[Windows.Gaming.Input.UINavigationController][]
[Windows.Gaming.Input.IGameController][]

[Windows.Gaming.Input]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.aspx
[Windows.Gaming.Input.IGameController]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.igamecontroller.aspx
[Windows.Gaming.Input.UINavigationController]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.uinavigationcontroller.aspx
[arcadestick]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.arcadestick.aspx
[arcadesticks]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.arcadestick.arcadesticks.aspx
[arcadestickadded]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.arcadestick.arcadestickadded.aspx
[arcadestickremoved]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.arcadestick.arcadestickremoved.aspx
[getcurrentreading]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.arcadestick.getcurrentreading.aspx
[arcadestickreading]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.arcadestickreading.aspx
[arcadestickbuttons]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.arcadestickbuttons.aspx
