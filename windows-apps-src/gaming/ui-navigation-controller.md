---
author: eliotcowley
title: Контроллер навигации по пользовательскому интерфейсу
description: Используйте API контроллера навигации по пользовательскому интерфейсу Windows.Gaming.Input для обнаружения и чтения различных устройств ввода для навигации по пользовательскому интерфейсу.
ms.assetid: 5A14926D-8C2E-4DE8-AAFB-BEEB9BFE91A5
ms.author: elcowle
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp, игры, пользовательский интерфейс, навигация
ms.localizationpriority: medium
ms.openlocfilehash: a0ec2790f6dddf93959a8c826602c0ac622a7d23
ms.sourcegitcommit: 144f5f127fc4fbd852f2f6780ef26054192d68fc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/02/2018
ms.locfileid: "5974518"
---
# <a name="ui-navigation-controller"></a>Контроллер навигации по пользовательскому интерфейсу

На этой странице приводятся основные принципы программирования устройств навигации по пользовательскому интерфейсу с использованием контроллера [Windows.Gaming.Input.UINavigationController][uinavigationcontroller] и связанных API для универсальной платформы Windows (UWP).

Изучив информацию на этой странице, вы узнаете:
* Как получить список подключенных устройств навигации по ИП и их пользователей
* Как определить, что устройство навигации было добавлено или удалено
* Как прочитать входные данные с одного или нескольких устройств навигации по ИП
* Как геймпады и аркадные джойстики функционируют в качестве устройств навигации

## <a name="ui-navigation-controller-overview"></a>Обзор контроллера навигации по пользовательскому интерфейсу

Почти во всех играх имеется хотя бы какой-то пользовательский интерфейс (будь то меню перед игрой или диалоговые окна в игре), отделенный от самой игры. У игроков должна быть возможность перемещаться по этому пользовательскому интерфейсу, используя выбранное ими устройство ввода, однако добавление поддержки для всех разновидностей устройств ввода весьма проблематично для разработчиков. Кроме того, это может привести к несоответствиям между играми и устройствами ввода и запутать игроков. По этим причинам был создан API [UINavigationController][].

Контроллеры навигации по пользовательскому интерфейсу— это _логические_ устройства ввода, предоставляющие вокабуляр стандартных команд навигации по пользовательскому интерфейсу, которые могут поддерживаться различными _физическими_ устройствами ввода. _Контроллер навигации по пользовательскому интерфейсу_— это другой взгляд на физическое устройство ввода; говоря _устройство навигации_, мы имеем в виду любое физическое устройство ввода, которое рассматривается как контроллер навигации. Выполняя программирование для устройства навигации, а не конкретных устройств ввода, разработчики избавляются от необходимости обеспечивать поддержку разных устройств ввода и достигают единообразия по умолчанию.

Поскольку количество и разнообразие элементов управления, поддерживаемых каждым устройством ввода, могут существенно различаться и поскольку определенные устройства ввода могут поддерживать более широкий набор команд навигации, интерфейс контроллера навигации разделяет вокабуляр команд на _обязательный набор_, который содержит основные, наиболее распространенные команды, и _дополнительный набор_, содержащий удобные, но не основные команды. Все устройства навигации поддерживают все команды из _обязательного набора_ и могут поддерживать все, некоторые или никакие команды из _необязательного набора_.

### <a name="required-set"></a>Обязательный набор

Устройства навигации могут поддерживать все команды навигации из _обязательного набора_; это команды направления (вверх, вниз, влево, вправо), просмотра, меню, принятия и отмены.

Команды направления предназначены для базовой [навигации по осям XY](../design/devices/designing-for-tv.md#xy-focus-navigation-and-interaction) между отдельными элементами пользовательского интерфейса. Команды просмотра и меню предназначены для отображения информации об игре (часто кратковременной и иногда модальной) и для переключения между игрой и контекстами меню соответственно. Команды принятия и отмены предназначены для утвердительных (да) и отрицательных (нет) ответов соответственно.

В следующей таблице перечислены эти команды и их предполагаемое использование с примерами.
| Команда | Целевое использование
| -------:| ---------------
|      Вверх | Навигация вверх по осям XY
|    Вниз | Навигация вниз по осям XY
|    Влево | Навигация влево по осям XY
|   Вправо | Навигация вправо по осям XY
|    Просмотр | Отображение информации об игре _(табло, статистика игры, цели, карта мира или области)_
|    Меню | Основное меню/пауза _(настройки, статус, оборудование, запасы, пауза)_
|  Принять | Положительный ответ _(принять, перейти вперед, подтвердить, начать, да)_
|  Отмена | Отрицательный ответ _(отказаться, отменить, отклонить, остановить, нет)_


### <a name="optional-set"></a>Дополнительный набор

Устройства навигации могут поддерживать все команды навигации из _дополнительного набора_, некоторые или никакие из них; это команды перемещения по страницам (вверх, вниз, влево и вправо), прокрутки (вверх, вниз, влево и вправо) и контекстные команды (контекст 1–4).

Контекстные команды явно не предназначены для работы с приложением и упрощения навигации. Команды перемещения по страницам и прокрутки предназначены для быстрой навигации между страницами или группами элементов пользовательского интерфейса, а также для более точной навигации в пределах элементов пользовательского интерфейса соответственно.

В следующей таблице перечислены эти команды и их предполагаемое использование.
|     Команда | Целевое использование
| -----------:| ------------
|      PageUp | Перейти вверх (к предыдущей вертикальной странице или группе либо странице или группе верхнего уровня)
|    PageDown | Перейти вниз (к следующей вертикальной странице или группе либо странице или группе нижнего уровня)
|    PageLeft | Перейти влево (к расположенной слева или предыдущей горизонтальной странице или группе)
|   PageRight | Перейти вправо (к расположенной справа или следующей горизонтальной странице или группе)
|    ScrollUp | Перейти вверх (в пределах элемента пользовательского интерфейса в фокусе или прокручиваемой группы)
|  ScrollDown | Перейти вниз (в пределах элемента пользовательского интерфейса в фокусе или прокручиваемой группы)
|  ScrollLeft | Перейти влево (в пределах элемента пользовательского интерфейса в фокусе или прокручиваемой группы)
| ScrollRight | Перейти вправо (в пределах элемента пользовательского интерфейса в фокусе или прокручиваемой группы)
|    Context1 | Основное действие с контекстом
|    Context2 | Второе действие с контекстом
|    Context3 | Третьей действие с контекстом
|    Context4 | Четвертое действие с контекстом

> **Примечание**. Несмотря на то что игра может отреагировать на любую команду функцией, которая отличается от целевого использования команды, неожиданного поведения следует избегать. В частности, не следует менять действительную функцию команды, если требуется ее целевое использование— попробуйте назначить новые функции наиболее логичной команде, а противоположные функции— противоположным командам, например PageUp/PageDown. Наконец, подумайте, какие команды поддерживаются всеми видами устройств ввода, каким элементам управления они соответствуют. Помните, что критически важные команды должны быть доступны с любого устройства.

## <a name="gamepad-arcade-stick-and-racing-wheel-navigation"></a>Навигация с помощью геймпада, аркадного джойстика и гоночного руля

Все устройства ввода, поддерживаемые пространством имен Windows.Gaming.Input, являются устройствами навигации по пользовательскому интерфейсу.

В следующей таблице приводится сопоставление _необходимого набора_ команд навигации с различными устройствами ввода.

| Команда навигации | Ввод с геймпада                       | Ввод с аркадного джойстика | Ввод с гоночного руля |
| ------------------:| ----------------------------------- | ------------------ | ------------------ |
|                 Вверх | Левый аналоговый стик вверх / D-клавиша вверх       | Стик вверх           | D-клавиша вверх           |
|               Вниз | Левый аналоговый стик вниз/D-клавиша вниз   | Стик вниз         | D-клавиша вниз         |
|               Влево | Левый аналоговый стик влево/D-клавиша влево   | Стик влево         | D-клавиша влево         |
|              Вправо | Левый аналоговый стик вправо/D-клавиша вправо | Стик вправо        | D-клавиша вправо        |
|               Просмотр | Кнопка просмотра                         | Кнопка просмотра        | Кнопка просмотра        |
|               Меню | Кнопка меню                         | Кнопка меню        | Кнопка меню        |
|             Принять | Кнопка A                            | Кнопка действия 1    | Кнопка A           |
|             Отмена | кнопка B                            | Кнопка действия 2    | Кнопка B           |

В следующей таблице приводится сопоставление _дополнительного набора_ команд навигации с различными устройствами ввода.

| Команда навигации | Ввод с геймпада          | Ввод с аркадного джойстика | Ввод с гоночного руля    |
| ------------------:| ---------------------- | ------------------ | --------------------- |
|             PageUp | Левый триггер           | _не поддерживается_    | _варьируется_              |
|           PageDown | Правый триггер          | _не поддерживается_    | _варьируется_              |
|           PageLeft | Левый бампер            | _не поддерживается_    | _варьируется_              |
|          PageRight | Правый бампер           | _не поддерживается_    | _варьируется_              |
|           ScrollUp | Правый аналоговый стик вверх    | _не поддерживается_    | _варьируется_              |
|         ScrollDown | Правый аналоговый стик вниз  | _не поддерживается_    | _варьируется_              |
|         ScrollLeft | Правый аналоговый стик влево  | _не поддерживается_    | _варьируется_              |
|        ScrollRight | Правый аналоговый стик вправо | _не поддерживается_    | _варьируется_              |
|           Context1 | Кнопка х               | _не поддерживается_    | Кнопка X (_часто_) |
|           Context2 | Кнопка Y               | _не поддерживается_    | Кнопка Y (_часто_) |
|           Context3 | Нажатие левого аналогового стика  | _не поддерживается_    | _варьируется_              |
|           Context4 | Нажатие правого аналогового стика | _не поддерживается_    | _варьируется_              |


## <a name="detect-and-track-ui-navigation-controllers"></a>Обнаружение и отслеживание контроллеров навигации по пользовательскому интерфейсу

Несмотря на то что контроллеры навигации по пользовательскому интерфейсу являются логическими устройствами ввода, они представляют собой физические устройства и система управляет ими аналогичным образом. Их не требуется создавать или инициализировать; система предоставляет список подключенных контроллеров навигации по пользовательскому интерфейсу и событий, уведомляющих вас о добавлении или удалении контроллера навигации по пользовательскому интерфейсу.

### <a name="the-ui-navigation-controllers-list"></a>Список контроллеров навигации по пользовательскому интерфейсу

Класс [UINavigationController][] предоставляет статическое свойство [UINavigationControllers][], которое представляет собой доступный только для чтения список устройств навигации по пользовательскому интерфейсу, которые в настоящее время подключены к системе. Поскольку вам могут быть нужны лишь некоторые подключенные устройства навигации, рекомендуется поддерживать собственную коллекцию устройств, а не осуществлять к ним доступ с помощью свойства `UINavigationControllers`.

В следующем примере в новую коллекцию копируются все подключенные контроллеры навигации по пользовательскому интерфейсу.
```cpp
auto myNavigationControllers = ref new Vector<UINavigationController^>();

for (auto device : UINavigationController::UINavigationControllers)
{
    // This code assumes that you're interested in all navigation controllers.
    myNavigationControllers->Append(device);
}
```

### <a name="adding-and-removing-ui-navigation-controllers"></a>Добавление и удаление контроллеров навигации по пользовательскому интерфейсу

При добавлении или удалении контроллера навигации по пользовательскому интерфейсу создаются события [UINavigationControllerAdded][] и [UINavigationControllerRemoved][]. Для этих событий можно зарегистрировать обработчик, чтобы отслеживать подключенные в настоящее время устройства навигации.

В следующем примере начинается отслеживание добавленного устройства навигации по пользовательскому интерфейсу.
```cpp
UINavigationController::UINavigationControllerAdded += ref new EventHandler<UINavigationController^>(Platform::Object^, UINavigationController^ args)
{
    // This code assumes that you're interested in all new navigation controllers.
    myNavigationControllers->Append(args);
}
```

В следующем примере завершается отслеживание удаленного аркадного джойстика.
```cpp
UINavigationController::UINavigationControllerRemoved += ref new EventHandler<UINavigationController^>(Platform::Object^, UINavigationController^ args)
{
    unsigned int indexRemoved;

    if(myNavigationControllers->IndexOf(args, &indexRemoved))
    {
        myNavigationControllers->RemoveAt(indexRemoved);
    }
}
```

### <a name="users-and-headsets"></a>Пользователи и гарнитура

Каждое устройство навигации можно связать с учетной записью пользователя, тем самым привязав их удостоверение к устройству ввода; привязка гарнитуры позволяет вести голосовой чат и использовать функции навигации. Подробнее о работе с пользователями и гарнитурой см. в разделах [Отслеживание пользователей и их устройств](input-practices-for-games.md#tracking-users-and-their-devices) и [Гарнитура](headset.md).

## <a name="reading-the-ui-navigation-controller"></a>Чтение контроллера навигации по пользовательскому интерфейсу

Идентифицировав нужное устройство навигации по пользовательскому интерфейсу, вы можете получать с него входные данные. Однако в отличие от некоторых других типов ввода, к которым, вы привыкли, устройства навигации не сообщают об изменении состояния, создавая события. Вместо этого для получения стандартной информации об их текущем состоянии вы проводите _опрос_.

### <a name="polling-the-ui-navigation-controller"></a>Опрос контроллера навигации по пользовательскому интерфейсу

Опроса сохраняется моментальный снимок устройства навигации в конкретный момент времени. Такой подход к сбору входных данных отлично подходит для большинства игр, потому что их логика, как правило, выполняется в детерминированном цикле и не зависит от событий; кроме того, проще интерпретировать игровые команды из входных данных, собранных в один момент, чем из многочисленных единичных входных данных, собранных за определенный период.

Для опроса устройства навигации вызывается метод [UINavigationController.GetCurrentReading][getcurrentreading]; эта функция возвращает элемент [UINavigationReading][], который содержит состояние устройства навигации.

```cpp
auto navigationController = myNavigationControllers[0];

UINavigationReading reading = navigationController->GetCurrentReading();
```

### <a name="reading-the-buttons"></a>Чтение кнопок

Каждая кнопка навигации по пользовательскому интерфейсу предоставляет логическое значение, соответствующее определенному действию: нажатию (вниз) или отпусканию (вверх). В целях эффективности значения кнопок не представляются как отдельные логические значения; они объединены в одно из двух битовых полей, представляемых перечислениями [RequiredUINavigationButtons][] и [OptionalUINavigationButtons][].

Кнопки, которые относятся к _обязательному набору_, считываются из свойства `RequiredButtons` структуры [UINavigationReading][]; кнопки, которые относятся к _дополнительному набору_, считываются из свойства `OptionalButtons`. Поскольку эти свойства представляют собой битовые поля, битовая маскировка применяется для изоляции значения нужной кнопки. Кнопка нажата (вниз), если задан соответствующий бит; в противном случае она отпускается (вверх).

В следующем примере определяется, нажата ли кнопка "Принять" из _обязательного набора_.
```cpp
if (RequiredUINavigationButtons::Accept == (reading.RequiredButtons & RequiredUINavigationButtons::Accept))
{
    // Accept is pressed
}
```

В следующем примере определяется, отпущена ли кнопка "Принять" из _обязательного набора_.
```cpp
if (RequiredUINavigationButtons::None == (reading.RequiredButtons & RequiredUINavigationButtons::Accept))
{
    // Accept is released (not pressed)
}
```

Обязательно используйте свойство `OptionalButtons` и перечисление `OptionalUINavigationButtons` при чтении кнопок из _дополнительного набора_.

В следующем примере определяется, нажата ли кнопка Context1 из _дополнительного набора_.
```cpp
if (OptionalUINavigationButtons::Context1 == (reading.OptionalButtons & OptionalUINavigationButtons::Context1))
{
    // Context 1 is pressed
}
```

Иногда требуется определить, переходит ли кнопка из нажатого состояния в отпущенное (и наоборот), нажато ли (или отпущено) несколько кнопок и упорядочен ли набор кнопок определенным образом (некоторые нажаты, другие— нет). Сведения о том, как обнаруживать эти условия, см. в разделах [Обнаружение переходов состояний кнопок](input-practices-for-games.md#detecting-button-transitions) и [Обнаружение сложных расположений кнопок](input-practices-for-games.md#detecting-complex-button-arrangements).


## <a name="run-the-ui-navigation-controller-sample"></a>Запуск примера контроллера навигации по интерфейсу пользователя

[Пример InputInterfacingUWP_ (github)_](https://github.com/Microsoft/Xbox-ATG-Samples/tree/master/UWPSamples/System/InputInterfacingUWP) показывает, как разные устройства ввода ведут себя в качестве контроллеров навигации по пользовательскому интерфейсу.

## <a name="see-also"></a>См. также
[Windows.Gaming.Input.Gamepad][]
[Windows.Gaming.Input.ArcadeStick][]
[Windows.Gaming.Input.RacingWheel][]
[Windows.Gaming.Input.IGameController][]


[Windows.Gaming.Input]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.aspx
[Windows.Gaming.Input.Gamepad]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.gamepad.aspx
[Windows.Gaming.Input.Arcadestick]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.arcadestick.aspx
[Windows.Gaming.Input.Racingwheel]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.racingwheel.aspx
[Windows.Gaming.Input.IGameController]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.igamecontroller.aspx
[uinavigationcontroller]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.uinavigationcontroller.aspx
[uinavigationcontrollers]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.uinavigationcontroller.uinavigationcontrollers.aspx
[uinavigationcontrolleradded]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.uinavigationcontroller.uinavigationcontrolleradded.aspx
[uinavigationcontrollerremoved]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.uinavigationcontroller.uinavigationcontrollerremoved.aspx
[getcurrentreading]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.uinavigationcontroller.getcurrentreading.aspx
[uinavigationreading]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.uinavigationreading.aspx
[requireduinavigationbuttons]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.requireduinavigationbuttons.aspx
[optionaluinavigationbuttons]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.optionaluinavigationbuttons.aspx
