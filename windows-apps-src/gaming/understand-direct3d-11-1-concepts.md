---
author: mtoepke
title: Важные изменения в Direct3D11 по сравнению с Direct3D9
description: В этой статье рассматриваются основные различия между DirectX 9 и DirectX 11.
ms.assetid: 35a9e388-b25e-2aac-0534-577b15dae364
ms.author: mtoepke
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp, игры, directx, direct3d 9, direct3d 11, изменения
ms.localizationpriority: medium
ms.openlocfilehash: 969d8f2620adbc289c1f4c89242e0282901357c2
ms.sourcegitcommit: cbe7cf620622a5e4df7414f9e38dfecec1cfca99
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/20/2018
ms.locfileid: "7426225"
---
# <a name="important-changes-from-direct3d-9-to-direct3d-11"></a>Важные изменения в Direct3D 11 по сравнению с Direct3D 9



**Краткий обзор**

-   [Планирование переноса приложений на DirectX](plan-your-directx-port.md)
-   Важные изменения в Direct3D11 по сравнению с Direct3D9
-   [Сопоставление компонентов](feature-mapping.md)


В этом разделе представлены общие отличия между DirectX 9 и DirectX 11.

Direct3D11 — это по сути тот же тип API, что и Direct3D9, а именно виртуализованный интерфейс нижнего уровня для взаимодействия с графическим оборудованием. Он также по-прежнему позволяет выполнять графические операции в разнообразных аппаратных реализациях. Структура графического API изменилась по сравнению с Direct3D9; идея контекста устройства была расширена. Также был добавлен специальный API для графической инфраструктуры. Ресурсы, хранящиеся на устройстве Direct3D, получили принципиально новый механизм для полиморфизма данных — представление ресурсов.

## <a name="core-api-functions"></a>Базовые функции API


В Direct3D 9, прежде чем использовать интерфейс для взаимодействия с API Direct3D, его приходилось создавать. В играх UWP с использованием Direct3D11 вы вызываете статическую функцию [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082) для создания устройства и контекста устройства.

## <a name="devices-and-device-context"></a>Устройства и контекст устройства


Устройство Direct3D11 представляет собой виртуализованный графический адаптер. Оно используется для создания ресурсов в видеопамяти, например для отправки текстур графическому процессору (GPU), создания представлений на основе ресурсов текстуры и цепочек буферов и для создания дискретизаторов текстур. Полный перечень способов использования интерфейса устройства Direct3D11 приведен в разделах [**ID3D11Device**](https://msdn.microsoft.com/library/windows/desktop/ff476379) и [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575).

Контекст устройства Direct3D 11 используется для настройки состояния конвейера и создания команд отрисовки. Например, цепочка отрисовки Direct3D11 использует контекст устройства для настройки цепочки отрисовки и рисования сцены (см. ниже). Контекст устройства применяется для доступа к видеопамяти (сопоставления), которую используют ресурсы устройства Direct3D, а также для обновления данных подресурсов, например данных буфера констант. Полный перечень способов использования контекста устройства Direct3D11 приведен в разделах [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385) и [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598). Обратите внимание, что большинство наших образцов используют мгновенный контекст для обработки напрямую на устройстве, но Direct3D11 также поддерживает и отложенные контексты устройств, которые применяются преимущественно для многопоточности.

Чтобы получить маркер устройства и маркер контекста устройства, в Direct3D11 вызывается [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082). В этом методе также запрашивается определенный набор аппаратных функций и извлекаются сведения об уровнях компонентов Direct3D, которые поддерживает графический адаптер. Дополнительные сведения об устройствах, контекстах устройств и потоковой модели см. в разделе [Вводные сведения об устройстве в Direct3D11](https://msdn.microsoft.com/library/windows/desktop/ff476880).

## <a name="device-infrastructure-frame-buffers-and-render-target-views"></a>Инфраструктура устройства, буферы кадров и представления однобуферной прорисовки


В Direct3D11 для настройки адаптера устройств и конфигурации оборудования применяется API DirectX Graphics Infrastructure (DXGI) с использованием COM-интерфейсов [**IDXGIAdapter**](https://msdn.microsoft.com/library/windows/desktop/bb174523) и [**IDXGIDevice1**](https://msdn.microsoft.com/library/windows/desktop/hh404543). Буферы и другие ресурсы окон (видимые и закадровые) создаются и настраиваются при помощи определенных интерфейсов DXGI. Реализация шаблона фабрики [**IDXGIFactory2**](https://msdn.microsoft.com/library/windows/desktop/hh404556) получает ресурсы DXGI, такие как буфер кадров. Поскольку DXGI принадлежит цепочка буферов, интерфейс DXGI используется для представления кадров на экране. Дополнительные сведения об этом см. в [**IDXGISwapChain1**](https://msdn.microsoft.com/library/windows/desktop/hh404631).

Используйте [**IDXGIFactory2**](https://msdn.microsoft.com/library/windows/desktop/hh404556) для создания цепочки буферов, совместимой с вашей игрой. Необходимо создать цепочку буферов не для HWND, а для основного окна или для композиции (взаимодействие с XAML).

## <a name="device-resources-and-resource-views"></a>Ресурсы устройств и представления ресурсов


Direct3D11 поддерживает дополнительный уровень полиморфизма для ресурсов видеопамяти — для представлений. По сути там, где раньше был один объект Direct3D9 для текстуры, теперь есть два объекта: ресурс текстуры, где хранятся данные, и представление ресурсов, которое определяет способ использования представления для отрисовки. Представление на основе ресурса позволяет использовать ресурс для определенной цели. Например, ресурс двухмерной текстуры создается в форме [**ID3D11Texture2D**](https://msdn.microsoft.com/library/windows/desktop/ff476635), затем на его основе создается представление ресурсов шейдера ([**ID3D11ShaderResourceView**](https://msdn.microsoft.com/library/windows/desktop/ff476628)), и его можно использовать как текстуру в шейдере. Представление однобуферной прорисовки ([**ID3D11RenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476582)) можно также создать на основе того же ресурса двухмерной текстуры и использовать его как поверхность рисования. В другом примере те же пиксельные данные представлены в двух разных форматах пикселей с использованием двух отдельных представлений на основе одного ресурса текстуры.

Основной ресурс необходимо создать со свойствами, совместимыми с типом представлений, которые будут созданы из него. Например, если [**ID3D11RenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476582) применяется к поверхности, ее нужно создать с флагом [**D3D11\_BIND\_RENDER\_TARGET**](https://msdn.microsoft.com/library/windows/desktop/ff476085). Формат поверхности DXGI должен быть совместим с отрисовкой (см. [**DXGI\_FORMAT**](https://msdn.microsoft.com/library/windows/desktop/bb173059)).

Большинство ресурсов, которые вы используете для отрисовки, унаследованы от интерфейса [**ID3D11Resource**](https://msdn.microsoft.com/library/windows/desktop/ff476584), в свою очередь унаследованного от [**ID3D11DeviceChild**](https://msdn.microsoft.com/library/windows/desktop/ff476380). Буферы вершин, буферы индексов, буферы констант и шейдеры — все это ресурсы Direct3D11. Входные макеты и состояния дискретизатора унаследованы напрямую от [**ID3D11DeviceChild**](https://msdn.microsoft.com/library/windows/desktop/ff476380).

Представления ресурсов используют значение перечисления DXGI\_FORMAT для указания формата пикселей. Не каждый D3DFMT поддерживается как DXGI\_FORMAT. Например, в DXGI не существует формата RGB 24 бита на пиксель, эквивалентного D3DFMT\_R8G8B8. Также эквиваленты BGR существуют не для каждого формата RGB (DXGI\_FORMAT\_R10G10B10A2\_UNORM эквивалентен D3DFMT\_A2B10G10R10, но прямого эквивалента D3DFMT\_A2R10G10B10 нет). Во время сборки следует преобразовать содержимое в этих устаревших форматах в поддерживаемые форматы. Полный перечень форматов DXGI см. в перечислении [**DXGI\_FORMAT**](https://msdn.microsoft.com/library/windows/desktop/bb173059).

Ресурсы устройств Direct3D (и представления ресурсов) создаются до обработки сцены. Контексты устройств используются для настройки цепочки отрисовки, как описано ниже.

## <a name="device-context-and-the-rendering-chain"></a>Контекст устройства и цепочка отрисовки


В Direct3D9 и Direct3D10.x был единственный объект устройства Direct3D, который управлял созданием ресурсов, состоянием и рисованием. В Direct3D11 интерфейс устройства Direct3D также управляет созданием ресурсов, но для управления состоянием и операциями рисования используется контекст устройства Direct3D. Вот пример использования контекста устройства (интерфейса [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598)) для настройки цепочки отрисовки:

-   Настройка и очистка представлений однобуферной прорисовки (и представления трафарета глубины)
-   Настройка буфера вершин, буфера индексов и входного макета для этапа сборщика входных данных (этапа IA)
-   Привязка вершинного и обычного построителей текстуры к конвейеру
-   Привязка буферов констант к шейдерам
-   Привязка представлений текстуры и дискретизаторов к построителю текстуры
-   Рисование сцены

Когда вызван один из методов [**ID3D11DeviceContext::Draw**](https://msdn.microsoft.com/library/windows/desktop/ff476407), рисуется сцена в представлении однобуферной прорисовки. По завершении рисования адаптер DXGI используется для представления законченного кадра вызовом [**IDXGISwapChain1::Present1**](https://msdn.microsoft.com/library/windows/desktop/hh446797).

## <a name="state-management"></a>Управление состоянием


В Direct3D 9 для управления параметрами состояния использовался большой набор отдельных переключателей, которые настраивались с помощью методов SetRenderState, SetSamplerState и SetTextureStageState. Поскольку Direct3D11 не поддерживает устаревший конвейер с фиксированной функцией, метод SetTextureStageState заменен написанием построителей текстуры (PS). Не существует эквивалента блоку состояний Direct3D9. В Direct3D 11 для управления состоянием используются 4 вида объектов состояния, что упрощает группировку состояний отрисовки.

Например, вместо использования метода SetRenderState с D3DRS\_ZENABLE вы создаете объект DepthStencilState с этим и другими связанными параметрами состояния и используете его для изменения состояния в процессе отрисовки.

При переносе приложений Direct3D9 в объекты состояния учитывайте, что различные комбинации состояний представлены в виде неизменяемых объектов состояния. Их следует создать один раз и многократно использовать, пока они остаются действительными.

## <a name="direct3d-feature-levels"></a>Уровни функций Direct3D 


В Direct3D появился новый механизм определения аппаратной поддержки — уровни функций. Благодаря уровням функций становится проще узнать о возможностях графического адаптера, поскольку можно запросить четко определенный набор функций GPU. Например, уровень функций 9\_1 реализует функции графических адаптеров Direct3D9, включая модель шейдера 2.x. Так как 9\_1 — самый нижний уровень функций, можно предположить, что все устройства будут поддерживать вершинный и обычный построители текстуры — те же этапы, которые поддерживала программируемая модель шейдера Direct3D9.

Ваша игра будет использовать [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082) для создания устройства и контекста устройства Direct3D. Вызывая эту функцию, вы предоставляете список уровней функций, которые поддерживает ваша игра. На основе этого списка функция вернет самый высокий поддерживаемый уровень функций. Например, если ваша игра может использовать текстуры BC4/BC5 (функцию оборудования DirectX10), следует включить в список поддерживаемых уровней функций как минимум уровни 9\_1 и 10\_0. Если игра работает на оборудовании DirectX9 и текстуры BC4/BC5 использовать нельзя, то [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082) вернет 9\_1. Затем ваша игра может переключиться на другой формат текстур (и более мелкие текстуры).

Если вы решили расширить игру Direct3D9, добавив поддержку более высоких уровней функций Direct3D, лучше сначала закончить перенос существующего графического кода Direct3D9. После переноса игры в Direct3D11 будет проще добавить дополнительные пути отрисовки с более сложной графикой.

Подробное объяснение поддержки уровней функций см. в разделе [Уровни функций Direct3D](https://msdn.microsoft.com/library/windows/desktop/ff476876). Полный перечень функций Direct3D 11 см. в разделах [Функции Direct3D 11](https://msdn.microsoft.com/library/windows/desktop/ff476342) и [Функции Direct3D 11.1](https://msdn.microsoft.com/library/windows/desktop/hh404562).

## <a name="feature-levels-and-the-programmable-pipeline"></a>Уровни функций и программируемый конвейер


С момента появления Direct3D9 оборудование непрерывно совершенствовалось, и в программируемый графический конвейер было добавлено несколько новых дополнительных этапов. Набор параметров для графического конвейера зависит от уровня функций Direct3D. Уровень функций 10.0 включает этап геометрического построителя текстуры с дополнительным потоковым выводом для многопроходной отрисовки на GPU. Уровень функций 11\_0 включает шейдер поверхности и шейдер доменов для использования с аппаратным мозаичным представлением. Уровень функций 11\_0 также включает полную поддержку шейдеров DirectCompute, тогда как уровни функций 10.x поддерживают только ограниченную форму DirectCompute.

Все шейдеры написаны на языке HLSL с использованием профиля шейдеров, соответствующего уровню функций Direct3D. Профили шейдеров имеют прямую совместимость, поэтому шейдер HLSL, скомпилированный с использованием vs\_4\_0\_level\_9\_1 или ps\_4\_0\_level\_9\_1, будет работать на всех устройствах. Профили шейдеров не совместимы с предыдущими уровнями, поэтому шейдер, скомпилированный с использованием vs\_4\_1, будет работать только на устройствах с уровнями функций 10\_1, 11\_0 или 11\_1.

В Direct3D 9 для управления константами шейдеров использовался общий массив с методами SetVertexShaderConstant и SetPixelShaderConstant. Direct3D11 использует буферы констант, которые представляют собой ресурсы, аналогичные буферу вершин или буферу индексов. Буферы констант эффективно обновляются благодаря своей структуре. Вам не нужно размещать все константы шейдера в одном глобальном массиве. Вместо этого вы объединяете константы в логические группы и управляете ими при помощи одного или нескольких буферов констант. При переносе игры Direct3D9 в Direct3D11 запланируйте такую организацию буферов констант, чтобы можно было обновлять их соответствующим образом. Например, сгруппируйте константы шейдера, которые не обновляются с каждым кадром, в отдельный буфер констант. Тогда вам не придется постоянно отправлять эти данные графическому адаптеру вместе с более динамическими константами шейдера.

> **Примечание**  большинство приложений Direct3D 9 широко использовали шейдеры, но иногда в комбинации с традиционной фиксированной функции. Обратите внимание, что Direct3D11 использует только программируемую модель шейдеров. Устаревшие компоненты Direct3D9 с фиксированными функциями использовать не рекомендуется.

 

 

 




