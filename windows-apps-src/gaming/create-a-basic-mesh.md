---
author: mtoepke
title: Создание и отображение базовой сетки
description: Для представления объектов и поверхностей в трехмерных играх универсальной платформы Windows (UWP) обычно используются многоугольники.
ms.assetid: bfe0ed5b-63d8-935b-a25b-378b36982b7d
ms.author: mtoepke
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp, игры, сетка, directx
ms.localizationpriority: medium
ms.openlocfilehash: e3ae6416217efa16d70b65b8ff55e36654a11557
ms.sourcegitcommit: e814a13978f33654d8e995584f4b047cb53e0aef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/05/2018
ms.locfileid: "6045454"
---
# <a name="create-and-display-a-basic-mesh"></a>Создание и отображение базовой сетки



Для представления объектов и поверхностей в трехмерных играх универсальной платформы Windows (UWP) обычно используются многоугольники. Списки вершин, составляющих структуру данных многоугольных объектов и поверхностей, называются сетками. В настоящем разделе будет создана простая сетка для объекта кубической формы, которая затем будет передана в конвейер шейдера для отрисовки и отображения.

> **Важные**  в примере кода ниже используются типы (такие как DirectX::XMFLOAT3 и DirectX::XMFLOAT4X4) и встроенные методы, объявленные в DirectXMath.h. Если вы вырезаете и вставляете этот код, добавьте в свой проект объявление: \#include &lt;DirectXMath.h&gt;.

 

## <a name="what-you-need-to-know"></a>Что необходимо знать


### <a name="technologies"></a>Технологии

-   [Direct3D](https://msdn.microsoft.com/library/windows/desktop/hh769064)

### <a name="prerequisites"></a>Необходимые условия

-   Основные сведения о линейной алгебре и трехмерных системах координат
-   Visual Studio 2015 или более поздней версии шаблона Direct3D

## <a name="instructions"></a>Инструкции

Далее показано, как создать простой куб сетки. 


Если вы хотите подробнее узнать об этих принципах, посмотрите это видео.
</br>
</br>
<iframe src="https://channel9.msdn.com/Series/Introduction-to-C-and-DirectX-Game-Development/03/player#time=7m39s:paused" width="600" height="338" allowFullScreen frameBorder="0"></iframe>


### <a name="step-1-construct-the-mesh-for-the-model"></a>Шаг 1. Построение сетки для модели

В большинстве игр сетка для объектов игры загружается из файла, который содержит специальные данные вершин. Расстановка этих вершин зависит от приложения, но обычно они упорядочиваются в виде полос или вееров. Данные вершин могут поступать из любого программного источника или могут быть созданы вручную. Вашей игре остается интерпретировать данные таким образом, чтобы вершинный шейдер мог эффективно их обработать.

В нашем примере используется простая сетка для куба. Куб, как и любая сетка объекта на данном этапе в конвейере, представлен в своей собственной системе координат. Вершинный шейдер берет координаты куба и, применяя к ним матрицы преобразования, предоставляемые вами, возвращает итоговую двухмерную проекцию вида в гомогенной системе координат.

Определите сетку для куба. (Или загрузите ее из файла. Исходя из ваших предпочтений.)

```cpp
SimpleCubeVertex cubeVertices[] =
{
    { DirectX::XMFLOAT3(-0.5f, 0.5f, -0.5f), DirectX::XMFLOAT3(0.0f, 1.0f, 0.0f) }, // +Y (top face)
    { DirectX::XMFLOAT3( 0.5f, 0.5f, -0.5f), DirectX::XMFLOAT3(1.0f, 1.0f, 0.0f) },
    { DirectX::XMFLOAT3( 0.5f, 0.5f,  0.5f), DirectX::XMFLOAT3(1.0f, 1.0f, 1.0f) },
    { DirectX::XMFLOAT3(-0.5f, 0.5f,  0.5f), DirectX::XMFLOAT3(0.0f, 1.0f, 1.0f) },

    { DirectX::XMFLOAT3(-0.5f, -0.5f,  0.5f), DirectX::XMFLOAT3(0.0f, 0.0f, 1.0f) }, // -Y (bottom face)
    { DirectX::XMFLOAT3( 0.5f, -0.5f,  0.5f), DirectX::XMFLOAT3(1.0f, 0.0f, 1.0f) },
    { DirectX::XMFLOAT3( 0.5f, -0.5f, -0.5f), DirectX::XMFLOAT3(1.0f, 0.0f, 0.0f) },
    { DirectX::XMFLOAT3(-0.5f, -0.5f, -0.5f), DirectX::XMFLOAT3(0.0f, 0.0f, 0.0f) },
};
```

Система координат куба помещает его центр в начало координат, при этом ось Y проходит сверху вниз в левосторонней системе координат. Значения координат представлены в виде 32-разрядных величин с плавающей запятой в диапазоне между –1 и 1.

В каждой паре, заключенной в скобки, вторая группа значений DirectX::XMFLOAT3 определяет цвет, сопоставляемый с вершиной, в виде RGB-значения. Например, первая вершина с координатами (–0,5, 0,5, –0,5) имеет насыщенный зеленый цвет (параметр "G" имеет значение 1,0, а параметры "R" и "B" имеют значения 0).

Таким образом имеются 8 вершин, каждая своего цвета. В нашем примере каждая пара вершина-цвет содержит полные данные для каждой вершины. При определении буфера наших вершин необходимо помнить об этом макете. Мы предоставляем этот входной макет для вершинного шейдера, чтобы он мог распознавать данные вершин.

### <a name="step-2-set-up-the-input-layout"></a>Шаг 2. Настройка входного макета

Теперь вершины записаны в память. Но ваше графическое устройство имеет свою собственную память, и для доступа к ней вы используете Direct3D. Для передачи данных вершин в графическое устройство на обработку необходимо объявить, как именно расположены данные вершин, чтобы графическое устройство могло интерпретировать их при получении этих данных из игры. Для этого используется [**ID3D11InputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476575).

Объявите и настройте входной макет для буфера вершин.

```cpp
const D3D11_INPUT_ELEMENT_DESC basicVertexLayoutDesc[] =
{
    { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,  0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
    { "COLOR",    0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },
};

ComPtr<ID3D11InputLayout> inputLayout;
m_d3dDevice->CreateInputLayout(
                basicVertexLayoutDesc,
                ARRAYSIZE(basicVertexLayoutDesc),
                vertexShaderBytecode->Data,
                vertexShaderBytecode->Length,
                &inputLayout)
);
```

В этом коде вы указываете макет для вершин, а точнее — какие именно данные содержит каждый элемент списка вершин. Здесь, в **basicVertexLayoutDesc**, указываются два компонента данных:

-   **POSITION** — это семантика HLSL для данных о положении, предоставляемых шейдеру. В данном коде это DirectX::XMFLOAT3 или, точнее, структура с тремя 32-разрядными величинами с плавающей запятой, которые соответствуют трехмерной координате (X, Y, Z). Также можно использовать float4, если вы будете предоставлять гомогенную координатуw. В таком случае указывается DXGI\_FORMAT\_R32G32B32A32\_FLOAT. Будете ли вы использовать DirectX::XMFLOAT3 или float4, зависит от специфических потребностей вашей игры. Обязательно убедитесь, что данные вершин для вашей сетки соответствуют используемому формату.

    Каждое значение координаты выражено величиной с плавающей запятой в диапазоне между –1 и 1 в пространстве координат данного объекта. Когда вершинный шейдер завершает свою работу, преобразованная вершина находится в гомогенном пространстве проекции вида (со скорректированной перспективой).

    «Но значение перечисления обозначает RGB, а не XYZ!»,— скажете вы. Молодцы! В обоих случаях — и с данными о цвете, и с данными о координатах — вы обычно используете трех- или четырехкомпонентные величины, так почему бы не использовать один и тот же формат для обоих случаев? Семантика HLSL — а не название формата — определяет то, как шейдер будет обрабатывать данные.

-   **COLOR** — это семантика HLSL для данных о цвете. Аналогично **POSITION**, она содержит три 32-разрядных значения с плавающей запятой (DirectX::XMFLOAT3). Каждое значение содержит компонент, отвечающий за цвет: красный (r), синий (b) или зеленый (g), выраженный числом с плавающей запятой в диапазоне от 0 до 1.

    Значения **COLOR** обычно возвращаются в виде четырехкомпонентного значения RGBA по завершении работы конвейера шейдера. В этом примере в конвейере шейдера для всех пикселей вы будете задавать альфа-фактору «А» значение 1,0 (максимальная прозрачность).

Полный список форматов приведен здесь: [**DXGI\_FORMAT**](https://msdn.microsoft.com/library/windows/desktop/bb173059). Полный список семантик HLSL приведен здесь: [Семантики](https://msdn.microsoft.com/library/windows/desktop/bb509647).

Вызовите [**ID3D11Device::CreateInputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476512) и создайте входной макет на устройстве Direct3D. А теперь необходимо создать буфер, в котором будут храниться данные.

### <a name="step-3-populate-the-vertex-buffers"></a>Шаг 3. Заполнение буферов вершин

Буферы вершин содержат списки вершин каждого из треугольников сетки. В этом списке каждая вершина должна быть уникальной. В нашем примере имеются 8 вершин куба. Вершинный шейдер работает на графическом устройстве, считывает данные из буфера вершин и интерпретирует их на основе входного макета, заданного в предыдущем шаге.

В следующем примере вы дадите для буфера описание и предоставите подресурс, которые сообщают Direct3D сведения о физическом сопоставлении данных вершин и способе их обработки в памяти графического устройства. Это необходимо, поскольку вы используете универсальный буфер [**ID3D11Buffer**](https://msdn.microsoft.com/library/windows/desktop/ff476351), который может содержать что угодно. Структуры [**D3D11\_BUFFER\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476092) и [**D3D11\_SUBRESOURCE\_DATA**](https://msdn.microsoft.com/library/windows/desktop/ff476220) поставляются для того, чтобы обеспечить распознавание компонентом Direct3D представления физической памяти буфера, включая размер каждого элемента вершины, содержащейся в буфере, а также максимальный размер списка вершин. Кроме того, здесь вы можете управлять доступом к памяти буфера и просмотром его содержимого, но эта информация выходит за рамки данного учебника.

После настройки буфера следует вызвать [**ID3D11Device::CreateBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476501), чтобы фактически создать его. Очевидно, что для нескольких объектов необходимо создать буферы для каждой уникальной модели.

Объявите и создайте буфер вершин.

```cpp
D3D11_BUFFER_DESC vertexBufferDesc = {0};
vertexBufferDesc.ByteWidth = sizeof(SimpleCubeVertex) * ARRAYSIZE(cubeVertices);
vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
vertexBufferDesc.CPUAccessFlags = 0;
vertexBufferDesc.MiscFlags = 0;
vertexBufferDesc.StructureByteStride = 0;

D3D11_SUBRESOURCE_DATA vertexBufferData;
vertexBufferData.pSysMem = cubeVertices;
vertexBufferData.SysMemPitch = 0;
vertexBufferData.SysMemSlicePitch = 0;

ComPtr<ID3D11Buffer> vertexBuffer;
m_d3dDevice->CreateBuffer(
                &vertexBufferDesc,
                &vertexBufferData,
                &vertexBuffer);
```

Вершины загружены. Но в каком порядке будут обрабатываться эти вершины? Это определяется, когда вы предоставляете список индексов вершин; расстановка этих индексов является порядком, в котором вершинный шейдер их обрабатывает.

### <a name="step-4-populate-the-index-buffers"></a>Шаг 4. Заполнение буферов индексов

Теперь предоставьте список индексов для каждой из вершин. Данные индексы соответствуют положению вершины в буфере вершин, начиная с 0. Чтобы вам легче было представить себе это, считайте, что каждая уникальная вершина в вашей сетке имеет уникальный номер, присвоенный ей в качестве идентификатора. Данный идентификатор — выраженное целым числом положение вершины в буфере вершин.

![Куб с восемью пронумерованными вершинами](images/cube-mesh-1.png)

В нашем примере у куба 8 вершин, которые образуют 6 квадратов для сторон. Вы делите квадраты на треугольники (в общей сложности на 12 треугольников), в которых используются наши 8 вершин. При 3 вершинах на треугольник у вас будет 36 записей в буфере индексов. В нашем примере данный шаблон индексов называется списком треугольников, и при настройке топологии примитивов вы обозначали его в Direct3D как **D3D11\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST**.

Возможно, список индексов является самым неэффективным способом, поскольку возникает избыточность, так как у треугольников есть общие стороны и точки. Например, когда у треугольника есть общая сторона в ромбе, вы перечисляете 6 индексов для четырех вершин:

![порядок индексов при построении ромба](images/rhombus-surface-1.png)

-   Треугольник 1: \[0, 1, 2\]
-   Треугольник 2: \[0, 2, 3\]

В топологии «полоса» или «веер» вершины упорядочиваются так, чтобы исключить лишние стороны при обходе (такие как сторона от индекса 0 к индексу 2 на изображении). Для крупных сеток эта топология значительно уменьшает количество запусков вершинного шейдера и значительно повышает производительность. Однако остановимся на таком простом варианте, как список треугольников.

Объявите индексы для буфера вершин как топологию "список треугольников".

```cpp
unsigned short cubeIndices[] =
{   0, 1, 2,
    0, 2, 3,

    4, 5, 6,
    4, 6, 7,

    3, 2, 5,
    3, 5, 4,

    2, 1, 6,
    2, 6, 5,

    1, 7, 6,
    1, 0, 7,

    0, 3, 4,
    0, 4, 7 };
```

Тридцать шесть индексных элементов в буфере — это слишком много, если у вас всего 8 вершин. Если вы решили исключить избыточность и использовать список вершин иного типа, например «полоса» или «веер», вы должны указать этот тип при предоставлении особого параметра [**D3D11\_PRIMITIVE\_TOPOLOGY**](https://msdn.microsoft.com/library/windows/desktop/ff476189) методу [**ID3D11DeviceContext::IASetPrimitiveTopology**](https://msdn.microsoft.com/library/windows/desktop/ff476455).

Дополнительные сведения о других технологиях составления списков индексов см. в разделе [Топологии примитивов](https://msdn.microsoft.com/library/windows/desktop/bb205124).

### <a name="step-5-create-a-constant-buffer-for-your-transformation-matrices"></a>Шаг 5. Создание буфера констант для матриц преобразования

Перед началом обработки вершин вам необходимо предоставить матрицы преобразования, которые будут применяться (умножением) к каждой вершине при ее запуске. Для большинства трехмерных игр существуют три матрицы:

-   Матрица 4x4, которая преобразуется из системы координат объекта (модели) в реальную систему координат.
-   Матрица 4x4, которая преобразуется из реальной системы координат в систему координат камеры (вида).
-   Матрица 4x4, которая преобразуется из системы координат камеры в двухмерную систему координат проекции вида.

Эти матрицы передаются шейдеру в *буфер констант*. Буфер констант — это область памяти, которая остается постоянной во время выполнения следующего перехода конвейера шейдера и к которой шейдеры имеют прямой доступ из кода HLSL. Каждый буфер констант определяется дважды: первый раз в коде вашей игры, написанной на языке C++, и по меньшей мере один раз в C-образном синтаксисе HLSL для кода шейдера. Два объявления должны точно совпадать в том, что касается типов данных и их выравнивания. Очень просто допустить ошибки, когда шейдер использует объявление HLSL для интерпретации данных, объявленных на C++, а типы не совпадают или выравнивание данных отключено.

HLSL не может вносить изменения в буфер констант. В эти буферы можно вносить изменения, когда ваша игра обновляет конкретные данные. Часто разработчики игр создают 4 класса буферов констант: один тип для обновлений на один кадр, один тип для обновлений на одну модель или объект, один тип для одного обновления состояния игры и один тип для данных, которые никогда не изменяются на протяжении всего жизненного цикла игры.

В данном примере у нас используется всего один класс, который никогда не изменяется: данные DirectX::XMFLOAT4X4 для трех матриц.

> **Примечание**  в представленном здесь примере кода используются матрицы по столбцам. Вместо этого можно использовать матрицы с разверткой по строкам, применив ключевое слово **row\_major** на HLSL, а также убедившись, что данные в матрице-источнике также развернуты по строкам. DirectXMath работает с матрицами с разверткой по строкам и может непосредственно использоваться с матрицами HLSL, определенными ключевым словом **row\_major**.

 

Объявите и создайте буфер констант для трех матриц, используемых вами для преобразования каждой вершины.

```cpp
struct ConstantBuffer
{
    DirectX::XMFLOAT4X4 model;
    DirectX::XMFLOAT4X4 view;
    DirectX::XMFLOAT4X4 projection;
};
ComPtr<ID3D11Buffer> m_constantBuffer;
ConstantBuffer m_constantBufferData;

// ...

// Create a constant buffer for passing model, view, and projection matrices
// to the vertex shader.  This allows us to rotate the cube and apply
// a perspective projection to it.

D3D11_BUFFER_DESC constantBufferDesc = {0};
constantBufferDesc.ByteWidth = sizeof(m_constantBufferData);
constantBufferDesc.Usage = D3D11_USAGE_DEFAULT;
constantBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
constantBufferDesc.CPUAccessFlags = 0;
constantBufferDesc.MiscFlags = 0;
constantBufferDesc.StructureByteStride = 0;
m_d3dDevice->CreateBuffer(
                &constantBufferDesc,
                nullptr,
                &m_constantBuffer
             );

m_constantBufferData.model = DirectX::XMFLOAT4X4( // Identity matrix, since you are not animating the object
            1.0f, 0.0f, 0.0f, 0.0f,
            0.0f, 1.0f, 0.0f, 0.0f,
            0.0f, 0.0f, 1.0f, 0.0f,
            0.0f, 0.0f, 0.0f, 1.0f);

);
// Specify the view (camera) transform corresponding to a camera position of
// X = 0, Y = 1, Z = 2.  

m_constantBufferData.view = DirectX::XMFLOAT4X4(
            -1.00000000f, 0.00000000f,  0.00000000f,  0.00000000f,
             0.00000000f, 0.89442718f,  0.44721359f,  0.00000000f,
             0.00000000f, 0.44721359f, -0.89442718f, -2.23606800f,
             0.00000000f, 0.00000000f,  0.00000000f,  1.00000000f);
```

> **Примечание**обычно объявляется матрицу проекции при настройке конкретных ресурсов устройства, поскольку результаты умножения матрицы должны соответствовать текущим параметрам размера окна просмотра 2-D (который часто соответствуют пикселей высоты и ширины Отображение). Если эти параметры меняются, необходимо соответственно устанавливать пропорции значений координат X и Y.

 

```cpp
// Finally, update the constant buffer perspective projection parameters
// to account for the size of the application window.  In this sample,
// the parameters are fixed to a 70-degree field of view, with a depth
// range of 0.01 to 100.  

float xScale = 1.42814801f;
float yScale = 1.42814801f;
if (backBufferDesc.Width > backBufferDesc.Height)
{
    xScale = yScale *
                static_cast<float>(backBufferDesc.Height) /
                static_cast<float>(backBufferDesc.Width);
}
else
{
    yScale = xScale *
                static_cast<float>(backBufferDesc.Width) /
                static_cast<float>(backBufferDesc.Height);
}
m_constantBufferData.projection = DirectX::XMFLOAT4X4(
            xScale, 0.0f,    0.0f,  0.0f,
            0.0f,   yScale,  0.0f,  0.0f,
            0.0f,   0.0f,   -1.0f, -0.01f,
            0.0f,   0.0f,   -1.0f,  0.0f
            );
```

Настройте буферы вершин и индексов в [ID3D11DeviceContext](https://msdn.microsoft.com/library/windows/desktop/ff476149), а также используемую топологию.

```cpp
// Set the vertex and index buffers, and specify the way they define geometry.
UINT stride = sizeof(SimpleCubeVertex);
UINT offset = 0;
m_d3dDeviceContext->IASetVertexBuffers(
                0,
                1,
                vertexBuffer.GetAddressOf(),
                &stride,
                &offset);

m_d3dDeviceContext->IASetIndexBuffer(
                indexBuffer.Get(),
                DXGI_FORMAT_R16_UINT,
                0);

 m_d3dDeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
```

Отлично! Входная сборка завершена. Теперь все готово для отрисовки. Запустим вершинный шейдер.

### <a name="step-6-process-the-mesh-with-the-vertex-shader"></a>Шаг 6. Обработка сетки с помощью вершинного шейдера

Теперь, когда у вас есть буфер вершин, определяющий сетку, и буфер индексов, определяющий порядок обработки вершин, вы отправляете их в вершинный шейдер. Код вершинного шейдера, представленный в виде откомпилированного высокоуровневого языка шейдер, однократно запускается для каждой вершины буфера вершин, предоставляя возможность осуществления ваших преобразований для каждой из вершин. Конечный результат, как правило, представлен двухмерной проекцией.

(Вы загрузили свой вершинный шейдер? Если нет, см. [Загрузка ресурсов в игре DirectX](load-a-game-asset.md)).

Здесь вы создаете вершинный шейдер...

``` syntax
// Set the vertex and pixel shader stage state.
m_d3dDeviceContext->VSSetShader(
                vertexShader.Get(),
                nullptr,
                0);
```

...и настраиваете буферы констант.

``` syntax
m_d3dDeviceContext->VSSetConstantBuffers(
                0,
                1,
                m_constantBuffer.GetAddressOf());
```

Вот код вершинного шейдера, который выполняет преобразование координат объекта в реальную систему координат, а затем в двухмерную систему координат проекции вида. Также можно украсить каждую вершину подсветкой. Эта возможность представлена в файле HLSL вершинного шейдера (SimplerVertexShader.hlsl в этом примере).

``` syntax
cbuffer simpleConstantBuffer : register( b0 )
{
    matrix model;
    matrix view;
    matrix projection;
};

struct VertexShaderInput
{
    DirectX::XMFLOAT3 pos : POSITION;
    DirectX::XMFLOAT3 color : COLOR;
};

struct PixelShaderInput
{
    float4 pos : SV_POSITION;
    float4 color : COLOR;
};

PixelShaderInput SimpleVertexShader(VertexShaderInput input)
{
    PixelShaderInput vertexShaderOutput;
    float4 pos = float4(input.pos, 1.0f);

    // Transform the vertex position into projection space.
    pos = mul(pos, model);
    pos = mul(pos, view);
    pos = mul(pos, projection);
    vertexShaderOutput.pos = pos;

    // Pass the vertex color through to the pixel shader.
    vertexShaderOutput.color = float4(input.color, 1.0f);

    return vertexShaderOutput;
}
```

Видите **cbuffer** наверху? Это HLSL-аналог того же буфера констант, который мы предварительно объявили в вашем коде на языке C++. И **VertexShaderInputstruct**? Похоже, что это ваше объявление входного макета и данных вершин. Важно, чтобы объявления буфера констант и данных вершин в коде на C++ совпадали с объявлениями в HLSL-коде. Это касается знаков, типов и выравнивания данных.

**PixelShaderInput** определяет макет данных, которые возвращаются главной функцией вершинного шейдера. По окончании обработки вершины вы возвратите положение вершины в пространстве двухмерных проекций и цвет, используемый для подсветки вершин. Графическая плата использует данные на выходе шейдера для подсчета «фрагментов» (возможных пикселей), которые должны быть раскрашены при запуске пиксельного шейдера на следующем этапе работы конвейера.

### <a name="step-7-passing-the-mesh-through-the-pixel-shader"></a>Шаг 7. Прохождение сетки через пиксельный шейдер

Обычно на данном этапе графического конвейера выполняются попиксельные операции на видимых проецируемых поверхностях ваших объектов. (Люди как текстуры.) В этом примере просто пропустите сетку через данный этап.

Во-первых, создадим экземпляр пиксельного шейдера. Пиксельный шейдер запускается для каждого пикселя в двухмерной проекции вашей сцены, назначая цвет этому пикселю. В данном случае цвет пикселя, возвращенный вершинным шейдером, проходит напрямую.

Настройте пиксельный шейдер.

``` syntax
m_d3dDeviceContext->PSSetShader( pixelShader.Get(), nullptr, 0 );
```

Определите сквозной пиксельный шейдер на HLSL.

``` syntax
struct PixelShaderInput
{
    float4 pos : SV_POSITION;
};

float4 SimplePixelShader(PixelShaderInput input) : SV_TARGET
{
    // Draw the entire triangle yellow.
    return float4(1.0f, 1.0f, 0.0f, 1.0f);
}
```

Поместите этот код в HLSL-файл отдельно от HLSL вершинного шейдера (например, SimplePixelShader.hlsl). Данный код запускается однократно для каждого видимого пикселя вашего окна просмотра (представление в памяти части экрана, на которой вы рисуете), которое в этом случае отображается на весь экран. Теперь ваш графический конвейер полностью определен!

### <a name="step-8-rasterizing-and-displaying-the-mesh"></a>Шаг 8. Растеризация и отображение сетки

Запустим конвейер. Это легко: вызовите [**ID3D11DeviceContext::DrawIndexed**](https://msdn.microsoft.com/library/windows/desktop/bb173565).

Нарисуйте куб.

```cpp
// Draw the cube.
m_d3dDeviceContext->DrawIndexed( ARRAYSIZE(cubeIndices), 0, 0 );
            
```

Графическая плата обрабатывает каждую вершину в порядке, указанном в вашем буфере индексов. После того как будет выполнен ваш код, а вершинный шейдер и двухмерные фрагменты будут определены, вызывается пиксельный шейдер, и треугольники закрашиваются.

Теперь выведите куб на экран.

Представьте буфер кадров на экране.

```cpp
// Present the rendered image to the window.  Because the maximum frame latency is set to 1,
// the render loop is generally  throttled to the screen refresh rate, typically around
// 60 Hz, by sleeping the app on Present until the screen is refreshed.

m_swapChain->Present(1, 0);
```

Все готово! Для сцен, наполненных моделями, используйте несколько буферов вершин и индексов. У вас даже могут быть разные шейдеры для разных типов моделей. Помните, что у каждой модели своя система координат, и вам необходимо преобразовать их в общую реальную систему координат, используя при этом матрицы, определенные вами в буфере констант.

## <a name="remarks"></a>Примечания

В данном разделе описывается создание и отображение простых геометрических объектов, которые вы создаете самостоятельно. Дополнительные сведения о загрузке более сложной геометрии из файла и ее преобразовании в характерный для данного образца формат объекта буфера вершин (VBO) см. в разделе [Загрузка ресурсов в игре DirectX](load-a-game-asset.md).  

 

## <a name="related-topics"></a>Ссылки по теме


* [Загрузка ресурсов в игре DirectX](load-a-game-asset.md)

 

 




