---
author: mtoepke
title: Перенос GLSL
description: После переноса кода, который создает и настраивает буферы и объекты шейдеров, следует перенести внутренний код шейдеров из версии GLSL (GL Shader Language) для OpenGL ES 2.0 в HLSL (High-level Shader Language) для Direct3D 11.
ms.assetid: 0de06c51-8a34-dc68-6768-ea9f75dc57ee
ms.author: mtoepke
ms.date: 02/08/2017
ms.topic: article
keywords: Windows 10, uwp, игры, glsl, перенос
ms.localizationpriority: medium
ms.openlocfilehash: 47fa601a7e0ff307108713a0a6fcd7a5468b0468
ms.sourcegitcommit: 71e8eae5c077a7740e5606298951bb78fc42b22c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/14/2018
ms.locfileid: "6670193"
---
# <a name="port-the-glsl"></a>Перенос GLSL




**Важные API**

-   [Семантика HLSL](https://msdn.microsoft.com/library/windows/desktop/bb205574)
-   [Константы шейдера (HLSL)](https://msdn.microsoft.com/library/windows/desktop/bb509581)

После переноса кода, который создает и настраивает буферы и объекты шейдеров, следует перенести внутренний код шейдеров из версии GLSL (GL Shader Language) для OpenGL ES 2.0 в HLSL (High-level Shader Language) для Direct3D 11.

В OpenGL ES 2.0 шейдеры возвращают данные после выполнения с помощью встроенных элементов, таких как **gl\_Position**, **gl\_FragColor** или **gl\_FragData\[n\]** (где n представляет индекс конкретного целевого объекта отрисовки). В Direct3D нет специфических встроенных элементов, и шейдеры возвращают данные как возвращаемый тип соответствующих функций main().

Данные, которые требуется интерполировать между стадиями шейдера, такие как позиция вершины или нормаль, обрабатываются с помощью объявления **varying**. Однако в Direct3D такого объявления нет. Вместо этого любые данные, которые требуется передавать между стадиями шейдера, должны быть отмечены с помощью [семантики HLSL](https://msdn.microsoft.com/library/windows/desktop/bb205574). Конкретная выбранная семантика указывает предназначение данных. Например, данные вершины, которые требуется интерполировать между шейдером фрагментов, объявляются как:

`float4 vertPos : POSITION;`

или

`float4 vertColor : COLOR;`

где семантика POSITION используется, чтобы указать данные позиции вершины. POSITION представляет также особый случай, поскольку после интерполяции к этому элементу невозможно получить доступ с помощью построителя текстуры. Таким образом, вы должны указать входные данные для пиксельного шейдера с помощью SV\_POSITION, и интерполированные данные вершины будут помещены в эту переменную.

`float4 position : SV_POSITION;`

Семантики можно объявлять в методах тела (main) шейдеров. Для пиксельных шейдеров переменная SV\_TARGET\[n\], указывающая целевой объект отрисовки, является необходимой в методе тела. (SV\_TARGET без числового суффикса по умолчанию соответствует индексу цели «0».)

Также следует отметить, что выходными данными вершинных шейдеров должна быть семантика системного значения SV\_POSITION. Эта семантика преобразует данные о положении вершины в значения координат, где x находится в диапазоне от –1 до 1, y находится в диапазоне от –1 до 1, z делится на исходное значение однородной координаты w (z/w), а w равняется единице, деленной на исходное значение w (1/w). Пиксельные шейдеры используют семантику системных значений SV\_POSITION, чтобы получить позицию пикселя на экране, где x имеет значение от 0 до ширины целевого объекта отрисовки, а y — от 0 до высоты целевого объекта отрисовки (каждое со смещением 0,5). Пиксельные шейдеры с уровнем компонентов 9\_x не могут прочесть значение SV\_POSITION.

Буферы констант должны объявляться с ключевым словом **cbuffer** и связываться с конкретным начальным регистром для подстановки.

Direct3D 11: объявление буфера констант HLSL

``` syntax
cbuffer ModelViewProjectionConstantBuffer : register(b0)
{
  matrix mvp;
};
```

Здесь буфер констант использует регистр b0 для сохранения упакованного буфера. Ссылки на все регистры имеют вид «b\#». Дополнительные сведения о реализации буферов констант, регистров и упаковке данных в HLSL см. в разделе [Константы шейдера (HLSL)](https://msdn.microsoft.com/library/windows/desktop/bb509581).

<a name="instructions"></a>Инструкции
------------

### <a name="step-1-port-the-vertex-shader"></a>Шаг1. Перенос вершинного шейдера

В нашем простом примере OpenGL ES 2.0 вершинный шейдер имеет три входных параметра: постоянная матрица модель-представление-проекция 4×4 и два вектора с 4 координатами. Эти два вектора содержат позицию вершины и ее цвет. Шейдер преобразует вектор позиции в координаты перспективы и назначает их встроенному элементу gl\_Position для растеризации. Цвет вершины также копируется в изменяющуюся переменную для интерполяции при растеризации.

OpenGL ES 2.0: вершинный шейдер для кубического объекта (GLSL)

``` syntax
uniform mat4 u_mvpMatrix; 
attribute vec4 a_position;
attribute vec4 a_color;
varying vec4 destColor;

void main()
{           
  gl_Position = u_mvpMatrix * a_position;
  destColor = a_color;
}
```

Теперь в Direct3D матрица констант проекции модельного представления содержится в буфере констант, упакованном в регистре b0, а позиция и цвет вершины конкретно помечаются соответствующей семантикой HLSL: POSITION и COLOR. Поскольку наш макет входных данных указывает конкретное упорядочение значений этих двух векторов, вы должны создать содержащую их структуру и объявить ее как тип для входного параметра в функции тела шейдера (main). (Можно также указать их как отдельные параметры, но это приведет к сложностям.) Вы также должны задать для этой стадии выходной тип, содержащий интерполированную позицию и цвет, и объявить его как возвращаемое значение для функции тела в вершинном шейдере.

Direct3D 11: вершинный шейдер для кубического объекта (HLSL)

``` syntax
cbuffer ModelViewProjectionConstantBuffer : register(b0)
{
  matrix mvp;
};

// Per-vertex data used as input to the vertex shader.
struct VertexShaderInput
{
  float3 pos : POSITION;
  float3 color : COLOR;
};

// Per-vertex color data passed through the pixel shader.
struct PixelShaderInput
{
  float3 pos : SV_POSITION;
  float3 color : COLOR;
};

PixelShaderInput main(VertexShaderInput input)
{
  PixelShaderInput output;
  float4 pos = float4(input.pos, 1.0f); // add the w-coordinate

  pos = mul(mvp, projection);
  output.pos = pos;

  output.color = input.color;

  return output;
}
```

Выходной тип данных PixelShaderInput заполняется при растеризации и предоставляется шейдеру фрагментов (пиксельному шейдеру).

### <a name="step-2-port-the-fragment-shader"></a>Шаг 2. Перенос шейдера фрагментов

Наш пример шейдера фрагментов на GLSL весьма прост: предоставляется встроенный элемент gl\_FragColor с интерполированным значением цвета. OpenGL ES 2.0 запишет его в целевой объект отрисовки по умолчанию.

OpenGL ES 2.0: шейдер фрагментов для кубического объекта (GLSL)

``` syntax
varying vec4 destColor;

void main()
{
  gl_FragColor = destColor;
} 
```

В Direct3D все почти так же просто. Единственное существенное различие заключается в том, что функция тела построителя текстуры должна возвращать значение. Поскольку цвет представляется 4-координатным (RGBA) значением с плавающей точкой, необходимо указать float4 как возвращаемый тип, а затем указать целевой объект отрисовки по умолчанию с помощью семантики системного значения SV\_TARGET.

Direct3D 11: пиксельный шейдер для кубического объекта (HLSL)

``` syntax
struct PixelShaderInput
{
  float4 pos : SV_POSITION;
  float3 color : COLOR;
};


float4 main(PixelShaderInput input) : SV_TARGET
{
  return float4(input.color, 1.0f);
}
```

Цвет пикселя для позиции записывается в целевой объект отрисовки. Теперь посмотрим, как отобразить содержимое целевого объекта отрисовки, в разделе [Рисование на экране](draw-to-the-screen.md).

## <a name="previous-step"></a>Предыдущий шаг


[Перенос буферов вершин и данных](port-the-vertex-buffers-and-data-config.md) Следующий шаг
---------

[Рисование на экране](draw-to-the-screen.md) Заметки
-------

Понимание семантики HLSL и упаковки буферов констант избавит вас от многих затруднений при отладке, а также обеспечит возможности оптимизации. Если у вас есть возможность, внимательно изучите разделы [Синтаксис переменных (HLSL)](https://msdn.microsoft.com/library/windows/desktop/bb509706), [Введение в буферы в Direct3D 11](https://msdn.microsoft.com/library/windows/desktop/ff476898) и [Инструкции: создание буфера констант](https://msdn.microsoft.com/library/windows/desktop/ff476896). Если нет, вот для начала несколько полезных замечаний о семантике и буферах констант:

-   Всегда тщательно проверяйте код конфигурации вашего обработчика Direct3D, чтобы убедиться, что структуры ваших буферов констант соответствуют объявлениям cbuffer элементов struct в коде HLSL и что скалярные типы компонентов совпадают в обоих объявлениях.
-   В коде C++ обработчика используйте типы [DirectXMath](https://msdn.microsoft.com/library/windows/desktop/hh437833) в своих объявлениях буферов констант, чтобы обеспечить правильную упаковку данных.
-   Лучшим способом эффективного использования буферов констант является упорядочение переменных шейдера в буферах констант согласно частоте их обновления. Например, если имеются однородные данные, которые обновляются с каждым кадром, и другие однородные данные, которые обновляются только при движении камеры, постарайтесь разделить эти данные в двух отдельных буферах констант.
-   Первым источником ошибок при компиляции шейдера (FXC) будет семантика, которую вы забыли применить или применили неверно. Тщательно проверяйте семантику! Источниками ошибок могут быть документы, поскольку на многих старых страницах и в примерах имеются ссылки на другие версии семантики HLSL, предшествующие версии Direct3D 11.
-   Убедитесь, что вы понимаете, для какого уровня компонентов Direct3D вы разрабатываете каждый свой шейдер. Семантика для уровня компонентов 9\_\* отличается от семантики для уровня 11\_1.
-   Семантика SV\_POSITION сопоставляет соответствующие данные позиции после интерполяции со значениями координат, где x имеет значение от 0 до ширины объекта отрисовки, y — от 0 до высоты объекта отрисовки, z делится на исходное значение однородной координаты w (z/w), а w равняется частному деления 1 на исходное значение w (1/w).

## <a name="related-topics"></a>Ссылки по теме


[Инструкции: перенос простого обработчика OpenGL ES 2.0 в Direct3D 11](port-a-simple-opengl-es-2-0-renderer-to-directx-11-1.md)

[Перенос объектов шейдеров](port-the-shader-config.md)

[Перенос буферов вершин и данных](port-the-vertex-buffers-and-data-config.md)

[Рисование на экране](draw-to-the-screen.md)

 

 




