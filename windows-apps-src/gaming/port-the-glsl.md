---
title: Перенос GLSL
description: После переноса кода, который создает и настраивает буферы и объекты шейдеров, следует перенести внутренний код шейдеров из версии GLSL (GL Shader Language) для OpenGL ES 2.0 в HLSL (High-level Shader Language) для Direct3D 11.
ms.assetid: 0de06c51-8a34-dc68-6768-ea9f75dc57ee
ms.date: 02/08/2017
ms.topic: article
keywords: Windows 10, uwp, игры, glsl, перенос
ms.localizationpriority: medium
ms.openlocfilehash: 210f98476a06b88e7d3d543006a6d4ec886cfd45
ms.sourcegitcommit: ac7f3422f8d83618f9b6b5615a37f8e5c115b3c4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/29/2019
ms.locfileid: "66368255"
---
# <a name="port-the-glsl"></a>Перенос GLSL




**Важные API**

-   [Семантика HLSL](https://docs.microsoft.com/windows/desktop/direct3dhlsl/dcl-usage---ps)
-   [Константы построителей текстур (HLSL)](https://docs.microsoft.com/windows/desktop/direct3dhlsl/dx-graphics-hlsl-constants)

После переноса кода, который создает и настраивает буферы и объекты шейдеров, следует перенести внутренний код шейдеров из версии GLSL (GL Shader Language) для OpenGL ES 2.0 в HLSL (High-level Shader Language) для Direct3D 11.

OpenGL ES 2.0, шейдеры возвращать данные после выполнения с помощью встроенных функций, таких как **gl\_позиции**, **gl\_FragColor**, или **gl\_FragData \[n\]**  (где n — это индекс для определенной отрисовки целевого объекта). В Direct3D нет специфических встроенных элементов, и шейдеры возвращают данные как возвращаемый тип соответствующих функций main().

Данные, которые требуется интерполировать между стадиями шейдера, такие как позиция вершины или нормаль, обрабатываются с помощью объявления **varying**. Однако в Direct3D такого объявления нет. Вместо этого любые данные, которые требуется передавать между стадиями шейдера, должны быть отмечены с помощью [семантики HLSL](https://docs.microsoft.com/windows/desktop/direct3dhlsl/dcl-usage---ps). Конкретная выбранная семантика указывает предназначение данных. Например, данные вершины, которые требуется интерполировать между шейдером фрагментов, объявляются как:

`float4 vertPos : POSITION;`

или диспетчер конфигурации служб

`float4 vertColor : COLOR;`

где семантика POSITION используется, чтобы указать данные позиции вершины. POSITION представляет также особый случай, поскольку после интерполяции к этому элементу невозможно получить доступ с помощью построителя текстуры. Таким образом, необходимо указать входные данные для построителя текстуры с SV\_положение и интерполированными данными вершин будут помещены в эту переменную.

`float4 position : SV_POSITION;`

Семантики можно объявлять в методах тела (main) шейдеров. Для построители текстуры, SV\_ЦЕЛЕВОЙ\[n\], которое указывает целевой объект отрисовки, необходим для тела метода. (SV\_ЦЕЛЕВОЙ без числовой суффикс по умолчанию используется для подготовки к просмотру целевой индекс 0.)

Также Обратите внимание, что необходимые шейдеры вершин для вывода SV\_семантической значение system ПОЗИЦИИ. Эта семантика преобразует данные о положении вершины в значения координат, где x находится в диапазоне от –1 до 1, y находится в диапазоне от –1 до 1, z делится на исходное значение однородной координаты w (z/w), а w равняется единице, деленной на исходное значение w (1/w). Построители текстур используйте SV\_семантической для получения расположения указывается пикселей на экране, где x — между 0 и ширину целевой объект отрисовки и y ПОЗИЦИИ системное значение находится между 0 и высота целевой объект отрисовки (каждым смещением, 0,5). Уровень 9\_x пиксель, шейдеры не удается считать из SV\_значение ПОЗИЦИИ.

Буферы констант должны объявляться с ключевым словом **cbuffer** и связываться с конкретным начальным регистром для подстановки.

Direct3D 11: Объявление буфера констант HLSL

``` syntax
cbuffer ModelViewProjectionConstantBuffer : register(b0)
{
  matrix mvp;
};
```

Здесь буфер констант использует регистр b0 для сохранения упакованного буфера. В форме b называется регистров\#. Дополнительные сведения о реализации буферов констант, регистров и упаковке данных в HLSL см. в разделе [Константы шейдера (HLSL)](https://docs.microsoft.com/windows/desktop/direct3dhlsl/dx-graphics-hlsl-constants).

<a name="instructions"></a>Инструкция
------------
### <a name="step-1-port-the-vertex-shader"></a>Шаг 1. Порт вершинный построитель текстуры

В нашем простом примере OpenGL ES 2.0 вершинный шейдер имеет три входных параметра: постоянная матрица модель-представление-проекция 4×4 и два вектора с 4 координатами. Эти два вектора содержат позицию вершины и ее цвет. Преобразует вектор положение координаты точки зрения шейдер и ему присваивается gl\_внутренние растеризации позиции. Цвет вершины также копируется в изменяющуюся переменную для интерполяции при растеризации.

OpenGL ES 2.0: Вершинный построитель текстуры для объекта куба (GLSL)

``` syntax
uniform mat4 u_mvpMatrix; 
attribute vec4 a_position;
attribute vec4 a_color;
varying vec4 destColor;

void main()
{           
  gl_Position = u_mvpMatrix * a_position;
  destColor = a_color;
}
```

Теперь в Direct3D, постоянное матрица проекции model-view, содержащийся в буфер констант, упакованные в b0 регистра и вершин положение и цвет специально отмечены соответствующие соответствующей семантики HLSL: ПОЛОЖЕНИЕ и ЦВЕТ. Поскольку наш макет входных данных указывает конкретное упорядочение значений этих двух векторов, вы должны создать содержащую их структуру и объявить ее как тип для входного параметра в функции тела шейдера (main). (Можно также указать их как два отдельных параметров, но которое давало громоздким.) Также укажите тип выходных данных для этапа, который содержит интерполированные положение и цвет, и объявите его в качестве возвращаемого значения для тела функции шейдера вершин.

Direct3D 11: Вершинный построитель текстуры для объекта куба (HLSL)

``` syntax
cbuffer ModelViewProjectionConstantBuffer : register(b0)
{
  matrix mvp;
};

// Per-vertex data used as input to the vertex shader.
struct VertexShaderInput
{
  float3 pos : POSITION;
  float3 color : COLOR;
};

// Per-vertex color data passed through the pixel shader.
struct PixelShaderInput
{
  float3 pos : SV_POSITION;
  float3 color : COLOR;
};

PixelShaderInput main(VertexShaderInput input)
{
  PixelShaderInput output;
  float4 pos = float4(input.pos, 1.0f); // add the w-coordinate

  pos = mul(mvp, projection);
  output.pos = pos;

  output.color = input.color;

  return output;
}
```

Выходной тип данных PixelShaderInput заполняется при растеризации и предоставляется шейдеру фрагментов (пиксельному шейдеру).

### <a name="step-2-port-the-fragment-shader"></a>Шаг 2. Порт шейдер фрагмента

Шейдер фрагментов наш пример в GLSL чрезвычайно проста: укажите gl\_FragColor встроенная функция с значение интерполированные цвета. OpenGL ES 2.0 запишет его в целевой объект отрисовки по умолчанию.

OpenGL ES 2.0: Шейдер фрагмента для объекта куба (GLSL)

``` syntax
varying vec4 destColor;

void main()
{
  gl_FragColor = destColor;
} 
```

В Direct3D все почти так же просто. Единственное существенное различие заключается в том, что функция тела построителя текстуры должна возвращать значение. Поскольку цвет является значением 4 координат (RGBA) число с плавающей запятой, указать float4 в качестве возвращаемого типа и укажите целевой объект отрисовки по умолчанию SV\_целевого системы семантического значения.

Direct3D 11: Построитель текстуры для объекта куба (HLSL)

``` syntax
struct PixelShaderInput
{
  float4 pos : SV_POSITION;
  float3 color : COLOR;
};


float4 main(PixelShaderInput input) : SV_TARGET
{
  return float4(input.color, 1.0f);
}
```

Цвет пикселя для позиции записывается в целевой объект отрисовки. Теперь посмотрим, как отобразить содержимое целевого объекта отрисовки, в разделе [Рисование на экране](draw-to-the-screen.md).

## <a name="previous-step"></a>Предыдущий шаг


[Перенос буферов вершин и данных](port-the-vertex-buffers-and-data-config.md) Следующий шаг
---------
[Рисование на экране](draw-to-the-screen.md) Заметки
-------
Понимание семантики HLSL и упаковки буферов констант избавит вас от многих затруднений при отладке, а также обеспечит возможности оптимизации. Если вы получаете шанс, прочтите [переменной синтаксис (HLSL)](https://docs.microsoft.com/windows/desktop/direct3dhlsl/dx-graphics-hlsl-variable-syntax), [введение буферов в Direct3D 11](https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-resources-buffers-intro), и [как: Создание буфера констант](https://docs.microsoft.com/windows/desktop/direct3d11/overviews-direct3d-11-resources-buffers-constant-how-to). Если нет, вот для начала несколько полезных замечаний о семантике и буферах констант:

-   Всегда тщательно проверяйте код конфигурации вашего обработчика Direct3D, чтобы убедиться, что структуры ваших буферов констант соответствуют объявлениям cbuffer элементов struct в коде HLSL и что скалярные типы компонентов совпадают в обоих объявлениях.
-   В коде C++ обработчика используйте типы [DirectXMath](https://docs.microsoft.com/windows/desktop/dxmath/directxmath-portal) в своих объявлениях буферов констант, чтобы обеспечить правильную упаковку данных.
-   Лучшим способом эффективного использования буферов констант является упорядочение переменных шейдера в буферах констант согласно частоте их обновления. Например, если имеются однородные данные, которые обновляются с каждым кадром, и другие однородные данные, которые обновляются только при движении камеры, постарайтесь разделить эти данные в двух отдельных буферах констант.
-   Первым источником ошибок при компиляции шейдера (FXC) будет семантика, которую вы забыли применить или применили неверно. Тщательно проверяйте семантику! Источниками ошибок могут быть документы, поскольку на многих старых страницах и в примерах имеются ссылки на другие версии семантики HLSL, предшествующие версии Direct3D 11.
-   Убедитесь, что вы понимаете, для какого уровня компонентов Direct3D вы разрабатываете каждый свой шейдер. Семантика для функции уровня 9\_ \* отличаются от 11\_1.
-   SV\_семантической разрешает ПОЗИЦИИ данных связанную позицию после интерполяции для координации значения, где x — между 0 и ширины целевой объект отрисовки, y находится между 0 и подготовки к просмотру целевых высоты, z делится на исходное однородных координат w значение (z и w) и w,-1, деленное на исходное значение w (1/w).

## <a name="related-topics"></a>См. также


[Практическое: порт простой модуль подготовки отчетов OpenGL ES 2.0 на Direct3D 11](port-a-simple-opengl-es-2-0-renderer-to-directx-11-1.md)

[Перенос объектов шейдеров](port-the-shader-config.md)

[Перенос данных и буферов вершин](port-the-vertex-buffers-and-data-config.md)

[Рисование объектов на экране](draw-to-the-screen.md)

 

 




