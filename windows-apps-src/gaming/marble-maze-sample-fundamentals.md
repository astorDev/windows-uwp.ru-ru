---
title: Основные положения примера Marble Maze
description: В этом документе описаны основные характеристики проекта Marble Maze, такие как использование Visual C++ в среде выполнения Windows, создание проекта, его структурирование и сборка.
ms.assetid: 73329b29-62e3-1b36-01db-b7744ee5b4c3
ms.date: 08/22/2017
ms.topic: article
keywords: windows 10, uwp, игры, пример, directx, основы
ms.localizationpriority: medium
ms.openlocfilehash: 21dcbbcc1fde25877592fafe9e8372e269a72a42
ms.sourcegitcommit: ac7f3422f8d83618f9b6b5615a37f8e5c115b3c4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/29/2019
ms.locfileid: "66368494"
---
# <a name="marble-maze-sample-fundamentals"></a>Основные положения примера Marble Maze




В этом разделе описаны основные характеристики проекта Marble Maze,&mdash;такие как использование Visual C++ в среде выполнения Windows, создание проекта, его структурирование и сборка. Здесь также описаны некоторые соглашения, используемые в коде.

> [!NOTE]
> Пример кода, соответствующего этому документу, см. в [примере игры DirectX Marble Maze](https://go.microsoft.com/fwlink/?LinkId=624011).

Ниже приведены основные вопросы, возникающие при планировании и разработке игры универсальной платформы Windows (UWP), которые обсуждаются в этом документе.

-   Использование шаблона Visual C++ **Приложение DirectX 11 (универсальные приложения для Windows)** в Visual Studio для создания игры UWP на DirectX.
-   Среда выполнения Windows предоставляет классы и интерфейсы, благодаря чему вы можете создавать приложения UWP в более современном объектно-ориентированном стиле.
-   Используйте ссылки на объекты с символом hat (^) для управления временем жизни переменных среды выполнения Windows, [Microsoft::wrl:: comptr](https://docs.microsoft.com/cpp/windows/comptr-class) для управления временем жизни объектов COM и [std::shared\_ptr](https://docs.microsoft.com/cpp/standard-library/shared-ptr-class) или [std::unique\_ptr](https://docs.microsoft.com/cpp/standard-library/unique-ptr-class) для управления временем жизни всех остальных куче C++ объектов.
-   В большинстве случаев рекомендуется обработка исключений вместо кодов завершения для обработки непредвиденных ошибок.
-   Использование для обнаружения ошибок в приложении [аннотаций SAL](https://docs.microsoft.com/visualstudio/code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects) совместно со средствами анализа кода.

## <a name="creating-the-visual-studio-project"></a>Создание проекта Visual Studio


После скачивания и распаковки примера вы можете открыть файл **MarbleMaze_VS2017.sln** (в папке **C++** ) в Visual Studio и просмотреть его код.

Когда мы создавали проект Visual Studio для Marble Maze, мы начинали с существующего проекта. Однако если у вас нет уже существующего проекта, который обеспечивает основные функции, необходимые для игры UWP на DirectX, рекомендуется создать проект на основе шаблона Visual Studio **Приложение DirectX 11 (универсальное приложение Windows)** , поскольку он позволяет создать простое работающее трехмерное приложение. Для этого выполните следующие действия:

1. В Visual Studio 2017 выберите **Файл > Создать > Проект...**

2. В окне **Новый проект** на левой боковой панели выберите **Установленные > Шаблоны > Visual C++** .

3. В центральном списке выберите **Приложение DirectX 11 (универсальные приложения для Windows)** . Если этот вариант отсутствует, возможно у вас не установлены необходимые компоненты. Сведения об установке дополнительных компонентов см. в разделе [Изменение Visual Studio 2017 путем добавления или удаления рабочих нагрузок и компонентов](https://docs.microsoft.com/visualstudio/install/modify-visual-studio).

4. Дайте проекту **Имя**, укажите **Расположение** для хранения файлов и **Имя решения**, а затем нажмите кнопку **ОК**.

![Новый проект](images/marble-maze-sample-fundamentals-1.png)

Одним из важных параметров проекта в шаблоне **Приложение DirectX 11 (универсальное приложение Windows)** является параметр **/ZW**, который позволяет программе использовать языковые исключения среды выполнения Windows. При использовании шаблона Visual Studio этот параметр включен по умолчанию. В разделе [Настройка параметров компилятора](https://docs.microsoft.com/cpp/build/reference/setting-compiler-options) представлены дополнительные сведения о том, как настроить параметры компилятора в Visual Studio.

> **Внимание**    **/ZW** параметр не совместим с параметрами таких как **/CLR**. В случае **/clr** это означает, что вы не сможете настроить работу и .NET Framework, и среды выполнения Windows с одним и тем же проектом Visual C++.

 

Каждое приложение универсальной платформы Windows, полученные из Microsoft Store поставляется в виде пакета приложения. Пакет приложения включает в себя манифест пакета, содержащий информацию о вашем приложении. Например, вы можете указать возможности (то есть требуемый доступ к защищенным системным ресурсам или данным пользователя) вашего приложения. Если вы знаете, что вашему приложению необходимы определенные возможности, используйте манифест пакета для объявления требуемых возможностей. Манифест позволяет также задать свойства проекта, такие как поддержка поворота устройств, изображения плиток и экран приветствия. Изменить манифест можно, открыв файл **Package.appxmanifest** в проекте. Подробнее о пакетах приложений см. в разделе [Создание пакетов приложений](https://docs.microsoft.com/windows/uwp/packaging/index).

##  <a name="building-deploying-and-running-the-game"></a>Сборка, развертывание и запуск игры

В раскрывающихся меню в верхней части Visual Studio, слева от зеленой кнопки "Воспроизведение", выберите конфигурацию развертывания. Рекомендуется выбрать конфигурацию **Отладка** для архитектуры вашего устройства (**x86** для 32-разрядного устройства и **x64** для 64-разрядного), а также **Локальный компьютер**. Кроме того, тестирование можно выполнить на **удаленном компьютере** или на **устройстве**, подключенном к USB-порту. Затем нажмите зеленую кнопку "Воспроизведение" для создания и развертывания на устройстве.

![Отладка; x64; Локальный компьютер](images/marble-maze-sample-fundamentals-2.png)

###  <a name="controlling-the-game"></a>Управление игрой

Для управления Marble Maze можно использовать сенсорный ввод, акселерометр, контроллер Xbox One или мышь.

-   Для изменения активного пункта меню используйте планшет контроллера.
-   Для выбора пункта меню используйте сенсорный ввод, кнопку A или кнопку "Пуск" на контроллере или мышь.
-   Для наклона лабиринта используйте сенсорный ввод, акселерометр, левый манипулятор или мышь.
-   Для закрытия меню, например таблицы рекордов, используйте сенсорный ввод, кнопку A или кнопку "Пуск" на контроллере или мышь.
-   Для приостановки или возобновления игры используйте кнопку "Пуск" на контроллере или клавишу P на клавиатуре.
-   Для перезапуска игры используйте кнопку «Назад» на контроллере или клавишу HOME на клавиатуре.
-   Для очистки всех результатов в таблице рекордов используйте кнопку "Назад" на контроллере или клавишу HOME на клавиатуре.

##  <a name="code-conventions"></a>Соглашения, касающиеся кода


Среда выполнения Windows — это интерфейс программирования, который можно использовать для создания приложений UWP, выполняющихся только в особой среде для приложений. Такие приложения используют авторизованные функции, типы данных и устройства и распространяются через Microsoft Store. На самом низком уровне среда выполнения Windows представляет собой двоичный интерфейс приложения (ABI). ABI — это двоичный контракт низкого уровня, который обеспечивает доступ к API среды выполнения Windows многим языкам программирования, таким как JavaScript, .NET и Visual C++.

Чтобы вызвать API среды выполнения Windows из JavaScript и .NET, этим языкам требуются проекции, специфические для среды каждого языка. Когда вы вызываете API среды выполнения Windows из JavaScript или .NET, вы вызываете проекцию, которая в свою очередь вызывает нижестоящую функцию ABI. Хотя вы можете вызывать функции ABI непосредственно из C++, Майкрософт предоставляет проекции и для C++, так как они значительно упрощают использование API среды выполнения Windows, сохраняя при этом высокую производительность. Майкрософт также предоставляет расширения языка Visual C++, которое поддерживает конкретно проекции среды выполнения Windows. Синтаксис многих из этих расширений похож на синтаксис C++/CLI. Однако вместо обращения к общей среде выполнения языков (CLR) собственные приложения используют для обращения к среде выполнения Windows следующий синтаксис. Модификатор ссылок на объекты, или «крышка» (^) является важной частью этого нового синтаксиса, постольку он дает возможность автоматически удалять объекты среды выполнения при помощи подсчета ссылок. Вызов методов, таких как [AddRef](https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref) и [Release](https://docs.microsoft.com/windows/desktop/api/unknwn/nf-unknwn-iunknown-release), для управления жизненным циклом объектов среды выполнения Windows не требуется. Среда выполнения удаляет объекты, когда на них не остается ни одной ссылки от других компонентов, например когда они покидают область или вы устанавливаете для всех ссылок значение **nullptr**. Еще одна важная особенность использования Visual C++ для создания приложений UWP — ключевое слово **ref new**. Используйте **ref new** вместо **new** для создания объектов среды выполнения Windows с подсчетом ссылок. Дополнительные сведения см. в разделе [Система типов (C++/CX)](https://docs.microsoft.com/cpp/cppcx/type-system-c-cx).

> [!IMPORTANT]
> При создании объектов или компонентов среды выполнения Windows следует использовать только **^** и **ref new**. Вы можете использовать стандартный синтаксис C++ при написании основного кода приложения, который не использует среду выполнения Windows.

В Marble Maze используется символ **^** совместно с **Microsoft::WRL::ComPtr**, чтобы управлять динамически выделенными объектами и свести к минимуму потери памяти. Мы рекомендуем использовать ^ для управления временем жизни переменных среды выполнения Windows, **ComPtr** для управления временем жизни переменных COM (например, при использовании DirectX), и **std::shared\_ptr** или **std::unique\_ptr** для управления временем жизни всех остальных куче C++ объектов.

 

Дополнительные сведения о расширениях языков, доступных для приложений UWP на C++, см. в разделе [Справочник по языку Visual C++ (C++/CX)](https://docs.microsoft.com/cpp/cppcx/visual-c-language-reference-c-cx).

###  <a name="error-handling"></a>Обработка ошибок

В Marble Maze основной метод обработки непредвиденных ошибок — обработка исключений. Хотя традиционно в коде игр для указания на ошибки используется ведение журнала или коды ошибок, например значения **HRESULT**, обработка исключений имеет два основных преимущества. Во-первых, она облегчает чтение и поддержку кода. При написании кода удобнее использовать обработку исключений для передачи данных об ошибке в процедуру, которая может обработать эту ошибку. Обычно при использовании кодов ошибок каждая функция должна явно передать данные об ошибках. Во-вторых, вы можете настроить отладчик Visual Studio так, чтобы он прерывался при возникновении исключения, и вы могли бы остановиться непосредственно в расположении и контексте ошибки. Обработка исключений также широко используется в среде выполнения Windows. Таким образом, благодаря использованию исключений в коде вы можете объединить обработку всех ошибок в одной модели.

Мы рекомендуем использовать в вашей модели обработки ошибок следующие соглашения.

-   Используйте исключения для передачи данных о непредвиденных ошибках.
-   Не используйте исключения для управления потоком кода.
-   Захватывайте только те исключения, которые можете безопасно обработать с последующим восстановлением. В ином случае не захватывайте исключение и позвольте приложению завершиться.
-   При вызове процедуры DirectX, которая возвращает **HRESULT**, используйте функцию **DX::ThrowIfFailed**. Эта функция определена в [DirectXHelper.h](https://github.com/Microsoft/Windows-appsample-marble-maze/blob/master/C%2B%2B/Shared/DirectXHelper.h). **ThrowIfFailed** выдает исключение, если переданный **HRESULT** является кодом ошибки. Например **E\_УКАЗАТЕЛЬ** вызывает **ThrowIfFailed** исключение [Platform::NullReferenceException](https://docs.microsoft.com/cpp/cppcx/platform-nullreferenceexception-class).

    Используя **ThrowIfFailed**, поместите вызов DirectX в отдельную строку для удобочитаемости кода, как показано в следующем примере.

    ```cpp
    // Identify the physical adapter (GPU or card) this device is running on.
    ComPtr<IDXGIAdapter> dxgiAdapter;
    DX::ThrowIfFailed(
        dxgiDevice->GetAdapter(&dxgiAdapter)
        );
    ```

-   Мы рекомендуем вам избегать использования **HRESULT** при обработке непредвиденных ошибок, но гораздо важнее избегать использования обработки исключений при управлении потоком кода. Поэтому, когда возникает необходимость управлять потоком кода, предпочтительнее использовать значение, возвращаемое **HRESULT**.

###  <a name="sal-annotations"></a>Аннотации SAL

Использование для обнаружения ошибок в приложении аннотаций SAL совместно со средствами анализа кода.

Используя язык аннотаций исходного кода Microsoft (SAL), вы можете аннотировать (описывать) то, как функция использует свои параметры. Аннотации SAL описывают также возвращаемые значения. Аннотации SAL при выявлении возможных дефектов в исходном коде C и C++ работают совместно со средством C/C++ Code Analysis. Это средство выявляет типичные ошибки кодирования, такие как переполнения буфера, неинициализированную память, разыменование пустых указателей, утечку памяти и ресурсов.

Рассмотрим метод **BasicLoader::LoadMesh**, заявленный в [BasicLoader.h](https://github.com/Microsoft/Windows-appsample-marble-maze/blob/e62d68a85499e208d591d2caefbd9df62af86809/C%2B%2B/Shared/BasicLoader.h). В этом методе используется параметр `_In_` для указания того, что *filename* — входной параметр (поэтому из него возможно только чтение), `_Out_` — для указания того, что *vertexBuffer* и *indexBuffer* — выходные параметры (поэтому в них возможна только запись), и `_Out_opt_` — для указания того, что *vertexCount* и *indexCount* — необязательные выходные параметры (в них возможна запись). Поскольку *vertexCount* и *indexCount* являются необязательными выходными параметрами, они могут принимать значение **nullptr**. Средство C/C++ Code Analysis проверяет вызовы этого метода, чтобы убедиться, что параметры, передаваемые им, удовлетворяют этим критериям.

```cpp
void LoadMesh(
    _In_ Platform::String^ filename,
    _Out_ ID3D11Buffer** vertexBuffer,
    _Out_ ID3D11Buffer** indexBuffer,
    _Out_opt_ uint32* vertexCount,
    _Out_opt_ uint32* indexCount
    );
```

Чтобы выполнить анализ кода вашего приложения, в строке меню выберите команду **Сборка > Выполнить анализ кода решения**. Дополнительные сведения об анализе кода см. в разделе [Анализ качества кода C/C++ с использованием анализа кода](https://docs.microsoft.com/visualstudio/code-quality/analyzing-c-cpp-code-quality-by-using-code-analysis).

Полный перечень возможных аннотаций приведен в sal.h. Дополнительные сведения см. в статье [Аннотации SAL](https://docs.microsoft.com/cpp/c-runtime-library/sal-annotations).

## <a name="next-steps"></a>Следующие шаги


Прочтите раздел [Структура приложения Marble Maze](marble-maze-application-structure.md), чтобы понять, как структурирован код приложения Marble Maze и как структура приложения UWP на DirectX отличается от структуры традиционного классического приложения.

## <a name="related-topics"></a>См. также


* [Структура приложения marble Maze](marble-maze-application-structure.md)
* [Разработка Marble Maze, игрой UWP на C++ и DirectX](developing-marble-maze-a-windows-store-game-in-cpp-and-directx.md)

 

 




