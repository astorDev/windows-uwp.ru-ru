---
author: eliotcowley
title: Основные положения примера Marble Maze
description: В этом документе описаны основные характеристики проекта Marble Maze; например как использование Visual C++ в среде выполнения Windows, как он создается и структурирование и как его сборки.
ms.assetid: 73329b29-62e3-1b36-01db-b7744ee5b4c3
ms.author: elcowle
ms.date: 08/22/2017
ms.topic: article
keywords: windows 10, uwp, игры, пример, directx, основы
ms.localizationpriority: medium
ms.openlocfilehash: f595c8f429c93a13d6342c281a90f3b0f5741621
ms.sourcegitcommit: b7e3d222e229cdbf04e837fcb94fb7d84a93de09
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/26/2018
ms.locfileid: "5597063"
---
# <a name="marble-maze-sample-fundamentals"></a>Основные положения примера Marble Maze




В этом разделе описаны основные характеристики проекта Marble Maze,&mdash;такие как использование Visual C++ в среде выполнения Windows, создание проекта, его структурирование и сборка. Здесь также описаны некоторые соглашения, используемые в коде.

> [!NOTE]
> Пример кода, соответствующего этому документу, см. в [примере игры DirectX Marble Maze](http://go.microsoft.com/fwlink/?LinkId=624011).

Ниже приведены основные вопросы, возникающие при планировании и разработке игры универсальной платформы Windows (UWP), которые обсуждаются в этом документе.

-   Использование шаблона Visual C++ **Приложение DirectX11 (универсальные приложения для Windows)** в Visual Studio для создания игры UWP на DirectX.
-   Среда выполнения Windows предоставляет классы и интерфейсы, благодаря чему вы можете создавать приложения UWP в более современном объектно-ориентированном стиле.
-   Использование ссылок на объекты с применением символа ^ («крышка») для управления жизненным циклом переменных среды выполнения Windows, [Microsoft::WRL::ComPtr](https://docs.microsoft.com/cpp/windows/comptr-class) для управления жизненным циклом объектов модели COM и [std::shared\_ptr](https://docs.microsoft.com/cpp/standard-library/shared-ptr-class) или [std::unique\_ptr](https://docs.microsoft.com/cpp/standard-library/unique-ptr-class) для управления жизненным циклом всех остальных динамически выделенных объектов C++.
-   В большинстве случаев рекомендуется обработка исключений вместо кодов завершения для обработки непредвиденных ошибок.
-   Использование [SAL совместно со](https://docs.microsoft.com/visualstudio/code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects) средствами анализа кода для обнаружения ошибок в приложении аннотаций.

## <a name="creating-the-visual-studio-project"></a>Создание проекта Visual Studio


Если после скачивания и распаковки примера, можно открыть файл **MarbleMaze_VS2017.sln** (в папке **C++** ) в Visual Studio, и вы получите код.

Когда мы создавали проект Visual Studio для Marble Maze, мы начинали с существующего проекта. Однако если у вас нет уже существующего проекта, который обеспечивает основные функции, необходимые для игры UWP на DirectX, рекомендуется создать проект на основе шаблона Visual Studio **Приложение DirectX11 (универсальное приложение Windows)**, поскольку он позволяет создать простое работающее трехмерное приложение. Для этого выполните следующие действия:

1. В Visual Studio 2017, выберите **Файл > Создать > проект**

2. В окне **Новый проект** в левой боковой панели, выберите **Установленные > Шаблоны > Visual C++**.

3. В среднем списке выберите **Приложение DirectX 11 (универсальное приложение Windows)**. Если вы не видите этот параметр, все необходимые компоненты, возможно не&mdash; [Изменить Visual Studio 2017 путем добавления или удаления рабочих нагрузок и компонентов](https://docs.microsoft.com/visualstudio/install/modify-visual-studio) см. в разделе о том, как установить дополнительные компоненты.

4. Предоставьте свой проект, **имя**, **расположение** файлов для хранения и **имя решения**и нажмите кнопку **ОК**.

![Новый проект](images/marble-maze-sample-fundamentals-1.png)

Одним из важных параметров проекта в шаблоне **Приложение DirectX11 (универсальное приложение Windows)** является параметр **/ZW**, который позволяет программе использовать языковые исключения среды выполнения Windows. При использовании шаблона Visual Studio этот параметр включен по умолчанию. В разделе [Настройка параметров компилятора](https://docs.microsoft.com/cpp/build/reference/setting-compiler-options) представлены дополнительные сведения о том, как настроить параметры компилятора в Visual Studio.

> **Внимание**  **/ZW** вариант не совместим с параметры, такие **как/CLR**. В случае **/clr** это означает, что вы не сможете настроить работу и .NET Framework, и среды выполнения Windows с одним и тем же проектом Visual C++.

 

Каждое приложение UWP, которые вы получаете из Microsoft Store поставляется в виде пакета приложения. Пакет приложения включает в себя манифест пакета, содержащий информацию о вашем приложении. Например, вы можете указать возможности (то есть требуемый доступ к защищенным системным ресурсам или данным пользователя) вашего приложения. Если вы знаете, что вашему приложению необходимы определенные возможности, используйте манифест пакета для объявления требуемых возможностей. Манифест позволяет также задать свойства проекта, такие как поддержка поворота устройств, изображения плиток и экран приветствия. Изменить манифест можно, открыв файл **Package.appxmanifest** в проекте. Подробнее о пакетах приложений см. в разделе [Создание пакетов приложений](https://msdn.microsoft.com/library/windows/apps/mt270969).

##  <a name="building-deploying-and-running-the-game"></a>Сборка, развертывание и запуск игры

В раскрывающихся меню в верхней части Visual Studio, слева от зеленой кнопки "Воспроизведение", выберите конфигурацию развертывания. Рекомендуется выбрать конфигурацию **Отладка** для архитектуры вашего устройства (**x86** для 32-разрядного устройства и **x64** для 64-разрядного), а также **Локальный компьютер**. Кроме того, тестирование можно выполнить на **удаленном компьютере** или на **устройстве**, подключенном к USB-порту. Затем нажмите зеленую кнопку "Воспроизведение" для создания и развертывания на устройстве.

![Отладка; x64; Локальный компьютер](images/marble-maze-sample-fundamentals-2.png)

###  <a name="controlling-the-game"></a>Управление игрой

Вы можете использовать сенсорный ввод, акселерометр, контроллер Xbox One или мыши для управления Marble Maze.

-   Для изменения активного пункта меню используйте планшет контроллера.
-   Используйте сенсорный ввод, A или меню "Пуск" кнопки на контроллере или мыши для выбора пункта меню.
-   Для наклона лабиринта используйте сенсорный ввод, акселерометр, левый манипулятор или мышь.
-   Используйте сенсорный ввод, A или меню "Пуск" кнопки на контроллере или мышь, чтобы закрыть меню, например таблицу.
-   Используйте кнопку «Пуск» на контроллере или клавишу P на клавиатуре для приостановки и возобновления игры.
-   Для перезапуска игры используйте кнопку «Назад» на контроллере или клавишу HOME на клавиатуре.
-   Если лучших отображается, используйте кнопки "Назад" на контроллере или клавишу Home на клавиатуре для очистки всех результатов.

##  <a name="code-conventions"></a>Соглашения, касающиеся кода


Среда выполнения Windows — это интерфейс программирования, который можно использовать для создания приложений UWP, выполняющихся только в особой среде для приложений. Таких приложениях используются авторизованные функции, типы данных и устройств и распространяются через Microsoft Store. На самом низком уровне среда выполнения Windows представляет собой двоичный интерфейс приложения (ABI). ABI — это двоичный контракт низкого уровня, который обеспечивает доступ к API среды выполнения Windows многим языкам программирования, таким как JavaScript, .NET и Visual C++.

Чтобы вызвать API среды выполнения Windows из JavaScript и .NET, этим языкам требуются проекции, специфические для среды каждого языка. Когда вы вызываете API среды выполнения Windows из JavaScript или .NET, вы вызываете проекцию, которая в свою очередь вызывает нижестоящую функцию ABI. Хотя вы можете вызывать функции ABI непосредственно из C++, Майкрософт предоставляет проекции и для C++, так как они значительно упрощают использование API среды выполнения Windows, сохраняя при этом высокую производительность. Майкрософт также предоставляет расширения языка Visual C++, которое поддерживает конкретно проекции среды выполнения Windows. Синтаксис многих из этих расширений похож на синтаксис C++/CLI. Однако вместо обращения к общей среде выполнения языков (CLR) собственные приложения используют для обращения к среде выполнения Windows следующий синтаксис. Модификатор ссылок на объекты, или «крышка» (^) является важной частью этого нового синтаксиса, постольку он дает возможность автоматически удалять объекты среды выполнения при помощи подсчета ссылок. Вызов методов, таких как [AddRef](https://msdn.microsoft.com/library/windows/desktop/ms691379) и [Release](https://msdn.microsoft.com/library/windows/desktop/ms682317), для управления жизненным циклом объектов среды выполнения Windows не требуется. Среда выполнения удаляет объекты, когда на них не остается ни одной ссылки от других компонентов, например когда они покидают область или вы устанавливаете для всех ссылок значение **nullptr**. Еще одна важная особенность использования Visual C++ для создания приложений UWP— ключевое слово **ref new**. Используйте **ref new** вместо **new** для создания объектов среды выполнения Windows с подсчетом ссылок. Дополнительные сведения см. в разделе [Система типов (C++/CX)](https://msdn.microsoft.com/library/windows/apps/hh755822).

> [!IMPORTANT]
> При создании объектов или компонентов среды выполнения Windows следует использовать только **^** и **ref new**. Вы можете использовать стандартный синтаксис C++ при написании основного кода приложения, который не использует среду выполнения Windows.

Marble Maze использует **^** совместно с **Microsoft::WRL::ComPtr**, чтобы управлять динамически выделенными объектами и свести к минимуму потери памяти. Мы рекомендуем использовать ^ для управления жизненным циклом переменных среды выполнения Windows, **ComPtr** для управления жизненным циклом переменных модели COM (например, при использовании DirectX) и **std:: shared\_ptr** или **std:: unique\_ptr** для управления жизненным циклом всех остальных динамически выделенных объектов C++.

 

Дополнительные сведения о расширениях языков, доступных для приложений UWP на C++, см. в разделе [Справочник по языку Visual C++ (C++/CX)](https://msdn.microsoft.com/library/windows/apps/hh699871).

###  <a name="error-handling"></a>Обработка ошибок

В Marble Maze основной метод обработки непредвиденных ошибок — обработка исключений. Хотя традиционно в коде игр для указания на ошибки используется ведение журнала или коды ошибок, например значения **HRESULT**, обработка исключений имеет два основных преимущества. Во-первых, она облегчает чтение и поддержку кода. При написании кода удобнее использовать обработку исключений для передачи данных об ошибке в процедуру, которая может обработать эту ошибку. Обычно при использовании кодов ошибок каждая функция должна явно передать данные об ошибках. Во-вторых, вы можете настроить отладчик Visual Studio так, чтобы он прерывался при возникновении исключения, и вы могли бы остановиться непосредственно в расположении и контексте ошибки. Обработка исключений также широко используется в среде выполнения Windows. Таким образом, благодаря использованию исключений в коде вы можете объединить обработку всех ошибок в одной модели.

Мы рекомендуем использовать в вашей модели обработки ошибок следующие соглашения.

-   Используйте исключения для передачи данных о непредвиденных ошибках.
-   Не используйте исключения для управления потоком кода.
-   Захватывайте только те исключения, которые можете безопасно обработать с последующим восстановлением. В ином случае не захватывайте исключение и позвольте приложению завершиться.
-   При вызове процедуры DirectX, которая возвращает **HRESULT**, используйте функцию **DX::ThrowIfFailed**. Эта функция определена в [DirectXHelper.h](https://github.com/Microsoft/Windows-appsample-marble-maze/blob/master/C%2B%2B/Shared/DirectXHelper.h). **ThrowIfFailed** создает исключение, если предоставленный **HRESULT** является кодом ошибки. Например, **E\_POINTER** заставляет **ThrowIfFailed** вызвать [Platform::NullReferenceException](https://msdn.microsoft.com/library/windows/apps/hh755823.aspx).

    Используя **ThrowIfFailed**, поместите вызов DirectX в отдельную строку для удобочитаемости кода, как показано в следующем примере.

    ```cpp
    // Identify the physical adapter (GPU or card) this device is running on.
    ComPtr<IDXGIAdapter> dxgiAdapter;
    DX::ThrowIfFailed(
        dxgiDevice->GetAdapter(&dxgiAdapter)
        );
    ```

-   Несмотря на то, что мы рекомендуем не допустить использование **HRESULT** непредвиденных ошибок, важнее избегать использования обработки исключений при управлении потоком кода. Поэтому, когда возникает необходимость управлять потоком кода, предпочтительнее использовать значение, возвращаемое **HRESULT**.

###  <a name="sal-annotations"></a>Аннотации SAL

Использование для обнаружения ошибок в приложении аннотаций SAL совместно со средствами анализа кода.

Используя язык аннотаций исходного кода Microsoft (SAL), вы можете аннотировать (описывать) то, как функция использует свои параметры. Аннотации SAL описывают также возвращаемые значения. Аннотации SAL при выявлении возможных дефектов в исходном коде C и C++ работают совместно со средством C/C++ Code Analysis. Это средство выявляет типичные ошибки кодирования, такие как переполнения буфера, неинициализированную память, разыменование пустых указателей, утечку памяти и ресурсов.

Рассмотрим метод **BasicLoader::LoadMesh** , заявленный в [BasicLoader.h](https://github.com/Microsoft/Windows-appsample-marble-maze/blob/e62d68a85499e208d591d2caefbd9df62af86809/C%2B%2B/Shared/BasicLoader.h). Этот метод использует `_In_` для указания *имени файла* является входным параметром (и, следовательно, только будет считываться из) `_Out_` для указания, что *vertexBuffer* и *indexBuffer* являются выходными параметрами (и поэтому будет только для записи) и `_Out_opt_` для указания, что *vertexCount* и *indexCount* являются необязательными выходными (и могут быть записаны в). Поскольку *vertexCount* и *indexCount* являются необязательными выходными параметрами, они могут принимать значение **nullptr**. Средство C/C++ Code Analysis проверяет вызовы этого метода, чтобы убедиться, что параметры, передаваемые им, удовлетворяют этим критериям.

```cpp
void LoadMesh(
    _In_ Platform::String^ filename,
    _Out_ ID3D11Buffer** vertexBuffer,
    _Out_ ID3D11Buffer** indexBuffer,
    _Out_opt_ uint32* vertexCount,
    _Out_opt_ uint32* indexCount
    );
```

Чтобы выполнить анализ кода вашего приложения в строке меню выберите **сборка > выполнить анализ кода на решение**. Дополнительные сведения об анализе кода см. в разделе [Анализ качества кода C/C++ с использованием анализа кода](https://docs.microsoft.com/visualstudio/code-quality/analyzing-c-cpp-code-quality-by-using-code-analysis).

Полный перечень возможных аннотаций приведен в sal.h. Дополнительные сведения см. в статье [Аннотации SAL](https://docs.microsoft.com/cpp/c-runtime-library/sal-annotations).

## <a name="next-steps"></a>Дальнейшие действия


Прочтите раздел [Структура приложения Marble Maze](marble-maze-application-structure.md), чтобы понять, как структурирован код приложения Marble Maze и как структура приложения UWP на DirectX отличается от структуры традиционного классического приложения.

## <a name="related-topics"></a>Ссылки по теме


* [Структура приложения Marble Maze](marble-maze-application-structure.md)
* [Разработка Marble Maze — игры UWP — на C++ и DirectX](developing-marble-maze-a-windows-store-game-in-cpp-and-directx.md)

 

 




