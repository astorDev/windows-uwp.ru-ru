---
author: mithom
title: "Геймпад и вибрация"
description: "Используйте API Windows.Gaming.Input геймпада для определения, считывания и отправки команд вибрации и импульсов на геймпады."
ms.assetid: BB03BB8E-255F-4AE8-AC43-1E519CA860FE
ms.author: wdg-dev-content
ms.date: 02/08/2017
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: "windows 10, uwp, игры, геймпад, вибрация"
translationtype: Human Translation
ms.sourcegitcommit: c6b64cff1bbebc8ba69bc6e03d34b69f85e798fc
ms.openlocfilehash: b92ddbaadd7fd09b252d5c8842ed89daf53a6982
ms.lasthandoff: 02/07/2017

---

# <a name="gamepad-and-vibration"></a>Геймпад и вибрация

На этой странице приведены основные принципы программирования для геймпадов Xbox One с помощью [Windows.Gaming.Input.Gamepad][gamepad] и связанных API для универсальной платформы Windows (UWP).

Изучив информацию на этой странице, вы узнаете:
* как составить список подключенных геймпадов и их пользователей;
* как определить, что геймпад был добавлен или удален;
* как считывать входные данные с одного или нескольких геймпадов;
* как отправлять команды вибрации и импульсов;
* как геймпады работают в качестве устройства для навигации.


## <a name="gamepad-overview"></a>Обзор геймпадов

Такие геймпады, как беспроводной геймпад Xbox и беспроводной геймпад Xbox серии S являются игровыми устройствами ввода общего назначения. Это стандартные устройства ввода для Xbox One, которое игроки часто используют в среде Windows, если им неудобно играть с помощью клавиатуры и мыши. Поддержка геймпадов в приложениях UWP для Windows 10 и Xbox реализована с помощью пространства имен [Windows.Gaming.Input][].

Геймпады Xbox One оснащены навигационной клавишей (или крестовиной), кнопками **A**, **B**, **X**, **Y**, **Просмотр** и **Меню**, левым и правым аналоговым стиком, бамперами и триггерами, а также четырьмя вибромоторами. Оба аналоговых стика обеспечивают двойное считывание аналоговых данных по осям X и Y, а также выступают как кнопки при нажатии вниз. Каждый триггер передает аналоговые данные о том, как далеко он оттянут назад.

> **Примечание.**    Беспроводной геймпад Xbox Elite оснащен четырьмя дополнительными кнопками-**ручками** на нижней стороне. Они могут дублировать игровые команды, которые сложно использовать вместе (например, использование правого аналогового стика с любой из кнопок **A**, **B**, **X** или **Y**), или для предоставлять отдельный доступ к дополнительным командам.

> **Примечание.**    `Windows.Gaming.Input.Gamepad` также поддерживает геймпады Xbox 360, которые имеют такую же схему элементов управления, как и стандартные геймпады Xbox One.

### <a name="vibration-and-impulse-triggers"></a>Триггеры вибрации и импульсов

Геймпады Xbox One оснащены двумя отдельными моторами, обеспечивающими сильную и слабую вибрацию геймпада, а также двумя специальными моторами для резкой вибрации для каждого триггера (благодаря этой уникальной функции триггеры геймпадов Xbox One называются _импульсными триггерами_).

> **Примечание.**    Геймпады Xbox 360 не имеют _импульсных триггеров_.

Дополнительные сведения см. в разделе [Обзор вибрации и импульсных триггеров](#vibration-and-impulse-triggers-overview).

### <a name="thumbstick-deadzones"></a>Мертвые зоны аналоговых стиков

Аналоговый стик в состоянии покоя в центральном положении в идеале каждый раз должен давать одинаковые нейтральные значения по осям X и Y. Однако из-за механических воздействий и чувствительности стика фактические значения в центральном положении только приблизительно соответствуют идеальным нейтральным значениям и могут различаться между разными считываниями. По этой причине необходимо всегда использовать небольшую _мертвую зону_ — диапазон значений рядом с идеальным центральным положением, которые должны игнорироваться, чтобы компенсировать различия, обусловленными особенностями производства, механическим износом и другими проблемами с геймпадом.

Чем больше мертвая зона, тем проще отличить преднамеренный ввод от непреднамеренного ввода.

Дополнительные сведения см. в разделе [Считывание значений аналогового стика](#reading-the-thumbsticks).

### <a name="ui-navigation"></a>Навигация по пользовательскому интерфейсу

Чтобы облегчить поддержку разных устройств ввода для навигации по пользовательскому интерфейсу и сохранить единообразие используемых для этого элементов управления в разных играх и на разных устройствах, большинство _физических_ устройств ввода одновременно выступают в качестве отдельного _логического_ устройства ввода под названием [контроллер навигации по пользовательскому интерфейсу](ui-navigation-controller.md). Контроллер навигации по пользовательскому интерфейсу предоставляет стандартный набор элементов управления для команд навигации по пользовательскому интерфейсу на разных устройствах ввода.

Если рассматривать геймпад в качестве контроллера навигации по пользовательскому интерфейсу, то в нем реализован [необходимый набор](ui-navigation-controller.md#required-set) навигационных команд, присвоенных левому аналоговому стику, крестовине, кнопкам **Просмотр**, **Меню**, **A** и **B**.

| Команда навигации | Действие геймпада                       |
| ------------------:| ----------------------------------- |
|                 Вверх | Левый аналоговый стик вверх / крестовина вверх       |
|               Вниз | Левый аналоговый стик вниз / крестовина вниз   |
|               Влево | Левый аналоговый стик влево / крестовина влево   |
|              Вправо | Левый аналоговый стик вправо / крестовина вправо |
|               Просмотр | Кнопка просмотра                         |
|               Меню | Кнопка меню                         |
|             Принять | Кнопка A                            |
|             Отмена | Кнопка B                            |

Кроме того, геймпады поддерживают все [дополнительные наборы](ui-navigation-controller.md#optional-set) команд навигации для остальных входных данных.

| Команда навигации | Действие геймпада          |
| ------------------:| ---------------------- |
|            Предыдущая страница | Левый триггер           |
|          Следующая страница | Правый триггер          |
|          Страница влево | Левый бампер            |
|         Страница вправо | Правый бампер           |
|          Прокрутка вверх | Правый аналоговый стик вверх    |
|        Прокрутка вниз | Правый аналоговый стик вниз  |
|        Прокрутка влево | Правый аналоговый стик влево  |
|       Прокрутка вправо | Правый аналоговый стик вправо |
|          Контекстный вызов 1 | Кнопка X               |
|          Контекстный вызов 2 | Кнопка Y               |
|          Контекстный вызов 3 | Нажатие левого аналогового стика  |
|          Контекстный вызов 4 | Нажатие правого аналогового стика |


## <a name="detect-and-track-gamepads"></a>Обнаружение и отслеживание геймпадов

Геймпадами управляет система, поэтому их не требуется создавать или инициализировать. Система предоставляет список подключенных геймпадов и событий и уведомляет о добавлении или удалении геймпада.

### <a name="the-gamepads-list"></a>Список геймпадов

Класс [Gamepad][] имеет статическое свойство [Gamepads][] — доступный только для чтения список подключенных геймпадов. Поскольку вам могут быть нужны лишь некоторые подключенные геймпады, рекомендуется создать собственную коллекцию геймпадов, а не осуществлять доступ к ним через свойство `Gamepads`.

В следующем примере кода выполняется копирование всех подключенных геймпадов в новую коллекцию.

```cpp
auto myGamepads = ref new Vector<Gamepad^>();

for (auto gamepad : Gamepad::Gamepads)
{
    // This code assumes that you're interested in all gamepads.
    myGamepads->Append(gamepad);
}
```

### <a name="adding-and-removing-gamepads"></a>Добавление и удаление геймпадов

При добавлении или удалении геймпада возникают события [GamepadAdded][] и [GamepadRemoved][]. Можно зарегистрировать обработчики для этих событий, чтобы отслеживать подключенные в данный момент геймпады.

Следующий пример кода запускает отслеживание добавленного геймпада.

```cpp
Gamepad::GamepadAdded += ref new EventHandler<Gamepad^>(Platform::Object^, Gamepad^ args)
{
    // This code assumes that you're interested in all new gamepads.
    myGamepads->Append(args);
}
```

Следующий пример кода останавливает отслеживание удаленного геймпада.

```cpp
Gamepad::GamepadRemoved += ref new EventHandler<Gamepad^>(Platform::Object^, Gamepad^ args)
{
    unsigned int indexRemoved;

    if(myGamepads->IndexOf(args, &indexRemoved))
    {
        myGamepads->RemoveAt(indexRemoved);
    }
}
```

### <a name="users-and-headsets"></a>Пользователи и гарнитуры

Каждый геймпад можно связать с учетной записью пользователя, чтобы соотнести его личность с игровым процессом. Также к геймпаду можно подключить гарнитуру для использования голосового чата или других внутриигровых возможностей. Дополнительные сведения о работе с пользователями и гарнитурами см. в разделах [Отслеживание пользователей и их устройств](input-practices-for-games.md#tracking-users-and-their-devices) и [Гарнитура](headset.md).

## <a name="reading-the-gamepad"></a>Считывание данных с геймпада

После выбора необходимого геймпада можно приступить к сбору данных, вводимых с его помощью. В отличие от некоторых других типов вводимых данных, с которыми вы, возможно, уже знакомы, геймпады не передают сведения об изменении состояния путем создания событий. Вместо этого необходимо регулярно считывать их текущее состояние, _опрашивая_ соответствующие устройства.

### <a name="polling-the-gamepad"></a>Опрос геймпада

В ходе опроса сохраняется моментальный снимок устройства навигации в конкретный момент времени. Этот подход к сбору данных ввода подходит для большинства игр, так как их логика, как правило, выполняется в рамках детерминированного цикла и не привязана к событиям. Также обычно проще интерпретировать игровые команды на основании данных ввода, собранных сразу, а не на основании большого количества единичных событий ввода данных, собранных с течением времени.

Опрос геймпада выполняется путем вызова функции [GetCurrentReading][], которая возвращает структуру [GamepadReading][], содержащую состояние геймпада.

В следующем примере кода выполняется опрос геймпада на предмет его текущего состояния.

```cpp
auto gamepad = myGamepads[0];

GamepadReading reading = gamepad->GetCurrentReading();
```

Помимо состояния геймпада, считанные данные содержат метку времени, указывающую точное время получения сведений о состоянии. Метку времени удобно использовать для обращения ко времени предыдущего события считывания данных или ко времени моделирования конкретного игрового момента.

### <a name="reading-the-thumbsticks"></a>Считывание данных с аналоговых стиков

Каждый стик позволяет считывать с него аналоговые данные в диапазоне от -1,0 до +1,0 по осям X и Y. На оси X значение -1,0 соответствует крайнему левому положению стика, значение +1,0 — крайнему правому. На оси Y значение -1,0 соответствует крайнему нижнему положению стика, а значение +1,0 — крайнему верхнему. Если манипулятор находится в центральном положении, значение для обеих осей составляет приблизительно 0,0, но оно может изменяться даже между двумя последовательными считываниями. Способы решения данной проблемы будут рассмотрены далее в этом разделе.

Значение для оси X левого аналогового стика считывается из свойства `LeftThumbstickX` структуры [GamepadReading][], а значение для оси Y — из свойства `LeftThumbstickY`. Значение для оси X правого аналогового стика считывается из свойства `RightThumbstickX` структуры, а значение для оси Y — из свойства `RightThumbstickY`.

```cpp
float leftStickX = reading.LeftThumbstickX;   // returns a value between -1.0 and +1.0
float leftStickY = reading.LeftThumbstickY;   // returns a value between -1.0 and +1.0
float rightStickX = reading.RightThumbstickX; // returns a value between -1.0 and +1.0
float rightStickY = reading.RightThumbstickY; // returns a value between -1.0 and +1.0
```

При считывании значений аналогового стика можно заметить, что когда манипулятор находится в состоянии покоя в центральном положении, значения могут быть не равны 0,0. Вместо этого вы будете получать различные значения, близкие к 0,0, каждый раз, когда манипулятор перемещается и возвращается в центральное положение. Для устранения данной проблемы можно установить небольшую _мертвую зону_ — диапазон значений рядом с идеальным центральным положением, которые будут игнорироваться. Один из способов создания мертвой зоны — определить, насколько далеко от центра сдвинулся стик, и игнорировать смещения на расстояние, которое окажется меньше выбранного вами. Можно вычислить расстояние приближенно — не точно, поскольку значения стика по сути являются полярными, а не плоскостными — с помощью теоремы Пифагора. В результате вы получите радиальную мертвую зону.

В следующем примере кода показан расчет базовой радиальной мертвой зоны с помощью теоремы Пифагора.

```cpp
float leftStickX = reading.LeftThumbstickX;   // returns a value between -1.0 and +1.0
float leftStickY = reading.LeftThumbstickY;   // returns a value between -1.0 and +1.0

// choose a deadzone -- readings inside this radius are ignored.
const float deadzoneRadius = 0.1;
const float deadzoneSquared = deadzoneRadius * deadzoneRadius;

// Pythagorean theorem -- for a right triangle, hypotenuse^2 = (opposite side)^2 + (adjacent side)^2
auto oppositeSquared = leftStickY * leftStickY;
auto adjacentSquared = leftStickX * leftStickX;

// accept and process input if true; otherwise, reject and ignore it.
if((oppositeSquared + adjacentSquared) < deadzoneSquared)
{
    // input accepted, process it
}
```

Каждый аналоговый стик также действует как кнопка при нажатии вниз. Дополнительные сведения о чтении этих входных данных см. в разделе [Считывание данных с кнопок](#reading-the-buttons).

### <a name="reading-the-triggers"></a>Считывание данных с триггеров

Триггеры представлены в виде значений с плавающей запятой в диапазоне от 0,0 (полностью отпущены) до 1,0 (полностью нажаты). Значение левого триггера считывается из свойства `LeftTrigger` структуры [GamepadReading][], а значение правого триггера — из свойства `RightTrigger`.

```cpp
float leftTrigger  = reading.LeftTrigger;  // returns a value between 0.0 and 1.0
float rightTrigger = reading.RightTrigger; // returns a value between 0.0 and 1.0
```

### <a name="reading-the-buttons"></a>Считывание данных с кнопок

Все кнопки геймпада — четыре направления крестовины, левый и правый бамперы, нажатие левого и правого аналоговых стиков, кнопки **A**, **B**, **X**, **Y**, **Просмотр** и **Меню** — предоставляют цифровые данные, указывающие на то, нажата ли кнопка (вниз) или отпущена (вверх). В целях обеспечения эффективности эти показания кнопок не указываются в виде отдельных логических значений. Вместо этого все они упаковываются в одно битовое поле, представляемое перечислением [GamepadButtons][].

> **Примечание.**    Беспроводной геймпад Xbox Elite оснащен четырьмя дополнительными кнопками-**ручками** на нижней стороне. Эти кнопки также представлены в перечислении `GamepadButtons` и их значения считываются так же, как и значения стандартных кнопок геймпада.

Значения кнопок считываются из свойства `Buttons` структуры [GamepadReading][]. Так как это свойство представляет собой битовое поле, для изоляции значения кнопки, сведения о которой вам интересны, используется побитовая маскировка. Кнопка нажата (вниз), когда соответствующий бит установлен; в противном случае кнопка отпущена (вверх).

Следующий пример кода определяет, нажата ли кнопка A.

```cpp
if (GamepadButtons::A == (reading.Buttons & GamepadButtons::A))
{
    // button A is pressed
}
```

Следующий пример кода определяет, отпущена ли кнопка A.

```cpp
if (GamepadButtons::None == (reading.Buttons & GamepadButtons::A))
{
    // button A is pressed
}
```

Иногда может потребоваться определить, когда кнопка переходит из нажатого состояния в отпущенное или наоборот, нажаты ли или отпущены кнопки (несколько) либо узнать особое расположение ряда кнопок (когда некоторые кнопки нажаты, а некоторые отпущены). Сведения о том, как определить каждое из этих условий, см. в разделах [Определение положений кнопки](input-practices-for-games.md#detecting-button-transitions) и [Определение сложных схем положений кнопок](input-practices-for-games.md#detecting-complex-button-arrangements).

## <a name="run-the-gamepad-input-sample"></a>Пример чтения данных, вводимых с геймпада

Пример [GamepadUWP sample _(github)_](https://github.com/Microsoft/Xbox-ATG-Samples/tree/master/Samples/System/GamepadUWP) показывает, как подключиться к геймпаду и считать его состояние.


## <a name="vibration-and-impulse-triggers-overview"></a>Обзор вибрации и импульсных триггеров

Вибромоторы внутри геймпада предназначены для предоставления пользователю тактильной обратной связи. В играх эта возможность используется для усиления эффекта погружения, для передачи информации о состоянии (например, получение повреждений), для предупреждения о приближении к важным объектам и в иных целях.

Геймпады Xbox One оснащены четырьмя независимыми вибромоторами. Две больших мотора расположены в корпусе геймпада. Левый мотор обеспечивает жесткую вибрацию высокой амплитуды, а правый — более плавную и нежную вибрацию. Два других маленьких мотора располагаются в каждом триггере. Они обеспечивают резкую вибрацию, воспринимаемую пальцами пользователя на триггере. Благодаря этой уникальной функции триггеры геймпадов Xbox One называются _импульсными триггерами_. Управляя этими моторами, можно создавать широкий спектр тактильных ощущений.


## <a name="using-vibration-and-impulse"></a>Использование вибрации и импульсов

Вибрация геймпада управляется с помощью свойства [Vibration][] класса [Gamepad][]. `Vibration` — это экземпляр структуры [GamepadVibration][], которая состоит из четырех значений с плавающей запятой. Каждое значение представляет интенсивность работы одного их моторов.

Несмотря на то, что элементы свойства `Gamepad.Vibration` можно изменить напрямую, рекомендуется инициализировать отдельный экземпляр `GamepadVibration` для нужных вам значений, а затем скопировать его в свойство `Gamepad.Vibration` для одновременного изменения фактической интенсивности работы моторов.

В следующем примере показано, как одновременно изменить интенсивность работы всех моторов.

```cpp
// get the first gamepad
Gamepad^ gamepad = Gamepad::Gamepads->GetAt(0);

// create an instance of GamepadVibration
GamepadVibration vibration;

// ... set vibration levels on vibration struct here

// copy the GamepadVibration struct to the gamepad
gamepad.Vibration = vibration.
```

### <a name="using-the-vibration-motors"></a>Использование вибромоторов

Левый и правый вибромоторы получают значения с плавающей запятой от 0,0 (без вибрации) до 1,0 (наиболее сильная вибрация). Интенсивность работы левого мотора задается с помощью свойства `LeftMotor` структуры [GamepadVibration][], а интенсивность работы правого мотора — с помощью свойства `RightMotor`.

В следующем примере задается интенсивность работы обоих вибромоторов и активируется вибрация геймпада.

```cpp
GamepadVibration vibration;
vibration.LeftMotor = 0.80;  // sets the intensity of the left motor to 80%
vibration.RightMotor = 0.25; // sets the intensity of the right motor to 25%
gamepad.Vibration = vibration;
```

Помните, что эти два мотора не идентичны, и установка одинаковых значений для этих свойств не приведет к возникновению одинакового уровня вибрации в этих моторах. При любых значениях левый мотор создает более сильную вибрацию с более низкой частотой. Правый мотор при таком же значении создает более плавную вибрацию с более высокой частотой. Даже при максимальных значениях левый мотор не сможет обеспечить такую же высокую частоту вибрации, как правый, а правый — не сможет обеспечить такую же сильную вибрацию, как левый. При этом, так как моторы жестко прикреплены к корпусу геймпада, игроки не воспринимают вибрацию как идущую от двух разных источников, несмотря на то, что моторы имеют различные характеристики и вибрируют с разной интенсивностью. Это позволяет получить более широкий диапазон ощущений, чем в случае использования одинаковых моторов.

### <a name="using-the-impulse-triggers"></a>Использование импульсных триггеров

Мотор каждого импульсного триггера получает значение с плавающей запятой от 0,0 (без вибрации) до 1,0 (наиболее сильная вибрация). Интенсивность мотора левого триггера задается с помощью свойства `LeftTrigger` структуры [GamepadVibration][], интенсивность мотора правого триггера — с помощью свойства `RightTrigger`.

В следующем примере задается интенсивность обоих импульсных триггеров и выполняется их активация.

```cpp
GamepadVibration vibration;
vibration.LeftTrigger = 0.75;  // sets the intensity of the left trigger to 75%
vibration.RightTrigger = 0.50; // sets the intensity of the right trigger to 50%
gamepad.Vibration = vibration;
```

В отличие от первых двух моторов, эти два вибромотора внутри триггеров идентичны друг другу, и установка одинаковых значений приведет к одинаковой вибрации этих моторов. Однако, так как эти моторы не имеют жесткого сцепления друг с другом, игроки чувствуют их вибрацию независимо. Это позволяет одновременно создавать с помощью обоих триггеров полностью независимые ощущения и помогает им передавать более подробную информацию, чем та информация, которую передают моторы в корпусе геймпада.


## <a name="run-the-gamepad-vibration-sample"></a>Пример вибрации геймпада

Пример [GamepadVibrationUWP sample _(github)_](https://github.com/Microsoft/Xbox-ATG-Samples/tree/master/Samples/System/GamepadVibrationUWP) показывает, как вибромоторы и импульсные триггеры геймпада создают различные эффекты.

## <a name="see-also"></a>См. также
[Windows.Gaming.Input.UINavigationController][]
[Windows.Gaming.Input.IGameController][]


[Windows.Gaming.Input]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.aspx
[Windows.Gaming.Input.UINavigationController]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.uinavigationcontroller.aspx
[Windows.Gaming.Input.IGameController]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.igamecontroller.aspx
[gamepad]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.gamepad.aspx
[gamepads]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.gamepad.gamepads.aspx
[gamepadadded]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.gamepad.gamepadadded.aspx
[gamepadremoved]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.gamepad.gamepadremoved.aspx
[getcurrentreading]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.gamepad.getcurrentreading.aspx
[vibration]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.gamepad.vibration.aspx
[gamepadreading]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.gamepadreading.aspx
[gamepadbuttons]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.gamepadbuttons.aspx
[gamepadvibration]: https://msdn.microsoft.com/library/windows/apps/windows.gaming.input.gamepadvibration.aspx

