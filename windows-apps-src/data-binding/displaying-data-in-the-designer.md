---
ms.assetid: 089660A2-7CAE-4911-9994-F619C5D22287
title: Демонстрационные данные в рабочей области конструирования и демонстрационные данные для создания прототипов
description: Для вашего приложения может быть невозможно или нежелательно (например, по соображениям конфиденциальности или производительности) отображать динамические данные в рабочей области конструирования в Microsoft Visual Studio или Blend для Visual Studio.
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 5f08c2cc39bb4cdf9a49351f70143a0f86df1fb7
ms.sourcegitcommit: b52ddecccb9e68dbb71695af3078005a2eb78af1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/20/2019
ms.locfileid: "74254725"
---
<a name="sample-data-on-the-design-surface-and-for-prototyping"></a>Демонстрационные данные в рабочей области конструирования и демонстрационные данные для создания прототипов
=============================================================================================



**Обратите внимание** ,  степень, в которой требуется выборка данных, и сколько это поможет вам — зависит от того, использует ли привязка [расширение разметки {Binding}](https://docs.microsoft.com/windows/uwp/xaml-platform/binding-markup-extension) или [расширение разметки {КС:бинд}](https://docs.microsoft.com/windows/uwp/xaml-platform/x-bind-markup-extension). Приемы, описанные в этом разделе, основаны на использовании [**DataContext**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.datacontext), поэтому они подходят только для **{Binding}** . Но если вы используете **{x:Bind}** , ваши привязки как минимум показывают значения заполнителей в рабочей области конструирования (даже для элементов управления элементами), поэтому демонстрационные данные уже не так нужны.

Для вашего приложения может быть невозможно или нежелательно (например, по соображениям конфиденциальности или производительности) отображать динамические данные в рабочей области конструирования в Microsoft Visual Studio или Blend для Visual Studio. Для заполнения элементов управления данными (чтобы можно было работать над макетом, шаблонами и другими визуальными свойствами приложения) есть различные способы, в которых можно использовать демонстрационные данные времени разработки. Демонстрационные данные также могут быть очень полезны и экономить время при создании эскиза (или прототипа) приложения. Демонстрационные данные можно использовать в эскизе или прототипе во время выполнения для иллюстрации идей, не доходя до подключения к реальным динамическим данным.

**Примеры приложений, демонстрирующие {Binding}**

-   Скачайте приложение [Bookstore1](https://codeload.github.com/MicrosoftDocs/windows-topic-specific-samples/zip/Bookstore1Universal_10).
-   Скачайте приложение [Bookstore2](https://codeload.github.com/MicrosoftDocs/windows-topic-specific-samples/zip/Bookstore2Universal_10).

<a name="setting-datacontext-in-markup"></a>Задание DataContext в разметке
-----------------------------

Довольно частая практика у разработчиков — использовать императивный код (в коде программной части), чтобы задать [**DataContext**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.datacontext) элемента управления страницы или пользовательского элемента управления как экземпляр модели представления.

``` csharp
public MainPage()
{
    InitializeComponent();
    this.DataContext = new BookstoreViewModel();
}
```

Но если это сделать, ваша страница не будет поддаваться проектированию так, как могла бы. Причина заключается в том, что когда страница XAML открыта в Visual Studio или Blend для Visual Studio, императивный код, который назначает значение **DataContext**, никогда не запускается (по сути, не выполняется ни один из кодов программной части). Конечно, средства XAML анализируют разметку и создают экземпляры всех объектов, объявленных в ней, но они не создают экземпляр самого типа страницы. В результате в ваших элементах управления или в диалоговом окне **Создание привязки данных** будут отображаться не все данные, и будет сложнее оформить страницу и создать ее макет.

![Пользовательский интерфейс разработки фрагментарного кэширования.](images/displaying-data-in-the-designer-01.png)

Первый способ, который можно попробовать, — это закомментировать данное назначение **DataContext** и задать **DataContext** в разметке страницы. Таким образом, ваши динамические данные будут отображаться как во время разработки, так и во время выполнения. Для этого сначала откройте страницу XAML. Затем в окне " **Структура документа** " щелкните корневой элемент (обычно с надписью **\[страница\]** ), чтобы выбрать его. В окне **Свойства** найдите свойство **DataContext** (в категории «Общие»), а затем щелкните **Создать**. Выберите свой тип модели представления в диалоговом окне **Выбор объекта**, а затем нажмите кнопку **ОК**.

![Пользовательский интерфейс для задания DataContext.](images/displaying-data-in-the-designer-02.png)

Вот как выглядит конечная разметка.

``` xaml
<Page ... >
    <Page.DataContext>
        <local:BookstoreViewModel/>
    </Page.DataContext>
```

А вот как выглядит рабочая область конструирования теперь, когда ваши привязки могут разрешать. Обратите внимание, что элемент выбора **Путь** в диалоговом окне **Создание привязки данных** теперь заполнен на основе типа **DataContext** и свойств, к которым можно выполнить привязку.

![Пользовательский интерфейс для проектирования.](images/displaying-data-in-the-designer-03.png)

Диалоговому окну **Создание привязки данных** для работы нужен только тип, но привязкам для инициализации со значениями необходимы свойства. Если вы не хотите обращаться к своей облачной службе во время разработки (из-за производительности, платы за передачу данных, проблем конфиденциальности и т.п.), ваш код инициализации может проверить, запущено ли ваше приложение в средстве разработки (например, в Visual Studio или Blend для Visual Studio), и в этом случае загрузить демонстрационные данные для использования только во время разработки.

``` csharp
if (Windows.ApplicationModel.DesignMode.DesignModeEnabled)
{
    // Load design-time books.
}
else
{
    // Load books from a cloud service.
}
```

Если вам нужно передать параметры в свой код инициализации, можно использовать локатор моделей представлений. Локатор моделей представлений — это класс, который можно поместить в ресурсы приложения. У него есть свойство, которое выводит модель представления, и **DataContext** вашей страницы привязывается к этому свойству. Другой шаблон, который локатор или модель представления может использовать, — это внедрение зависимостей, которое может создать поставщика данных времени разработки или времени выполнения (каждый из которых реализует общий интерфейс) в зависимости от того, что применимо.

<a name="sample-data-from-class-and-design-time-attributes"></a>«Демонстрационные данные из класса» и атрибуты времени разработки
---------------------------------------------------------------------------------------

Если по какой-либо причине ни один из параметров в предыдущем разделе вам не подходит, множество вариантов данных времени разработки все еще доступно через функции и атрибуты времени разработки средств XAML. Один хороший вариант — это функция **Создать демонстрационные данные из класса** в Blend для Visual Studio. Эту команду можно найти на одной из кнопок в верхней части панели **Данные**.

Вам нужно лишь указать класс, который команда будет использовать. Команда затем выполняет два важных действия. Во-первых, она создает файл XAML, который содержит демонстрационные данные, подходящие для рекурсивной расконсервации экземпляра выбранного класса и всех его элементов (по сути, средства работают одинаково хорошо с файлами XAML и JSON). Во-вторых, она заполняет панель **Данные** схемой выбранного класса. Затем можно перетащить элементы с панели **Данные** в рабочую область конструирования для выполнения различных задач. В зависимости от того, что перетаскивается и куда, можно добавить привязки к существующим элементам управления (с помощью **{Binding}** ) или создать новые элементы управления и одновременно привязать их. В любом случае операция также задает контекст данных времени разработки (**d:DataContext**) за вас (если он еще не задан) в корневой части макета страницы. Этот контекст данных времени разработки использует атрибут **d:DesignData**, чтобы получить свои демонстрационные данные из созданного файла XAML (который вы, кстати, можете найти в своем проекте и отредактировать, чтобы он содержал нужные вам демонстрационные данные).

``` xaml
<Page ...
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d">
    <Grid ... d:DataContext="{d:DesignData /SampleData/RecordingViewModelSampleData.xaml}"/>
        <ListView ItemsSource="{Binding Recordings}" ... />
        ...
    </Grid>
</Page>
```

Различные объявления xmlns означают, что атрибуты с префиксом **d:** интерпретируются только во время разработки и игнорируются во время выполнения. Поэтому атрибут **d:DataContext** влияет на значение свойства [**DataContext**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.datacontext) только во времени разработки; он не действует во время выполнения. При желании в разметке можно задать и **d:DataContext**, и **DataContext**. **d:DataContext** будет переопределять значение во время разработки, а **DataContext** — во время выполнения. Эти же правила переопределения применяются ко всем атрибутам времени разработки и времени выполнения.

Атрибут **d:DataContext** и все остальные атрибуты времени разработки задокументированы в разделе [Атрибуты времени разработки](https://msdn.microsoft.com/library/ff602277(v=VS.95).aspx), который по-прежнему доступен для приложений универсальной платформы Windows (UWP).

[**CollectionViewSource**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Data.CollectionViewSource) не имеет свойства **DataContext** , но имеет свойство **Source** . Следовательно, есть свойство **d:Source**, которое можно использовать, чтобы задать демонстрационные данные, отображаемые только во время разработки, в **CollectionViewSource**.

``` xaml
    <Page.Resources>
        <CollectionViewSource x:Name="RecordingsCollection" Source="{Binding Recordings}"
            d:Source="{d:DesignData /SampleData/RecordingsSampleData.xaml}"/>
    </Page.Resources>

    ...

        <ListView ItemsSource="{Binding Source={StaticResource RecordingsCollection}}" ... />
    ...
```

Для того чтобы такой способ работал, необходим класс с именем `Recordings : ObservableCollection<Recording>`, а также необходимо отредактировать файл XAML с демонстрационными данными, чтобы он содержал только объект **Recordings** (с объектами **Recording** внутри), как показано ниже.

``` xml
<Quickstart:Recordings xmlns:Quickstart="using:Quickstart">
    <Quickstart:Recording ArtistName="Mollis massa" CompositionName="Cubilia metus"
        OneLineSummary="Morbi adipiscing sed" ReleaseDateTime="01/01/1800 15:53:17"/>
    <Quickstart:Recording ArtistName="Vulputate nunc" CompositionName="Parturient vestibulum"
        OneLineSummary="Dapibus praesent netus amet vestibulum" ReleaseDateTime="01/01/1800 15:53:17"/>
    <Quickstart:Recording ArtistName="Phasellus accumsan" CompositionName="Sit bibendum"
        OneLineSummary="Vestibulum egestas montes dictumst" ReleaseDateTime="01/01/1800 15:53:17"/>
</Quickstart:Recordings>
```

Если вместо XAML используется файл с демонстрационными данными JSON, необходимо задать свойство **Type**.

``` xaml
    d:Source="{d:DesignData /SampleData/RecordingsSampleData.json, Type=local:Recordings}"
```

До сих пор для загрузки демонстрационных данных времени разработки из файла XAML или JSON мы использовали **d:DesignData**. Альтернатива этому — расширение разметки **d:DesignInstance**, которое указывает, что источник времени разработки основан на классе, заданном свойством **Type**. Рассмотрим пример.

``` xaml
    <CollectionViewSource x:Name="RecordingsCollection" Source="{Binding Recordings}"
        d:Source="{d:DesignInstance Type=local:Recordings, IsDesignTimeCreatable=True}"/>
```

Свойство **IsDesignTimeCreatable** указывает, что средство разработки должно фактически создать экземпляр класса, что подразумевает, что у класса есть открытый конструктор по умолчанию и он заполняет сам себя данными (реальными или демонстрационными). Если не задать **IsDesignTimeCreatable** (или установить значение **False**), демонстрационные данные не будут отображаться в рабочей области конструирования. В этом случае все средство разработки выполняет синтаксический анализ класса для его связываемых свойств и отображает их на панели **данных** и в диалоговом окне **создания привязки данных** .

<a name="sample-data-for-prototyping"></a>Демонстрационные данные для создания прототипов
--------------------------------------------------------

При создании прототипа демонстрационные данные понадобятся и во время разработки, и во время выполнения. Для такого случая в Blend для Visual Studio есть функция **Создать демонстрационные данные**. Эту команду можно найти на одной из кнопок в верхней части панели **Данные**.

Вместо того, чтобы указывать класс, можно фактически спроектировать схему источника демонстрационных данных прямо на панели **Данные** . На панели **Данные** также можно редактировать значения демонстрационных данных: нет необходимости открывать и редактировать файл (хотя вы по-прежнему можете делать это, если хотите).

Функция **Создать демонстрационные данные** использует [**DataContext**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.datacontext), а не **d:DataContext**, чтобы демонстрационные данные были доступны при запуске эскиза или прототипа, а также при их разработке. А панель **Данные** действительно ускоряет выполнение задач разработки и привязки. Например, если просто перетащить свойство коллекции с панели **Данные** в рабочую область конструирования, будет создан элемент управления элементами с привязкой к данным и необходимые шаблоны, готовые к сборке и запуску.

![Демонстрационные данные для создания прототипов.](images/displaying-data-in-the-designer-04.png)
