---
ms.assetid: 95CF7F3D-9E3A-40AC-A083-D8A375272181
title: Рекомендации по использованию пула потоков
description: Этот раздел содержит рекомендации по работе с пулом потоков.
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp, поток, пул потоков
ms.localizationpriority: medium
ms.openlocfilehash: a498f685e7a810d19e2f1eb63ae112dd02587b84
ms.sourcegitcommit: ac7f3422f8d83618f9b6b5615a37f8e5c115b3c4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/29/2019
ms.locfileid: "66370697"
---
# <a name="best-practices-for-using-the-thread-pool"></a>Рекомендации по использованию пула потоков

Этот раздел содержит рекомендации по работе с пулом потоков.

## <a name="dos"></a>Следует:


-   Использовать пул потоков для выполнения параллельных операций в приложении.

-   Использовать рабочие элементы для выполнения расширенных задач без блокировки потока пользовательского интерфейса.

-   Создавать кратковременные и независимые рабочие элементы. Рабочие элементы выполняются асинхронно и могут отправляться в пул из очереди в любом порядке.

-   Обновления обработки в поток пользовательского интерфейса с помощью [**Windows.UI.Core.CoreDispatcher**](https://docs.microsoft.com/uwp/api/Windows.UI.Core.CoreDispatcher).

-   Используйте [**ThreadPoolTimer.CreateTimer**](https://docs.microsoft.com/uwp/api/windows.system.threading.threadpooltimer.createtimer) вместо функции **Sleep**.

-   Использовать пул потоков вместо того, чтобы создавать собственную систему управления потоками. Пул потоков работает на уровне ОС с расширенными функциями и оптимизирован для динамического масштабирования согласно ресурсам устройства и событиям в рамках процесса и в системе.

-   В случае языка C++ убедитесь, что делегаты рабочих элементов используют гибкую потоковую модель (делегаты C++ являются гибкими по умолчанию).

-   Использовать предварительно выделенные рабочие элементы, когда нельзя допустить сбой выделения ресурса во время использования.

## <a name="donts"></a>Не следует:


-   Создавать периодические таймеры, используя значение *period*&lt;1 мс (включая 0). Иначе рабочий элемент будет действовать как однократный таймер.

-   Отправлять периодические рабочие элементы, выполнение которых занимает больше времени, чем указано в параметре *period*.

-   Отправлять обновления пользовательского интерфейса (кроме всплывающих и обычных уведомлений) из рабочего элемента, отправленного из фоновой задаче. Вместо этого нужно использовать обработчики хода выполнения и завершения фоновой задачи — например, [**IBackgroundTaskInstance.Progress**](https://docs.microsoft.com/uwp/api/windows.applicationmodel.background.ibackgroundtaskinstance.progress).

-   При использовании обработчиков рабочих элементов, использующих ключевое слово **async**, помните о том, что рабочий элемент пула потоков может быть настроен на состояние выполнения до выполнения всего кода в обработчике. Код после ключевого слова **await** в обработчике может выполняться после настройки рабочего элемента на состояние завершения.

-   Выполнять предварительно выделенный рабочий элемент более одного раза без повторной инициализации. [Создание периодического рабочего элемента](create-a-periodic-work-item.md)

## <a name="related-topics"></a>См. также


* [Создание периодического рабочего элемента](create-a-periodic-work-item.md)
* [Отправка рабочего элемента в пул потоков](submit-a-work-item-to-the-thread-pool.md)
* [Отправка рабочего элемента по таймеру](use-a-timer-to-submit-a-work-item.md)
