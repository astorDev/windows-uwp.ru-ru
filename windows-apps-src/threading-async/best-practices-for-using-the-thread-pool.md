---
author: normesta
ms.assetid: 95CF7F3D-9E3A-40AC-A083-D8A375272181
title: Рекомендации по использованию пула потоков
description: Этот раздел содержит рекомендации по работе с пулом потоков.
ms.author: normesta
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp, поток, пул потоков
ms.localizationpriority: medium
ms.openlocfilehash: ff607e3b39ea9d9a3731cc1f231fe1eb27b0b155
ms.sourcegitcommit: 144f5f127fc4fbd852f2f6780ef26054192d68fc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/02/2018
ms.locfileid: "5980576"
---
# <a name="best-practices-for-using-the-thread-pool"></a>Рекомендации по использованию пула потоков

Этот раздел содержит рекомендации по работе с пулом потоков.

## <a name="dos"></a>Следует:


-   Использовать пул потоков для выполнения параллельных операций в приложении.

-   Использовать рабочие элементы для выполнения расширенных задач без блокировки потока пользовательского интерфейса.

-   Создавать кратковременные и независимые рабочие элементы. Рабочие элементы выполняются асинхронно и могут отправляться в пул из очереди в любом порядке.

-   Обновления обработки в поток пользовательского интерфейса с помощью [**Windows.UI.Core.CoreDispatcher**](https://msdn.microsoft.com/library/windows/apps/BR208211).

-   Используйте [**ThreadPoolTimer.CreateTimer**](https://msdn.microsoft.com/library/windows/apps/Hh967921) вместо функции **Sleep**.

-   Использовать пул потоков вместо того, чтобы создавать собственную систему управления потоками. Пул потоков работает на уровне ОС с расширенными функциями и оптимизирован для динамического масштабирования согласно ресурсам устройства и событиям в рамках процесса и в системе.

-   В случае языка C++ убедитесь, что делегаты рабочих элементов используют гибкую потоковую модель (делегаты C++ являются гибкими по умолчанию).

-   Использовать предварительно выделенные рабочие элементы, когда нельзя допустить сбой выделения ресурса во время использования.

## <a name="donts"></a>Не следует:


-   Создавать периодические таймеры, используя значение *period* &lt;1 мс (включая 0). Иначе рабочий элемент будет действовать как однократный таймер.

-   Отправлять периодические рабочие элементы, выполнение которых занимает больше времени, чем указано в параметре *period*.

-   Отправлять обновления пользовательского интерфейса (кроме всплывающих и обычных уведомлений) из рабочего элемента, отправленного из фоновой задаче. Вместо этого нужно использовать обработчики хода выполнения и завершения фоновой задачи — например, [**IBackgroundTaskInstance.Progress**](https://msdn.microsoft.com/library/windows/apps/BR224800).

-   При использовании обработчиков рабочих элементов, использующих ключевое слово **async**, помните о том, что рабочий элемент пула потоков может быть настроен на состояние выполнения до выполнения всего кода в обработчике. Код после ключевого слова **await** в обработчике может выполняться после настройки рабочего элемента на состояние завершения.

-   Выполнять предварительно выделенный рабочий элемент более одного раза без повторной инициализации. [Создание периодического рабочего элемента](create-a-periodic-work-item.md)

## <a name="related-topics"></a>Связанные темы


* [Создание периодического рабочего элемента](create-a-periodic-work-item.md)
* [Отправка рабочего элемента в пул потоков](submit-a-work-item-to-the-thread-pool.md)
* [Отправка рабочего элемента по таймеру](use-a-timer-to-submit-a-work-item.md)
