---
title: Использование MRT для преобразованных классических приложений и игр
description: Упаковав свое приложение или игру .NET или Win32 в виде пакета AppX, можно использовать Систему управления ресурсами для загрузки ресурсов приложения, адаптированных к контексту во время выполнения. В этой статье подробно рассматриваются соответствующие методы.
ms.date: 10/25/2017
ms.topic: article
keywords: windows 10, uwp, mrt, pri. ресурсы, игры, centennial, desktop app converter, mui, вспомогательная сборка
ms.localizationpriority: medium
ms.openlocfilehash: 620efc73502c741e415d210170ea53deefd4e974
ms.sourcegitcommit: 8921a9cc0dd3e5665345ae8eca7ab7aeb83ccc6f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/10/2018
ms.locfileid: "8873375"
---
# <a name="use-the-windows-10-resource-management-system-in-a-legacy-app-or-game"></a>Использование Системы управления ресурсами Windows 10 в устаревшем приложении или игре

## <a name="overview"></a>Обзор

Приложения и игры .NET и Win32 часто локализуются на разные языки, расширяя свой общий адресуемый рынок. Дополнительные сведения о преимуществах локализации приложений см. в разделе [Глобализация и локализация](../design/globalizing/globalizing-portal.md). Упаковав свое приложение или игру .NET или Win32 в виде пакета AppX, можно использовать Систему управления ресурсами для загрузки ресурсов приложения, адаптированных к контексту во время выполнения. В этой статье подробно рассматриваются соответствующие методы.

Существует множество способов локализации традиционных приложений Win32, однако Windows 8 представила новую [систему управления ресурсами](https://msdn.microsoft.com/en-us/library/windows/apps/jj552947.aspx), которая работает со всеми языками программирования, в различных типах приложений и предоставляет функциональные возможности, которые гораздо шире простой локализации. Эта система будет называться MRT в этой статье. В прошлом это означало Modern Resource Technology ("Современная технология ресурсов"), но от термина "Современный" решено отказаться. Диспетчер ресурсов может быть также известен как MRM (диспетчер современных ресурсов) или PRI (индекс ресурсов пакета).

В сочетании с развертыванием на основе AppX (например, из Microsoft Store) MRT может автоматически предоставлять самые подходящие ресурсы для определенного пользователя или устройства, что сводит к минимуму размер загрузки и установки приложения. Это уменьшение размера может быть очень значительным для приложений с большим объемом локализованного содержимого. Оно может достигать даже порядка несколько *ГБ* для игр высочайшего класса. Дополнительные преимущества MRT включают локализованные описания в оболочке Windows и Microsoft Store, логику автоматического перехода к запасному варианту, если выбранный пользователем язык не соответствует доступным ресурсам.

В этом документе описывается высокоуровневая архитектура MRT и предоставляется руководство по переносу, которое поможет переместить устаревшие приложения Win32 на платформу MRT с минимальными изменениями кода. После перемещения в MRT для разработчика становятся доступными дополнительные преимущества (например, возможность делить ресурсы на сегменты по коэффициенту масштабирования или системной теме). Обратите внимание, что локализация на основе MRT работает как для приложений UWP, так и для приложений Win32, обработанных мостом для классических приложений (известным как "Centennial").

Во многих случаях вы можете продолжать использовать ваши существующие форматы локализации и исходный код, так как интеграция с MRT для разрешения ресурсов во время выполнения и минимизации размеров скачивания — это подход, допускающий компромиссы. В следующей таблице перечислены трудозатраты, расчетные затраты и преимущества каждого этапа. В эту таблицу не включены задачи, не имеющие отношения к локализации, например, предоставление значков приложений с высоким разрешением или высокой контрастностью. Дополнительные сведения о предоставлении нескольких ресурсов для плиток, значков и т. п. см. в разделе [Адаптация ресурсов с учетом языка, масштаба, высокой контрастности и других квалификаторов](tailor-resources-lang-scale-contrast.md).

<table>
<tr>
<th>Работа</th>
<th>Преимущество</th>
<th>Расчетные затраты</th>
</tr>
<tr>
<td>Локализация манифеста AppX</td>
<td>Требуется совсем немного усилий, чтобы ваше локализованное содержимое отобразилось в оболочке Windows и в Microsoft Store</td>
<td>Небольшой</td>
</tr>
<tr>
<td>Использование MRT для определения и поиска ресурсов</td>
<td>Предварительные требования к уменьшению размеров загрузки и установки, автоматический переход к запасному языку</td>
<td>Среднее</td>
</tr>
<tr>
<td>Создание пакетов ресурсов</td>
<td>Последний шаг к минимизации размеров загрузки и установки</td>
<td>Небольшое</td>
</tr>
<tr>
<td>Переход к форматам и интерфейсам API ресурсов MRT</td>
<td>Значительно меньшие размеры файлов (в зависимости от существующей технологии ресурсов)</td>
<td>Крупное</td>
</tr>
</table>

## <a name="introduction"></a>Введение

Большинство нестандартных приложений содержат элементы пользовательского интерфейса, известные как *ресурсы*, которые не связаны с кодом приложения (в отличие от *жестко заданных значений*, которые создаются в самом коде источника). Существует несколько причин выбрать ресурсы вместо жестко заданных значений (например, простота редактирования не разработчиками), но одна из ключевых причин — дать возможность приложению выбирать различные представления одного и того же логического ресурса во время выполнения. Например, текст, отображаемый на кнопке (или изображение, отображаемое на значке) может отличаться в зависимости от языков, которые пользователь понимает, характеристик устройства отображения или наличия у пользователя каких-либо включенных специальных возможностей.

Таким образом, основной целью любой технологии управления ресурсами является преобразование во время выполнения запроса логического или символьного *имени ресурса* (например, `SAVE_BUTTON_LABEL`) в лучшее возможное актуальное *значение* (например, "Сохранить") из набора возможных *кандидатов* (например, "Save", "Speichern" или "저장"). MRT предоставляет такую функцию и позволяет приложениям определять кандидатов ресурсов с помощью различных атрибутов (называемых *квалификаторами*), например языка пользователя, коэффициента масштабирования монитора, выбранной пользователем темы и других факторов окружающей среды. MRT поддерживает даже пользовательские квалификаторы для приложений, которые в них нуждаются (например, приложение может предоставлять различные графические ресурсы для пользователей, которые вошли с помощью учетной записи, и для гостей без явного добавления этой проверки в каждую часть приложения). MRT работает со строковыми ресурсами и с ресурсами на основе файлов, где ресурсы на основе файлов реализованы как ссылки на внешние данные (сами файлы). 

### <a name="example"></a>Пример.

Вот простой пример приложения, которое содержит текстовые метки на двух кнопках (`openButton` и `saveButton`) и PNG-файл, используемый для логотипа (`logoImage`). Текстовые метки локализованы на английском и немецком языках, а логотип оптимизирован для обычных мониторов настольных компьютеров (коэффициент масштабирования 100%) и телефонов с высоким разрешением (коэффициент масштабирования 300%). Обратите внимание, что на этой схеме представлено высокоуровневое концептуальное представление модели; оно не совпадает в точности с реализацией.

<p><img src="images\conceptual-resource-model.png"/></p>

На рисунке код приложения ссылается на три имени логических ресурсов. Во время выполнения виртуальная функция `GetResource` использует MRT для поиска имен этих ресурсов в таблице ресурсов (также называется PRI-файл) и находит наиболее подходящего кандидата на основе условий окружающей среды (язык пользователя и коэффициент масштабирования монитора). В случае наличия этих меток строки используются напрямую. В случае использования изображения логотипа строки интерпретируются как имена файлов, и файлы читаются с диска. 

Если пользователь говорит на языке, отличном от английского или немецкого языка, или коэффициент масштабирования монитора не равен 100% или 300%, MRT выбирает "ближайший" подходящий кандидат, основанный на наборе правил резервных вариантов (базовую информацию см. в разделе [ **Система управления ресурсами** на веб-сайте MSDN](https://msdn.microsoft.com/en-us/library/windows/apps/jj552947.aspx)). 

Обратите внимание, что MRT поддерживает ресурсы, настроенные для нескольких квалификаторов. Например, если изображение логотипа содержит встроенный текст, который также требуется локализовать, логотип будет иметь четыре кандидата: EN/Scale-100, DE/Scale-100, EN/Scale-300 and DE/Scale-300.

### <a name="sections-in-this-document"></a>Разделы данного документа

В следующих разделах описываются высокоуровневые задачи, которые необходимо выполнить для интеграции MRT с вашим приложением.

**Этап 0. Сборка пакета приложения**

В этом разделе описываются способы получения сборки существующего классического приложения в виде пакета приложения. На этом этапе никакие функции MRT не используются.

**Этап 1. Локализация манифеста приложения**

В этом разделе описывается локализация манифеста приложения (чтобы он правильно отображался в оболочке Windows). На этом этапе по-прежнему используется устаревший формат ресурсов и устаревшие API для упаковки и поиска ресурсов. 

**Этап 2. Использование MRT для определения и поиска ресурсов**

В этом разделе описывается процедура изменения вашего кода приложения (и, возможно, макет ресурсов) для поиска ресурсов с помощью MRT. На этом этапе по-прежнему используются существующие форматы ресурсов и интерфейсы API для загрузки и использования ресурсов. 

**Этап 3. Создание пакетов ресурсов**

В этом разделе описываются окончательные изменения, необходимые для разделения ресурсов на отдельные *пакеты ресурсов*, минимизирующие размер загрузки (и установки) приложения.

### <a name="not-covered-in-this-document"></a>В этом документе не рассматривается

После завершения описанных выше этапов 0-3 у вас будет "пакет" приложения, который можно отправить в Microsoft Store. Он также минимизирует размер загрузки и установки для пользователей, опуская ненужные ресурсы (например, языки, на которых они не говорят). Дополнительные улучшения в размере приложения и функциональности можно сделать, выполнив один последний этап. 

**Этап 4. Переход к форматам и API ресурсов MRT**

Этот этап выходит за рамки данного документа. Он включает в себя перемещение ресурсов (в частности, строк) из таких устаревших форматов, как библиотеки DLL MUI или сборки ресурсов .NET в PRI-файлы. Это может привести к дальнейшей экономии места для размеров скачивания и установки. Это действие также позволяет использовать другие функции MRT, например минимизацию загрузки и установки файлов изображений на основе коэффициента масштабирования, параметров специальных возможностей и т. д.

- - -

## <a name="phase-0-build-an-application-package"></a>Этап 0. Сборка пакета приложения

Прежде чем вносить изменения в ресурсы приложения, необходимо сначала заменить текущую технологию упаковки и установки на стандартную технологию упаковки и развертывания UWP. Это можно сделать тремя способами.

0. При наличии большого классического приложения со сложным установщиком или использовании множества точек расширения операционной системы можно использовать средство Desktop App Converter, чтобы создать структуру файлов UWP и сведения о манифесте из существующего установщика приложения (например, MSI)
0. При наличии классического приложения меньшего размера с относительно небольшим количеством файлов или простого установщика и отсутствии обработчиков расширений вы можете создать структуру файлов и сведения о манифесте вручную
0. Если вы перестраиваете исходное приложение и хотите обновить ваше приложение до "чистого" приложения UWP, можно создать новый проект в Visual Studio и использовать интегрированную среду разработки, которая выполнит большую часть работы за вас

Если вы хотите использовать [Desktop App Converter](https://aka.ms/converter), см. раздел [ **Мост переноса классических приложений на UWP: Desktop App Converter** на веб-сайте MSDN](https://aka.ms/converterdocs), чтобы получить дополнительные сведения о процессе преобразования. Полный набор примеров Desktop Converter можно найти в [репозитории GitHub **Примеры кода для преобразования классических приложений в приложения UWP**](https://github.com/Microsoft/DesktopBridgeToUWP-Samples).

Если вы хотите вручную создать пакет, необходимо создать структуру каталогов, которая включает все файлы вашего приложения (исполняемые файлы и содержимое, но не исходный код) и файл `AppXManifest.xml`. Образец можно найти в [примере GitHub **Hello, World**](https://github.com/Microsoft/DesktopBridgeToUWP-Samples/blob/master/Samples/HelloWorldSample/CentennialPackage/AppxManifest.xml), но основной файл `AppXManifest.xml`, который запускает исполняемый файл классического приложения с названием `ContosoDemo.exe`, выглядит следующим образом, где <span style="background-color: yellow">выделенный текст</span> заменяется вашими собственными значениями:

<blockquote>
<pre>
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;Package xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
         xmlns:mp="http://schemas.microsoft.com/appx/2014/phone/manifest"
         xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"
         xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities"
         IgnorableNamespaces="uap mp rescap"&gt;
    &lt;Identity Name="<span style="background-color: yellow">Contoso.Demo</span>"
              Publisher="<span style="background-color: yellow">CN=Contoso.Demo</span>"
              Version="<span style="background-color: yellow">1.0.0.0</span>" /&gt;
    &lt;Properties&gt;
    &lt;DisplayName&gt;<span style="background-color: yellow">Contoso App</span>&lt;/DisplayName&gt;
    &lt;PublisherDisplayName&gt;<span style="background-color: yellow">Contoso, Inc</span>&lt;/PublisherDisplayName&gt;
    &lt;Logo&gt;Assets\StoreLogo.png&lt;/Logo&gt;
  &lt;/Properties&gt;
    &lt;Dependencies&gt;
    &lt;TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.14393.0" 
                        MaxVersionTested="10.0.14393.0" /&gt;
  &lt;/Dependencies&gt;
    &lt;Resources&gt;
    &lt;Resource Language="<span style="background-color: yellow">en-US</span>" /&gt;
  &lt;/Resources&gt;
    &lt;Applications&gt;
    &lt;Application Id="<span style="background-color: yellow">ContosoDemo</span>" Executable="<span style="background-color: yellow">ContosoDemo.exe</span>" 
                 EntryPoint="Windows.FullTrustApplication"&gt;
    &lt;uap:VisualElements DisplayName="<span style="background-color: yellow">Contoso Demo</span>" BackgroundColor="#777777" 
                        Square150x150Logo="Assets\Square150x150Logo.png" 
                        Square44x44Logo="Assets\Square44x44Logo.png" 
        Description="<span style="background-color: yellow">Contoso Demo</span>"&gt;
      &lt;/uap:VisualElements&gt;
    &lt;/Application&gt;
  &lt;/Applications&gt;
    &lt;Capabilities&gt;
    &lt;rescap:Capability Name="runFullTrust" /&gt;
  &lt;/Capabilities&gt;
&lt;/Package&gt;
</pre>
</blockquote>

Дополнительные сведения о файле `AppXManifest.xml` и макете пакета см. [в теме **Манифест пакета приложения** на веб-сайте MSDN](https://msdn.microsoft.com/en-us/library/windows/apps/br211474.aspx).

И, наконец, если вы используете Visual Studio для создания нового проекта и переносите существующий код в него, см. раздел [Документация MSDN для создания нового проекта UWP](https://msdn.microsoft.com/en-us/windows/uwp/get-started/create-a-hello-world-app-xaml-universal). Можно включить существующий код в новый проект, но, скорее всего, вам придется внести в него значительные изменения (особенно в пользовательском интерфейсе), чтобы приложение работало как "чистое" приложение UWP. Эти изменения выходят за рамки данного документа.

***

## <a name="phase-1-localize-the-application-manifest"></a>Этап 1. Локализация манифеста приложения

### <a name="step-11-update-strings--assets-in-the-appxmanifest"></a>Шаг 1.1. Обновление строк и ресурсов в AppXManifest

На этапе 0 вы создали простой файл `AppXManifest.xml` для приложения (на основе предоставленных преобразователю значений, извлеченных из MSI-файла или вручную введенных в манифест), но он не будет содержать локализованные сведения и не будет поддерживать дополнительные функции, например, ресурсы плиток меню "Пуск" высокого разрешения и т. д. 

Чтобы убедиться, что имя и описание приложения правильно локализованы, необходимо определить некоторые ресурсы в наборе файлов ресурсов и обновить манифест AppX для ссылки на них.

**Создание файла ресурсов по умолчанию**

Первый этап — это создание файла ресурсов по умолчанию на языке по умолчанию (например, английский (США)). Это можно сделать вручную с помощью текстового редактора или с помощью конструктора ресурсов в Visual Studio.

Если вы хотите создать ресурсы вручную, выполните следующие действия.

0. Создайте XML-файл с именем `resources.resw` и разместите его во вложенной папке проекта `Strings\en-us`. 
 * Используйте соответствующий код BCP-47, если английский (США) не является языком по умолчанию 
0. В XML-файл добавьте следующее содержимое, где <span style="background-color: yellow">выделенный текст</span> необходимо заменить соответствующим текстом для вашего приложения на языке по умолчанию.

**Примечание**. Существуют ограничения по размеру некоторых из этих строк. Дополнительные сведения см. в разделе [VisualElements](/uwp/schemas/appxpackage/appxmanifestschema/element-visualelements?branch=live).

<blockquote>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;root&gt;
  &lt;data name="ApplicationDescription"&gt;
    &lt;value&gt;<span style="background-color: yellow">Contoso Demo app with localized resources (English)</span>&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name="ApplicationDisplayName"&gt;
    &lt;value&gt;<span style="background-color: yellow">Contoso Demo Sample (English)</span>&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name="PackageDisplayName"&gt;
    &lt;value&gt;<span style="background-color: yellow">Contoso Demo Package (English)</span>&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name="PublisherDisplayName"&gt;
    &lt;value&gt;<span style="background-color: yellow">Contoso Samples, USA</span>&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name="TileShortName"&gt;
    &lt;value&gt;<span style="background-color: yellow">Contoso (EN)</span>&lt;/value&gt;
  &lt;/data&gt;
&lt;/root&gt;
</pre>
</blockquote>

Если вы хотите использовать конструктор в Visual Studio, выполните следующие действия.

0. Создайте папку `Strings\en-us` (или другой необходимый язык) в проекте и добавьте **Новый элемент** в корневую папку проекта, используя имя по умолчанию `resources.resw`
 * Убедитесь, что вы выбрали **Файл ресурсов (.resw)**, а не **Словарь ресурсов**, так как "Словарь ресурсов" — это файл, используемый приложениями XAML
0. С помощью конструктора введите следующие строки (используйте те же `Names`, но замените `Values` соответствующим текстом для вашего приложения):

<img src="images\editing-resources-resw.png"/>

Примечание. Если вы начали работу с конструктором Visual Studio, вы всегда можете отредактировать XML-файл напрямую, нажав кнопку `F7`. Но если вы начали работу с минимальным XML-файлом, *конструктор не сможет распознать файл* из-за отсутствия множества дополнительных метаданных. Это можно исправить путем копирования шаблонных сведений XSD из файла, созданного конструктором, в XML-файл, отредактированный вручную. 

**Обновление манифеста для ссылки на ресурсы**

После получения значений, определенных в файле `.resw`, следующим шагом будет обновление манифеста для ссылки на строки ресурсов. При желании вы можете изменить XML-файл напрямую или доверить это конструктору манифестов Visual Studio.

Если вы напрямую редактируете XML-файл, откройте файл `AppxManifest.xml` и внесите следующие изменения в <span style="background-color: lightgreen">выделенные значения</span>. Используйте этот *точный* текст, а не текст, относящийся к приложению. Не требуется использовать именно эти имена ресурсов &mdash; вы можете выбрать собственные имена, &mdash; но выбранные вами имена должны точно совпадать с именами, содержащимися в файле `.resw`. Эти имена должны соответствовать `Names`, которые вы создали в файле `.resw`, с добавленной в префиксе схемой `ms-resource:` и пространством имен `Resources/`. 

*Примечание. Многие элементы манифеста исключены из этого фрагмента — ничего не удаляйте!*

<blockquote>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Package&gt;
  &lt;Properties&gt;
    &lt;DisplayName&gt;<span style="background-color: lightgreen">ms-resource:Resources/PackageDisplayName</span>&lt;/DisplayName&gt;
    &lt;PublisherDisplayName&gt;<span style="background-color: lightgreen">ms-resource:Resources/PublisherDisplayName</span>&lt;/PublisherDisplayName&gt;
  &lt;/Properties&gt;
  &lt;Applications&gt;
    &lt;Application&gt;
      &lt;uap:VisualElements DisplayName="<span style="background-color: lightgreen">ms-resource:Resources/ApplicationDisplayName</span>"
        Description="<span style="background-color: lightgreen">ms-resource:Resources/ApplicationDescription</span>"&gt;
        &lt;uap:DefaultTile ShortName="<span style="background-color: lightgreen">ms-resource:Resources/TileShortName</span>"&gt;
          &lt;uap:ShowNameOnTiles&gt;
            &lt;uap:ShowOn Tile="square150x150Logo" /&gt;
          &lt;/uap:ShowNameOnTiles&gt;
        &lt;/uap:DefaultTile&gt;
      &lt;/uap:VisualElements&gt;
    &lt;/Application&gt;
  &lt;/Applications&gt;
&lt;/Package&gt;
</pre>
</blockquote>

Если вы используете конструктор манифестов Visual Studio, откройте файл `Package.appxmanifest` и измените <span style="background-color: lightgreen">выделенные значения</span> на вкладке `Application` и вкладке `Packaging`:

<img src="images\editing-application-info.png"/>
<img src="images\editing-packaging-info.png"/>

### <a name="step-12-build-pri-file-make-an-appx-package-and-verify-its-working"></a>Шаг 1.2. Сборка PRI-файла, создание пакета AppX и проверка его работы

Теперь вы должны иметь возможность создать файл `.pri` и развернуть приложение, чтобы убедиться, что в меню "Пуск" отображаются правильные сведения (на языке по умолчанию). 

Если вы работаете в Visual Studio, просто нажмите сочетание клавиш `Ctrl+Shift+B` для сборки проекта, а затем щелкните проект правой кнопкой мыши и выберите `Deploy` в контекстном меню. 

Если вы собираете программу вручную, выполните следующие действия, чтобы создать файл конфигурации для средства `MakePRI` и создания самого файла `.pri` (дополнительные сведения можно найти в разделе [**Упаковка приложений вручную** на веб-сайте MSDN](https://docs.microsoft.com/en-us/windows/uwp/packaging/manual-packaging-root)):

0. Откройте командную строку разработчика из папки `Visual Studio 2015` в меню "Пуск"
0. Перейдите в корневой каталог проекта (тот, который содержит файл `AppxManifest.xml` и папку `Strings`)
0. Введите следующую команду, заменив "contoso_demo.xml" именем, соответствующим вашему проекту, и "en-US" на язык по умолчанию для вашего приложения (или оставьте его en-US, если необходимо). Обратите внимание, что XML-файл создается в родительском каталоге (**не** в каталоге проекта), так как он не является частью приложения (вы можете выбрать любой другой каталог, но не забудьте использовать его в будущих командах).

```CMD
    makepri createconfig /cf ..\contoso_demo.xml /dq en-US /pv 10.0 /o
```

0. Вы можете ввести `makepri createconfig /?`, чтобы узнать, что делает каждый параметр, но в целом:
 * `/cf` Задает имя файла конфигурации (выходные данные этой команды)
 * `/dq` Задает квалификаторы по умолчанию, в данном случае язык `en-US`
 * `/pv` Задает версию платформы, в этом случае Windows 10
 * `/o` Задает перезапись выходного файла, если он существует
0. Теперь у вас есть файл конфигурации. Запустите `MakePRI` еще раз, чтобы фактически выполнить поиск ресурсов на диске и упаковать их в PRI-файл. Замените "contoso_demop.xml" на имя XML-файла, который вы использовали на предыдущем шаге, и не забудьте указать родительский каталог для входного и выходного файла: 

    `makepri new /pr . /cf ..\contoso_demo.xml /of ..\resources.pri /mf AppX /o`
0. Вы можете ввести `makepri new /?`, чтобы узнать, что делает каждый параметр, но вкратце:
 * `/pr` Задает корневой каталог проекта (в данном случае текущий каталог)
 * `/cf` Задает имя файла конфигурации, созданного на предыдущем этапе
 * `/of` Задает выходной файл 
 * `/mf` Создает файл сопоставления (поэтому можно исключить файлы в пакете следующем этапе)
 * `/o` Задает перезапись выходного файла, если он существует
0. Теперь у вас есть файл `.pri` с языковыми ресурсами по умолчанию (например, en-US). Чтобы убедиться, что он работает правильно, можно выполнить следующую команду:

    `makepri dump /if ..\resources.pri /of ..\resources /o`
0. Вы можете ввести `makepri dump /?`, чтобы узнать, что делает каждый параметр, но вкратце:
 * `/if` Задает имя входного файла 
 * `/of` Задает имя выходного файла (`.xml` будет автоматически добавлен)
 * `/o` Задает перезапись выходного файла, если он существует
0. Наконец, вы можете открыть `..\resources.xml` в текстовом редакторе и убедиться, что в нем перечислены ваши значения `<NamedResource>` (например, `ApplicationDescription` и `PublisherDisplayName`) вместе со значениями `<Candidate>` для выбранного языка по умолчанию (в начале файла будет другое содержимое; игнорируйте это на данный момент).

При желании можно открыть файл сопоставления `..\resources.map.txt`, чтобы убедиться, что он содержит файлы, необходимые для вашего проекта (в том числе PRI-файл, который не является частью каталога проекта). Важно, что файл сопоставления *не* будет содержать ссылку на ваш файл `resources.resw`, так как содержимое этого файла уже было встроено в PRI-файл. Тем не менее, здесь содержатся другие ресурсы, такие как имена файлов изображений.

**Создание и подписывание пакета**

После создания PRI-файла можно создать и подписать пакет:

0. Для создания пакета приложения запустите следующую команду, заменяя `contoso_demo.appx` именем файла AppX, который вы хотите создать, и убедившись, что выбран другой каталог для файла `.AppX` (в этом примере используется родительский каталог; он может быть в любом месте, но **не** должен быть каталогом проекта):

    `makeappx pack /m AppXManifest.xml /f ..\resources.map.txt /p ..\contoso_demo.appx /o`
0. Вы можете ввести `makeappx pack /?`, чтобы узнать, что делает каждый параметр, но вкратце:
 * `/m` Задает использование файла манифеста
 * `/f` Задает использование файла сопоставления (созданного на предыдущем шаге) 
 * `/p` Задает имя выходного пакета
 * `/o` Задает перезапись выходного файла, если он существует
0. После создания пакета его необходимо подписать. Самый простой способ получить сертификат подписи — создать пустой проект универсального приложения для Windows в Visual Studio и скопировать `.pfx` файла, он создает, но его можно создать вручную с помощью `MakeCert` и `Pvk2Pfx` служебных программ, как описано в разделе [ **Создание сертификат подписи пакета приложения** разделе на сайте MSDN] (https://msdn.microsoft.com/en-us/library/windows/desktop/jj835832(v=vs.85).aspx). 
 * **Важно!** При создании сертификата подписи вручную убедитесь, что вы сохранили файлы в каталоге, отличном от каталога исходного проекта или источника пакета. В противном случае он может быть включен в состав пакета вместе с закрытым ключом!
0. Чтобы подписать пакет, используйте следующую команду. Обратите внимание, что `Publisher`, указанный в элементе `Identity` `AppxManifest.xml` должен соответствовать `Subject` сертификата (это **не** элемент `<PublisherDisplayName>`, который является локализованным отображаемым именем для показа пользователям). Как обычно, замените имена файлов `contoso_demo...` именами, соответствующими вашему проекту и (**очень важно**) убедитесь, что файл `.pfx` не находится в текущем каталоге (в противном случае он был бы создан как часть пакета, включая закрытый ключ подписи!):

    `signtool sign /fd SHA256 /a /f ..\contoso_demo_key.pfx ..\contoso_demo.appx`
0. Вы можете ввести `signtool sign /?`, чтобы узнать, что делает каждый параметр, но вкратце:
 * `/fd` Задает дайджест-алгоритм файла (SHA256 – значение по умолчанию для AppX)
 * `/a` Автоматически выбирает лучший сертификат
 * `/f` Задает входной файл, содержащий сертификат подписи

Наконец, теперь можно дважды щелкнуть файл `.appx`, чтобы установить его. Если вы предпочитаете использовать командную строку, можно открыть командную строку PowerShell, перейти в каталог с пакетом и ввести следующую команду (заменив `contoso_demo.appx` именем вашего пакета):

```CMD
    add-appxpackage contoso_demo.appx
```

При появлении ошибок с указанием, что сертификат не является доверенным, убедитесь, что он добавлен в хранилище компьютера (**не** в хранилище пользователя). Чтобы добавить сертификат в хранилище компьютера, можно использовать командную строку или проводник Windows.

Для использования командной строки выполните следующие действия.

0. Запустите командную строку Visual Studio 2015 с правами администратора.
0. Перейдите в каталог, содержащий файл `.cer` (не забудьте убедиться, что он находится не в исходной папке или папке проекта!)
0. Введите следующую команду, заменив `contoso_demo.cer` именем вашего файла:

    `certutil -addstore TrustedPeople contoso_demo.cer`
0. Вы можете выполнить команду `certutil -addstore /?`, чтобы узнать, что делает каждый параметр, но вкратце:
 * `-addstore` Добавляет сертификат в хранилище сертификатов
 * `TrustedPeople` Указывает магазин, в котором размещен сертификат

Чтобы использовать проводник Windows, выполните следующие действия.

0. Перейдите в папку, содержащую файл `.pfx`
0. Дважды щелкните файл `.pfx`, после чего должен открыться **мастер импорта сертификата**
0. Выберите `Local Machine` и нажмите кнопку `Next`
0. Примите запрос на использование прав администратора для контроля учетных записей, если он отображается, и нажмите кнопку `Next`
0. Введите пароль для закрытого ключа, если он существует, и нажмите кнопку `Next`
0. Выделить `Place all certificates in the following store`
0. Нажмите кнопку `Browse` и выберите папку `Trusted People` (**не** "Доверенные издатели")
0. Нажмите кнопку `Next`, а потом `Finish`

После добавления сертификата в магазин `Trusted People` попробуйте снова установить пакет.

Теперь ваше приложение должно отобразится в списке меню "Пуск" "Все приложения" с правильными сведениями из файла `.resw` / `.pri`. Если вы видите пустую строку или строку `ms-resource:...`, значит произошла ошибка. Тщательно проверьте внесенные изменения и убедитесь в их правильности. Если щелкнуть правой кнопкой мыши приложение в меню "Пуск", можно закрепить его как плитку и убедиться, что там тоже отображаются правильные сведения.

### <a name="step-13-add-more-supported-languages"></a>Шаг 1.3. Добавление других поддерживаемых языков

После внесения изменений в манифест AppX и создания начального файла `resources.resw` можно легко добавить дополнительные языки.

**Создание дополнительных локализованных ресурсов**

Во-первых, создайте значения дополнительных локализованных ресурсов. 

В папке `Strings` создайте дополнительные папки для каждого поддерживаемого языка, используя соответствующий код BCP-47 (например, `Strings\de-DE`). В каждой из этих папок создайте файл `resources.resw` (с помощью редактора XML или конструктора Visual Studio), который содержит переведенные значения ресурсов. Предполагается, что у вас уже где-то есть доступные локализованные строки и нужно просто скопировать их в файл `.resw`. В этом документе не рассматривается сам этап перевода. 

Например, файл `Strings\de-DE\resources.resw` может выглядеть следующим образом, с <span style="background-color: yellow">выделенным текстом</span>, измененным с `en-US`:

<blockquote>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;root&gt;
  &lt;data name="ApplicationDescription"&gt;
    &lt;value&gt;<span style="background-color: yellow">Contoso Demo app with localized resources (German)</span>&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name="ApplicationDisplayName"&gt;
    &lt;value&gt;<span style="background-color: yellow">Contoso Demo Sample (German)</span>&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name="PackageDisplayName"&gt;
    &lt;value&gt;<span style="background-color: yellow">Contoso Demo Package (German)</span>&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name="PublisherDisplayName"&gt;
    &lt;value&gt;<span style="background-color: yellow">Contoso Samples, DE</span>&lt;/value&gt;
  &lt;/data&gt;
  &lt;data name="TileShortName"&gt;
    &lt;value&gt;<span style="background-color: yellow">Contoso (DE)</span>&lt;/value&gt;
  &lt;/data&gt;
&lt;/root&gt;
</pre>
</blockquote>

В следующих шагах предполагается, что вы добавили ресурсы для `de-DE` и `fr-FR`, но тот же шаблон можно использовать для любого языка.

**Обновление манифеста AppX для внесения поддерживаемых языков в список**

Манифест AppX необходимо обновить, чтобы внести в список языки, поддерживаемые приложением. Desktop App Converter добавляет язык по умолчанию, но другие языки должны быть добавлены явным образом. При редактировании файла `AppxManifest.xml` напрямую обновите узел `Resources` следующим образом, добавляя необходимое количество элементов и заменяя <span style="background-color: yellow">соответствующие языки, которые вы поддерживаете</span>, и убедитесь, что первый элемент в списке — это язык по умолчанию (резервный). В этом примере значение по умолчанию — английский (США) с дополнительной поддержкой немецкого (Германия) и французского (Франция):

<blockquote>
<pre>
&lt;Resources&gt;
  &lt;Resource Language="<span style="background-color: yellow">EN-US</span>" /&gt;
  &lt;Resource Language="<span style="background-color: yellow">DE-DE</span>" /&gt;
  &lt;Resource Language="<span style="background-color: yellow">FR-FR</span>" /&gt;
&lt;/Resources&gt;
</pre>
</blockquote>

Если вы используете Visual Studio, не требуется выполнять никаких действий. Если вы взглянете на `Package.appxmanifest`, вы увидите специальное значение <span style="background-color: yellow">x-generate</span>, которое заставляет процесс построения вставить языки, найденные в проекте (основываясь на папках, названных по имени кодов BCP-47). Обратите внимание, что это не является допустимым значением для реального манифеста Appx. Оно работает только для проектов Visual Studio:

<blockquote>
<pre>
&lt;Resources&gt;
  &lt;Resource Language="<span style="background-color: yellow">x-generate</span>" /&gt;
&lt;/Resources&gt;
</pre>
</blockquote>

**Повторная сборка с локализованными значениями**

Теперь вы можете собрать и развернуть приложение снова, и, если вы измените ваш выбор языка в Windows, вы должны увидеть вновь локализованные значения, отображающиеся в меню "Пуск" (ниже приведены инструкции о том, как изменить язык).

Для Visual Studio снова можно просто использовать `Ctrl+Shift+B` для сборки и щелкнуть правой кнопкой мыши проект, чтобы `Deploy` (Развернуть).

Если вы создаете проект вручную, выполните те же действия, что описаны выше, но добавьте дополнительные языки, разделенные символом подчеркивания, в список квалификаторов по умолчанию (`/dq`) при создании файла конфигурации. Например, для поддержки ресурсов английского, немецкого и французского языков, добавленных на предыдущем этапе:

```CMD
    makepri createconfig /cf ..\contoso_demo.xml /dq en-US_de-DE_fr-FR /pv 10.0 /o
```

Это действие приведет к созданию PRI-файла, содержащего все указанные языки, который легко можно использовать для тестирования. Если общий размер ресурсов мал или вы поддерживаете только небольшое количество языков, это может быть допустимо для приложения доставки. Дополнительные действия по созданию отдельных языковых пакетов необходимо выполнить, только если вам нужны преимущества минимизации размера установки и скачивания для ресурсов.

**Тестирование с локализованными значениями**

Для проверки новых локализованных изменений просто добавьте новый предпочтительный язык пользовательского интерфейса в Windows. Нет необходимости загружать языковые пакеты, перезагружать систему или давать команду всему пользовательскому интерфейсу Windows отобразиться на иностранном языке. 

0. Запустите приложение `Settings` (`Windows + I`)
0. Откройте `Time & language`
0. Откройте `Region & language`
0. Нажмите `Add a language`
0. Введите (или выберите) нужный язык (например, `Deutsch` или `German`)
 * Если имеются вложенные языки, выберите нужный вариант (например, `Deutsch / Deutschland`)
0. Выберите новый язык в списке языков
0. Нажмите `Set as default`

Теперь откройте меню "Пуск" и найдите свое приложение. Вы должны увидеть локализованные значения для выбранного языка (другие приложения также могут отображаться локализованными). Если вы не видите локализованное имя уже сейчас, подождите несколько минут до обновления кэша меню "Пуск". Чтобы вернуться к своему родному языку, просто сделайте его языком по умолчанию в списке языков. 

### <a name="step-14-localizing-more-parts-of-the-appx-manifest-optional"></a>Шаг 1.4. Локализация дополнительных частей манифеста AppX (необязательно)

Можно локализовать другие разделы манифеста AppX. Например, если приложение обрабатывает расширения файлов, оно должно иметь расширение `windows.fileTypeAssociation` в манифесте, используя <span style="background-color: lightgreen">выделенный зеленым текст</span> в точности так, как показано (так как он будет ссылаться на ресурсы) и заменяя <span style="background-color: yellow">выделенный желтым цветом текст</span> информацией, относящейся к вашему приложению:

<blockquote>
<pre>
&lt;Extensions&gt;
  &lt;uap:Extension Category="windows.fileTypeAssociation"&gt;
    &lt;uap:FileTypeAssociation Name="default"&gt;
      &lt;uap:DisplayName&gt;<span style="background-color: lightgreen">ms-resource:Resources/FileTypeDisplayName</span>&lt;/uap:DisplayName&gt;
      &lt;uap:Logo&gt;<span style="background-color: yellow">Assets\StoreLogo.png</span>&lt;/uap:Logo&gt;
      &lt;uap:InfoTip&gt;<span style="background-color: lightgreen">ms-resource:Resources/FileTypeInfoTip</span>&lt;/uap:InfoTip&gt;
      &lt;uap:SupportedFileTypes&gt;
        &lt;uap:FileType ContentType="<span style="background-color: yellow">application/x-contoso</span>"&gt;<span style="background-color: yellow">.contoso</span>&lt;/uap:FileType&gt;
      &lt;/uap:SupportedFileTypes&gt;
    &lt;/uap:FileTypeAssociation&gt;
  &lt;/uap:Extension&gt;
&lt;/Extensions&gt;
</pre>
</blockquote>

Вы также можете добавить эти сведения с помощью конструктора манифестов Visual Studio на вкладке `Declarations`, обращая внимание на <span style="background-color: lightgreen">выделенные значения</span>:

<p><img src="images\editing-declarations-info.png"/></p>

Теперь добавьте соответствующие имена ресурсов для каждого вашего файла `.resw`, заменяя <span style="background-color: yellow">выделенный текст</span> соответствующим текстом для вашего приложения (помните, что это необходимо сделать для *каждого поддерживаемого языка!*):

<blockquote>
<pre>
... existing content...

&lt;data name="FileTypeDisplayName"&gt;
  &lt;value&gt;<span style="background-color: yellow">Contoso Demo File</span>&lt;/value&gt;
&lt;/data&gt;
&lt;data name="FileTypeInfoTip"&gt;
  &lt;value&gt;<span style="background-color: yellow">Files used by Contoso Demo App</span>&lt;/value&gt;
&lt;/data&gt;
</pre>
</blockquote>

Это затем отобразится в таких частях оболочки Windows, как проводник:

<p><img src="images\file-type-tool-tip.png"/></p>

Соберите и протестируйте пакет, как и раньше, выполняя все новые сценарии, в которых должны отображаться новые строки пользовательского интерфейса.

- - -

## <a name="phase-2-use-mrt-to-identify-and-locate-resources"></a>Этап 2. Использование MRT для определения и поиска ресурсов

В предыдущем разделе показано, как использовать MRT для локализации файла манифеста вашего приложения, чтобы оболочка Windows могла правильно отображать имя приложения и другие метаданные. Никаких изменений кода для этого не потребовалось. Просто потребовалось использовать файлы `.resw` и некоторые дополнительные средства. В этом разделе будет показано, как использовать MRT для поиска ресурсов в существующих форматах ресурсов и как использовать существующий код обработки ресурсов с минимальными изменениями.

### <a name="assumptions-about-existing-file-layout--application-code"></a>Допущения о существующем макете файла и коде приложения

Так как существует множество способов локализации классических приложений Win32, в данном документе будут сделаны некоторые упрощающие допущения о структуре существующего приложения, которые необходимо сопоставить с вашей конкретной средой. Возможно, вам понадобится внести изменения в существующую базу кода или макет ресурсов, чтобы соответствовать требованиям MRT, а они в основном выходят за рамки данного документа.

**Макет файлов ресурсов**

В этом документе предполагается, что локализованные ресурсы все имеют одинаковые имена файлов (например, `contoso_demo.exe.mui` или `contoso_strings.dll` или `contoso.strings.xml`), но находятся в разных папках с именами, соответствующими кодам BCP-47 (`en-US`, `de-DE` и т. д.). Не имеет значения сколько файлов ресурсов у вас есть, каковы их имена, в каких они форматах и с какими API-интерфейсами связаны и т. д. Единственное, что важно, это то, что каждый *логический* ресурс имеет одно и то же имя файла (но размещен в другом *физическом* каталоге). 

В качестве контрпримера: если приложение использует плоскую структуру файлов с одним каталогом `Resources`, содержащим файлы `english_strings.dll` и `french_strings.dll`, он не будет правильно сопоставляться с MRT. Лучшей структурой был бы каталог `Resources` с подкаталогами и файлами `en\strings.dll` и `fr\strings.dll`. Можно также использовать такое же имя основного файла, но со встроенными квалификаторами, например `strings.lang-en.dll` и `strings.lang-fr.dll`, но использование каталогов с кодами языков концептуально проще, поэтому мы рассматриваем его подробно.

**Примечание**. По-прежнему можно использовать MRT и преимущества пакетов AppX, даже если не удается выполнить требование, касающееся названий файла. Просто для этого потребуется больше усилий.

Например, приложение может иметь набор команд пользовательского интерфейса (используемых для меток кнопок и др.) в простом текстовом файле с именем <span style="background-color: yellow">ui.txt</span>, размещенном в папке <span style="background-color: yellow">UICommands</span>:

<blockquote>
<pre>
+ ProjectRoot
|--+ Strings
|  |--+ en-US
|  |  \--- resources.resw
|  \--+ de-DE
|     \--- resources.resw
|--+ <span style="background-color: yellow">UICommands</span>
|  |--+ en-US
|  |  \--- <span style="background-color: yellow">ui.txt</span>
|  \--+ de-DE
|     \--- <span style="background-color: yellow">ui.txt</span>
|--- AppxManifest.xml
|--- ...rest of project...
</pre>
</blockquote>

**Код для загрузки ресурсов**

В этом документе предполагается, что в определенный момент в коде вы захотите найти файл, содержащий локализованный ресурс, загрузить его и затем использовать его. API, используемые для загрузки ресурсов, API, используемые для извлечения ресурсов, и т.д. не важны. Псевдокод состоит их трех основных этапов:

```
set userLanguage = GetUsersPreferredLanguage()
set resourceFile = FindResourceFileForLanguage(MY_RESOURCE_NAME, userLanguage)
set resource = LoadResource(resourceFile) 
    
// now use 'resource' however you want
```

MRT требует изменить только первые два этапа в этом процессе: определение наилучшего ресурса-кандидата и способа его поиска. Вам не требуется менять способ загрузки и использования этих ресурсов (хотя MRT предоставляет средства для этого, если вы хотите воспользоваться их преимуществами).
 
Например, приложение может использовать API Win32 `GetUserPreferredUILanguages`, функцию CRT `sprintf` и API Win32 `CreateFile` для замены трех вышеперечисленных функций псевдокода, а затем провести анализ текстового файла вручную, выполняя поиск пар `name=value`. (Детали не важны; информация приводится всего лишь, чтобы показать, что MRT не влияет на методы, используемые для обработки ресурсов, как только они будут найдены).

### <a name="step-21-code-changes-to-use-mrt-to-locate-files"></a>Шаг 2.1. Изменения кода для использования MRT для поиска файлов

Переключение кода на использования MRT для поиска ресурсов не составляет труда. Для этого требуется использовать ряд типов WinRT и несколько строк кода. Ниже приведены основные типы, которые будут использоваться:

* [ResourceContext](https://docs.microsoft.com/en-us/uwp/api/Windows.ApplicationModel.Resources.Core.ResourceContext), который инкапсулирует активный в данное время набор значений квалификатора (язык, коэффициент масштабирования и т. д.)
* [ResourceManager](https://docs.microsoft.com/en-us/uwp/api/windows.applicationmodel.resources.core.resourcemanager) (версия WinRT, а не версия .NET), который предоставляет доступ ко всем ресурсам из PRI-файла
* [ResourceMap](https://docs.microsoft.com/en-us/uwp/api/windows.applicationmodel.resources.core.resourcemap), который представляет конкретное подмножество ресурсов в PRI-файле (в этом примере файловые ресурсы в сравнении со строковыми ресурсами)
* [NamedResource](https://docs.microsoft.com/en-us/uwp/api/Windows.ApplicationModel.Resources.Core.NamedResource), представляющий логический ресурс и все его возможные кандидаты
* [ResourceCandidate](https://docs.microsoft.com/en-us/uwp/api/windows.applicationmodel.resources.core.resourcecandidate), представляющий одного конкретного ресурса-кандидата 

В псевдокоде способ, которым вы разрешаете данное имя файла ресурсов (например, `UICommands\ui.txt` в примере выше), выглядит следующим образом:

```
// Get the ResourceContext that applies to this app
set resourceContext = ResourceContext.GetForViewIndependentUse()
    
// Get the current ResourceManager (there's one per app)
set resourceManager = ResourceManager.Current
    
// Get the "Files" ResourceMap from the ResourceManager
set fileResources = resourceManager.MainResourceMap.GetSubtree("Files")
    
// Find the NamedResource with the logical filename we're looking for,
// by indexing into the ResourceMap
set desiredResource = fileResources["UICommands\ui.txt"]
    
// Get the ResourceCandidate that best matches our ResourceContext
set bestCandidate = desiredResource.Resolve(resourceContext)
   
// Get the string value (the filename) from the ResourceCandidate
set absoluteFileName = bestCandidate.ValueAsString
```

Обратите особое внимание, что код **не** запрашивает папку конкретного языка, например `UICommands\en-US\ui.txt`, хотя это то, как файлы существуют на диске. Вместо этого он запрашивает *логическое* имя файла `UICommands\ui.txt` и использует MRT, чтобы найти соответствующий файл на диске в одном из каталогов языка.

С этого момента образец приложения может продолжать использовать `CreateFile` для загрузки `absoluteFileName` и анализа пар `name=value` так же как и раньше. Ни одну эту логику не нужно менять в приложении. Если вы пишете на языках C# или C++/CX, фактический код не намного сложнее, чем этот (и на самом деле, большинство промежуточных переменных можно редактировать). См. в раздел, описывающий **загрузку ресурсов .NET** ниже. Приложения на основе C++/WRL будет сложнее перенести из-за низкоуровневых API на основе модели COM, используемых для активации и вызова API WinRT, но основные необходимые действия будут те же. См. раздел **Загрузка ресурсов MUI Win32** ниже.

**Загрузка ресурсов .NET**

Поскольку .NET имеет встроенный механизм для обнаружения и загрузки ресурсов (известный как "Вспомогательные сборки"), нет явного кода для замены как в приведенном выше синтетическом примере. В .NET необходима только библиотека DLL ресурсов в соответствующих папках и они будут автоматически находиться для вас. Если приложение упаковано в виде AppX с помощью пакетов ресурсов, структура каталогов будет несколько отличаться. Каталоги ресурсов расположены на одном уровне с основным каталогом приложения, а не являются его вложенными каталогами (или отсутствуют вообще, если у пользователя отсутствует язык, перечисленный в предпочтениях). 

Например, представим приложение .NET со следующим макетом, в котором все файлы существуют в папке `MainApp`:

<blockquote>
<pre>
+ MainApp
|--+ en-us
|  \--- MainApp.resources.dll
|--+ de-de
|  \--- MainApp.resources.dll
|--+ fr-fr
|  \--- MainApp.resources.dll
\--- MainApp.exe
</pre>
</blockquote>

После преобразования в AppX макет будет выглядеть примерно следующим образом при условии, что `en-US` был выбран языком по умолчанию, и пользователь также добавил в список языков немецкий и французский:

<blockquote>
<pre>
+ WindowsAppsRoot
|--+ MainApp_neutral
|  |--+ en-us
|  |  \--- <span style="background-color: yellow">MainApp.resources.dll</span>
|  \--- MainApp.exe
|--+ MainApp_neutral_resources.language_de
|  \--+ de-de
|     \--- <span style="background-color: yellow">MainApp.resources.dll</span>
\--+ MainApp_neutral_resources.language_fr
   \--+ fr-fr
      \--- <span style="background-color: yellow">MainApp.resources.dll</span>
</pre>
</blockquote>

Поскольку локализованные ресурсы больше не существуют во вложенных каталогах в расположении установки основного исполняемого файла, происходит сбой разрешения встроенных ресурсов .NET. К счастью, .NET имеет четкий механизм для обработки неудачных попыток загрузки сборки — событие `AssemblyResolve`. Приложение .NET, использующее MRT, должно зарегистрироваться для получения этого события и предоставить отсутствующую сборку для подсистемы ресурсов .NET. 

Краткий пример того, как использовать API WinRT для обнаружения вспомогательных сборок, используемых .NET, выглядит как описано ниже. Код в представленном виде намеренно сжат, чтобы показать минимальную реализацию, хотя вы видите, что он почти соответствует псевдокоду выше с переданными `ResolveEventArgs`, предоставляющими имя сборки, которую необходимо найти. Готовую к запуску версию этого кода (с подробными комментариями и обработкой ошибок) можно найти в файле `PriResourceRsolver.cs` в [образце на GitHub **Средство определения сборок .NET**](https://aka.ms/fvgqt4).

```C#
static class PriResourceResolver
{
  internal static Assembly ResolveResourceDll(object sender, ResolveEventArgs args)
  {
    var fullAssemblyName = new AssemblyName(args.Name);
    var fileName = string.Format(@"{0}.dll", fullAssemblyName.Name);

    var resourceContext = ResourceContext.GetForViewIndependentUse();
    resourceContext.Languages = new[] { fullAssemblyName.CultureName };

    var resource = ResourceManager.Current.MainResourceMap.GetSubtree("Files")[fileName];

    // Note use of 'UnsafeLoadFrom' - this is required for apps installed with AppX, but
    // in general is discouraged. The full sample provides a safer wrapper of this method
    return Assembly.UnsafeLoadFrom(resource.Resolve(resourceContext).ValueAsString);
  }
}
```

С учетом описанного выше класса вам необходимо добавить следующий фрагмент ранее в коде запуска приложения (до того, как понадобится загрузить какой-либо локализованный ресурс):

```C#
void EnableMrtResourceLookup()
{
  AppDomain.CurrentDomain.AssemblyResolve += PriResourceResolver.ResolveResourceDll;
}
```

Среда выполнения .NET будет вызывать событие `AssemblyResolve` всякий раз, когда не удается найти библиотеки DLL ресурсов. В этот момент обработчик событий обнаружит нужный файл через MRT и вернет сборку.

**Примечание**. Если ваше приложение уже содержит обработчик `AssemblyResolve` для других целей, необходимо будет интегрировать код разрешения ресурсов с существующим кодом.

**Загрузка ресурсов MUI Win32**

Загрузка ресурсов MUI Win32 очень похожа на загрузку вспомогательных сборок .NET, но вместо них используется код C++/CX или C++/WRL. Использование C++/CX позволяет использовать более простой код, который очень похож на описанный выше код C#, но он использует расширения языка C++, переключатели компилятора и дополнительные затраты среды выполнения, чего вы, возможно, захотите избежать. Если это так, использование C++/WRL предоставляет решение, которое оказывает меньшее влияние за счет более подробного кода. Однако если вы знакомы с программированием ATL (или COM в целом), WRL должен показаться вам знакомым. 

В следующем примере функции показано использование C++/WRL для загрузки конкретной библиотеки DLL ресурсов и возврата `HINSTANCE`, который можно использовать для дальнейшей загрузки ресурсов с помощью обычных API ресурсов Win32. Обратите внимание, что в отличие от примера C#, который явно инициализирует `ResourceContext` с языком, запрошенным средой выполнения .NET, этот код использует текущий язык пользователя.

```CPP
#include <roapi.h>
#include <wrl\client.h>
#include <wrl\wrappers\corewrappers.h>
#include <Windows.ApplicationModel.resources.core.h>
#include <Windows.Foundation.h>
   
#define IF_FAIL_RETURN(hr) if (FAILED((hr))) return hr;
    
HRESULT GetMrtResourceHandle(LPCWSTR resourceFilePath,  HINSTANCE* resourceHandle)
{
  using namespace Microsoft::WRL;
  using namespace Microsoft::WRL::Wrappers;
  using namespace ABI::Windows::ApplicationModel::Resources::Core;
  using namespace ABI::Windows::Foundation;
    
  *resourceHandle = nullptr;
  HRESULT hr{ S_OK };
  RoInitializeWrapper roInit{ RO_INIT_SINGLETHREADED };
  IF_FAIL_RETURN(roInit);
    
  // Get Windows.ApplicationModel.Resources.Core.ResourceManager statics
  ComPtr<IResourceManagerStatics> resourceManagerStatics;
  IF_FAIL_RETURN(GetActivationFactory(
    HStringReference(
    RuntimeClass_Windows_ApplicationModel_Resources_Core_ResourceManager).Get(),
    &resourceManagerStatics));
    
  // Get .Current property
  ComPtr<IResourceManager> resourceManager;
  IF_FAIL_RETURN(resourceManagerStatics->get_Current(&resourceManager));
    
  // get .MainResourceMap property
  ComPtr<IResourceMap> resourceMap;
  IF_FAIL_RETURN(resourceManager->get_MainResourceMap(&resourceMap));
    
  // Call .GetValue with supplied filename
  ComPtr<IResourceCandidate> resourceCandidate;
  IF_FAIL_RETURN(resourceMap->GetValue(HStringReference(resourceFilePath).Get(),
    &resourceCandidate));
    
  // Get .ValueAsString property
  HString resolvedResourceFilePath;
  IF_FAIL_RETURN(resourceCandidate->get_ValueAsString(
    resolvedResourceFilePath.GetAddressOf()));
    
  // Finally, load the DLL and return the hInst.
  *resourceHandle = LoadLibraryEx(resolvedResourceFilePath.GetRawBuffer(nullptr),
    nullptr, LOAD_LIBRARY_AS_DATAFILE | LOAD_LIBRARY_AS_IMAGE_RESOURCE);
    
  return S_OK;
}
```

## <a name="phase-3-building-resource-packs"></a>Этап 3. Создание пакетов ресурсов

Теперь, когда у вас есть "полный пакет", содержащий все ресурсы, существует два пути для создания отдельного основного пакета и пакетов ресурсов, чтобы свести к минимуму размеры загрузки и установки:

0. Возьмите существующий полный пакет и запустите его через [средство создания пакетов](https://aka.ms/bundlegen), чтобы автоматически создать пакеты ресурсов. Это предпочтительный подход, если вы используете систему сборки, которая уже создает полный пакет, и хотите выполнить его постобработку для создания пакетов ресурсов.
0. Напрямую создайте отдельные пакеты ресурсов и соберите их в пакет. Это предпочтительный подход, если у вас больше контроля над системой сборки и вы можете напрямую создавать пакеты.

### <a name="step-31-creating-the-bundle"></a>Шаг 3.1. Создание пакета

**Использование средства создания пакетов**

Чтобы использовать средство создания пакетов, необходимо вручную обновить PRI-файл конфигурации, созданный для пакета, чтобы удалить раздел `<packaging>`.

Если вы используете Visual Studio, см. раздел [**Убедитесь, что ресурсы установлены…** на веб-сайте MSDN](https://msdn.microsoft.com/en-us/library/dn482043.aspx), чтобы получить сведения о том, как собрать все языки в основной пакет путем создания файлов `priconfig.packaging.xml` и `priconfig.default.xml`.

При редактировании файлов вручную выполните следующие действия. 

0. Создайте файл конфигурации так же, как и раньше, подставляя правильный путь, имя файла и языки:

    `makepri createconfig /cf ..\contoso_demo.xml /dq en-US_de-DE_es-MX /pv 10.0 /o`
0. Вручную откройте созданный файл `.xml` и удалите весь раздел `&lt;packaging&rt;` (но сохраните все остальное без изменений):

<blockquote>
<pre>
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes" ?&gt; 
&lt;resources targetOsVersion="10.0.0" majorVersion="1"&gt;
  &lt;!-- Packaging section has been deleted... --&gt;
  &lt;index root="\" startIndexAt="\"&gt;
    &lt;default&gt;
    ...
    ...
</pre>
</blockquote>

0. Создайте пакет из фалов `.pri` и `.appx`, как и прежде, используя обновленный файл конфигурации и соответствующие имена каталогов и файлов (дополнительные сведения об этих командах см. выше):

```CMD
makepri new /pr . /cf ..\contoso_demo.xml /of ..\resources.pri /mf AppX /o
makeappx pack /m AppXManifest.xml /f ..\resources.map.txt /p ..\contoso_demo.appx /o
```

0. После создания пакета используйте следующую команду, чтобы создать пакет, используя соответствующие имена каталогов и файлов:

    `BundleGenerator.exe -Package ..\contoso_demo.appx -Destination ..\bundle -BundleName contoso_demo`

Теперь вы можете перейти к последнему шагу, а именно подписанию (см. ниже).

**Создание пакетов ресурсов вручную**

Для создания пакетов ресурсов вручную требуется выполнить немного другой набор команд для создания отдельных файлов `.pri` и `.appx`. Все они аналогичны командам, используемым выше для создания полных пакетов, поэтому дается минимальное описание. Обратите внимание, что все команды предполагают, что текущий каталог является каталогом, содержащим файл `AppXManifest.xml`, но все файлы помещаются в родительском каталоге (вы можете использовать другой каталог, если необходимо, но не следует загрязнять каталог проекта любым из этих файлов). Как всегда, замените имена файлов "Contoso" собственными именами файлов.

0. Используйте следующую команду, чтобы создать файл конфигурации, который называет **только** язык по умолчанию в качестве квалификатора по умолчанию, в этом случае – `en-US`:

    `makepri createconfig /cf ..\contoso_demo.xml /dq en-US /pv 10.0 /o`
0. Создайте файлы `.pri` и `.map.txt` по умолчанию для основного пакета, а также дополнительный набор файлов для каждого языка в проекте с помощью следующей команды:

    `makepri new /pr . /cf ..\contoso_demo.xml /of ..\resources.pri /mf AppX /o`
0. Используйте следующую команду для создания основного пакета (содержащего исполняемый код и ресурсы языка по умолчанию). Как всегда, измените имя по своему усмотрению, хотя пакет следует поместить в отдельный каталог, чтобы облегчить создание пакета на более позднем этапе (в этом примере используется каталог `..\bundle`):

    `makeappx pack /m .\AppXManifest.xml /f ..\resources.map.txt /p ..\bundle\contoso_demo.main.appx /o`
0. После создания основного пакета используйте следующую команду один раз для каждого дополнительного языка (то есть повторите эту команду для каждого файла сопоставления языка, созданного на предыдущем этапе). Помните, что выходной файл должен находиться в отдельном каталоге (том же, что и основной пакет). Обратите внимание, что язык указывается **как** в параметре `/f`, так и в параметре `/p` и используется новый аргумент `/r` (указывающий на то, что необходим пакет ресурсов):

    `makeappx pack /r /m .\AppXManifest.xml /f ..\resources.language-de.map.txt /p ..\bundle\contoso_demo.de.appx /o`
0. Объедините все пакеты из каталога набора в единый файл `.appxbundle`. Новый параметр `/d` определяет каталог, который необходимо использовать для всех файлов в этом пакете (поэтому файлы `.appx` помещаются в отдельный каталог на предыдущем шаге):

    `makeappx bundle /d ..\bundle /p ..\contoso_demo.appxbundle /o`

Последний шаг для создания пакета — подписывание.

### <a name="step-32-signing-the-bundle"></a>Шаг 3.2. Подписывание пакета

После создания файла `.appxbundle` (с помощью средства создания пакетов или вручную) вы получите один файл, содержащий основной пакет и все пакеты ресурсов. Последний шаг — подписать этот файл, чтобы Windows мог его установить:

    signtool sign /fd SHA256 /a /f ..\contoso_demo_key.pfx ..\contoso_demo.appxbundle

Это создаст подписанный файл `.appxbundle`, содержащий основной пакет и все пакеты языковых ресурсов. Его можно дважды щелкнуть так же, как файл пакета, чтобы установить приложение и любые необходимые языки на основе языковых настроек Windows пользователя.

## <a name="related-topics"></a>Статьи по теме

* [Адаптация ресурсов с учетом языка, масштаба, высокой контрастности и других квалификаторов](tailor-resources-lang-scale-contrast.md)