---
title: Использование MRT для преобразованных классических приложений и игр
description: Упаковав свое приложение или игру .NET или Win32 в виде пакета AppX, можно использовать Систему управления ресурсами для загрузки ресурсов приложения, адаптированных к контексту во время выполнения. В этой статье подробно рассматриваются соответствующие методы.
ms.date: 10/25/2017
ms.topic: article
keywords: windows 10, uwp, mrt, pri. ресурсы, игры, centennial, desktop app converter, mui, вспомогательная сборка
ms.localizationpriority: medium
ms.openlocfilehash: b17dffec37a5cadb450e93ea15508becfd7b9233
ms.sourcegitcommit: 46890e7f3c1287648631c5e318795f377764dbd9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/21/2019
ms.locfileid: "58320637"
---
# <a name="use-the-windows-10-resource-management-system-in-a-legacy-app-or-game"></a>Использование Системы управления ресурсами Windows 10 в устаревшем приложении или игре

Приложения и игры .NET и Win32 часто локализуются на разные языки, расширяя свой общий адресуемый рынок. Дополнительные сведения о преимуществах локализации приложений см. в разделе [Глобализация и локализация](../design/globalizing/globalizing-portal.md). Упаковка приложения .NET или Win32 или игры, как пакет MSIX или AppX, позволяют использовать систему управления ресурсами для загрузки ресурсов приложения, адаптированные к контексту выполнения. В этой статье подробно рассматриваются соответствующие методы.

Существует множество способов локализации традиционных приложений Win32, однако Windows 8 представила новую [систему управления ресурсами](https://msdn.microsoft.com/en-us/library/windows/apps/jj552947.aspx), которая работает со всеми языками программирования, в различных типах приложений и предоставляет функциональные возможности, которые гораздо шире простой локализации. Эта система будет называться MRT в этой статье. В прошлом это означало Modern Resource Technology ("Современная технология ресурсов"), но от термина "Современный" решено отказаться. Диспетчер ресурсов может быть также известен как MRM (диспетчер современных ресурсов) или PRI (индекс ресурсов пакета).

В сочетании с MSIX или AppX развертывания (например, из Microsoft Store), MRT можно автоматически передавать применимо большинство ресурсов для данного пользователя или устройства, который сводит к минимуму загрузку и установите размер приложения. Это уменьшение размера может быть очень значительным для приложений с большим объемом локализованного содержимого. Оно может достигать даже порядка несколько *ГБ* для игр высочайшего класса. Дополнительные преимущества MRT включают локализованные описания в оболочке Windows и Microsoft Store, логику автоматического перехода к запасному варианту, если выбранный пользователем язык не соответствует доступным ресурсам.

В этом документе описывается высокоуровневая архитектура MRT и предоставляется руководство по переносу, которое поможет переместить устаревшие приложения Win32 на платформу MRT с минимальными изменениями кода. После перемещения в MRT для разработчика становятся доступными дополнительные преимущества (например, возможность делить ресурсы на сегменты по коэффициенту масштабирования или системной теме). Обратите внимание, что локализация на основе MRT работает как для приложений UWP, так и для приложений Win32, обработанных мостом для классических приложений (известным как "Centennial").

Во многих случаях вы можете продолжать использовать ваши существующие форматы локализации и исходный код, так как интеграция с MRT для разрешения ресурсов во время выполнения и минимизации размеров скачивания — это подход, допускающий компромиссы. В следующей таблице перечислены трудозатраты, расчетные затраты и преимущества каждого этапа. В эту таблицу не включены задачи, не имеющие отношения к локализации, например, предоставление значков приложений с высоким разрешением или высокой контрастностью. Дополнительные сведения о предоставлении нескольких ресурсов для плиток, значков и т. п. см. в разделе [Адаптация ресурсов с учетом языка, масштаба, высокой контрастности и других квалификаторов](tailor-resources-lang-scale-contrast.md).

<table>
<tr>
<th>Work</th>
<th>Преимущество</th>
<th>Расчетные затраты</th>
</tr>
<tr>
<td>Локализация манифеста пакета</td>
<td>Требуется совсем немного усилий, чтобы ваше локализованное содержимое отобразилось в оболочке Windows и в Microsoft Store</td>
<td>Небольшой</td>
</tr>
<tr>
<td>Использование MRT для определения и поиска ресурсов</td>
<td>Предварительные требования к уменьшению размеров загрузки и установки, автоматический переход к запасному языку</td>
<td>Средний</td>
</tr>
<tr>
<td>Создание пакетов ресурсов</td>
<td>Последний шаг к минимизации размеров загрузки и установки</td>
<td>Небольшой</td>
</tr>
<tr>
<td>Переход к форматам и интерфейсам API ресурсов MRT</td>
<td>Значительно меньшие размеры файлов (в зависимости от существующей технологии ресурсов)</td>
<td>Большой</td>
</tr>
</table>

## <a name="introduction"></a>Введение

Большинство нестандартных приложений содержат элементы пользовательского интерфейса, известные как *ресурсы*, которые не связаны с кодом приложения (в отличие от *жестко заданных значений*, которые создаются в самом коде источника). Существует несколько причин выбрать ресурсы вместо жестко заданных значений (например, простота редактирования не разработчиками), но одна из ключевых причин — дать возможность приложению выбирать различные представления одного и того же логического ресурса во время выполнения. Например, текст, отображаемый на кнопке (или изображение, отображаемое на значке) может отличаться в зависимости от языков, которые пользователь понимает, характеристик устройства отображения или наличия у пользователя каких-либо включенных специальных возможностей.

Таким образом, основной целью любой технологии управления ресурсами является преобразование во время выполнения запроса логического или символьного *имени ресурса* (например, `SAVE_BUTTON_LABEL`) в лучшее возможное актуальное *значение* (например, "Сохранить") из набора возможных *кандидатов* (например, "Save", "Speichern" или "저장"). MRT предоставляет такую функцию и позволяет приложениям определять кандидатов ресурсов с помощью различных атрибутов (называемых *квалификаторами*), например языка пользователя, коэффициента масштабирования монитора, выбранной пользователем темы и других факторов окружающей среды. MRT поддерживает даже пользовательские квалификаторы для приложений, которые в них нуждаются (например, приложение может предоставлять различные графические ресурсы для пользователей, которые вошли с помощью учетной записи, и для гостей без явного добавления этой проверки в каждую часть приложения). MRT работает со строковыми ресурсами и с ресурсами на основе файлов, где ресурсы на основе файлов реализованы как ссылки на внешние данные (сами файлы).

### <a name="example"></a>Пример

Вот простой пример приложения, которое содержит текстовые метки на двух кнопках (`openButton` и `saveButton`) и PNG-файл, используемый для логотипа (`logoImage`). Текстовые метки локализованы на английском и немецком языках, а логотип оптимизирован для обычных мониторов настольных компьютеров (коэффициент масштабирования 100%) и телефонов с высоким разрешением (коэффициент масштабирования 300%). Обратите внимание, что на этой схеме представлено высокоуровневое концептуальное представление модели; оно не совпадает в точности с реализацией.

<p><img src="images\conceptual-resource-model.png"/></p>

На рисунке код приложения ссылается на три имени логических ресурсов. Во время выполнения виртуальная функция `GetResource` использует MRT для поиска имен этих ресурсов в таблице ресурсов (также называется PRI-файл) и находит наиболее подходящего кандидата на основе условий окружающей среды (язык пользователя и коэффициент масштабирования монитора). В случае наличия этих меток строки используются напрямую. В случае использования изображения логотипа строки интерпретируются как имена файлов, и файлы читаются с диска. 

Если пользователь говорит язык, отличный от английском или немецком языках, или отображения с коэффициентом масштабирования отличного от 100% или 300%, MRT выбирает «близко расположенные» кандидата сопоставления на основе набора правил отката (см. в разделе [система управления ресурсами](https://msdn.microsoft.com/en-us/library/windows/apps/jj552947.aspx) для получения дополнительных сведений фон).

Обратите внимание на то, что MRT поддерживает ресурсы, которые предназначены для более одного квалификатора — например, если изображение логотипа содержит внедренную текстовую, которую требуется локализовать, логотип будет иметь четыре кандидата: EN/масштабирования — 100, DE/масштаб-100, EN/масштаб – 300 и DE/шкалы-300.

### <a name="sections-in-this-document"></a>Разделы данного документа

В следующих разделах описываются высокоуровневые задачи, которые необходимо выполнить для интеграции MRT с вашим приложением.

#### <a name="phase-0-build-an-application-package"></a>Этап 0. Создание пакета приложения

В этом разделе описываются способы получения сборки существующего классического приложения в виде пакета приложения. На этом этапе никакие функции MRT не используются.

#### <a name="phase-1-localize-the-application-manifest"></a>Этап 1. Локализация манифеста приложения

В этом разделе описывается локализация манифеста приложения (чтобы он правильно отображался в оболочке Windows). На этом этапе по-прежнему используется устаревший формат ресурсов и устаревшие API для упаковки и поиска ресурсов. 

#### <a name="phase-2-use-mrt-to-identify-and-locate-resources"></a>Этап 2. Использование MRT для определения и поиска ресурсов

В этом разделе описывается процедура изменения вашего кода приложения (и, возможно, макет ресурсов) для поиска ресурсов с помощью MRT. На этом этапе по-прежнему используются существующие форматы ресурсов и интерфейсы API для загрузки и использования ресурсов. 

#### <a name="phase-3-build-resource-packs"></a>Этап 3. Создание пакетов ресурсов

В этом разделе описываются окончательные изменения, необходимые для разделения ресурсов на отдельные *пакеты ресурсов*, минимизирующие размер загрузки (и установки) приложения.

### <a name="not-covered-in-this-document"></a>В этом документе не рассматривается

После завершения этапа 0-3 выше, вы получите «пакета приложения», можно отправить в Microsoft Store, будет и свести к минимуму загрузку установить размер для пользователей, опустив ресурсы, им не нужны (например, языки не говорят). Дополнительные улучшения в размере приложения и функциональности можно сделать, выполнив один последний этап.

#### <a name="phase-4-migrate-to-mrt-resource-formats-and-apis"></a>Этап 4. Переход к форматам и интерфейсам API ресурсов MRT

Этот этап выходит за рамки данного документа. Он включает в себя перемещение ресурсов (в частности, строк) из таких устаревших форматов, как библиотеки DLL MUI или сборки ресурсов .NET в PRI-файлы. Это может привести к дальнейшей экономии места для размеров скачивания и установки. Это действие также позволяет использовать другие функции MRT, например минимизацию загрузки и установки файлов изображений на основе коэффициента масштабирования, параметров специальных возможностей и т. д.

## <a name="phase-0-build-an-application-package"></a>Этап 0. Создание пакета приложения

Прежде чем вносить изменения в ресурсы приложения, необходимо сначала заменить текущую технологию упаковки и установки на стандартную технологию упаковки и развертывания UWP. Это можно сделать тремя способами.

* Если у вас есть большой классического приложения с помощью сложных установщика или использовать множество точек расширения операционной системы, можно использовать средство Desktop App Converter для создания структуры файлов универсальной платформы Windows и сведения о манифесте из существующего установщика приложений (например, MSI).
* При наличии меньшего размера настольного приложения с помощью относительно небольшого числа файлов или простого установщика и нет обработчиков расширений, можно создать структуру файлов и сведения о манифесте вручную.
* Если выполняется перестроение из источника и хотите обновить приложения, которые будут чисто приложение UWP, можно создать новый проект в Visual Studio и зависят от интегрированной среды разработки сделать большую часть работы для вас.

Если вы хотите использовать [Desktop App Converter](https://aka.ms/converter), см. в разделе [упаковки классического приложения, с помощью Desktop App Converter](https://aka.ms/converterdocs) Дополнительные сведения о процессе преобразования. Полный набор преобразователь Desktop образцы можно найти на [мост для классических приложений для универсальной платформы Windows примеры репозиторий GitHub](https://github.com/Microsoft/DesktopBridgeToUWP-Samples).

Если вы хотите вручную создать пакет, необходимо будет создать структуру каталогов, которая включает файлы вашего приложения (исполняемые файлы и содержимое, но не исходный код) и файл манифеста пакета (appxmanifest-). Пример можно найти в [Hello, World GitHub пример](https://github.com/Microsoft/DesktopBridgeToUWP-Samples/blob/master/Samples/HelloWorldSample/CentennialPackage/AppxManifest.xml), но файл манифеста основного пакета, запущенная на рабочем столе исполняемый файл с именем `ContosoDemo.exe` выглядит следующим образом, где <span style="background-color: yellow">выделенный текст</span> бы заменен своими собственными значениями.

```xml
<?xml version="1.0" encoding="utf-8" ?>
<Package xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
         xmlns:mp="http://schemas.microsoft.com/appx/2014/phone/manifest"
         xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"
         xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities"
         IgnorableNamespaces="uap mp rescap">
    <Identity Name="Contoso.Demo"
              Publisher="CN=Contoso.Demo"
              Version="1.0.0.0" />
    <Properties>
    <DisplayName>Contoso App</DisplayName>
    <PublisherDisplayName>Contoso, Inc</PublisherDisplayName>
    <Logo>Assets\StoreLogo.png</Logo>
  </Properties>
    <Dependencies>
    <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.14393.0" 
                        MaxVersionTested="10.0.14393.0" />
  </Dependencies>
    <Resources>
    <Resource Language="en-US" />
  </Resources>
    <Applications>
    <Application Id="ContosoDemo" Executable="ContosoDemo.exe" 
                 EntryPoint="Windows.FullTrustApplication">
    <uap:VisualElements DisplayName="Contoso Demo" BackgroundColor="#777777" 
                        Square150x150Logo="Assets\Square150x150Logo.png" 
                        Square44x44Logo="Assets\Square44x44Logo.png" 
        Description="Contoso Demo">
      </uap:VisualElements>
    </Application>
  </Applications>
    <Capabilities>
    <rescap:Capability Name="runFullTrust" />
  </Capabilities>
</Package>
```

Дополнительные сведения о файле манифеста пакета и макет пакета, см. в разделе [манифест пакета приложения](https://docs.microsoft.com/en-us/uwp/schemas/appxpackage/appx-package-manifest).

Наконец, если вы используете для создания нового проекта и перенос существующего кода в Visual Studio, см. в разделе [создать «Hello, world» приложение](https://msdn.microsoft.com/windows/uwp/get-started/create-a-hello-world-app-xaml-universal). Можно включить существующий код в новый проект, но скорее всего, придется выполнить значительно изменить код (особенно в пользовательском интерфейсе) для выполнения как чистые приложения UWP. Эти изменения выходят за рамки данного документа.

## <a name="phase-1-localize-the-manifest"></a>Этап 1. Локализация манифеста

### <a name="step-11-update-strings--assets-in-the-manifest"></a>Шаг 1.1. Обновите строки & ресурсов в манифесте

На этапе 0 был создан файл манифеста (appxmanifest-) основного пакета приложения (на основе значений для преобразователя, извлеченных из MSI-ФАЙЛ или вручную введены в манифесте), но он не содержит локализованные сведения, а также будет поддерживать Дополнительные функции, например с высоким разрешением начала плитку ресурсы и т. д.

Чтобы убедиться, что правильно локализованное имя и описание приложения, необходимо определить некоторые ресурсы в набор файлов ресурсов и обновить манифест пакета, чтобы ссылаться на них.

#### <a name="creating-a-default-resource-file"></a>Создание файла ресурсов по умолчанию

Первый этап — это создание файла ресурсов по умолчанию на языке по умолчанию (например, английский (США)). Это можно сделать вручную с помощью текстового редактора или с помощью конструктора ресурсов в Visual Studio.

Если вы хотите создать ресурсы вручную, выполните следующие действия.

1. Создайте XML-файл с именем `resources.resw` и разместите его во вложенной папке проекта `Strings\en-us`. Используйте соответствующий код BCP-47, если язык по умолчанию не английский (США).
2. В XML-файл добавьте следующее содержимое, где <span style="background-color: yellow">выделенный текст</span> необходимо заменить соответствующим текстом для вашего приложения на языке по умолчанию.

> [!NOTE]
> Существуют ограничения на длину некоторые из этих строк. Дополнительные сведения см. в разделе [VisualElements](/uwp/schemas/appxpackage/appxmanifestschema/element-visualelements).

```xml
<?xml version="1.0" encoding="utf-8"?>
<root>
  <data name="ApplicationDescription">
    <value>Contoso Demo app with localized resources (English)</value>
  </data>
  <data name="ApplicationDisplayName">
    <value>Contoso Demo Sample (English)</value>
  </data>
  <data name="PackageDisplayName">
    <value>Contoso Demo Package (English)</value>
  </data>
  <data name="PublisherDisplayName">
    <value>Contoso Samples, USA</value>
  </data>
  <data name="TileShortName">
    <value>Contoso (EN)</value>
  </data>
</root>
```

Если вы хотите использовать конструктор в Visual Studio, выполните следующие действия.

1. Создание `Strings\en-us` папке (или другом языке, соответствующим образом) в проекте и добавьте **новый элемент** в корневую папку проекта, используя имя по умолчанию `resources.resw`. Обязательно выберите **файл ресурсов (.resw)** и не **словарь ресурсов** -словарь ресурсов — это файл, используемый приложениями XAML.
2. С помощью конструктора введите следующие строки (используйте те же `Names`, но замените `Values` соответствующим текстом для вашего приложения):

<img src="images\editing-resources-resw.png"/>

> [!NOTE]
> При запуске с помощью конструктора Visual Studio, можно всегда изменить XML напрямую, нажав клавишу `F7`. Но если вы начали работу с минимальным XML-файлом, *конструктор не сможет распознать файл* из-за отсутствия множества дополнительных метаданных. Это можно исправить путем копирования шаблонных сведений XSD из файла, созданного конструктором, в XML-файл, отредактированный вручную.

#### <a name="update-the-manifest-to-reference-the-resources"></a>Обновление манифеста для ссылки на ресурсы

После получения значений, определенных в `.resw` файла, следующим шагом является обновление манифеста для ссылки на строки ресурсов. При желании вы можете изменить XML-файл напрямую или доверить это конструктору манифестов Visual Studio.

Если вы напрямую редактируете XML-файл, откройте файл `AppxManifest.xml` и внесите следующие изменения в <span style="background-color: lightgreen">выделенные значения</span>. Используйте этот *точный* текст, а не текст, относящийся к приложению. Не требуется использовать именно эти имена ресурсов &mdash; вы можете выбрать собственные имена, &mdash; но выбранные вами имена должны точно совпадать с именами, содержащимися в файле `.resw`. Эти имена должны соответствовать `Names`, которые вы создали в файле `.resw`, с добавленной в префиксе схемой `ms-resource:` и пространством имен `Resources/`. 

> [!NOTE]
> Многие элементы манифеста, которые включены в этот фрагмент кода — что-нибудь не удалять!

```xml
<?xml version="1.0" encoding="utf-8"?>
<Package>
  <Properties>
    <DisplayName>ms-resource:Resources/PackageDisplayName</DisplayName>
    <PublisherDisplayName>ms-resource:Resources/PublisherDisplayName</PublisherDisplayName>
  </Properties>
  <Applications>
    <Application>
      <uap:VisualElements DisplayName="ms-resource:Resources/ApplicationDisplayName"
        Description="ms-resource:Resources/ApplicationDescription">
        <uap:DefaultTile ShortName="ms-resource:Resources/TileShortName">
          <uap:ShowNameOnTiles>
            <uap:ShowOn Tile="square150x150Logo" />
          </uap:ShowNameOnTiles>
        </uap:DefaultTile>
      </uap:VisualElements>
    </Application>
  </Applications>
</Package>
```

Если вы используете конструктор манифеста Visual Studio, откройте appxmanifest-файл и измените <span style="background-color: lightgreen">выделены значения</span> значения в **приложения* вкладку и *упаковки*вкладки:

<img src="images\editing-application-info.png"/>
<img src="images\editing-packaging-info.png"/>

### <a name="step-12-build-pri-file-make-an-msix-package-and-verify-its-working"></a>Шаг 1.2. Построение PRI-файл, внести пакет MSIX и проверить его работы

Теперь вы должны иметь возможность создать файл `.pri` и развернуть приложение, чтобы убедиться, что в меню "Пуск" отображаются правильные сведения (на языке по умолчанию).

Если вы работаете в Visual Studio, просто нажмите сочетание клавиш `Ctrl+Shift+B` для сборки проекта, а затем щелкните проект правой кнопкой мыши и выберите `Deploy` в контекстном меню.

Если вы создаете вручную, выполните следующие действия для создания файла конфигурации для `MakePRI` средство и для создания `.pri` сам файл (Дополнительные сведения можно найти в [упаковки приложения вручную](https://docs.microsoft.com/en-us/windows/uwp/packaging/manual-packaging-root)):

1. Откройте командную строку разработчика от **Visual Studio 2017** или **Visual Studio 2019** папки в меню "Пуск".
2. Перейдите в корневой каталог проекта (в каталог, содержащий appxmanifest-файл и **строки** папку).
3. Введите следующую команду, заменив "contoso_demo.xml" именем, соответствующим вашему проекту, и "en-US" на язык по умолчанию для вашего приложения (или оставьте его en-US, если необходимо). Обратите внимание на то, XML-файл создается в родительском каталоге (**не** в каталоге проекта), так как он не является частью приложения (вы можете выбрать любой другой каталог, но в не забудьте подставить, команды в будущем).

    ```CMD
    makepri createconfig /cf ..\contoso_demo.xml /dq en-US /pv 10.0 /o
    ```

    Вы можете ввести `makepri createconfig /?`, чтобы узнать, что делает каждый параметр, но в целом:
      * `/cf` Задает имя файла конфигурации (выходные данные этой команды)
      * `/dq` Задает язык по квалификаторы по умолчанию, в данном случае `en-US`
      * `/pv` Задает версию платформы, в этом вариантов Windows 10
      * `/o` Задает его, чтобы перезаписать выходной файл, если он существует

4. Теперь у вас есть файл конфигурации. Запустите `MakePRI` еще раз, чтобы фактически выполнить поиск ресурсов на диске и упаковать их в PRI-файл. Замените "contoso_demop.xml" на имя XML-файла, который вы использовали на предыдущем шаге, и не забудьте указать родительский каталог для входного и выходного файла: 

    ```CMD
    makepri new /pr . /cf ..\contoso_demo.xml /of ..\resources.pri /mf AppX /o
    ```

    Вы можете ввести `makepri new /?`, чтобы узнать, что делает каждый параметр, но вкратце:
      * `/pr` Задает корневой каталог проекта (в данном случае текущий каталог)
      * `/cf` Задает имя файла конфигурации, созданные на предыдущем шаге
      * `/of` Задает выходной файл 
      * `/mf` Создает файл сопоставления (поэтому мы можно исключить файлы в пакете на более позднем этапе)
      * `/o` Задает его, чтобы перезаписать выходной файл, если он существует

5. Теперь у вас есть файл `.pri` с языковыми ресурсами по умолчанию (например, en-US). Чтобы убедиться, что он работает правильно, можно выполнить следующую команду:

    ```CMD
    makepri dump /if ..\resources.pri /of ..\resources /o
    ```

    Вы можете ввести `makepri dump /?`, чтобы узнать, что делает каждый параметр, но вкратце:
      * `/if` Задает имя файла входных данных 
      * `/of` Задает имя выходного файла (`.xml` будет автоматически добавлено)
      * `/o` Задает его, чтобы перезаписать выходной файл, если он существует

6. Наконец, вы можете открыть `..\resources.xml` в текстовом редакторе и убедиться, что в нем перечислены ваши значения `<NamedResource>` (например, `ApplicationDescription` и `PublisherDisplayName`) вместе со значениями `<Candidate>` для выбранного языка по умолчанию (в начале файла будет другое содержимое; игнорируйте это на данный момент).

Можно открыть файл сопоставления `..\resources.map.txt` для проверки, он содержит файлы, необходимые для проекта (включая PRI-файл, который не является частью каталога проекта). Важно, что файл сопоставления *не* будет содержать ссылку на ваш файл `resources.resw`, так как содержимое этого файла уже было встроено в PRI-файл. Тем не менее, здесь содержатся другие ресурсы, такие как имена файлов изображений.

#### <a name="building-and-signing-the-package"></a>Создание и подписывание пакета 

После создания PRI-файла можно создать и подписать пакет:

1. Чтобы создать пакет приложения, выполните следующие команды, заменив `contoso_demo.appx` именем MSIX/AppX файл вы, как требуется создать и обязательно выберите другой каталог для файла (в этом примере используется родительский каталог; его можно в любом месте, но должен **не** находиться в каталоге проекта).

    ```CMD
    makeappx pack /m AppXManifest.xml /f ..\resources.map.txt /p ..\contoso_demo.appx /o
    ```

    Вы можете ввести `makeappx pack /?`, чтобы узнать, что делает каждый параметр, но вкратце:
      * `/m` Задает файл манифеста для использования
      * `/f` Задает сопоставление файла для использования (созданный на предыдущем шаге) 
      * `/p` Задает выходные данные имя пакета
      * `/o` Задает его, чтобы перезаписать выходной файл, если он существует

2. После создания пакета, оно должно быть подписано. Самый простой способ получить сертификат для подписи, — путем создания пустой проект универсальной Windows в Visual Studio и копирования `.pfx` файла, он создает, но его можно создать вручную с помощью `MakeCert` и `Pvk2Pfx` служебные программы, как описано в [ Создание сертификата для подписи пакета приложения](https://docs.microsoft.com/windows/desktop/appxpkg/how-to-create-a-package-signing-certificate).

    > [!IMPORTANT]
    > Если вы вручную создать сертификат для подписи, убедитесь, что поместите файлы в каталоге, отличном от исходного проекта или источника пакета, в противном случае он может получить входит в состав пакета, включая закрытый ключ!

3. Чтобы подписать пакет, используйте следующую команду. Обратите внимание, что `Publisher`, указанный в элементе `Identity``AppxManifest.xml` должен соответствовать `Subject` сертификата (это **не** элемент `<PublisherDisplayName>`, который является локализованным отображаемым именем для показа пользователям). Как обычно, замените имена файлов `contoso_demo...` именами, соответствующими вашему проекту и (**очень важно**) убедитесь, что файл `.pfx` не находится в текущем каталоге (в противном случае он был бы создан как часть пакета, включая закрытый ключ подписи!):

    ```CMD
    signtool sign /fd SHA256 /a /f ..\contoso_demo_key.pfx ..\contoso_demo.appx
    ```

    Вы можете ввести `signtool sign /?`, чтобы узнать, что делает каждый параметр, но вкратце:
      * `/fd` Задает алгоритм дайджеста файл (SHA256 по умолчанию для AppX)
      * `/a` будет автоматически выбирать наиболее подходящего сертификата
      * `/f` Задает входной файл, содержащий сертификат для подписи

Наконец, теперь можно дважды щелкнуть файл `.appx`, чтобы установить его. Если вы предпочитаете использовать командную строку, можно открыть командную строку PowerShell, перейти в каталог с пакетом и ввести следующую команду (заменив `contoso_demo.appx` именем вашего пакета):

```CMD
add-appxpackage contoso_demo.appx
```

При появлении ошибок с указанием, что сертификат не является доверенным, убедитесь, что он добавлен в хранилище компьютера (**не** в хранилище пользователя). Чтобы добавить сертификат в хранилище компьютера, можно использовать командную строку или проводник Windows.

Для использования командной строки выполните следующие действия.

1. Запустите командную строку Visual Studio 2017 или Visual Studio 2019 от имени администратора.
2. Перейдите в каталог, содержащий файл `.cer` (не забудьте убедиться, что он находится не в исходной папке или папке проекта!)
3. Введите следующую команду, заменив `contoso_demo.cer` именем вашего файла:
    ```CMD
    certutil -addstore TrustedPeople contoso_demo.cer
    ```
    
    Вы можете выполнить команду `certutil -addstore /?`, чтобы узнать, что делает каждый параметр, но вкратце:
      * `-addstore` Добавляет сертификат в хранилище сертификатов
      * `TrustedPeople` Указывает хранилище, в которую помещается сертификата

Чтобы использовать проводник Windows, выполните следующие действия.

1. Перейдите в папку, содержащую файл `.pfx`
2. Дважды щелкните файл `.pfx`, после чего должен открыться **мастер импорта сертификата**
3. Выберите `Local Machine` и нажмите кнопку `Next`
4. Принять запроса на повышение прав контроля учетных записей администратора, в том случае, если она находится и нажмите кнопку `Next`
5. Введите пароль для закрытого ключа, если таковой имеется и нажмите кнопку `Next`
6. Выберите `Place all certificates in the following store`
7. Нажмите кнопку `Browse` и выберите папку `Trusted People` (**не** "Доверенные издатели")
8. Нажмите кнопку `Next` и затем `Finish`

После добавления сертификата в магазин `Trusted People` попробуйте снова установить пакет.

Теперь ваше приложение должно отобразится в списке меню "Пуск" "Все приложения" с правильными сведениями из файла `.resw` / `.pri`. Если вы видите пустую строку или строку `ms-resource:...`, значит произошла ошибка. Тщательно проверьте внесенные изменения и убедитесь в их правильности. Если щелкнуть правой кнопкой мыши приложение в меню "Пуск", можно закрепить его как плитку и убедиться, что там тоже отображаются правильные сведения.

### <a name="step-13-add-more-supported-languages"></a>Шаг 1.3. Добавление более поддерживаемых языков

После внесения изменений в манифесте пакета и в процессе первоначального `resources.resw` файл был создан, добавление дополнительных языков является простой.

#### <a name="create-additional-localized-resources"></a>Создание дополнительных локализованных ресурсов

Во-первых, создайте значения дополнительных локализованных ресурсов. 

В папке `Strings` создайте дополнительные папки для каждого поддерживаемого языка, используя соответствующий код BCP-47 (например, `Strings\de-DE`). В каждой из этих папок создайте файл `resources.resw` (с помощью редактора XML или конструктора Visual Studio), который содержит переведенные значения ресурсов. Предполагается, что у вас уже где-то есть доступные локализованные строки и нужно просто скопировать их в файл `.resw`. В этом документе не рассматривается сам этап перевода. 

Например, файл `Strings\de-DE\resources.resw` может выглядеть следующим образом, с <span style="background-color: yellow">выделенным текстом</span>, измененным с `en-US`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<root>
  <data name="ApplicationDescription">
    <value>Contoso Demo app with localized resources (German)</value>
  </data>
  <data name="ApplicationDisplayName">
    <value>Contoso Demo Sample (German)</value>
  </data>
  <data name="PackageDisplayName">
    <value>Contoso Demo Package (German)</value>
  </data>
  <data name="PublisherDisplayName">
    <value>Contoso Samples, DE</value>
  </data>
  <data name="TileShortName">
    <value>Contoso (DE)</value>
  </data>
</root>
```

В следующих шагах предполагается, что вы добавили ресурсы для `de-DE` и `fr-FR`, но тот же шаблон можно использовать для любого языка.

#### <a name="update-the-package-manifest-to-list-supported-languages"></a>Обновить манифест пакета для поддерживаемых языков

Манифест пакета необходимо обновить список, языки, поддерживаемые приложением. Desktop App Converter добавляет язык по умолчанию, но другие языки должны быть добавлены явным образом. При редактировании файла `AppxManifest.xml` напрямую обновите узел `Resources` следующим образом, добавляя необходимое количество элементов и заменяя <span style="background-color: yellow">соответствующие языки, которые вы поддерживаете</span>, и убедитесь, что первый элемент в списке — это язык по умолчанию (резервный). В этом примере значение по умолчанию — английский (США) с дополнительной поддержкой немецкого (Германия) и французского (Франция):

```xml
<Resources>
  <Resource Language="EN-US" />
  <Resource Language="DE-DE" />
  <Resource Language="FR-FR" />
</Resources>
```

Если вы используете Visual Studio, не требуется выполнять никаких действий. Если вы взглянете на `Package.appxmanifest`, вы увидите специальное значение <span style="background-color: yellow">x-generate</span>, которое заставляет процесс построения вставить языки, найденные в проекте (основываясь на папках, названных по имени кодов BCP-47). Обратите внимание, что это не является допустимым значением для реальных манифеста; он работает только для проектов Visual Studio:

```xml
<Resources>
  <Resource Language="x-generate" />
</Resources>
```

#### <a name="re-build-with-the-localized-values"></a>Повторная сборка с локализованными значениями

Теперь вы можете собрать и развернуть приложение снова, и, если вы измените ваш выбор языка в Windows, вы должны увидеть вновь локализованные значения, отображающиеся в меню "Пуск" (ниже приведены инструкции о том, как изменить язык).

Для Visual Studio снова можно просто использовать `Ctrl+Shift+B` для сборки и щелкнуть правой кнопкой мыши проект, чтобы `Deploy` (Развернуть).

Если вы создаете проект вручную, выполните те же действия, что описаны выше, но добавьте дополнительные языки, разделенные символом подчеркивания, в список квалификаторов по умолчанию (`/dq`) при создании файла конфигурации. Например, для поддержки ресурсов английского, немецкого и французского языков, добавленных на предыдущем этапе:

```CMD
makepri createconfig /cf ..\contoso_demo.xml /dq en-US_de-DE_fr-FR /pv 10.0 /o
```

Это действие приведет к созданию PRI-файла, содержащего все указанные языки, который легко можно использовать для тестирования. Если общий размер ресурсов мал или вы поддерживаете только небольшое количество языков, это может быть допустимо для приложения доставки. Дополнительные действия по созданию отдельных языковых пакетов необходимо выполнить, только если вам нужны преимущества минимизации размера установки и скачивания для ресурсов.

#### <a name="test-with-the-localized-values"></a>Тестирование с локализованными значениями

Для проверки новых локализованных изменений просто добавьте новый предпочтительный язык пользовательского интерфейса в Windows. Нет необходимости загружать языковые пакеты, перезагружать систему или давать команду всему пользовательскому интерфейсу Windows отобразиться на иностранном языке. 

1. Запустите приложение `Settings` (`Windows + I`)
2. Перейти к `Time & language`
3. Перейти к `Region & language`
4. Нажмите кнопку `Add a language`
5. Введите (или выберите) нужный язык (например, `Deutsch` или `German`)
 * Если имеются вложенные языки, выберите нужный вариант (например, `Deutsch / Deutschland`)
6. Выберите новый язык в списке языков
7. Нажмите кнопку `Set as default`

Теперь откройте меню "Пуск" и найдите свое приложение. Вы должны увидеть локализованные значения для выбранного языка (другие приложения также могут отображаться локализованными). Если вы не видите локализованное имя уже сейчас, подождите несколько минут до обновления кэша меню "Пуск". Чтобы вернуться к своему родному языку, просто сделайте его языком по умолчанию в списке языков. 

### <a name="step-14-localizing-more-parts-of-the-package-manifest-optional"></a>Шаг 1.4. Локализация большему количеству частей элемента манифеста пакета (необязательно)

Другие разделы манифеста пакета могут быть локализованы. Например, если приложение обрабатывает расширения файлов, оно должно иметь расширение `windows.fileTypeAssociation` в манифесте, используя <span style="background-color: lightgreen">выделенный зеленым текст</span> в точности так, как показано (так как он будет ссылаться на ресурсы) и заменяя <span style="background-color: yellow">выделенный желтым цветом текст</span> информацией, относящейся к вашему приложению:

```xml
<Extensions>
  <uap:Extension Category="windows.fileTypeAssociation">
    <uap:FileTypeAssociation Name="default">
      <uap:DisplayName>ms-resource:Resources/FileTypeDisplayName</uap:DisplayName>
      <uap:Logo>Assets\StoreLogo.png</uap:Logo>
      <uap:InfoTip>ms-resource:Resources/FileTypeInfoTip</uap:InfoTip>
      <uap:SupportedFileTypes>
        <uap:FileType ContentType="application/x-contoso">.contoso</uap:FileType>
      </uap:SupportedFileTypes>
    </uap:FileTypeAssociation>
  </uap:Extension>
</Extensions>
```

Вы также можете добавить эти сведения с помощью конструктора манифестов Visual Studio на вкладке `Declarations`, обращая внимание на <span style="background-color: lightgreen">выделенные значения</span>:

<p><img src="images\editing-declarations-info.png"/></p>

Теперь добавьте соответствующие имена ресурсов для каждого вашего файла `.resw`, заменяя <span style="background-color: yellow">выделенный текст</span> соответствующим текстом для вашего приложения (помните, что это необходимо сделать для *каждого поддерживаемого языка!*):

```xml
... existing content...
<data name="FileTypeDisplayName">
  <value>Contoso Demo File</value>
</data>
<data name="FileTypeInfoTip">
  <value>Files used by Contoso Demo App</value>
</data>
```

Это затем отобразится в таких частях оболочки Windows, как проводник:

<p><img src="images\file-type-tool-tip.png"/></p>

Соберите и протестируйте пакет, как и раньше, выполняя все новые сценарии, в которых должны отображаться новые строки пользовательского интерфейса.

## <a name="phase-2-use-mrt-to-identify-and-locate-resources"></a>Этап 2. Использование MRT для определения и поиска ресурсов

В предыдущем разделе показано, как использовать MRT для локализации файла манифеста вашего приложения, чтобы оболочка Windows могла правильно отображать имя приложения и другие метаданные. Никаких изменений кода для этого не потребовалось. Просто потребовалось использовать файлы `.resw` и некоторые дополнительные средства. В этом разделе будет показано, как использовать MRT для поиска ресурсов в существующих форматах ресурсов и как использовать существующий код обработки ресурсов с минимальными изменениями.

### <a name="assumptions-about-existing-file-layout--application-code"></a>Допущения о существующем макете файла и коде приложения

Так как существует множество способов локализации классических приложений Win32, в данном документе будут сделаны некоторые упрощающие допущения о структуре существующего приложения, которые необходимо сопоставить с вашей конкретной средой. Возможно, вам понадобится внести изменения в существующую базу кода или макет ресурсов, чтобы соответствовать требованиям MRT, а они в основном выходят за рамки данного документа.

#### <a name="resource-file-layout"></a>Макет файлов ресурсов

В этой статье предполагается, что ваши локализованные ресурсы имеют же имена файлов (например, `contoso_demo.exe.mui` или `contoso_strings.dll` или `contoso.strings.xml`), но, что они размещены в разных папках с именами BCP-47 (`en-US`, `de-DE`и т. д.). Он не имеет значения, сколько файлов ресурсов, у вас есть, каковы их имена, какие их-форматы файлов / связанные интерфейсы API, и т. д. Единственное, что действительно важно, является то, что каждый *логических* ресурсов имеет то же имя (но размещен в другом *физических* directory). 

В качестве контрпримера: если приложение использует плоскую структуру файлов с одним каталогом `Resources`, содержащим файлы `english_strings.dll` и `french_strings.dll`, он не будет правильно сопоставляться с MRT. Лучшей структурой был бы каталог `Resources` с подкаталогами и файлами `en\strings.dll` и `fr\strings.dll`. Можно также использовать такое же имя основного файла, но со встроенными квалификаторами, например `strings.lang-en.dll` и `strings.lang-fr.dll`, но использование каталогов с кодами языков концептуально проще, поэтому мы рассматриваем его подробно.

>[!NOTE]
> По-прежнему можно использовать MRT и преимущества упаковки, даже если не удается выполнить этот файл именования; она лишь требует больше работы.

Например, приложение может иметь набор команд пользовательского интерфейса (используемых для меток кнопок и др.) в простом текстовом файле с именем <span style="background-color: yellow">ui.txt</span>, размещенном в папке <span style="background-color: yellow">UICommands</span>:

<blockquote>
<pre>
+ ProjectRoot
|--+ Strings
|  |--+ en-US
|  |  \--- resources.resw
|  \--+ de-DE
|     \--- resources.resw
|--+ <span style="background-color: yellow">UICommands</span>
|  |--+ en-US
|  |  \--- <span style="background-color: yellow">ui.txt</span>
|  \--+ de-DE
|     \--- <span style="background-color: yellow">ui.txt</span>
|--- AppxManifest.xml
|--- ...rest of project...
</pre>
</blockquote>

#### <a name="resource-loading-code"></a>Код для загрузки ресурсов

В этой статье предполагается, что в определенный момент в коде, что вы хотите найти файл, содержащий локализованный ресурс, загрузить ее и затем использовать его. API, используемые для загрузки ресурсов, API, используемые для извлечения ресурсов, и т.д. не важны. Псевдокод состоит их трех основных этапов:

<blockquote>
<pre>
set userLanguage = GetUsersPreferredLanguage()
set resourceFile = FindResourceFileForLanguage(MY_RESOURCE_NAME, userLanguage)
set resource = LoadResource(resourceFile) 
    
// now use 'resource' however you want
</pre>
</blockquote>

MRT требует изменить только первые два этапа в этом процессе: определение наилучшего ресурса-кандидата и способа его поиска. Вам не требуется менять способ загрузки и использования этих ресурсов (хотя MRT предоставляет средства для этого, если вы хотите воспользоваться их преимуществами).

Например, приложение может использовать API Win32 `GetUserPreferredUILanguages`, функцию CRT `sprintf` и API Win32 `CreateFile` для замены трех вышеперечисленных функций псевдокода, а затем провести анализ текстового файла вручную, выполняя поиск пар `name=value`. (Детали не важны; информация приводится всего лишь, чтобы показать, что MRT не влияет на методы, используемые для обработки ресурсов, как только они будут найдены).

### <a name="step-21-code-changes-to-use-mrt-to-locate-files"></a>Шаг 2.1. Изменения кода, чтобы использовать MRT для нахождения файлов

Переключение кода на использования MRT для поиска ресурсов не составляет труда. Для этого требуется использовать ряд типов WinRT и несколько строк кода. Ниже приведены основные типы, которые будут использоваться:

* [ResourceContext](https://docs.microsoft.com/en-us/uwp/api/Windows.ApplicationModel.Resources.Core.ResourceContext), который инкапсулирует активный в данное время набор значений квалификатора (язык, коэффициент масштабирования и т. д.)
* [ResourceManager](https://docs.microsoft.com/en-us/uwp/api/windows.applicationmodel.resources.core.resourcemanager) (версия WinRT, а не версия .NET), который предоставляет доступ ко всем ресурсам из PRI-файла
* [ResourceMap](https://docs.microsoft.com/en-us/uwp/api/windows.applicationmodel.resources.core.resourcemap), который представляет конкретное подмножество ресурсов в PRI-файле (в этом примере файловые ресурсы в сравнении со строковыми ресурсами)
* [NamedResource](https://docs.microsoft.com/en-us/uwp/api/Windows.ApplicationModel.Resources.Core.NamedResource), представляющий логический ресурс и все его возможные кандидаты
* [ResourceCandidate](https://docs.microsoft.com/en-us/uwp/api/windows.applicationmodel.resources.core.resourcecandidate), представляющий одного конкретного ресурса-кандидата 

В псевдокоде способ, которым вы разрешаете данное имя файла ресурсов (например, `UICommands\ui.txt` в примере выше), выглядит следующим образом:

<blockquote>
<pre>
// Get the ResourceContext that applies to this app
set resourceContext = ResourceContext.GetForViewIndependentUse()
    
// Get the current ResourceManager (there's one per app)
set resourceManager = ResourceManager.Current
    
// Get the "Files" ResourceMap from the ResourceManager
set fileResources = resourceManager.MainResourceMap.GetSubtree("Files")
    
// Find the NamedResource with the logical filename we're looking for,
// by indexing into the ResourceMap
set desiredResource = fileResources["UICommands\ui.txt"]
    
// Get the ResourceCandidate that best matches our ResourceContext
set bestCandidate = desiredResource.Resolve(resourceContext)
   
// Get the string value (the filename) from the ResourceCandidate
set absoluteFileName = bestCandidate.ValueAsString
</blockquote>
</pre>

Обратите особое внимание, что код **не** запрашивает папку конкретного языка, например `UICommands\en-US\ui.txt`, хотя это то, как файлы существуют на диске. Вместо этого он запрашивает *логическое* имя файла `UICommands\ui.txt` и использует MRT, чтобы найти соответствующий файл на диске в одном из каталогов языка.

С этого момента образец приложения может продолжать использовать `CreateFile` для загрузки `absoluteFileName` и анализа пар `name=value` так же как и раньше. Ни одну эту логику не нужно менять в приложении. Если вы пишете на языках C# или C++/CX, фактический код не намного сложнее, чем этот (и на самом деле, большинство промежуточных переменных можно редактировать). См. в раздел, описывающий **загрузку ресурсов .NET** ниже. Приложения на основе C++/WRL будет сложнее перенести из-за низкоуровневых API на основе модели COM, используемых для активации и вызова API WinRT, но основные необходимые действия будут те же. См. раздел **Загрузка ресурсов MUI Win32** ниже.

#### <a name="loading-net-resources"></a>Загрузка ресурсов .NET

Поскольку .NET имеет встроенный механизм для обнаружения и загрузки ресурсов (известный как "Вспомогательные сборки"), нет явного кода для замены как в приведенном выше синтетическом примере. В .NET необходима только библиотека DLL ресурсов в соответствующих папках и они будут автоматически находиться для вас. При приложение входит в состав MSIX или AppX, использование пакетов ресурсов, структура каталогов немного отличаются — вместо наличие ресурсов каталогов быть вложенных каталогах каталога основного приложения, они являются одноранговыми его (или отсутствует, во всех, если пользователь не возникли язык, перечисленные в свои предпочтения). 

Например, представим приложение .NET со следующим макетом, в котором все файлы существуют в папке `MainApp`:

<blockquote>
<pre>
+ MainApp
|--+ en-us
|  \--- MainApp.resources.dll
|--+ de-de
|  \--- MainApp.resources.dll
|--+ fr-fr
|  \--- MainApp.resources.dll
\--- MainApp.exe
</pre>
</blockquote>

После преобразования в AppX макет будет выглядеть примерно следующим образом при условии, что `en-US` был выбран языком по умолчанию, и пользователь также добавил в список языков немецкий и французский:

<blockquote>
<pre>
+ WindowsAppsRoot
|--+ MainApp_neutral
|  |--+ en-us
|  |  \--- <span style="background-color: yellow">MainApp.resources.dll</span>
|  \--- MainApp.exe
|--+ MainApp_neutral_resources.language_de
|  \--+ de-de
|     \--- <span style="background-color: yellow">MainApp.resources.dll</span>
\--+ MainApp_neutral_resources.language_fr
   \--+ fr-fr
      \--- <span style="background-color: yellow">MainApp.resources.dll</span>
</pre>
</blockquote>

Поскольку локализованные ресурсы больше не существуют во вложенных каталогах в расположении установки основного исполняемого файла, происходит сбой разрешения встроенных ресурсов .NET. К счастью, .NET имеет четкий механизм для обработки неудачных попыток загрузки сборки — событие `AssemblyResolve`. Приложение .NET, использующее MRT, должно зарегистрироваться для получения этого события и предоставить отсутствующую сборку для подсистемы ресурсов .NET. 

Краткий пример того, как использовать API WinRT для обнаружения вспомогательных сборок, используемых .NET, выглядит как описано ниже. Код в представленном виде намеренно сжат, чтобы показать минимальную реализацию, хотя вы видите, что он почти соответствует псевдокоду выше с переданными `ResolveEventArgs`, предоставляющими имя сборки, которую необходимо найти. Готовую к запуску версию этого кода (с подробными комментариями и обработкой ошибок) можно найти в файле `PriResourceRsolver.cs` в [образце на GitHub **Средство определения сборок .NET**](https://aka.ms/fvgqt4).

```csharp
static class PriResourceResolver
{
  internal static Assembly ResolveResourceDll(object sender, ResolveEventArgs args)
  {
    var fullAssemblyName = new AssemblyName(args.Name);
    var fileName = string.Format(@"{0}.dll", fullAssemblyName.Name);

    var resourceContext = ResourceContext.GetForViewIndependentUse();
    resourceContext.Languages = new[] { fullAssemblyName.CultureName };

    var resource = ResourceManager.Current.MainResourceMap.GetSubtree("Files")[fileName];

    // Note use of 'UnsafeLoadFrom' - this is required for apps installed with AppX, but
    // in general is discouraged. The full sample provides a safer wrapper of this method
    return Assembly.UnsafeLoadFrom(resource.Resolve(resourceContext).ValueAsString);
  }
}
```

С учетом описанного выше класса вам необходимо добавить следующий фрагмент ранее в коде запуска приложения (до того, как понадобится загрузить какой-либо локализованный ресурс):

```csharp
void EnableMrtResourceLookup()
{
  AppDomain.CurrentDomain.AssemblyResolve += PriResourceResolver.ResolveResourceDll;
}
```

Среда выполнения .NET будет вызывать событие `AssemblyResolve` всякий раз, когда не удается найти библиотеки DLL ресурсов. В этот момент обработчик событий обнаружит нужный файл через MRT и вернет сборку.

> [!NOTE]
> Если приложение уже имеет `AssemblyResolve` обработчик для других целей, нужно будет интегрировать код разрешение ресурсов с существующим кодом.

#### <a name="loading-win32-mui-resources"></a>Загрузка ресурсов MUI Win32

Загрузка ресурсов MUI Win32 очень похожа на загрузку вспомогательных сборок .NET, но вместо них используется код C++/CX или C++/WRL. Использование C++/CX позволяет использовать более простой код, который очень похож на описанный выше код C#, но он использует расширения языка C++, переключатели компилятора и дополнительные затраты среды выполнения, чего вы, возможно, захотите избежать. Если это так, использование C++/WRL предоставляет решение, которое оказывает меньшее влияние за счет более подробного кода. Однако если вы знакомы с программированием ATL (или COM в целом), WRL должен показаться вам знакомым. 

В следующем примере функции показано использование C++/WRL для загрузки конкретной библиотеки DLL ресурсов и возврата `HINSTANCE`, который можно использовать для дальнейшей загрузки ресурсов с помощью обычных API ресурсов Win32. Обратите внимание, что в отличие от примера C#, который явно инициализирует `ResourceContext` с языком, запрошенным средой выполнения .NET, этот код использует текущий язык пользователя.

```cpp
#include <roapi.h>
#include <wrl\client.h>
#include <wrl\wrappers\corewrappers.h>
#include <Windows.ApplicationModel.resources.core.h>
#include <Windows.Foundation.h>
   
#define IF_FAIL_RETURN(hr) if (FAILED((hr))) return hr;
    
HRESULT GetMrtResourceHandle(LPCWSTR resourceFilePath,  HINSTANCE* resourceHandle)
{
  using namespace Microsoft::WRL;
  using namespace Microsoft::WRL::Wrappers;
  using namespace ABI::Windows::ApplicationModel::Resources::Core;
  using namespace ABI::Windows::Foundation;
    
  *resourceHandle = nullptr;
  HRESULT hr{ S_OK };
  RoInitializeWrapper roInit{ RO_INIT_SINGLETHREADED };
  IF_FAIL_RETURN(roInit);
    
  // Get Windows.ApplicationModel.Resources.Core.ResourceManager statics
  ComPtr<IResourceManagerStatics> resourceManagerStatics;
  IF_FAIL_RETURN(GetActivationFactory(
    HStringReference(
    RuntimeClass_Windows_ApplicationModel_Resources_Core_ResourceManager).Get(),
    &resourceManagerStatics));
    
  // Get .Current property
  ComPtr<IResourceManager> resourceManager;
  IF_FAIL_RETURN(resourceManagerStatics->get_Current(&resourceManager));
    
  // get .MainResourceMap property
  ComPtr<IResourceMap> resourceMap;
  IF_FAIL_RETURN(resourceManager->get_MainResourceMap(&resourceMap));
    
  // Call .GetValue with supplied filename
  ComPtr<IResourceCandidate> resourceCandidate;
  IF_FAIL_RETURN(resourceMap->GetValue(HStringReference(resourceFilePath).Get(),
    &resourceCandidate));
    
  // Get .ValueAsString property
  HString resolvedResourceFilePath;
  IF_FAIL_RETURN(resourceCandidate->get_ValueAsString(
    resolvedResourceFilePath.GetAddressOf()));
    
  // Finally, load the DLL and return the hInst.
  *resourceHandle = LoadLibraryEx(resolvedResourceFilePath.GetRawBuffer(nullptr),
    nullptr, LOAD_LIBRARY_AS_DATAFILE | LOAD_LIBRARY_AS_IMAGE_RESOURCE);
    
  return S_OK;
}
```

## <a name="phase-3-building-resource-packs"></a>Этап 3. Создание ресурса пакетов

Теперь, когда у вас есть "полный пакет", содержащий все ресурсы, существует два пути для создания отдельного основного пакета и пакетов ресурсов, чтобы свести к минимуму размеры загрузки и установки:

* Возьмите существующий полный пакет и запустите его через [средство создания пакетов](https://aka.ms/bundlegen), чтобы автоматически создать пакеты ресурсов. Это предпочтительный подход, если вы используете систему сборки, которая уже создает полный пакет, и хотите выполнить его постобработку для создания пакетов ресурсов.
* Напрямую создайте отдельные пакеты ресурсов и соберите их в пакет. Это предпочтительный подход, если у вас больше контроля над системой сборки и вы можете напрямую создавать пакеты.

### <a name="step-31-creating-the-bundle"></a>Шаг 3.1. Cоздание пакета

#### <a name="using-the-bundle-generator-tool"></a>Использование средства создания пакетов

Чтобы использовать средство создания пакетов, необходимо вручную обновить PRI-файл конфигурации, созданный для пакета, чтобы удалить раздел `<packaging>`.

Если вы используете Visual Studio, см. [убедитесь, что установка ресурсов в устройстве независимо от потребности устройства](https://docs.microsoft.com/en-us/previous-versions/dn482043(v=vs.140)) сведения о том, как построить все языки в главного пакета путем создания файлов `priconfig.packaging.xml`и `priconfig.default.xml`.

При редактировании файлов вручную выполните следующие действия. 

1. Создайте файл конфигурации так же, как и раньше, подставляя правильный путь, имя файла и языки:

    ```CMD
    makepri createconfig /cf ..\contoso_demo.xml /dq en-US_de-DE_es-MX /pv 10.0 /o
    ```

2. Вручную откройте созданный файл `.xml` и удалите весь раздел `&lt;packaging&rt;` (но сохраните все остальное без изменений):

    ```xml
    <?xml version="1.0" encoding="UTF-8" standalone="yes" ?> 
    <resources targetOsVersion="10.0.0" majorVersion="1">
      <!-- Packaging section has been deleted... -->
      <index root="\" startIndexAt="\">
        <default>
        ...
        ...
    ```

3. Создайте пакет из фалов `.pri` и `.appx`, как и прежде, используя обновленный файл конфигурации и соответствующие имена каталогов и файлов (дополнительные сведения об этих командах см. выше):

    ```CMD
    makepri new /pr . /cf ..\contoso_demo.xml /of ..\resources.pri /mf AppX /o
    makeappx pack /m AppXManifest.xml /f ..\resources.map.txt /p ..\contoso_demo.appx /o
    ```

4. После создания пакета, используйте следующую команду для создания пакета, используя соответствующие имена каталогов и файлов:

    ```CMD
    BundleGenerator.exe -Package ..\contoso_demo.appx -Destination ..\bundle -BundleName contoso_demo
    ```

Теперь можно переместить к последнему этапу подписи (см. ниже).

#### <a name="manually-creating-resource-packages"></a>Создание пакетов ресурсов вручную

Для создания пакетов ресурсов вручную требуется выполнить немного другой набор команд для создания отдельных файлов `.pri` и `.appx`. Все они аналогичны командам, используемым выше для создания полных пакетов, поэтому дается минимальное описание. Примечание. Все команды предполагается, что текущий каталог — это каталог содержащий `AppXManifest.xml` файл, но все файлы помещаются в родительский каталог (можно использовать другой каталог, при необходимости, но вы не должны засоряет каталог проекта с любой из Эти файлы). Как всегда, замените имена файлов "Contoso" собственными именами файлов.

1. Используйте следующую команду, чтобы создать файл конфигурации, который называет **только** язык по умолчанию в качестве квалификатора по умолчанию, в этом случае – `en-US`:

    ```CMD
    makepri createconfig /cf ..\contoso_demo.xml /dq en-US /pv 10.0 /o
    ```

2. Создайте файлы `.pri` и `.map.txt` по умолчанию для основного пакета, а также дополнительный набор файлов для каждого языка в проекте с помощью следующей команды:

    ```CMD
    makepri new /pr . /cf ..\contoso_demo.xml /of ..\resources.pri /mf AppX /o
    ```

3. Используйте следующую команду для создания основного пакета (содержащего исполняемый код и ресурсы языка по умолчанию). Как всегда, измените имя по своему усмотрению, хотя пакет следует поместить в отдельный каталог, чтобы облегчить создание пакета на более позднем этапе (в этом примере используется каталог `..\bundle`):

    ```CMD
    makeappx pack /m .\AppXManifest.xml /f ..\resources.map.txt /p ..\bundle\contoso_demo.main.appx /o
    ```

4. После создания основного пакета используйте следующую команду один раз для каждого дополнительного языка (то есть повторите эту команду для каждого файла сопоставления языка, созданного на предыдущем этапе). Помните, что выходной файл должен находиться в отдельном каталоге (том же, что и основной пакет). Обратите внимание, что язык указывается **как** в параметре `/f`, так и в параметре `/p` и используется новый аргумент `/r` (указывающий на то, что необходим пакет ресурсов):

    ```CMD
    makeappx pack /r /m .\AppXManifest.xml /f ..\resources.language-de.map.txt /p ..\bundle\contoso_demo.de.appx /o
    ```

5. Объедините все пакеты из каталога набора в единый файл `.appxbundle`. Новый параметр `/d` определяет каталог, который необходимо использовать для всех файлов в этом пакете (поэтому файлы `.appx` помещаются в отдельный каталог на предыдущем шаге):

    ```CMD
    makeappx bundle /d ..\bundle /p ..\contoso_demo.appxbundle /o
    ```

Последним шагом создания пакета подписи.

### <a name="step-32-signing-the-bundle"></a>Шаг 3.2. Подписывание пакета

После создания файла `.appxbundle` (с помощью средства создания пакетов или вручную) вы получите один файл, содержащий основной пакет и все пакеты ресурсов. Последний шаг — подписать этот файл, чтобы Windows мог его установить:

```CMD
signtool sign /fd SHA256 /a /f ..\contoso_demo_key.pfx ..\contoso_demo.appxbundle
```

Это создаст подписанный файл `.appxbundle`, содержащий основной пакет и все пакеты языковых ресурсов. Его можно дважды щелкнуть так же, как файл пакета, чтобы установить приложение и любые необходимые языки на основе языковых настроек Windows пользователя.

## <a name="related-topics"></a>См. также

* [Адаптация ресурсов с учетом языка, масштаба, высокой контрастности и других квалификаторов](tailor-resources-lang-scale-contrast.md)