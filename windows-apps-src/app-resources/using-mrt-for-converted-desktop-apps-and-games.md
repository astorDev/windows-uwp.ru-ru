---
title: Использование MRT для преобразованных классических приложений и игр
description: Упаковав свое приложение или игру .NET или Win32 в виде пакета AppX, можно использовать Систему управления ресурсами для загрузки ресурсов приложения, адаптированных к контексту во время выполнения. В этой статье подробно рассматриваются соответствующие методы.
ms.date: 10/25/2017
ms.topic: article
keywords: windows 10, uwp, mrt, pri. ресурсы, игры, centennial, desktop app converter, mui, вспомогательная сборка
ms.localizationpriority: medium
ms.openlocfilehash: 77cf9444e06920da0eae3ae430fe78c9f5a188ad
ms.sourcegitcommit: 350d6e6ba36800df582f9715c8d21574a952aef1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/31/2019
ms.locfileid: "68682538"
---
# <a name="use-the-windows-10-resource-management-system-in-a-legacy-app-or-game"></a>Использование Системы управления ресурсами Windows 10 в устаревшем приложении или игре

Приложения и игры .NET и Win32 часто локализуются на разные языки, расширяя свой общий адресуемый рынок. Дополнительные сведения о преимуществах локализации приложений см. в разделе [Глобализация и локализация](../design/globalizing/globalizing-portal.md). Упаковывая приложение .NET или Win32 или игру в качестве пакета MSIX или AppX, можно использовать систему управления ресурсами для загрузки ресурсов приложения, адаптированных к контексту времени выполнения. В этой статье подробно рассматриваются соответствующие методы.

Существует множество способов локализации традиционных приложений Win32, однако Windows 8 представила новую [систему управления ресурсами](https://docs.microsoft.com/previous-versions/windows/apps/jj552947(v=win.10)), которая работает со всеми языками программирования, в различных типах приложений и предоставляет функциональные возможности, которые гораздо шире простой локализации. Эта система будет называться MRT в этой статье. В прошлом это означало Modern Resource Technology ("Современная технология ресурсов"), но от термина "Современный" решено отказаться. Диспетчер ресурсов может быть также известен как MRM (диспетчер современных ресурсов) или PRI (индекс ресурсов пакета).

В сочетании с развертыванием на основе MSIX или AppX (например, из Microsoft Store) MRT может автоматически предоставлять наиболее применимые ресурсы для конкретного пользователя или устройства, что позволяет максимально сокращать размер загружаемого приложения и его установку. Это уменьшение размера может быть очень значительным для приложений с большим объемом локализованного содержимого. Оно может достигать даже порядка несколько *ГБ* для игр высочайшего класса. Дополнительные преимущества MRT включают локализованные описания в оболочке Windows и Microsoft Store, логику автоматического перехода к запасному варианту, если выбранный пользователем язык не соответствует доступным ресурсам.

В этом документе описывается высокоуровневая архитектура MRT и предоставляется руководство по переносу, которое поможет переместить устаревшие приложения Win32 на платформу MRT с минимальными изменениями кода. После перемещения в MRT для разработчика становятся доступными дополнительные преимущества (например, возможность делить ресурсы на сегменты по коэффициенту масштабирования или системной теме). Обратите внимание, что локализация на основе MRT работает как для приложений UWP, так и для приложений Win32, обработанных мостом для классических приложений (известным как "Centennial").

Во многих случаях вы можете продолжать использовать ваши существующие форматы локализации и исходный код, так как интеграция с MRT для разрешения ресурсов во время выполнения и минимизации размеров скачивания — это подход, допускающий компромиссы. В следующей таблице перечислены трудозатраты, расчетные затраты и преимущества каждого этапа. В эту таблицу не включены задачи, не имеющие отношения к локализации, например, предоставление значков приложений с высоким разрешением или высокой контрастностью. Дополнительные сведения о предоставлении нескольких ресурсов для плиток, значков и т. п. см. в разделе [Адаптация ресурсов с учетом языка, масштаба, высокой контрастности и других квалификаторов](tailor-resources-lang-scale-contrast.md).

<table>
<tr>
<th>Work</th>
<th>Преимущество</th>
<th>Расчетные затраты</th>
</tr>
<tr>
<td>Локализация манифеста пакета</td>
<td>Требуется совсем немного усилий, чтобы ваше локализованное содержимое отобразилось в оболочке Windows и в Microsoft Store</td>
<td>Небольшой</td>
</tr>
<tr>
<td>Использование MRT для определения и поиска ресурсов</td>
<td>Предварительные требования к уменьшению размеров загрузки и установки, автоматический переход к запасному языку</td>
<td>Средний</td>
</tr>
<tr>
<td>Создание пакетов ресурсов</td>
<td>Последний шаг к минимизации размеров загрузки и установки</td>
<td>Небольшой</td>
</tr>
<tr>
<td>Переход к форматам и интерфейсам API ресурсов MRT</td>
<td>Значительно меньшие размеры файлов (в зависимости от существующей технологии ресурсов)</td>
<td>Большой</td>
</tr>
</table>

## <a name="introduction"></a>Введение

Большинство нестандартных приложений содержат элементы пользовательского интерфейса, известные как *ресурсы*, которые не связаны с кодом приложения (в отличие от *жестко заданных значений*, которые создаются в самом коде источника). Существует несколько причин выбрать ресурсы вместо жестко заданных значений (например, простота редактирования не разработчиками), но одна из ключевых причин — дать возможность приложению выбирать различные представления одного и того же логического ресурса во время выполнения. Например, текст, отображаемый на кнопке (или изображение, отображаемое на значке) может отличаться в зависимости от языков, которые пользователь понимает, характеристик устройства отображения или наличия у пользователя каких-либо включенных специальных возможностей.

Таким образом, основной целью любой технологии управления ресурсами является преобразование во время выполнения запроса логического или символьного *имени ресурса* (например, `SAVE_BUTTON_LABEL`) в лучшее возможное актуальное *значение* (например, "Сохранить") из набора возможных *кандидатов* (например, "Save", "Speichern" или "저장"). MRT предоставляет такую функцию и позволяет приложениям определять кандидатов ресурсов с помощью различных атрибутов (называемых *квалификаторами*), например языка пользователя, коэффициента масштабирования монитора, выбранной пользователем темы и других факторов окружающей среды. MRT поддерживает даже пользовательские квалификаторы для приложений, которые в них нуждаются (например, приложение может предоставлять различные графические ресурсы для пользователей, которые вошли с помощью учетной записи, и для гостей без явного добавления этой проверки в каждую часть приложения). MRT работает со строковыми ресурсами и с ресурсами на основе файлов, где ресурсы на основе файлов реализованы как ссылки на внешние данные (сами файлы).

### <a name="example"></a>Пример

Вот простой пример приложения, которое содержит текстовые метки на двух кнопках (`openButton` и `saveButton`) и PNG-файл, используемый для логотипа (`logoImage`). Текстовые метки локализованы на английском и немецком языках, а логотип оптимизирован для обычных мониторов настольных компьютеров (коэффициент масштабирования 100%) и телефонов с высоким разрешением (коэффициент масштабирования 300%). Обратите внимание, что на этой схеме представлено высокоуровневое концептуальное представление модели; оно не совпадает в точности с реализацией.

<p><img src="images\conceptual-resource-model.png"/></p>

На рисунке код приложения ссылается на три имени логических ресурсов. Во время выполнения виртуальная функция `GetResource` использует MRT для поиска имен этих ресурсов в таблице ресурсов (также называется PRI-файл) и находит наиболее подходящего кандидата на основе условий окружающей среды (язык пользователя и коэффициент масштабирования монитора). В случае наличия этих меток строки используются напрямую. В случае использования изображения логотипа строки интерпретируются как имена файлов, и файлы читаются с диска. 

Если пользователь говорит о языке, отличном от английского или немецкого, или имеет масштабный коэффициент дисплея, отличный от 100% или 300%, то средство MRT выбирает "ближайший" соответствующий кандидат на основе набора правил резервирования (Дополнительные сведения см. в разделе об [управлении ресурсами](https://docs.microsoft.com/previous-versions/windows/apps/jj552947(v=win.10)) ).

Обратите внимание, что MRT поддерживает ресурсы, предназначенные для нескольких квалификаторов. Например, если изображение логотипа содержит внедренный текст, который также должен быть локализован, Эмблема будет иметь четыре кандидата: EN/Scale-100, DE/Scale-100, ru/Scale-300 и DE/Scale-300.

### <a name="sections-in-this-document"></a>Разделы данного документа

В следующих разделах описываются высокоуровневые задачи, которые необходимо выполнить для интеграции MRT с вашим приложением.

#### <a name="phase-0-build-an-application-package"></a>Этап 0: Создание пакета приложения

В этом разделе описываются способы получения сборки существующего классического приложения в виде пакета приложения. На этом этапе никакие функции MRT не используются.

#### <a name="phase-1-localize-the-application-manifest"></a>Этап 1. Локализация манифеста приложения

В этом разделе описывается локализация манифеста приложения (чтобы он правильно отображался в оболочке Windows). На этом этапе по-прежнему используется устаревший формат ресурсов и устаревшие API для упаковки и поиска ресурсов. 

#### <a name="phase-2-use-mrt-to-identify-and-locate-resources"></a>Этап 2. Использование MRT для определения и поиска ресурсов

В этом разделе описывается процедура изменения вашего кода приложения (и, возможно, макет ресурсов) для поиска ресурсов с помощью MRT. На этом этапе по-прежнему используются существующие форматы ресурсов и интерфейсы API для загрузки и использования ресурсов. 

#### <a name="phase-3-build-resource-packs"></a>Этап 3. Создание пакетов ресурсов

В этом разделе описываются окончательные изменения, необходимые для разделения ресурсов на отдельные *пакеты ресурсов*, минимизирующие размер загрузки (и установки) приложения.

### <a name="not-covered-in-this-document"></a>В этом документе не рассматривается

После завершения этапов 0-3 выше вы получите приложение "пакет", которое можно отправить в Microsoft Store, и это позволит максимально сокращать размер загружаемых и устанавливаемых пользователей, пропуская ненужные ресурсы (например, языки, которые они не говорят). Дополнительные улучшения в размере приложения и функциональности можно сделать, выполнив один последний этап.

#### <a name="phase-4-migrate-to-mrt-resource-formats-and-apis"></a>Этап 4. Переход к форматам и интерфейсам API ресурсов MRT

Этот этап выходит за рамки данного документа. Он включает в себя перемещение ресурсов (в частности, строк) из таких устаревших форматов, как библиотеки DLL MUI или сборки ресурсов .NET в PRI-файлы. Это может привести к дальнейшей экономии места для размеров скачивания и установки. Это действие также позволяет использовать другие функции MRT, например минимизацию загрузки и установки файлов изображений на основе коэффициента масштабирования, параметров специальных возможностей и т. д.

## <a name="phase-0-build-an-application-package"></a>Этап 0: Создание пакета приложения

Прежде чем вносить изменения в ресурсы приложения, необходимо сначала заменить текущую технологию упаковки и установки на стандартную технологию упаковки и развертывания UWP. Это можно сделать тремя способами.

* При наличии большого настольного приложения с помощью сложного установщика или большого количества точек расширения ОС можно использовать средство преобразования классических приложений, чтобы создать структуру файлов UWP и сведения о манифесте из существующего установщика приложения (например, MSI).
* При наличии меньшего рабочего стола с относительно небольшими файлами или простым установщиком без обработчиков расширяемости можно создать структуру файлов и сведения о манифесте вручную.
* Если вы перестраиваете из источника и хотите обновить приложение до чистого приложения UWP, можно создать новый проект в Visual Studio и использовать интегрированную среду разработки для выполнения большей части работы.

Если вы хотите использовать преобразователь для [классических приложений](https://aka.ms/converter), см. Дополнительные сведения о процессе преобразования в разделе Упаковка приложения для настольных [приложений с помощью конвертера](https://aka.ms/converterdocs) для настольных приложений. Полный набор примеров конвертера для настольных систем можно найти в репозитории на сайте [Samples Bridge](https://github.com/Microsoft/DesktopBridgeToUWP-Samples).

Если вы хотите вручную создать пакет, необходимо создать структуру каталогов, включающую все файлы приложения (исполняемые объекты и содержимое, но не исходный код) и файл манифеста пакета (. appxmanifest). Пример можно найти в [примере Hello, World GitHub](https://github.com/Microsoft/DesktopBridgeToUWP-Samples/blob/master/Samples/HelloWorldSample/CentennialPackage/AppxManifest.xml), но базовый файл манифеста пакета, который запускает исполняемый объект `ContosoDemo.exe` рабочего стола, выглядит следующим образом, где выделенный <span style="background-color: yellow">текст</span> будет заменен собственными значениями.

```xml
<?xml version="1.0" encoding="utf-8" ?>
<Package xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
         xmlns:mp="http://schemas.microsoft.com/appx/2014/phone/manifest"
         xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"
         xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities"
         IgnorableNamespaces="uap mp rescap">
    <Identity Name="Contoso.Demo"
              Publisher="CN=Contoso.Demo"
              Version="1.0.0.0" />
    <Properties>
    <DisplayName>Contoso App</DisplayName>
    <PublisherDisplayName>Contoso, Inc</PublisherDisplayName>
    <Logo>Assets\StoreLogo.png</Logo>
  </Properties>
    <Dependencies>
    <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.14393.0" 
                        MaxVersionTested="10.0.14393.0" />
  </Dependencies>
    <Resources>
    <Resource Language="en-US" />
  </Resources>
    <Applications>
    <Application Id="ContosoDemo" Executable="ContosoDemo.exe" 
                 EntryPoint="Windows.FullTrustApplication">
    <uap:VisualElements DisplayName="Contoso Demo" BackgroundColor="#777777" 
                        Square150x150Logo="Assets\Square150x150Logo.png" 
                        Square44x44Logo="Assets\Square44x44Logo.png" 
        Description="Contoso Demo">
      </uap:VisualElements>
    </Application>
  </Applications>
    <Capabilities>
    <rescap:Capability Name="runFullTrust" />
  </Capabilities>
</Package>
```

Дополнительные сведения о файле манифеста пакета и разметке пакета см. в разделе [манифест пакета приложения](https://docs.microsoft.com/en-us/uwp/schemas/appxpackage/appx-package-manifest).

Наконец, если вы используете Visual Studio для создания нового проекта и переноса существующего кода в, см. статью [Создание приложения "Hello, World"](https://docs.microsoft.com/windows/uwp/get-started/create-a-hello-world-app-xaml-universal). Существующий код можно включить в новый проект, но, скорее всего, потребуется внести значительные изменения в код (особенно в пользовательском интерфейсе), чтобы работать как чистое приложение UWP. Эти изменения выходят за рамки данного документа.

## <a name="phase-1-localize-the-manifest"></a>Этап 1. Локализация манифеста

### <a name="step-11-update-strings--assets-in-the-manifest"></a>Шаг 1,1. Обновление строк & ресурсов в манифесте

На этапе 0 вы создали базовый файл манифеста пакета (. appxmanifest) для своего приложения (на основе значений, предоставленных преобразователю, извлеченных из MSI-файла или вручную введенных в манифест), но он не будет содержать локализованную информацию и не будет поддерживать Дополнительные функции, такие как начальные активы с высоким разрешением и т. д.

Чтобы правильно локализовать имя и описание приложения, необходимо определить некоторые ресурсы в наборе файлов ресурсов и обновить манифест пакета, чтобы они ссылались на них.

#### <a name="creating-a-default-resource-file"></a>Создание файла ресурсов по умолчанию

Первый этап — это создание файла ресурсов по умолчанию на языке по умолчанию (например, английский (США)). Это можно сделать вручную с помощью текстового редактора или с помощью конструктора ресурсов в Visual Studio.

Если вы хотите создать ресурсы вручную, выполните следующие действия.

1. Создайте XML-файл с именем `resources.resw` и разместите его во вложенной папке проекта `Strings\en-us`. Используйте соответствующий код BCP-47, если ваш язык по умолчанию не является английским языком США.
2. В XML-файл добавьте следующее содержимое, где <span style="background-color: yellow">выделенный текст</span> необходимо заменить соответствующим текстом для вашего приложения на языке по умолчанию.

> [!NOTE]
> Существуют ограничения по длине некоторых из этих строк. Дополнительные сведения см. в разделе [VisualElements](/uwp/schemas/appxpackage/appxmanifestschema/element-visualelements).

```xml
<?xml version="1.0" encoding="utf-8"?>
<root>
  <data name="ApplicationDescription">
    <value>Contoso Demo app with localized resources (English)</value>
  </data>
  <data name="ApplicationDisplayName">
    <value>Contoso Demo Sample (English)</value>
  </data>
  <data name="PackageDisplayName">
    <value>Contoso Demo Package (English)</value>
  </data>
  <data name="PublisherDisplayName">
    <value>Contoso Samples, USA</value>
  </data>
  <data name="TileShortName">
    <value>Contoso (EN)</value>
  </data>
</root>
```

Если вы хотите использовать конструктор в Visual Studio, выполните следующие действия.

1. Создайте в проекте `resources.resw` папку(илидругойязык)идобавьтеновыйэлементвкорневуюпапкупроекта,`Strings\en-us` используя имя по умолчанию. Не забудьте выбрать **файл ресурсов (. resw)** , а не **словарь ресурсов** . словарь ресурсов — это файл, используемый приложениями XAML.
2. С помощью конструктора введите следующие строки (используйте те же `Names`, но замените `Values` соответствующим текстом для вашего приложения):

<img src="images\editing-resources-resw.png"/>

> [!NOTE]
> Если начать с конструктора Visual Studio, вы всегда можете изменить XML непосредственно, нажав клавишу `F7`. Но если вы начали работу с минимальным XML-файлом, *конструктор не сможет распознать файл* из-за отсутствия множества дополнительных метаданных. Это можно исправить путем копирования шаблонных сведений XSD из файла, созданного конструктором, в XML-файл, отредактированный вручную.

#### <a name="update-the-manifest-to-reference-the-resources"></a>Обновление манифеста для ссылки на ресурсы

После определения значений в `.resw` файле следующим шагом является обновление манифеста для ссылки на строки ресурсов. При желании вы можете изменить XML-файл напрямую или доверить это конструктору манифестов Visual Studio.

Если вы напрямую редактируете XML-файл, откройте файл `AppxManifest.xml` и внесите следующие изменения в <span style="background-color: lightgreen">выделенные значения</span>. Используйте этот *точный* текст, а не текст, относящийся к приложению. Не требуется использовать именно эти имена ресурсов &mdash; вы можете выбрать собственные имена, &mdash; но выбранные вами имена должны точно совпадать с именами, содержащимися в файле `.resw`. Эти имена должны соответствовать `Names`, которые вы создали в файле `.resw`, с добавленной в префиксе схемой `ms-resource:` и пространством имен `Resources/`. 

> [!NOTE]
> Многие элементы манифеста были опущены из этого фрагмента — не удаляйте ничего.

```xml
<?xml version="1.0" encoding="utf-8"?>
<Package>
  <Properties>
    <DisplayName>ms-resource:Resources/PackageDisplayName</DisplayName>
    <PublisherDisplayName>ms-resource:Resources/PublisherDisplayName</PublisherDisplayName>
  </Properties>
  <Applications>
    <Application>
      <uap:VisualElements DisplayName="ms-resource:Resources/ApplicationDisplayName"
        Description="ms-resource:Resources/ApplicationDescription">
        <uap:DefaultTile ShortName="ms-resource:Resources/TileShortName">
          <uap:ShowNameOnTiles>
            <uap:ShowOn Tile="square150x150Logo" />
          </uap:ShowNameOnTiles>
        </uap:DefaultTile>
      </uap:VisualElements>
    </Application>
  </Applications>
</Package>
```

Если вы используете конструктор манифестов Visual Studio, откройте файл appxmanifest и измените значения <span style="background-color: lightgreen">выделенных значений</span> на вкладках **приложение* и *Упаковка* :

<img src="images\editing-application-info.png"/>
<img src="images\editing-packaging-info.png"/>

### <a name="step-12-build-pri-file-make-an-msix-package-and-verify-its-working"></a>Шаг 1,2. Создание PRI файла, создание пакета MSIX и проверка его работоспособности

Теперь вы должны иметь возможность создать файл `.pri` и развернуть приложение, чтобы убедиться, что в меню "Пуск" отображаются правильные сведения (на языке по умолчанию).

Если вы работаете в Visual Studio, просто нажмите сочетание клавиш `Ctrl+Shift+B` для сборки проекта, а затем щелкните проект правой кнопкой мыши и выберите `Deploy` в контекстном меню.

Если вы собираетесь вручную, выполните следующие действия, чтобы создать файл конфигурации для `MakePRI` средства и `.pri` создать сам файл (Дополнительные сведения можно найти в разделе [Упаковка приложений вручную](/windows/msix/package/manual-packaging-root)):

1. Откройте командную строку разработчика из папки **Visual studio 2017** или **Visual Studio 2019** в меню "Пуск".
2. Перейдите в корневой каталог проекта (содержащий appxmanifest-файл и папку **Strings** ).
3. Введите следующую команду, заменив "contoso_demo.xml" именем, соответствующим вашему проекту, и "en-US" на язык по умолчанию для вашего приложения (или оставьте его en-US, если необходимо). Примечание. XML-файл создается в родительском каталоге (а**не** в каталоге проекта), так как он не является частью приложения (вы можете выбрать любой другой каталог, но обязательно замените его в последующих командах).

    ```CMD
    makepri createconfig /cf ..\contoso_demo.xml /dq en-US /pv 10.0 /o
    ```

    Вы можете ввести `makepri createconfig /?`, чтобы узнать, что делает каждый параметр, но в целом:
      * `/cf`Задает имя файла конфигурации (результат выполнения команды).
      * `/dq`Задает квалификаторы по умолчанию, в данном случае язык`en-US`
      * `/pv`Задает версию платформы, в данном случае Windows 10
      * `/o`Задает перезапись выходного файла, если он существует

4. Теперь у вас есть файл конфигурации. Запустите `MakePRI` еще раз, чтобы фактически выполнить поиск ресурсов на диске и упаковать их в PRI-файл. Замените "contoso_demop.xml" на имя XML-файла, который вы использовали на предыдущем шаге, и не забудьте указать родительский каталог для входного и выходного файла: 

    ```CMD
    makepri new /pr . /cf ..\contoso_demo.xml /of ..\resources.pri /mf AppX /o
    ```

    Вы можете ввести `makepri new /?`, чтобы узнать, что делает каждый параметр, но вкратце:
      * `/pr`задает корневую папку проекта (в данном случае текущий каталог)
      * `/cf`Задает имя файла конфигурации, созданное на предыдущем шаге.
      * `/of`Задает выходной файл 
      * `/mf`создает файл сопоставления (поэтому мы можем исключить файлы пакета на более позднем этапе).
      * `/o`Задает перезапись выходного файла, если он существует

5. Теперь у вас есть файл `.pri` с языковыми ресурсами по умолчанию (например, en-US). Чтобы убедиться, что он работает правильно, можно выполнить следующую команду:

    ```CMD
    makepri dump /if ..\resources.pri /of ..\resources /o
    ```

    Вы можете ввести `makepri dump /?`, чтобы узнать, что делает каждый параметр, но вкратце:
      * `/if`Задает имя входного файла. 
      * `/of`Задает имя выходного файла`.xml` (будет автоматически добавляться)
      * `/o`Задает перезапись выходного файла, если он существует

6. Наконец, вы можете открыть `..\resources.xml` в текстовом редакторе и убедиться, что в нем перечислены ваши значения `<NamedResource>` (например, `ApplicationDescription` и `PublisherDisplayName`) вместе со значениями `<Candidate>` для выбранного языка по умолчанию (в начале файла будет другое содержимое; игнорируйте это на данный момент).

Можно открыть файл `..\resources.map.txt` сопоставления, чтобы убедиться, что он содержит файлы, необходимые для проекта (включая PRI-файл, который не является частью каталога проекта). Важно, что файл сопоставления *не* будет содержать ссылку на ваш файл `resources.resw`, так как содержимое этого файла уже было встроено в PRI-файл. Тем не менее, здесь содержатся другие ресурсы, такие как имена файлов изображений.

#### <a name="building-and-signing-the-package"></a>Создание и подписывание пакета 

После создания PRI-файла можно создать и подписать пакет:

1. Чтобы создать пакет приложения, выполните следующую команду, заменив `contoso_demo.appx` именем файла MSIX/appx, который требуется создать, и выберите другой каталог для файла (в этом примере используется родительский каталог). он может находиться в любом месте, но должен  **не** быть каталогом проекта).

    ```CMD
    makeappx pack /m AppXManifest.xml /f ..\resources.map.txt /p ..\contoso_demo.appx /o
    ```

    Вы можете ввести `makeappx pack /?`, чтобы узнать, что делает каждый параметр, но вкратце:
      * `/m`Задает используемый файл манифеста
      * `/f`Задает используемый файл сопоставления (созданный на предыдущем шаге). 
      * `/p`Задает имя выходного пакета.
      * `/o`Задает перезапись выходного файла, если он существует

2. После создания пакета он должен быть подписан. Самый простой способ получить сертификат подписи — создать пустой универсальный проект Windows в Visual Studio и скопировать `.pfx` созданный файл, но можно создать его вручную `MakeCert` с помощью служебных программ и `Pvk2Pfx` , как описано в разделе. [ Создание сертификата для подписи пакета приложения](https://docs.microsoft.com/windows/desktop/appxpkg/how-to-create-a-package-signing-certificate).

    > [!IMPORTANT]
    > Если вы вручную создадите сертификат для подписи, убедитесь, что файлы помещаются в каталог, отличный от каталога исходного проекта или источника пакета, в противном случае он может быть включен в состав пакета, включая закрытый ключ!

3. Чтобы подписать пакет, используйте следующую команду. Обратите внимание, что `Publisher`, указанный в элементе `Identity``AppxManifest.xml` должен соответствовать `Subject` сертификата (это **не** элемент `<PublisherDisplayName>`, который является локализованным отображаемым именем для показа пользователям). Как обычно, замените имена файлов `contoso_demo...` именами, соответствующими вашему проекту и (**очень важно**) убедитесь, что файл `.pfx` не находится в текущем каталоге (в противном случае он был бы создан как часть пакета, включая закрытый ключ подписи!):

    ```CMD
    signtool sign /fd SHA256 /a /f ..\contoso_demo_key.pfx ..\contoso_demo.appx
    ```

    Вы можете ввести `signtool sign /?`, чтобы узнать, что делает каждый параметр, но вкратце:
      * `/fd`Задает алгоритм дайджеста файла (SHA256 используется по умолчанию для AppX)
      * `/a`будет автоматически выбирать лучший сертификат
      * `/f`Указывает входной файл, содержащий сертификат подписи

Наконец, теперь можно дважды щелкнуть файл `.appx`, чтобы установить его. Если вы предпочитаете использовать командную строку, можно открыть командную строку PowerShell, перейти в каталог с пакетом и ввести следующую команду (заменив `contoso_demo.appx` именем вашего пакета):

```CMD
add-appxpackage contoso_demo.appx
```

При появлении ошибок с указанием, что сертификат не является доверенным, убедитесь, что он добавлен в хранилище компьютера (**не** в хранилище пользователя). Чтобы добавить сертификат в хранилище компьютера, можно использовать командную строку или проводник Windows.

Для использования командной строки выполните следующие действия.

1. Запустите командную строку Visual Studio 2017 или Visual Studio 2019 с правами администратора.
2. Перейдите в каталог, содержащий файл `.cer` (не забудьте убедиться, что он находится не в исходной папке или папке проекта!)
3. Введите следующую команду, заменив `contoso_demo.cer` именем вашего файла:
    ```CMD
    certutil -addstore TrustedPeople contoso_demo.cer
    ```
    
    Вы можете выполнить команду `certutil -addstore /?`, чтобы узнать, что делает каждый параметр, но вкратце:
      * `-addstore`Добавляет сертификат в хранилище сертификатов
      * `TrustedPeople`Указывает магазин, в который помещается сертификат

Чтобы использовать проводник Windows, выполните следующие действия.

1. Перейдите в папку, содержащую файл `.pfx`
2. Дважды щелкните файл `.pfx`, после чего должен открыться **мастер импорта сертификата**
3. Выберите `Local Machine` и щелкните`Next`
4. Примите запрос на повышение прав администратора контроля учетных записей, если он отображается, и нажмите кнопку`Next`
5. Введите пароль для закрытого ключа, если он есть, и нажмите кнопку`Next`
6. Метьте`Place all certificates in the following store`
7. Нажмите кнопку `Browse` и выберите папку `Trusted People` (**не** "Доверенные издатели")
8. Щелкните `Next` , а затем`Finish`

После добавления сертификата в магазин `Trusted People` попробуйте снова установить пакет.

Теперь ваше приложение должно отобразится в списке меню "Пуск" "Все приложения" с правильными сведениями из файла `.resw` / `.pri`. Если вы видите пустую строку или строку `ms-resource:...`, значит произошла ошибка. Тщательно проверьте внесенные изменения и убедитесь в их правильности. Если щелкнуть правой кнопкой мыши приложение в меню "Пуск", можно закрепить его как плитку и убедиться, что там тоже отображаются правильные сведения.

### <a name="step-13-add-more-supported-languages"></a>Шаг 1,3. Добавить дополнительные Поддерживаемые языки

После внесения изменений в манифест пакета и создания исходного `resources.resw` файла Добавление дополнительных языков становится непростой задачей.

#### <a name="create-additional-localized-resources"></a>Создание дополнительных локализованных ресурсов

Во-первых, создайте значения дополнительных локализованных ресурсов. 

В папке `Strings` создайте дополнительные папки для каждого поддерживаемого языка, используя соответствующий код BCP-47 (например, `Strings\de-DE`). В каждой из этих папок создайте файл `resources.resw` (с помощью редактора XML или конструктора Visual Studio), который содержит переведенные значения ресурсов. Предполагается, что у вас уже где-то есть доступные локализованные строки и нужно просто скопировать их в файл `.resw`. В этом документе не рассматривается сам этап перевода. 

Например, файл `Strings\de-DE\resources.resw` может выглядеть следующим образом, с <span style="background-color: yellow">выделенным текстом</span>, измененным с `en-US`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<root>
  <data name="ApplicationDescription">
    <value>Contoso Demo app with localized resources (German)</value>
  </data>
  <data name="ApplicationDisplayName">
    <value>Contoso Demo Sample (German)</value>
  </data>
  <data name="PackageDisplayName">
    <value>Contoso Demo Package (German)</value>
  </data>
  <data name="PublisherDisplayName">
    <value>Contoso Samples, DE</value>
  </data>
  <data name="TileShortName">
    <value>Contoso (DE)</value>
  </data>
</root>
```

В следующих шагах предполагается, что вы добавили ресурсы для `de-DE` и `fr-FR`, но тот же шаблон можно использовать для любого языка.

#### <a name="update-the-package-manifest-to-list-supported-languages"></a>Обновление манифеста пакета для перечисления поддерживаемых языков

Манифест пакета необходимо обновить, чтобы получить список языков, поддерживаемых приложением. Desktop App Converter добавляет язык по умолчанию, но другие языки должны быть добавлены явным образом. При редактировании файла `AppxManifest.xml` напрямую обновите узел `Resources` следующим образом, добавляя необходимое количество элементов и заменяя <span style="background-color: yellow">соответствующие языки, которые вы поддерживаете</span>, и убедитесь, что первый элемент в списке — это язык по умолчанию (резервный). В этом примере значение по умолчанию — английский (США) с дополнительной поддержкой немецкого (Германия) и французского (Франция):

```xml
<Resources>
  <Resource Language="EN-US" />
  <Resource Language="DE-DE" />
  <Resource Language="FR-FR" />
</Resources>
```

Если вы используете Visual Studio, не требуется выполнять никаких действий. Если вы взглянете на `Package.appxmanifest`, вы увидите специальное значение <span style="background-color: yellow">x-generate</span>, которое заставляет процесс построения вставить языки, найденные в проекте (основываясь на папках, названных по имени кодов BCP-47). Обратите внимание, что это недопустимое значение для действительного манифеста пакета; Он работает только для проектов Visual Studio:

```xml
<Resources>
  <Resource Language="x-generate" />
</Resources>
```

#### <a name="re-build-with-the-localized-values"></a>Повторная сборка с локализованными значениями

Теперь вы можете собрать и развернуть приложение снова, и, если вы измените ваш выбор языка в Windows, вы должны увидеть вновь локализованные значения, отображающиеся в меню "Пуск" (ниже приведены инструкции о том, как изменить язык).

Для Visual Studio снова можно просто использовать `Ctrl+Shift+B` для сборки и щелкнуть правой кнопкой мыши проект, чтобы `Deploy` (Развернуть).

Если вы создаете проект вручную, выполните те же действия, что описаны выше, но добавьте дополнительные языки, разделенные символом подчеркивания, в список квалификаторов по умолчанию (`/dq`) при создании файла конфигурации. Например, для поддержки ресурсов английского, немецкого и французского языков, добавленных на предыдущем этапе:

```CMD
makepri createconfig /cf ..\contoso_demo.xml /dq en-US_de-DE_fr-FR /pv 10.0 /o
```

Это действие приведет к созданию PRI-файла, содержащего все указанные языки, который легко можно использовать для тестирования. Если общий размер ресурсов мал или вы поддерживаете только небольшое количество языков, это может быть допустимо для приложения доставки. Дополнительные действия по созданию отдельных языковых пакетов необходимо выполнить, только если вам нужны преимущества минимизации размера установки и скачивания для ресурсов.

#### <a name="test-with-the-localized-values"></a>Тестирование с локализованными значениями

Для проверки новых локализованных изменений просто добавьте новый предпочтительный язык пользовательского интерфейса в Windows. Нет необходимости загружать языковые пакеты, перезагружать систему или давать команду всему пользовательскому интерфейсу Windows отобразиться на иностранном языке. 

1. Запустите приложение `Settings` (`Windows + I`)
2. Перейти к`Time & language`
3. Перейти к`Region & language`
4. Откройте`Add a language`
5. Введите (или выберите) нужный язык (например, `Deutsch` или `German`)
 * Если имеются вложенные языки, выберите нужный вариант (например, `Deutsch / Deutschland`)
6. Выберите новый язык в списке языков
7. Откройте`Set as default`

Теперь откройте меню "Пуск" и найдите свое приложение. Вы должны увидеть локализованные значения для выбранного языка (другие приложения также могут отображаться локализованными). Если вы не видите локализованное имя уже сейчас, подождите несколько минут до обновления кэша меню "Пуск". Чтобы вернуться к своему родному языку, просто сделайте его языком по умолчанию в списке языков. 

### <a name="step-14-localizing-more-parts-of-the-package-manifest-optional"></a>Шаг 1,4. Локализация дополнительных частей манифеста пакета (необязательно)

Другие разделы манифеста пакета можно локализовать. Например, если приложение обрабатывает расширения файлов, оно должно иметь расширение `windows.fileTypeAssociation` в манифесте, используя <span style="background-color: lightgreen">выделенный зеленым текст</span> в точности так, как показано (так как он будет ссылаться на ресурсы) и заменяя <span style="background-color: yellow">выделенный желтым цветом текст</span> информацией, относящейся к вашему приложению:

```xml
<Extensions>
  <uap:Extension Category="windows.fileTypeAssociation">
    <uap:FileTypeAssociation Name="default">
      <uap:DisplayName>ms-resource:Resources/FileTypeDisplayName</uap:DisplayName>
      <uap:Logo>Assets\StoreLogo.png</uap:Logo>
      <uap:InfoTip>ms-resource:Resources/FileTypeInfoTip</uap:InfoTip>
      <uap:SupportedFileTypes>
        <uap:FileType ContentType="application/x-contoso">.contoso</uap:FileType>
      </uap:SupportedFileTypes>
    </uap:FileTypeAssociation>
  </uap:Extension>
</Extensions>
```

Вы также можете добавить эти сведения с помощью конструктора манифестов Visual Studio на вкладке `Declarations`, обращая внимание на <span style="background-color: lightgreen">выделенные значения</span>:

<p><img src="images\editing-declarations-info.png"/></p>

Теперь добавьте соответствующие имена ресурсов для каждого вашего файла `.resw`, заменяя <span style="background-color: yellow">выделенный текст</span> соответствующим текстом для вашего приложения (помните, что это необходимо сделать для *каждого поддерживаемого языка!* ):

```xml
... existing content...
<data name="FileTypeDisplayName">
  <value>Contoso Demo File</value>
</data>
<data name="FileTypeInfoTip">
  <value>Files used by Contoso Demo App</value>
</data>
```

Это затем отобразится в таких частях оболочки Windows, как проводник:

<p><img src="images\file-type-tool-tip.png"/></p>

Соберите и протестируйте пакет, как и раньше, выполняя все новые сценарии, в которых должны отображаться новые строки пользовательского интерфейса.

## <a name="phase-2-use-mrt-to-identify-and-locate-resources"></a>Этап 2. Использование MRT для определения и поиска ресурсов

В предыдущем разделе показано, как использовать MRT для локализации файла манифеста вашего приложения, чтобы оболочка Windows могла правильно отображать имя приложения и другие метаданные. Никаких изменений кода для этого не потребовалось. Просто потребовалось использовать файлы `.resw` и некоторые дополнительные средства. В этом разделе будет показано, как использовать MRT для поиска ресурсов в существующих форматах ресурсов и как использовать существующий код обработки ресурсов с минимальными изменениями.

### <a name="assumptions-about-existing-file-layout--application-code"></a>Допущения о существующем макете файла и коде приложения

Так как существует множество способов локализации классических приложений Win32, в данном документе будут сделаны некоторые упрощающие допущения о структуре существующего приложения, которые необходимо сопоставить с вашей конкретной средой. Возможно, вам понадобится внести изменения в существующую базу кода или макет ресурсов, чтобы соответствовать требованиям MRT, а они в основном выходят за рамки данного документа.

#### <a name="resource-file-layout"></a>Макет файлов ресурсов

В этой статье предполагается, что все локализованные ресурсы имеют одинаковые имена файлов `contoso_demo.exe.mui` ( `contoso_strings.dll` например `contoso.strings.xml`, или), но они помещаются в разные папки с именами bcp-`en-US`47 `de-DE`(, и т. д.). Не имеет значения, сколько файлов ресурсов имеется, какие именно их имена, какие форматы файлов и связанные с ними интерфейсы API и т. д. Единственное, что важно, — это то, что каждый *логический* ресурс имеет одно и то же имя файла (но помещено в другой *физический* каталог). 

В качестве контрпримера: если приложение использует плоскую структуру файлов с одним каталогом `Resources`, содержащим файлы `english_strings.dll` и `french_strings.dll`, он не будет правильно сопоставляться с MRT. Лучшей структурой был бы каталог `Resources` с подкаталогами и файлами `en\strings.dll` и `fr\strings.dll`. Можно также использовать такое же имя основного файла, но со встроенными квалификаторами, например `strings.lang-en.dll` и `strings.lang-fr.dll`, но использование каталогов с кодами языков концептуально проще, поэтому мы рассматриваем его подробно.

>[!NOTE]
> Также можно использовать MRT и преимущества упаковки, даже если вы не можете следовать этому соглашению об именовании файлов. для этого требуется только дополнительная работа.

Например, приложение может иметь набор команд пользовательского интерфейса (используемых для меток кнопок и др.) в простом текстовом файле с именем <span style="background-color: yellow">ui.txt</span>, размещенном в папке <span style="background-color: yellow">UICommands</span>:

<blockquote>
<pre>
+ ProjectRoot
|--+ Strings
|  |--+ en-US
|  |  \--- resources.resw
|  \--+ de-DE
|     \--- resources.resw
|--+ <span style="background-color: yellow">UICommands</span>
|  |--+ en-US
|  |  \--- <span style="background-color: yellow">ui.txt</span>
|  \--+ de-DE
|     \--- <span style="background-color: yellow">ui.txt</span>
|--- AppxManifest.xml
|--- ...rest of project...
</pre>
</blockquote>

#### <a name="resource-loading-code"></a>Код для загрузки ресурсов

В этой статье предполагается, что в каком-то месте кода нужно указать файл, содержащий локализованный ресурс, загрузить его, а затем использовать. API, используемые для загрузки ресурсов, API, используемые для извлечения ресурсов, и т.д. не важны. Псевдокод состоит их трех основных этапов:

<blockquote>
<pre>
set userLanguage = GetUsersPreferredLanguage()
set resourceFile = FindResourceFileForLanguage(MY_RESOURCE_NAME, userLanguage)
set resource = LoadResource(resourceFile) 
    
// now use 'resource' however you want
</pre>
</blockquote>

MRT требует изменить только первые два этапа в этом процессе: определение наилучшего ресурса-кандидата и способа его поиска. Вам не требуется менять способ загрузки и использования этих ресурсов (хотя MRT предоставляет средства для этого, если вы хотите воспользоваться их преимуществами).

Например, приложение может использовать API Win32 `GetUserPreferredUILanguages`, функцию CRT `sprintf` и API Win32 `CreateFile` для замены трех вышеперечисленных функций псевдокода, а затем провести анализ текстового файла вручную, выполняя поиск пар `name=value`. (Детали не важны; информация приводится всего лишь, чтобы показать, что MRT не влияет на методы, используемые для обработки ресурсов, как только они будут найдены).

### <a name="step-21-code-changes-to-use-mrt-to-locate-files"></a>Шаг 2,1. Изменения кода для использования MRT для выявления файлов

Переключение кода на использования MRT для поиска ресурсов не составляет труда. Для этого требуется использовать ряд типов WinRT и несколько строк кода. Ниже приведены основные типы, которые будут использоваться:

* [ResourceContext](https://docs.microsoft.com/en-us/uwp/api/Windows.ApplicationModel.Resources.Core.ResourceContext), который инкапсулирует активный в данное время набор значений квалификатора (язык, коэффициент масштабирования и т. д.)
* [ResourceManager](https://docs.microsoft.com/en-us/uwp/api/windows.applicationmodel.resources.core.resourcemanager) (версия WinRT, а не версия .NET), который предоставляет доступ ко всем ресурсам из PRI-файла
* [ResourceMap](https://docs.microsoft.com/en-us/uwp/api/windows.applicationmodel.resources.core.resourcemap), который представляет конкретное подмножество ресурсов в PRI-файле (в этом примере файловые ресурсы в сравнении со строковыми ресурсами)
* [NamedResource](https://docs.microsoft.com/en-us/uwp/api/Windows.ApplicationModel.Resources.Core.NamedResource), представляющий логический ресурс и все его возможные кандидаты
* [ResourceCandidate](https://docs.microsoft.com/en-us/uwp/api/windows.applicationmodel.resources.core.resourcecandidate), представляющий одного конкретного ресурса-кандидата 

В псевдокоде способ, которым вы разрешаете данное имя файла ресурсов (например, `UICommands\ui.txt` в примере выше), выглядит следующим образом:

<blockquote>
<pre>
// Get the ResourceContext that applies to this app
set resourceContext = ResourceContext.GetForViewIndependentUse()
    
// Get the current ResourceManager (there's one per app)
set resourceManager = ResourceManager.Current
    
// Get the "Files" ResourceMap from the ResourceManager
set fileResources = resourceManager.MainResourceMap.GetSubtree("Files")
    
// Find the NamedResource with the logical filename we're looking for,
// by indexing into the ResourceMap
set desiredResource = fileResources["UICommands\ui.txt"]
    
// Get the ResourceCandidate that best matches our ResourceContext
set bestCandidate = desiredResource.Resolve(resourceContext)
   
// Get the string value (the filename) from the ResourceCandidate
set absoluteFileName = bestCandidate.ValueAsString
</blockquote>
</pre>

Обратите особое внимание, что код **не** запрашивает папку конкретного языка, например `UICommands\en-US\ui.txt`, хотя это то, как файлы существуют на диске. Вместо этого он запрашивает *логическое* имя файла `UICommands\ui.txt` и использует MRT, чтобы найти соответствующий файл на диске в одном из каталогов языка.

С этого момента образец приложения может продолжать использовать `CreateFile` для загрузки `absoluteFileName` и анализа пар `name=value` так же как и раньше. Ни одну эту логику не нужно менять в приложении. Если вы пишете на языках C# или C++/CX, фактический код не намного сложнее, чем этот (и на самом деле, большинство промежуточных переменных можно редактировать). См. в раздел, описывающий **загрузку ресурсов .NET** ниже. Приложения на основе C++/WRL будет сложнее перенести из-за низкоуровневых API на основе модели COM, используемых для активации и вызова API WinRT, но основные необходимые действия будут те же. См. раздел **Загрузка ресурсов MUI Win32** ниже.

#### <a name="loading-net-resources"></a>Загрузка ресурсов .NET

Поскольку .NET имеет встроенный механизм для обнаружения и загрузки ресурсов (известный как "Вспомогательные сборки"), нет явного кода для замены как в приведенном выше синтетическом примере. В .NET необходима только библиотека DLL ресурсов в соответствующих папках и они будут автоматически находиться для вас. Если приложение упаковано как MSIX или AppX с помощью пакетов ресурсов, структура каталогов немного отличается. вместо того, чтобы каталоги ресурсов были вложенными каталогами главного каталога приложения, они являются одноранговыми узлами (или не отображаются вообще, если пользователь язык не указан в параметрах. 

Например, представим приложение .NET со следующим макетом, в котором все файлы существуют в папке `MainApp`:

<blockquote>
<pre>
+ MainApp
|--+ en-us
|  \--- MainApp.resources.dll
|--+ de-de
|  \--- MainApp.resources.dll
|--+ fr-fr
|  \--- MainApp.resources.dll
\--- MainApp.exe
</pre>
</blockquote>

После преобразования в AppX макет будет выглядеть примерно следующим образом при условии, что `en-US` был выбран языком по умолчанию, и пользователь также добавил в список языков немецкий и французский:

<blockquote>
<pre>
+ WindowsAppsRoot
|--+ MainApp_neutral
|  |--+ en-us
|  |  \--- <span style="background-color: yellow">MainApp.resources.dll</span>
|  \--- MainApp.exe
|--+ MainApp_neutral_resources.language_de
|  \--+ de-de
|     \--- <span style="background-color: yellow">MainApp.resources.dll</span>
\--+ MainApp_neutral_resources.language_fr
   \--+ fr-fr
      \--- <span style="background-color: yellow">MainApp.resources.dll</span>
</pre>
</blockquote>

Поскольку локализованные ресурсы больше не существуют во вложенных каталогах в расположении установки основного исполняемого файла, происходит сбой разрешения встроенных ресурсов .NET. К счастью, .NET имеет четкий механизм для обработки неудачных попыток загрузки сборки — событие `AssemblyResolve`. Приложение .NET, использующее MRT, должно зарегистрироваться для получения этого события и предоставить отсутствующую сборку для подсистемы ресурсов .NET. 

Краткий пример того, как использовать API WinRT для обнаружения вспомогательных сборок, используемых .NET, выглядит как описано ниже. Код в представленном виде намеренно сжат, чтобы показать минимальную реализацию, хотя вы видите, что он почти соответствует псевдокоду выше с переданными `ResolveEventArgs`, предоставляющими имя сборки, которую необходимо найти. Готовую к запуску версию этого кода (с подробными комментариями и обработкой ошибок) можно найти в файле `PriResourceRsolver.cs` в [образце на GitHub **Средство определения сборок .NET**](https://aka.ms/fvgqt4).

```csharp
static class PriResourceResolver
{
  internal static Assembly ResolveResourceDll(object sender, ResolveEventArgs args)
  {
    var fullAssemblyName = new AssemblyName(args.Name);
    var fileName = string.Format(@"{0}.dll", fullAssemblyName.Name);

    var resourceContext = ResourceContext.GetForViewIndependentUse();
    resourceContext.Languages = new[] { fullAssemblyName.CultureName };

    var resource = ResourceManager.Current.MainResourceMap.GetSubtree("Files")[fileName];

    // Note use of 'UnsafeLoadFrom' - this is required for apps installed with AppX, but
    // in general is discouraged. The full sample provides a safer wrapper of this method
    return Assembly.UnsafeLoadFrom(resource.Resolve(resourceContext).ValueAsString);
  }
}
```

С учетом описанного выше класса вам необходимо добавить следующий фрагмент ранее в коде запуска приложения (до того, как понадобится загрузить какой-либо локализованный ресурс):

```csharp
void EnableMrtResourceLookup()
{
  AppDomain.CurrentDomain.AssemblyResolve += PriResourceResolver.ResolveResourceDll;
}
```

Среда выполнения .NET будет вызывать событие `AssemblyResolve` всякий раз, когда не удается найти библиотеки DLL ресурсов. В этот момент обработчик событий обнаружит нужный файл через MRT и вернет сборку.

> [!NOTE]
> Если у приложения уже есть `AssemblyResolve` обработчик для других целей, необходимо интегрировать код разрешения ресурсов с существующим кодом.

#### <a name="loading-win32-mui-resources"></a>Загрузка ресурсов MUI Win32

Загрузка ресурсов MUI Win32 очень похожа на загрузку вспомогательных сборок .NET, но вместо них используется код C++/CX или C++/WRL. Использование C++/CX позволяет использовать более простой код, который очень похож на описанный выше код C#, но он использует расширения языка C++, переключатели компилятора и дополнительные затраты среды выполнения, чего вы, возможно, захотите избежать. Если это так, использование C++/WRL предоставляет решение, которое оказывает меньшее влияние за счет более подробного кода. Однако если вы знакомы с программированием ATL (или COM в целом), WRL должен показаться вам знакомым. 

В следующем примере функции показано использование C++/WRL для загрузки конкретной библиотеки DLL ресурсов и возврата `HINSTANCE`, который можно использовать для дальнейшей загрузки ресурсов с помощью обычных API ресурсов Win32. Обратите внимание, что в отличие от примера C#, который явно инициализирует `ResourceContext` с языком, запрошенным средой выполнения .NET, этот код использует текущий язык пользователя.

```cpp
#include <roapi.h>
#include <wrl\client.h>
#include <wrl\wrappers\corewrappers.h>
#include <Windows.ApplicationModel.resources.core.h>
#include <Windows.Foundation.h>
   
#define IF_FAIL_RETURN(hr) if (FAILED((hr))) return hr;
    
HRESULT GetMrtResourceHandle(LPCWSTR resourceFilePath,  HINSTANCE* resourceHandle)
{
  using namespace Microsoft::WRL;
  using namespace Microsoft::WRL::Wrappers;
  using namespace ABI::Windows::ApplicationModel::Resources::Core;
  using namespace ABI::Windows::Foundation;
    
  *resourceHandle = nullptr;
  HRESULT hr{ S_OK };
  RoInitializeWrapper roInit{ RO_INIT_SINGLETHREADED };
  IF_FAIL_RETURN(roInit);
    
  // Get Windows.ApplicationModel.Resources.Core.ResourceManager statics
  ComPtr<IResourceManagerStatics> resourceManagerStatics;
  IF_FAIL_RETURN(GetActivationFactory(
    HStringReference(
    RuntimeClass_Windows_ApplicationModel_Resources_Core_ResourceManager).Get(),
    &resourceManagerStatics));
    
  // Get .Current property
  ComPtr<IResourceManager> resourceManager;
  IF_FAIL_RETURN(resourceManagerStatics->get_Current(&resourceManager));
    
  // get .MainResourceMap property
  ComPtr<IResourceMap> resourceMap;
  IF_FAIL_RETURN(resourceManager->get_MainResourceMap(&resourceMap));
    
  // Call .GetValue with supplied filename
  ComPtr<IResourceCandidate> resourceCandidate;
  IF_FAIL_RETURN(resourceMap->GetValue(HStringReference(resourceFilePath).Get(),
    &resourceCandidate));
    
  // Get .ValueAsString property
  HString resolvedResourceFilePath;
  IF_FAIL_RETURN(resourceCandidate->get_ValueAsString(
    resolvedResourceFilePath.GetAddressOf()));
    
  // Finally, load the DLL and return the hInst.
  *resourceHandle = LoadLibraryEx(resolvedResourceFilePath.GetRawBuffer(nullptr),
    nullptr, LOAD_LIBRARY_AS_DATAFILE | LOAD_LIBRARY_AS_IMAGE_RESOURCE);
    
  return S_OK;
}
```

## <a name="phase-3-building-resource-packs"></a>Этап 3. Создание пакетов ресурсов

Теперь, когда у вас есть "полный пакет", содержащий все ресурсы, существует два пути для создания отдельного основного пакета и пакетов ресурсов, чтобы свести к минимуму размеры загрузки и установки:

* Возьмите существующий полный пакет и запустите его через [средство создания пакетов](https://aka.ms/bundlegen), чтобы автоматически создать пакеты ресурсов. Это предпочтительный подход, если вы используете систему сборки, которая уже создает полный пакет, и хотите выполнить его постобработку для создания пакетов ресурсов.
* Напрямую создайте отдельные пакеты ресурсов и соберите их в пакет. Это предпочтительный подход, если у вас больше контроля над системой сборки и вы можете напрямую создавать пакеты.

### <a name="step-31-creating-the-bundle"></a>Шаг 3,1. Создание пакета

#### <a name="using-the-bundle-generator-tool"></a>Использование средства создания пакетов

Чтобы использовать средство создания пакетов, необходимо вручную обновить PRI-файл конфигурации, созданный для пакета, чтобы удалить раздел `<packaging>`.

Если вы используете Visual Studio, ознакомьтесь с разрядом [, чтобы убедиться, что ресурсы установлены на устройстве независимо от того, требуются ли им устройства](https://docs.microsoft.com/en-us/previous-versions/dn482043(v=vs.140)) для получения сведений о том, как создать все языки в основном пакете, `priconfig.packaging.xml` создав `priconfig.default.xml` файлы и .

При редактировании файлов вручную выполните следующие действия. 

1. Создайте файл конфигурации так же, как и раньше, подставляя правильный путь, имя файла и языки:

    ```CMD
    makepri createconfig /cf ..\contoso_demo.xml /dq en-US_de-DE_es-MX /pv 10.0 /o
    ```

2. Вручную откройте созданный файл `.xml` и удалите весь раздел `&lt;packaging&rt;` (но сохраните все остальное без изменений):

    ```xml
    <?xml version="1.0" encoding="UTF-8" standalone="yes" ?> 
    <resources targetOsVersion="10.0.0" majorVersion="1">
      <!-- Packaging section has been deleted... -->
      <index root="\" startIndexAt="\">
        <default>
        ...
        ...
    ```

3. Создайте пакет из фалов `.pri` и `.appx`, как и прежде, используя обновленный файл конфигурации и соответствующие имена каталогов и файлов (дополнительные сведения об этих командах см. выше):

    ```CMD
    makepri new /pr . /cf ..\contoso_demo.xml /of ..\resources.pri /mf AppX /o
    makeappx pack /m AppXManifest.xml /f ..\resources.map.txt /p ..\contoso_demo.appx /o
    ```

4. После создания пакета используйте следующую команду, чтобы создать пакет, используя соответствующий каталог и имена файлов:

    ```CMD
    BundleGenerator.exe -Package ..\contoso_demo.appx -Destination ..\bundle -BundleName contoso_demo
    ```

Теперь можно перейти к последнему шагу, подписывания (см. ниже).

#### <a name="manually-creating-resource-packages"></a>Создание пакетов ресурсов вручную

Для создания пакетов ресурсов вручную требуется выполнить немного другой набор команд для создания отдельных файлов `.pri` и `.appx`. Все они аналогичны командам, используемым выше для создания полных пакетов, поэтому дается минимальное описание. Примечание. Все команды предполагают, что текущий каталог — это каталог, содержащий `AppXManifest.xml` файл, но все файлы помещаются в родительский каталог (при необходимости можно использовать другой каталог), но не следует засоряла каталог проекта с любым из Эти файлы). Как всегда, замените имена файлов "Contoso" собственными именами файлов.

1. Используйте следующую команду, чтобы создать файл конфигурации, который называет **только** язык по умолчанию в качестве квалификатора по умолчанию, в этом случае – `en-US`:

    ```CMD
    makepri createconfig /cf ..\contoso_demo.xml /dq en-US /pv 10.0 /o
    ```

2. Создайте файлы `.pri` и `.map.txt` по умолчанию для основного пакета, а также дополнительный набор файлов для каждого языка в проекте с помощью следующей команды:

    ```CMD
    makepri new /pr . /cf ..\contoso_demo.xml /of ..\resources.pri /mf AppX /o
    ```

3. Используйте следующую команду для создания основного пакета (содержащего исполняемый код и ресурсы языка по умолчанию). Как всегда, измените имя по своему усмотрению, хотя пакет следует поместить в отдельный каталог, чтобы облегчить создание пакета на более позднем этапе (в этом примере используется каталог `..\bundle`):

    ```CMD
    makeappx pack /m .\AppXManifest.xml /f ..\resources.map.txt /p ..\bundle\contoso_demo.main.appx /o
    ```

4. После создания основного пакета используйте следующую команду один раз для каждого дополнительного языка (то есть повторите эту команду для каждого файла сопоставления языка, созданного на предыдущем этапе). Помните, что выходной файл должен находиться в отдельном каталоге (том же, что и основной пакет). Обратите внимание, что язык указывается **как** в параметре `/f`, так и в параметре `/p` и используется новый аргумент `/r` (указывающий на то, что необходим пакет ресурсов):

    ```CMD
    makeappx pack /r /m .\AppXManifest.xml /f ..\resources.language-de.map.txt /p ..\bundle\contoso_demo.de.appx /o
    ```

5. Объедините все пакеты из каталога набора в единый файл `.appxbundle`. Новый параметр `/d` определяет каталог, который необходимо использовать для всех файлов в этом пакете (поэтому файлы `.appx` помещаются в отдельный каталог на предыдущем шаге):

    ```CMD
    makeappx bundle /d ..\bundle /p ..\contoso_demo.appxbundle /o
    ```

Завершающим этапом создания пакета является подписывание.

### <a name="step-32-signing-the-bundle"></a>Шаг 3,2. Подписывание пакета

После создания файла `.appxbundle` (с помощью средства создания пакетов или вручную) вы получите один файл, содержащий основной пакет и все пакеты ресурсов. Последний шаг — подписать этот файл, чтобы Windows мог его установить:

```CMD
signtool sign /fd SHA256 /a /f ..\contoso_demo_key.pfx ..\contoso_demo.appxbundle
```

Это создаст подписанный файл `.appxbundle`, содержащий основной пакет и все пакеты языковых ресурсов. Его можно дважды щелкнуть так же, как файл пакета, чтобы установить приложение и любые необходимые языки на основе языковых настроек Windows пользователя.

## <a name="related-topics"></a>См. также

* [Адаптация ресурсов с учетом языка, масштаба, высокой контрастности и других квалификаторов](tailor-resources-lang-scale-contrast.md)