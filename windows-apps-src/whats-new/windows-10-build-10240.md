---
Description: В версии Windows 10, сборка 10240 и обновленных средствах разработчика мы, как и прежде, предоставляем полезные инструменты, функции и возможности на основе универсальной платформы Windows.
title: Что нового в Windows 10 (сборка 10240), июль 2015 г.
keywords: what's new, whats new, update, updates, features, new, Windows 10, 1507, 10240
ms.date: 11/02/2017
ms.topic: article
ms.assetid: 4853e55b-2232-4589-903a-ccb60e07aeb8
ms.localizationpriority: medium
ms.openlocfilehash: 986fa1b14fcb3b1ada150a232fb0d42f7eafa133
ms.sourcegitcommit: b52ddecccb9e68dbb71695af3078005a2eb78af1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/20/2019
ms.locfileid: "74258906"
---
# <a name="whats-new-in-windows10-for-developers-build-10240"></a>Что нового для разработчиков в Windows 10, сборка 10240

Сборка 10240 Windows 10 и обновленный пакет SDK предоставляют доступ к инструментам, компонентам и возможностям для создания потрясающих приложений универсальной платформы Windows. [Установив средства и пакет SDK](https://developer.microsoft.com/windows/downloads#_blank) в Windows 10, вы можете сразу приступить либо к [созданию нового проекта универсального приложения для Windows](../get-started/create-uwp-apps.md) либо к использованию [существующего кода приложения в ОС Windows](../porting/index.md).

Здесь представлен обзор новых функций в Windows 10 (сборка 10240, которая также известна как Windows 10 версии 1507).

## <a name="adaptive-layouts"></a>Адаптивные макеты

Функция | Описание
 :---- | ----:
Несколько представлений для адаптированного содержимого | XAML позволяет определять адаптированные представления (XAML-файлы), которые используют один и тот же файл кода. Это упрощает создание и поддержку различных представлений, адаптированных для определенного семейства устройств или сценария. Если ваше приложение имеет своеобразный пользовательский интерфейс, макет или модели навигации, которые существенно отличаются в зависимости от разных сценариев, создавайте несколько представлений. Например, вы можете задействовать [сводную таблицу](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Pivot) со средствами навигации, оптимизированными для работы одной рукой в приложении для мобильных устройств и [SplitView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.SplitView) с меню навигации, оптимизированном для работы мышью в классическом приложении.
Триггеры состояния | С помощью новой функции [VisualState.StateTriggers](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstate.statetriggers) можно определять свойства в зависимости от условий, таких как высота и ширина окна, а также в зависимости от пользовательского триггера. Ранее в коде было необходимо обрабатывать события окна [SizeChanged](https://docs.microsoft.com/uwp/api/windows.ui.xaml.window.sizechanged) и вызывать [VisualStateManager.GotoState](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstatemanager.gotostate).
Задающие методы | Благодаря новому синтаксису [VisualState.Setters](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstate.setters) можно использовать упрощенную разметку для определения изменений свойств в [VisualStateManager](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstatemanager). Ранее было необходимо использовать раскадровку и создавать анимации для изменения свойств, например изменения ориентации [StackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.stackpanel) с горизонтальной на вертикальную. В универсальных приложениях для Windows можно использовать упрощенный синтаксис метода задания: <setter target="stackPanel1.Orientation" value="Vertical" />


## <a name="xaml-features"></a>Возможности XAML

Функция | Описание
 :---- | :----
Скомпилированные привязки данных (x:Bind) | В универсальных приложениях для Windows можно использовать новый механизм привязки на основе компилятора, который включается свойством x:Bind. Привязки на основе компилятора являются строго типизированными и обрабатываются во время компиляции, что является более быстрым способом и позволяет выявлять ошибки во время компиляции, если типы привязки не совпадают. Так как привязки преобразуются в компилированный код приложения, теперь можно выполнять отладку привязок путем перебора кода в Visual Studio для диагностики определенных проблем, связанных с привязками. x:Bind можно также использовать для привязки к методу: <textblock text="{x:Bind Customer.Address.ToString()}" /> В типичных сценариях привязки можно использовать x:Bind вместо Binding для улучшения производительности и удобства поддержки.
Декларативная добавочная отрисовка списков (x:Phase) | В универсальных приложениях для Windows новый атрибут x:Phase позволяет выполнять добавочную или поэтапную отрисовку списков, используя XAML, а не код. При прокрутке длинных списков, содержащих сложные элементы, ваше приложение может не отрисовывать элементы достаточно быстро в соответствии со скоростью прокрутки, что ухудшает процесс взаимодействия пользователя с вашим приложением. Поэтапная отрисовка позволяет указать приоритет отрисовки отдельных элементов пункта списка, так что в сценариях быстрой прокрутки будут отрисовываться только важные части элемента списка. Это обеспечивает более плавную прокрутку при взаимодействии с пользователем. <br /><br /> В Windows 8.1 можно было обрабатывать событие [ContainerContentChanging](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.containercontentchanging) и писать код для поэтапной отрисовки элементов списка. В приложениях UWP можно декларативно выполнять поэтапную отрисовку с помощью атрибута x:Phase. При использовании вместе с компилированными привязками x:Bind атрибут x:Phase позволяет без труда определять приоритет отрисовки каждого привязанного элемента в шаблоне данных. При прокрутке отрисовка элементов разделяется по времени в зависимости от этапа, что позволяет отрисовывать элемент по частям.
Отложенная загрузка элементов пользовательского интерфейса (x:deferLoadstrategy) | В универсальных приложениях для Windows новая директива x:deferLoadstrategy позволяет откладывать загрузку определенных частей пользовательского интерфейса, что повышает производительность при запуске и сокращает объем потребляемой приложением памяти. Например, если пользовательский интерфейс вашего приложения содержит элемент для подтверждения данных, который отображается только при вводе неправильных данных, вы можете отложить его загрузку до того времени, когда он понадобится. В этом случае элементы-объекты создаются не при загрузке страницы, а только когда появляется ошибка данных и возникает необходимость добавить эти элементы в визуальное дерево страницы.
SplitView | Новый элемент управления [SplitView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.splitview) позволяет без труда показывать и скрывать промежуточное содержимое. Как правило, он используется для сценариев навигации верхнего уровня, например для "кнопки-гамбургера", где средства навигации скрыты, но при необходимости отображаются в ответ на действия пользователя.
RelativePanel | [RelativePanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.relativepanel) — это новая панель макета, которая позволяет располагать и выравнивать дочерние объекты относительно друг друга или родительской панели. Например, можно указать, что некоторый текст всегда должен располагаться с левой стороны панели, а кнопка всегда должна находиться под текстом. Используйте ReleativePanel при создании пользовательских интерфейсов, которые не имеют четкого линейного шаблона, который вызывал бы [StackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.stackpanel) или [Grid](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.grid).
CalendarView | Элемент управления [CalendarView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.calendarview) упрощает просмотр и выбор дат и их диапазонов с помощью настраиваемого представления на основе месяцев. CalendarView поддерживает такие функции, как минимальные, максимальные и закрытые даты в целях ограничения доступных для выбора дат. Вы также можете задать пользовательские шкалы плотности, которые используются для отображения общей "заполненности" расписания на определенный день.
CalendarDatePicker | [CalendarDatePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.calendardatepicker) — это раскрывающийся элемент управления, оптимизированный для выбора отдельной даты из CalendarView, когда важен контекст, например день недели или заполненность календаря. Он аналогичен элементу управления [DatePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.datepicker), однако последний оптимизирован для выбора известной даты, например дня рождения.
MediaTransportControls | Новый класс [MediaTransportControls](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediatransportcontrols) упрощает настройку элементов управления транспортировкой [MediaElement](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement). В Windows 8.1 вы можете включить встроенные элементы управления транспортировкой MediaElement или создать собственные элементы управления транспортировкой, вызывающие методы MediaElement. Теперь можно использовать встроенные функциональные возможности элементов управления MediaTransportControls и без труда настраивать внешний вид вашего приложения.
Уведомления об изменении свойств | В универсальных приложениях для Windows можно прослушивать изменения свойств в объектах DependencyObject, в том числе тех, у которых нет соответствующих событий изменения. Уведомление используется как событие, при этом фактически представляется как обратный вызов. Обратный вызов использует аргумент отправителя так же, как обработчик событий, но при этом не использует аргумент события. Вместо этого передается только идентификатор свойства для обозначения конкретного свойства. На основе этой информации ваше приложение может определить единый обработчик для нескольких уведомлений о свойствах. Дополнительные сведения см. в разделах, посвященных [RegisterPropertyChangedCallback](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dependencyobject.registerpropertychangedcallback) и [UnregisterPropertyChangedCallback](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dependencyobject.unregisterpropertychangedcallback).
Карты | Класс [MapControl](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.maps.mapcontrol) был обновлен, чтобы обеспечить трехмерное представление с воздуха и виды на уровне улиц. Эти новые функции и более ранние функции карт теперь доступны в универсальных приложениях для Windows. Добавьте карты в свое приложение с помощью следующих API: [Windows.UI.Xaml.Controls.Maps](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.maps) и [Windows.Services.Maps](https://docs.microsoft.com/uwp/api/windows.services.maps). Чтобы начать использовать эти API в универсальном приложении для Windows сегодня, запросите ключ из [Центра разработки Карт Bing](https://www.bingmapsportal.com/). Подробнее см. в разделе о [проверке подлинности приложения, использующего карты](https://docs.microsoft.com/previous-versions/windows/apps/dn741528(v=win.10)). Еще одной новинкой для пользователей Windows 10, ПК и телефонов является возможность загрузки карт для автономного использования из приложения "Параметры". При соответствующей возможности автономные карты используются элементом [MapControl](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.maps.mapcontrol) для отображения карт при отсутствии доступа к Интернету.
Сопоставление кнопки ввода | Класс [Windows.UI.Xaml.Input.KeyEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.input.keyroutedeventargs) имеет новое свойство [OriginalKey](https://docs.microsoft.com/uwp/api/windows.ui.xaml.input.keyroutedeventargs.originalkey), которое наряду с соответствующим обновлением [Windows.System.VirtualKey](https://docs.microsoft.com/uwp/api/windows.system.virtualkey) позволяет получить оригинальную несопоставленную кнопку ввода, связанную с событием ввода с клавиатуры.
Рукописный ввод | В приложениях среды выполнения Windows, использующих язык C++, C# или Visual Basic, теперь можно с удобством применять широкие возможности рукописного ввода благодаря элементу управления [InkCanvas](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.inkcanvas) и основным классам [InkPresenter](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkpresenter). Элемент управления [InkCanvas](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.inkcanvas) определяет область наложения для начертания и воспроизведения росчерков пера. Функциональные возможности этого элемента управления (ввод, обработка, воспроизведение) основаны на классах [InkPresenter](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkpresenter), [InkStroke](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkstroke), [InkRecognizers](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkrecognizer) и [InkSynchronizer](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inksynchronizer). **Важно!** Эти классы не поддерживаются в приложениях для Windows, использующих JavaScript.


## <a name="updated-xaml-features"></a>Обновленные функции XAML

Функция | Описание
 :---- | :----
Обновления CommandBar и AppBar | Элементы управления [CommandBar](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.commandbar) и [AppBar](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.appbar) были обновлены для соответствия интерфейса API, поведения и удобства использования в приложениях UWP по всем семействам устройств. <br /><br />Элемент управления CommandBar для универсальных приложений для Windows был улучшен и теперь предоставляет супермножество функциональных возможностей AppBar и большую гибкость при использовании приложения. CommandBar необходимо использовать для всех новых универсальных приложений для Windows 10. В CommandBar для Windows 8.1 можно было использовать только те элементы управления, которые реализовывали [ICommandBarElement](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.icommandbarelement), например [AppBarButton](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.appbarbutton). В универсальных приложениях для Windows теперь в CommandBar, как и в кнопки AppBarButton, можно помещать пользовательское содержимое. <br /><br />Элемент управления AppBar был обновлен, что позволяет без труда перевести ваши приложения Windows 8.1, которые используют AppBar, на платформу универсальных приложений для Windows. AppBar предназначается для использования в полноэкранных приложениях посредством вызова с помощью краевых жестов. Обновления этого элемента управления решают проблемы, связанные с оконными приложениями и отсутствием краевых жестов в Windows 10. <br /><br />Скрытый режим [AppBar.ClosedDisplayMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.appbar.closeddisplaymode), ранее присутствовавший только в Windows Phone, теперь поддерживается всеми семействами устройств, что позволяет перемещаться между различными уровнями подсказок для команд. По умолчанию AppBar отображает минимальную подсказку, обеспечивая согласованность при обновлении приложений Windows 8.1 до универсальных приложений для Windows, когда больше нет возможности использовать поддержку платформой краевых жестов.
Обновления GridView | До выхода Windows 10 ориентация макета GridView по умолчанию была горизонтальной в Windows и вертикальной в Windows Phone. В приложениях UWP GridView использует по умолчанию вертикальный макет для всех семейств устройств, что обеспечивает согласованность представления.
Свойство AreStickyGroupHeadersEnabled | При отображении сгруппированных данных в элементах управления [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) или [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview) заголовки группы отображаются при прокрутке списка. Это важно при работе с большими наборами данных, когда заголовок является контекстом для просматриваемых пользователем данных. Однако в случае наличия в каждой группе только нескольких элементов, может понадобиться убирать с экрана заголовки вместе с элементами при прокрутке. Для управления этим поведением можно задать свойство AreStickyGroupHeadersEnabled для [ItemsStackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemsstackpanel) и [ItemsWrapGrid](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemswrapgrid).
Метод GroupHeaderContainerFromItemContainer | При отображении сгруппированных данных в [ItemsControl](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemscontrol) можно вызвать метод [GroupHeaderContainerFromItemContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemscontrol.groupheadercontainerfromitemcontainer) для получения ссылки на родительский заголовок группы. Например, если пользователь удаляет последний элемент в группе, можно получить ссылку на заголовок группы и удалить элемент вместе с заголовком группы.
Событие ChoosingGroupHeaderContainer | Новое событие [ChoosingGroupHeaderContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.choosinggroupheadercontainer) в [ListViewBase](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase) позволяет определять состояние заголовков группы в элементе управления ListView или GridView. Например, это событие можно обработать для установки свойства [AutomationProperties.Name](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.automationproperties.nameproperty) для заголовка группы, чтобы представлять эту группу в специальных возможностях.
Событие ChoosingItemContainer | Новое событие [ChoosingItemContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.choosingitemcontainer) для ListViewBase предоставляет более богатые возможности управления виртуализацией пользовательского интерфейса в [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) или [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview). Используйте это событие вместе с событием [ContainerContentChanging](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.containercontentchanging) для поддержания собственной очереди повторно использованных контейнеров, которые могут использоваться по мере необходимости. Например, если источник данных был сброшен вследствие фильтрации, можно быстро сопоставить уже существующий набор визуальных элементов (контейнеры ItemContainer) с соответствующими данными, достигая тем самым оптимальной производительности.
Виртуализация прокрутки списка |В элементы управления XAML [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) и [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview) добавлено новое событие [ListViewBase.ChooseingItemContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.choosingitemcontainer), позволяющее улучшить работу элемента управления в случае изменения набора данных. Вместо полной перезагрузки списка, при которой воспроизводится анимационный эффект открытия, система теперь сохраняет текущее представление, а также состояния фокусирования и выбора, а новые и удаленные элементы плавно добавляются в окно просмотра или удаляются из него с соответствующим анимационным эффектом. После того как в наборе данных происходит изменение (но при этом контейнеры в нем сохраняются), приложение может быстро сопоставить все «старые» элементы с содержимым предыдущего контейнера и пропустить дальнейшие этапы обработки методов с перезаписью жизненного цикла контейнера. Только "новые" элементы обрабатываются и привязываются к повторно используемым или новым контейнерам.
Метод SelectRange и свойство SelectedRanges | В универсальных приложениях для Windows элементы управления [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) и [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview) теперь позволяют выбрать элементы на основе диапазона индексов элементов, а не ссылок на объекты элементов. Это более эффективный способ описания выбора элемента, так как объекты элементов не должны создаваться для каждого выбранного элемента. Дополнительные сведения см. в разделах, посвященных [ListViewBase.SelectedRanges](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.selectedranges), [ListViewBase.SelectRange](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.selectrange) и [ListViewBase.DeselectRange](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.deselectrange).
Новые интерфейсы API ListViewItemPresenter | [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) и [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview) используют заместители элементов для предоставления визуальных элементов для выбора и фокусировки по умолчанию. В приложениях UWP [ListViewItemPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.listviewitempresenter) и [GridViewItemPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.gridviewitempresenter) имеют новые свойства, которые позволяют в большей мере настраивать визуальные элементы списка. Новые свойства: CheckBoxBrush, CheckMode, FocusSecondaryBorderBrush, PointerOverForeground, PressedBackground и SelectedPressedBackground.
Обновления SemanticZoom | Элемент управления [SemanticZoom](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.semanticzoom) теперь имеет единое согласованное поведение в приложениях UWP по всем семействам устройств. Действием по умолчанию для переключения между увеличенным представлением и уменьшенным представлением является нажатие заголовка группы в увеличенном представлении. Это не отличается от поведения в Windows Phone 8.1, но отличается от поведения в Windows Phone 8.1, где необходимо было использовать жест сжатия для изменения масштаба. Чтобы увеличивать с помощью сведения пальцев, задайте значение [ScrollViewer.ZoomMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer.zoommode)="Enabled" для внутреннего объекта ScrollViewer в SemanticZoom. <br /><br />В универсальных приложениях для Windows уменьшенное представление заменяет увеличенное представление и не отличается по размерам от заменяемого представления. Это же поведение свойственно Windows 8.1, однако отличается от Windows Phone 8.1, где уменьшенное представление занимало весь экран и отрисовывалось поверх всего прочего содержимого.
Обновления DatePicker и TimePicker | Теперь элементы управления [DatePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.datepicker) и [TimePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.timepicker) реализуются согласованно для универсальных приложений Windows на всех семействах устройств. Кроме того, в Windows 10 они выглядят по-новому. Всплывающая часть теперь использует элементы управления [DatePickerFlyout](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.datepickerflyout) и [TimePickerFlyout](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.timepickerflyout) на всех устройствах. Это не отличается от поведения в Windows Phone 8.1, однако отличается от поведения в Windows 8.1, где применялись элементы управления [ComboBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.combobox). Использование всплывающих элементов управления позволяет без труда создавать настраиваемые элементы выбора даты и времени.
Новые интерфейсы API ScrollViewer | У [ScrollViewer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer) имеются новые события [DirectManipulationStarted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer.directmanipulationstarted) и [DirectManipulationCompleted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer.directmanipulationcompleted), которые используются для уведомления приложения о начале и завершении прокрутки касанием. Эти события можно обрабатывать для согласования пользовательского интерфейса с действиями пользователя.
Обновления MenuFlyout | В универсальных приложениях для Windows появились новые интерфейсы API, которые позволяют без труда создавать улучшенные контекстные меню. Новый метод [MenuFlyout.ShowAt](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.menuflyout.showat) позволяет указывать, где должен отображаться всплывающий элемент относительно другого элемента. (Элемент MenuFlyout может даже перекрывать границы окна приложения.) Используйте новый класс [MenuFlyoutSubItem](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.menuflyoutsubitem) для создания каскадных меню.
Новые свойства Border для ContentPresenter, Grid и StackPanel | Общие элементы управления контейнерами имеют новые свойства границы, которые позволяют рисовать вокруг них границу без добавления дополнительного элемента Border в XAML. [ContentPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentpresenter), [Grid](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.grid) и [StackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.stackpanel) имеют такие новые свойства: BorderBrush, BorderThickness, CornerRadius и Padding.
Новые интерфейсы API текста в ContentPresenter | [ContentPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentpresenter) имеет новые программные интерфейсы, которые позволяют лучше контролировать отображение текста: LineHeight, LineStackingStrategy, MaxLines и TextWrapping.
Визуальные элементы фокуса системы | Визуальные элементы фокуса для элементов управления XAML теперь создаются системой, а не объявляются в качестве элементов XAML в шаблоне элементов управления. Визуальные элементы фокуса, как правило, не нужны на мобильных устройствах, поэтому предоставление возможностей по их созданию и управлению ими системе повышает производительность приложений. Если вам необходим больший контроль над визуальными элементами фокуса, можно переопределить поведение системы и предоставить пользовательский шаблон элемента управления, в котором определяются визуальные элементы фокуса. Подробнее: [UseSystemFocusVisuals](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.usesystemfocusvisuals) и [IsTemplateFocusTarget](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.istemplatefocustargetproperty).
PasswordBox.PasswordRevealMode | В универсальных приложениях для Windows свойство [PasswordRevealMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.passwordbox.passwordrevealmode) заменяет свойство IsPasswordRevealButtonEnabled, обеспечивая единообразное поведение на всех семействах устройств. **Внимание!** До Windows 10 кнопка показа пароля не отображалась по умолчанию, а в универсальных приложениях для Windows эта кнопка отображается по умолчанию. Если в вашем приложении необходимо всегда скрывать пароль, установите для параметра PasswordRevealMode значение Hidden.
Control.IsTextScaleFactorEnabled | Свойство [IsTextScaleFactorEnabled](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.istextscalefactorenabledproperty), доступное в Windows Phone 8.1, теперь доступно для универсальных приложений для Windows на всех семействах устройств.
Элемент управления AutoSuggestBox | Элемент управления [AutoSuggestBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.autosuggestbox), используемый в Windows Phone 8.1, теперь доступен для универсальных приложений для Windows на всех семействах устройств, и его следует использовать вместо [SearchBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.searchbox). AutoSuggestBox отображает предложения по мере пользовательского ввода и хорошо работает с различными способами ввода, включая сенсорный ввод, ввод с клавиатуры и редакторы методов ввода. Он также имеет некоторые новые члены, которые улучшают его работу в качестве поля поиска: свойство [QueryIcon](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.autosuggestbox.queryicon) и событие [QuerySubmitted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.autosuggestbox.querysubmitted).
ContentDialog | Элемент управления [ContentDialog](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentdialog), свойственный Windows Phone 8.1, теперь доступен в универсальных приложениях для Windows на всех семействах устройств. ContentDialog позволяет отображать настраиваемое модальное диалоговое окно, которое хорошо работает на различных типах устройств.
Сводка | Элемент управления [Pivot](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.pivot), свойственный Windows Phone 8.1, теперь доступен в универсальных приложениях для Windows на всех семействах устройств. Теперь элемент управления Pivot можно использовать в приложении для мобильных и настольных устройств. Pivot обеспечивает адаптивное поведение на основе размера экрана и типа ввода. Вы можете стилизовать элемент управления Pivot под вкладку, определив различные представления данных для каждого элемента сводной таблицы.

## <a name="text"></a>Текст

Функция | Описание
 :---- | :----
Интерфейсы API основного текста в Windows | Новое пространство имен [Windows.UI.Text.Core](https://docs.microsoft.com/uwp/api/windows.ui.text.core) основано на клиент-серверной системе, которая обрабатывает данные, вводимые с клавиатуры, централизованно на одном сервере. Эту функцию можно использовать в работе с буфером редактирования пользовательского элемента управления входными текстовыми данными. Сервер входных текстовых данных обеспечивает постоянное соответствие содержимого в вашем элементе управления входными текстовыми данными и в своем буфере редактирования, используя для этого канал асинхронной передачи данных между приложением и сервером.
Значки вектора | Элемент [Glyphs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.documents.glyphs) имеет новые свойства [IsColorFontEnabled](https://docs.microsoft.com/uwp/api/windows.ui.xaml.documents.glyphs.iscolorfontenabled) и [ColorFontPalleteIndex](https://docs.microsoft.com/uwp/api/windows.ui.xaml.documents.glyphs.colorfontpaletteindex) для поддержки цветных шрифтов; теперь можно использовать файл шрифта для отрисовки значков на основе шрифтов. При использовании ColorFontPalleteIndex для переключения цветовых палитр можно отрисовывать один и тот же значок с использованием различных наборов цветов, чтобы, к примеру, отобразить включенный и выключенный значок.
События окна редактора метода ввода | Иногда пользователи вводят текст в редакторе метода ввода, который отображается в окне непосредственно под полем ввода текста (это свойственно, как правило, для восточно-азиатских языков). Можно использовать событие CandidateWindowBoundsChanged и свойство DesiredCandidateWindowAlignment для [TextBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.textbox) и [RichEditBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.richeditbox), чтобы пользовательский интерфейс приложения лучше работал в окне IME.
События композиции текста | У [TextBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.textbox) и [RichEditBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.richeditbox) теперь имеются новые события, информирующие ваше приложение о составлении текста с помощью редактора метода ввода: TextCompositionStarted TextCompositionEnded и TextCompositionChanged. Эти события можно обрабатывать для координации кода вашего приложения с процессом композиции текста IME. Например, можно реализовать встроенную функцию автозаполнения для восточно-азиатских языков.
Улучшенная обработка двунаправленного текста | Элементы управления текстом XAML имеют новый интерфейс API, который улучшает обработку двунаправленного текста, что приводит к оптимальному выравниванию текста и расположению абзацев независимо от языка ввода. Значение свойства TextReadingOrder по умолчанию было изменено на DetectFromContent, поэтому поддержка определения порядка чтения определяется по умолчанию. Свойство TextReadingOrder также было добавлено в объекты PasswordBox, RichEditBox и TextBox. Можно определить для свойства TextAlignment элементов управления текста новое значение DetectFromContent, чтобы выравнивание определялось автоматически в зависимости от содержимого.
Отрисовка текста | Теперь в Windows 10 текст в приложениях XAML отрисовывается в большинстве случаев в два раза быстрее, чем в Windows 8.1. В большинстве случаев вы ощутите преимущества этого улучшения в своих приложениях. Помимо более быстрой отрисовки, эти улучшения также снижают объем потребляемой приложениями XAML памяти на 5 %.

## <a name="application-model"></a>Модель приложения

Функция | Описание
 :---- | :----
Кортана | Расширьте основные функции Кортаны за счет голосовых команд, которые запускают и выполняют одно действие во внешнем приложении. Благодаря интеграции основных функций вашего приложения и предоставлению центральной точки входа пользователю для выполнения большинства задач без непосредственного открытия Кортаны может стать связующим звеном между вашим приложением и пользователем. Во многих случаях это может существенно сэкономить время и усилия пользователя. Сведения об [интеграции приложения в полотно Кортаны](https://docs.microsoft.com/previous-versions/windows/apps/dn974230(v=win.10)). Если вам нужны новые идеи, вы можете изучить рекомендации по проектированию и руководства UX, относящиеся непосредственно к Кортане, в разделе [основы разработки универсальных приложений для Windows](https://docs.microsoft.com/windows/uwp/design/layout/index).
Проводник | Новые методы [Windows.System.Launcher.LaunchFolderAsync](https://docs.microsoft.com/uwp/api/windows.system.launcher.launchfolderasync) позволяют запускать проводник и выводить на экран содержимое указанной папки.
Общее хранилище | Новый класс [Windows.ApplicationModel.DataTransfer.SharedStorageAccessManager](https://docs.microsoft.com/uwp/api/windows.applicationmodel.datatransfer.sharedstorageaccessmanager) и его методы позволяют открывать доступ к файлу для другого приложения путем передачи маркера общего доступа при запуске этого приложения с помощью активации универсального кода ресурса (URI). Конечное приложение активирует маркер и получает доступ к файлу из исходного приложения.
Параметры | Вы можете выводить на экран страницы со встроенными параметрами с помощью протокола ms-settings в рамках метода [LaunchUriAsync](https://docs.microsoft.com/uwp/api/windows.system.launcher.launchuriasync). Например, указанный далее код выводит страницу параметров Wi-Fi: **bool result = await Launcher.LaunchUriAsync(new Uri("ms-settings://network/wifi"));** <br /><br />Список страниц с параметрами, которые можно вывести на экран, см. в разделе [Вывод на экран страниц со встроенными параметрами с помощью протокола ms-settings](https://docs.microsoft.com/previous-versions/windows/apps/jj207014(v=vs.105)).
Связь между приложениями | Благодаря новым API [для связи между приложениями](https://docs.microsoft.com/previous-versions/windows/apps/dn997827(v=win.10)) в Windows 10 приложения для Windows (а также веб-приложения для Windows) могут запускать друга и обмениваться данными и файлами. С помощью этих новых API сложные задачи, для которых раньше приходилось использовать несколько приложений, теперь можно выполнять без проблем. Например, ваше приложение может запустить приложение социальной сети для выбора контакта или приложение для оформления заказа, чтобы завершить оплату.
Услуги для приложений | Благодаря службе приложения приложение может предоставлять услуги для других приложений в Windows 10. Служба приложения принимает форму фоновой задачи. Приложения переднего плана могут вызывать службу приложения в другом приложении для выполнения задач в фоновом режиме. Справочную информацию по API службы приложения см. в разделе [Windows.ApplicationModel.AppService](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.AppService).
Манифест пакета приложения | Обновления справочных материалов по [схеме манифеста пакета](https://docs.microsoft.com/uwp/schemas/appxpackage/appx-package-manifest) для Windows 10 включают элементы, которые были добавлены, удалены и изменены. Справочную информацию по всем элементам, атрибутам и типам в схеме см. в разделе [Иерархия элементов](https://docs.microsoft.com/uwp/schemas/appxpackage/uapmanifestschema/root-elements).

## <a name="devices"></a>Устройства

Функция | Описание
 :---- | :----
Microsoft Surface Hub | Microsoft Surface Hub — это мощное устройство для совместной групповой работы и платформа с большим экраном для универсальных приложений для Windows, которые предназначены для работы на Surface Hub или на подключенном устройстве. Создавайте собственные приложения, разработанные специально для вашего бизнеса и использующие преимущества большого экрана, сенсорного и рукописного управления, а также различного встроенного оборудования, такого как камеры и датчики.<br /><br />Изучите рекомендации по проектированию и руководства UX, относящиеся к Surface Hub, в разделе [Основы проектирования универсальных приложений для Windows](https://docs.microsoft.com/windows/uwp/design/layout/index). В этих документах объясняются принципы разработки универсальных приложений для Windows. <br /><br />Подробные сведения о поддержке общих приложений см. в разделе [SharedModeSettings](https://docs.microsoft.com/uwp/api/windows.system.profile.sharedmodesettings). Сведения о рукописном вводе и поддержке многоточечного рукописного ввода новым элементом управления [InkCanvas](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.inkcanvas) см. в разделах [Windows.UI.Input.Inking](https://docs.microsoft.com/uwp/api/windows.ui.input.inking) и [Windows.UI.Input.Inking.Core](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.core). Сведения об обработке входных данных датчика см. в разделе [Интеграция устройств, принтеров и датчиков](https://docs.microsoft.com/previous-versions/windows/apps/br229563(v=win.10)).
Location | В Windows 10 представлен новый метод запроса разрешения на доступ к расположению пользователя — [RequestAccessAsync](https://docs.microsoft.com/uwp/api/windows.devices.geolocation.geolocator.requestaccessasync). Пользователь устанавливает уровень защиты данных о расположении с помощью **настроек конфиденциальности сведений о расположении** в разделе приложения **Настройки**. Ваше приложение может получать доступ к данным о расположении пользователя только тогда, когда: включено **местоположение для этого устройства** *(не относится к Windows 10 для телефонов)* ; параметр **Местоположение** служб определения местоположения включен и в разделе **Выберите приложения, которые могут использовать данные о вашем местоположении** для вашего приложения установлено значение "Вкл.". <br /><br />Метод **RequestAccessAsync** должен обязательно вызываться перед получением доступа к данным о расположении пользователя. В этот момент ваше приложение должно находиться на переднем плане, а из потока пользовательского интерфейса должен быть вызван метод **RequestAccessAsync**. До тех пор пока пользователь не предоставит вашему приложению разрешение на доступ к данным о местоположении, приложение не сможет использовать такие данные.
AllJoyn | Пространство имен среды выполнения Windows [Windows.Devices.AllJoyn](https://docs.microsoft.com/uwp/api/windows.devices.alljoyn) — это реализации платформы и служб программного обеспечения с открытым исходным кодом AllJoyn корпорации Майкрософт. Благодаря этим API ваше универсальное приложение для устройства Windows сможет участвовать вместе с другими устройствами в различных сценариях "Интернет вещей" на базе платформы AllJoyn. Чтобы узнать больше о C API для AllJoyn, загрузите документацию с сайта [AllSeen Alliance](https://allseenalliance.org/). В данный выпуск включено средство [AllJoynCodeGen](https://docs.microsoft.com/previous-versions/windows/apps/dn913809(v=win.10)), с помощью которого можно создать компонент Windows для активации сценариев AllJoyn на вашем приложении для устройства. <br /><br />**Примечание.** ОС Windows 10 IoT Базовая теперь доступна для нового класса небольших устройств, что позволяет создавать устройства в рамках концепции «Интернет вещей» (IoT) с помощью Windows и Visual Studio. Подробнее о [Windows IoT в Центре разработки для Windows](https://developer.microsoft.com/windows/iot).
Интерфейсы API для печати на мобильных устройствах (XAML) | Это единый унифицированный набор интерфейсов API, который позволяет печатать из приложений UWP на основе XAML на устройствах из любых семейств, включая мобильные устройства. Теперь можно добавить функцию печати в мобильное приложение, используя знакомые интерфейсы API печати из пространств имен Windows.Graphics.Printing и Windows.UI.Xaml.Printing.
Аккумулятор | С помощью API аккумулятора в пространстве имен [Windows.Devices.Power](https://docs.microsoft.com/uwp/api/windows.devices.power) приложение может получать больше данных о любых аккумуляторах, подключенных к устройству, на котором работает это приложение. Вы можете создать объект [Батарея](https://docs.microsoft.com/uwp/api/windows.devices.power.battery) для представления отдельного контроллера батареи или совокупности всех контроллеров батареи (создается [FromIdAsync](https://docs.microsoft.com/uwp/api/windows.devices.power.battery.fromidasync) или [AggregateBattery](https://docs.microsoft.com/uwp/api/windows.devices.power.battery.aggregatebattery), соответственно). Метод [GetReport](https://docs.microsoft.com/uwp/api/windows.devices.power.battery.getreport) используется для получения объекта [BatteryReport](https://docs.microsoft.com/uwp/api/windows.devices.power.batteryreport), сообщающего об уровне заряда, емкости и состоянии соответствующих батарей.
Устройства MIDI | Новое пространство имен [Windows.Devices.Midi](https://docs.microsoft.com/uwp/api/windows.devices.midi) позволяет создавать приложения класса А, которые могут устанавливать связь со внешними устройствами MIDI, приложениями и внешними устройствами, которые устанавливают прямую связь с программным синтезатором Microsoft GS MIDI, а также сценариями, предусматривающими одновременный доступ нескольких клиентов к одному порту MIDI.
Поддержка пользовательских датчиков | Пространство имен [Windows.Devices.Sensors.Custom](https://docs.microsoft.com/uwp/api/windows.devices.sensors.custom) позволяет разработчикам оборудования определять новые типы пользовательских датчиков, например датчик углекислого газа.
Эмуляция карты на основе узла (HCE) | Эмуляция карты на основе узла позволяет реализовывать службы эмуляции карты NFC, размещенные в ОС, и по-прежнему связываться со внешним терминалом приложения для чтения через датчик NFC. Чтобы запустить фоновую задачу для эмуляции смарт-карты через NFC, используйте класс [SmartCardTrigger](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.Background.SmartCardTrigger). Значение EmulatorHostApplicationActivated в перечислении [SmartCardTriggerType](https://docs.microsoft.com/uwp/api/Windows.Devices.SmartCards.SmartCardTriggerType) позволяет приложению узнать, что событие HCE произошло.

## <a name="graphics"></a>Графика

Функция | Описание
 :---- | :----
DirectX | DirectX 12 в Windows 10 позволяет воспользоваться новой версией Microsoft Direct3D — интерфейсом API для трехмерной графики, лежащим в основе DirectX. [Графика Direct3D 12](https://docs.microsoft.com/windows/desktop/direct3d12/direct3d-12-graphics) обеспечивает эффективность и быстродействие низкоуровневых API, работающих по типу консоли. API Direct3D 12 работает с непревзойденной скоростью и эффективностью. С его помощью можно реализовать более сложные сцены и эффекты, увеличить количество объектов и использовать преимущества современных аппаратных графических средств.
SoftwareBitmapSource | В универсальных приложениях для Windows можно использовать новый тип [SoftwareBitmapSource](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.imaging.softwarebitmapsource) в качестве источника изображений XAML. Это позволяет передавать незакодированные изображения в инфраструктуру XAML для незамедлительного отображения на экране в обход раскодированию изображения в инфраструктуре XAML. Можно достигать более быстрой отрисовки изображения, например отрисовки низкоинерционных фотографий непосредственно с камеры, использование пользовательских декодировщиков, захват кадров с поверхностей DirectX или даже создание изображений в памяти "с нуля" и отрисовку их непосредственно в XAML с низкой задержкой и незначительной нагрузкой на память.
Камера перспективы | В универсальных приложениях для Windows XAML поддерживает новый интерфейс Transform3D API, который позволяет применять преобразования перспективы к дереву (или сцене) XAML, что приводит к преобразованию всех дочерних элементов XAML в соответствии с отдельным преобразованием всей сцены (или камеры). Раньше это можно было сделать с помощью MatrixTransform и сложных математических расчетов, однако Transform3D значительно упрощает применение этого эффекта и допускает даже его анимацию. Подробнее: [UIElement.Transform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.transform3d), [Transform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.media3d.transform3d), [CompositeTransform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.media3d.compositetransform3d) и [PerspectiveTransform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.media3d.perspectivetransform3d).

## <a name="media"></a>Media

Функция | Описание
 :---- | :----
Потоковая трансляция через HTTP | С помощью нового класса [AdaptiveMediaSource](https://docs.microsoft.com/uwp/api/windows.media.streaming.adaptive.adaptivemediasource) в приложении можно реализовать адаптивную трансляцию видео. Чтобы выполнялась инициализация объекта, он должен указывать на файл манифеста потоковой трансляции. Поддерживаемые форматы манифеста: Http Live Streaming (HLS) и Dynamic Adaptive Streaming over HTTP (DASH). Сразу после привязывания объекта к элементу списка воспроизведения XAML запускается адаптивное воспроизведение. Такие свойства потоковой трансляции, как доступная, минимальная или максимальная скорость, можно при необходимости запрашивать и настраивать.
Поддержка видеопроцессора Media Foundation Transcode Video Processor (XVP) в Media Foundation Transforms (MFTs) | Приложения для Windows, использующие Media Foundation Transforms (MFTs), теперь могут преобразовывать, масштабировать и трансформировать необработанные видеоданные с помощью видеопроцессора **Media Foundation Transcode Video Processor** (XVP), как указано ниже. Новый атрибут [MF_XVP_CALLER_ALLOCATES_OUTPUT](https://docs.microsoft.com/windows/desktop/medfound/mf-xvp-caller-allocates-output) обеспечивает вывод данных для распределенных между абонентами текстур даже в режиме ускорения видео Microsoft DirectX Video Acceleration (DXVA). Новый интерфейс [IMFVideoProcessorControl2](https://docs.microsoft.com/windows/desktop/api/mfidl/nn-mfidl-imfvideoprocessorcontrol2) позволяет приложению активировать эффекты оборудования, отправлять запросы на поддерживаемые эффекты оборудования и перезаписывать данные о выполнении вращения видеопроцессором.
Перекодировка | Новый интерфейс API [MediaProcessingTrigger](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.Background.MediaProcessingTrigger) позволяет приложению перекодировать мультимедиа в фоновой задаче. Благодаря этому перекодировка может продолжаться, даже когда приложение переднего плана завершило работу.
События ошибки мультимедиа MediaElement | В универсальных приложениях для Windows [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) будет воспроизводить содержимое с несколькими потоками, даже если при декодировании одного из них возникнет ошибка. Основное условие для этого — в содержимом должен быть по крайней мере один допустимый поток. Например, если при воспроизведении содержимого, которое включает в себя аудио- и видеопоток, происходит ошибка видеопотока, [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) по-прежнему будет воспроизводить аудиопоток. Событие [PartialMediaFailureDetected](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.partialmediafailuredetected) уведомляет о том, что один из потоков в общем потоке не может быть декодирован. Оно также позволяет узнать тип потока, затронутого ошибкой, поэтому вы можете отразить соответствующие сведения в своем пользовательском интерфейсе. Если ошибка затрагивает все потоки в общем потоке мультимедиа, порождается событие [MediaFailed](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.mediafailed).
Поддержка адаптивного потокового видеовоспроизведения с помощью MediaElement | У [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) имеется новый метод [SetPlaybackSource](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.setplaybacksource), поддерживающий адаптивное потоковое видеовоспроизведение. Используйте этот метод, чтобы задать источник мультимедиа как AdaptiveMediaSource.
Приведение с использованием MediaElement и Image | Элементы управления [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) и Image имеют новый метод [GetAsCastingSource](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.getascastingsource). Этот метод можно использовать для программной передачи содержимого из любого элемента мультимедиа или изображения на различные удаленные устройства, такие как Bluetooth, Miracast и DLNA. Эта функциональная возможность включается автоматически при определении для объекта [AreTransportControlsEnabled](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.aretransportcontrolsenabled) значения true в MediaElement.
Элементы управления транспортировкой мультимедиа для классических приложений | Интерфейс [ISystemMediaTransportControls](https://docs.microsoft.com/previous-versions/windows/desktop/mediatransport/isystemmediatransportcontrols) и соответствующие интерфейсы API позволяют классическим приложениям взаимодействовать со встроенными системными элементами управления транспортировкой мультимедиа. Это включает в себя отклик на взаимодействие пользователей с кнопками управления транспортировкой и обновление отображаемых элементов управления транспортировкой, позволяющее показать метаданные о мультимедийном содержимом, которое воспроизводится в настоящее время.
Кодирование и декодирование JPEG с прямым доступом | Новые методы WIC [IWICJpegFrameEncode](https://docs.microsoft.com/windows/desktop/api/wincodec/nn-wincodec-iwicjpegframeencode) и [IWICJpegFrameDecode](https://docs.microsoft.com/windows/desktop/api/wincodec/nn-wincodec-iwicjpegframedecode) позволяют кодировать и декодировать изображения JPEG. Теперь вы также можете включить индексирование графических данных, обеспечивающее эффективный прямой доступ к крупным изображениям за счет большего объема памяти.
Наложение слоев для композиций мультимедиа | Новые интерфейсы API [MediaOverlay](https://docs.microsoft.com/uwp/api/Windows.Media.Editing.MediaOverlay) и [MediaOverlayLayer](https://docs.microsoft.com/uwp/api/Windows.Media.Editing.MediaOverlayLayer) упрощают добавление нескольких слоев статического или динамического мультимедийного содержимого к композиции мультимедиа. Для каждого слоя можно настроить прозрачность, положение и расчет времени. Вы даже можете внедрить собственный пользовательский компоновщик для входных слоев.
Новая платформа эффектов | Пространство имен [Windows.Media.Effects](https://docs.microsoft.com/uwp/api/windows.media.effects) предоставляет простую и интуитивно понятную платформу для добавления эффектов к аудио- и видеопотокам. В платформу включены базовые интерфейсы, которые можно внедрить, чтобы создавать пользовательские аудио- и видеоэффекты и вставлять их в конвейер мультимедиа.

## <a name="networking"></a>Сеть

Функция | Описание
 :---- | :----
Сокеты | Далее перечислены новые возможности, связанные с сокетами. <br /><br />**Брокер сокетов.** Брокер сокетов может устанавливать и прекращать соединение между сокетами от имени приложения на любом этапе жизненного цикла приложения. Благодаря этому быстрее происходит обнаружение приложений и соответствующих служб. Например, через брокер сокетов служба Win32 может принимать входящие подключения сокетов даже тогда, когда она не работает. <br /><br />**Повышение пропускной способности.** Пропускная способность сокета оптимизирована для приложений, использующих пространство имен Windows.Networking.Sockets.
Задачи постобработки для фоновой передачи данных | Новые API в пространстве имен [Windows.Networking.BackgroundTransfer](https://docs.microsoft.com/uwp/api/windows.networking.backgroundtransfer) позволяют регистрировать группы задач постобработки. Таким образом ваше приложение, даже если оно не выполняется на переднем плане, может незамедлительно реагировать на удачные или неудачные процессы фоновой передачи данных, не дожидаясь перезапуска от пользователя.
Поддержка Bluetooth для рекламных объявлений | Благодаря пространству имен [Windows.Devices.Bluetooth.Advertisement](https://docs.microsoft.com/uwp/api/windows.devices.bluetooth.advertisement) ваше приложение может отправлять, получать и фильтровать рекламные объявления через соединение Bluetooth с низким энергопотреблением.
Новые возможности, связанные с API Wi-Fi Direct | Брокер устройства теперь может выполнять связывание без необходимости выхода из приложения. Благодаря дополнениям в пространстве имен [Windows.Devices.WiFiDirect](https://docs.microsoft.com/uwp/api/windows.devices.wifidirect) устройство теперь может переходить в состояние доступности для обнаружения другими устройствами, а также отслеживать уведомления о входящих подключениях.<br /><br />**Примечание.** В данном выпуске усовершенствованные функции Wi-Fi Direct не реализованы с точки зрения взаимодействия с пользователем, они работают только на основе кнопочного управления. Кроме того, в этом выпуске поддерживается только одно активное соединение.
Улучшенная поддержка JSON | В пространстве имен [Windows.Data.Json](https://docs.microsoft.com/uwp/api/windows.data.json) реализована улучшенная поддержка существующих стандартных определений и возможностей разработки при преобразовании объектов JSON в ходе сеансов отладки.

## <a name="security"></a>Безопасность

Функция | Описание
 :---- | :----
Шифрование ECC | Новые интерфейсы API в пространстве имен [Windows.Security.Cryptography](https://docs.microsoft.com/uwp/api/windows.security.cryptography) обеспечивают поддержку шифрования на основе эллиптических кривых (Elliptical Curve Cryptography, ECC) — метода шифрования с открытым ключом на основе эллиптических кривых в полях с конечными размерами. Метод ECC математически сложнее метода RSA, при этом он создает ключи меньшего размера, а также позволяет сократить потребление памяти и повысить производительность. Этот метод предусматривает использование параметров кривых согласно стандартам NIST (Национальный институт стандартов и технологий) и представляет собой альтернативу ключам RSA для служб и клиентов Microsoft.
Microsoft Passport | Служба Microsoft Passport — это альтернативный метод проверки подлинности, который заменяет пароли с асимметричными алгоритмами шифрования и жест. Классы в пространстве имен учетных данных, например [KeyCredentialManger](https://docs.microsoft.com/uwp/api/windows.security.credentials.keycredentialmanager), позволяют разработчикам с легкостью создавать приложения при помощи службы Microsoft Passport без шифрования и биометрии.
Microsoft Passport for Work | Служба Microsoft Passport for Work — это альтернативный метод подписи в Windows с помощью учетной записи Azure Active Directory, который не использует пароли, смарт-карту и виртуальные смарт-карты. Вы можете отключить или включить этот параметр политики.
Брокер маркеров | Брокер маркеров — это новая платформа проверки подлинности, с помощью которой приложениям проще подключаться к сетевым поставщикам удостоверений (например, Facebook). Благодаря таким функциям, как управление именем пользователя и паролем учетной записи, а также упрощенному пользовательскому интерфейсу, проверка подлинности для пользователей стала значительно удобнее.

## <a name="system-services"></a>Системные службы

Функция | Описание
 :---- | :----
Питание | Ваше классическое приложение для Windows теперь может получать уведомления о включении и выключении режима экономии заряда. Реагируя на изменения условий энергопотребления, приложение поможет продлить время работы батареи. <br /><br />[GUID_POWER_SAVING_STATUS](https://docs.microsoft.com/windows/desktop/Power/power-setting-guids). Используйте этот новый GUID с функцией [PowerSettingRegisterNotification](https://docs.microsoft.com/windows/desktop/api/powersetting/nf-powersetting-powersettingregisternotification) для получения уведомлений о включении и выключении режима экономии заряда. <br /><br />[SYSTEM_POWER_STATUS](https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-_system_power_status). Эта структура теперь поддерживает режим экономии заряда. Четвертый элемент *SystemStatusFlag* (ранее — Reserved1) теперь сообщает о том, включен или выключен режим экономии заряда. Чтобы получить указатель для этой структуры, используйте функцию [GetSystemPowerStatus](https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getsystempowerstatus).
Версия | Для определения версии операционной системы можно воспользоваться [вспомогательными функциями версии](https://docs.microsoft.com/windows/desktop/SysInfo/version-helper-apis). В Windows 10 среди таких вспомогательных функций представлена новая — [IsWindows10OrGreater](https://docs.microsoft.com/windows/desktop/api/versionhelpers/nf-versionhelpers-iswindows10orgreater). Чтобы определить версию системы, следует использовать именно вспомогательные функции, а не устаревшие функции [GetVersionEx](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) и [GetVersion](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion). Дополнительные сведения о том, как определить версию системы, см. в разделе [Определение версии системы](https://docs.microsoft.com/windows/desktop/SysInfo/getting-the-system-version). <br /><br />Если для получения данных о версии все же используется устаревшая функция [GetVersionEx](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) или [GetVersion](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion) в структуре [OSVERSIONINFOEX](https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-_osversioninfoexa) или [OSVERSIONINFO](https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-_osversioninfoa), следует учитывать, что номер версии в этих структурах увеличивается с 6.3 для Windows 8.1 и Windows Server 2012 R2 до 10.0 для Windows 10. Подробнее о номерах версий операционной системы см. разделе [Версия операционной системы](https://docs.microsoft.com/windows/desktop/SysInfo/operating-system-version). <br /><br />Кроме того, в приложении должно быть конкретное указание на Windows 8.1 или Windows 10, чтобы функция [GetVersionEx](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) или [GetVersion](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion) возвращала правильные данные об этих версиях. Сведения о способах указания на эти версии Windows в приложении см. в разделе [Указание на Windows в приложении](https://docs.microsoft.com/windows/desktop/SysInfo/targeting-your-application-at-windows-8-1).
Информация о пользователе | Новые API в пространстве имен [Windows.System](https://docs.microsoft.com/uwp/api/windows.system) облегчают доступ к сведениям о пользователе, например к имени пользователя и аватару. Они также дают возможность реагировать на события пользователя, такие как вход и выход.
Управление памятью и ее профилирование | Поддержка API для профилирования памяти в [Windows.System](https://docs.microsoft.com/uwp/api/windows.system) расширена для всех платформ, при этом в них добавлены новые классы и функции.

## <a name="storage"></a>Хранилище

Функция | Описание
 :---- | :----
API с функцией поиска в файлах для Windows Phone | Издатель может зарегистрировать свое приложение для размещения в общей папке вместе с другими приложениями, которые он издает, путем добавления расширения к манифесту приложения. Затем следует вызвать метод [Windows.Storage.ApplicationData.GetPublisherCacheFolder](https://docs.microsoft.com/uwp/api/windows.storage.applicationdata.getpublishercachefolder), чтобы получить данные расположения общего хранилища. Надежная система защиты в приложениях среды выполнения Windows, как правило, не позволяет приложениям обмениваться данными между собой. При этом в отдельных случаях может потребоваться обмен файлами и настройками между приложениями одного и того же издателя.

## <a name="tools"></a>Инструменты

Функция | Описание
 :---- | :----
Визуальное дерево в режиме реального времени в Visual Studio | Visual Studio теперь имеет новую функциональную возможность визуального дерева в режиме реального времени. Можно использовать ее во время отладки, чтобы лучше понять состояние визуального дерева вашего приложения и определить, как были определены свойства элементов. Кроме того, она позволяет менять значения свойств непосредственно во время работы приложения, поэтому вы можете оптимизировать настройки и экспериментировать с ними без необходимости перезапуска.
Ведение журнала трассировки | [TraceLogging](https://docs.microsoft.com/windows/desktop/tracelogging/trace-logging-portal) — новый API трассировки событий для приложений, работающих в пользовательском режиме, и драйверов, работающих в режиме ядра. Он работает на основе [трассировки событий Windows](https://docs.microsoft.com/windows/desktop/ETW/event-tracing-portal) (ETW). Этот API позволяет быстро получить код инструментария и включить структурированные данные для событий без отдельного XML-файла манифеста инструментирования. Доступны интерфейсы API TraceLogging для WinRT, .NET и C/C++, позволяющие удовлетворить потребности различных групп разработчиков.

## <a name="user-experience"></a>Взаимодействие с пользователем

Функция | Описание
 :---- | :----
Распознавание речи | Универсальная платформа Windows теперь поддерживает непрерывное распознавание речи для сценариев длительной диктовки. Узнайте, как включить непрерывную диктовку, изучив документы по речевому взаимодействию.
Возможности перетаскивания между различными платформами приложений | Новое пространство имен [Windows.ApplicationModel.DataTransfer.DragDrop](https://docs.microsoft.com/uwp/api/windows.applicationmodel.datatransfer.dragdrop) позволяет реализовать функции перетаскивания в универсальных приложениях для Windows. Ранее обычные сценарии перетаскивания для классических программ, например перетаскивание документа из папки в сообщение Outlook в качестве вложения, невозможно было реализовать в универсальных приложениях для Windows. Благодаря этим новым интерфейсам API в вашем приложении можно легко перемещать данные между различными универсальными приложениями для Windows и классическими программами. <br /><br />Для поддержки функции перетаскивания между приложениями в XAML были добавлены следующие интерфейсы API: [ListViewBase.DragItemsCompleted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.dragitemscompleted); <br />UIElement: [CanDrag](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.candrag), [DragStarting](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dragstarting), [StartDragAsync](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.startdragasync), [DropCompleted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dropcompleted)  <br />[DragOperationDeferral](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dragoperationdeferral), [DragUI](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dragui), [DragUIOverride](https://docs.microsoft.com/uwp/api/windows.ui.xaml.draguioverride); <br />DragEventArgs: [AcceptedOperation](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.acceptedoperation), [DataView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.dataview), [DragUIOverride](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.draguioverride), [GetDeferral](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.getdeferral), [Modifiers](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.modifiers); <br />[DragItemsCompletedEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.dragitemscompletedeventargs), [DropCompletedEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dropcompletedeventargs), [DragStartingEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dragstartingeventargs)
Пользовательские заголовки окон | Для приложений UWP, предназначенных для семейств настольных компьютеров, теперь можно использовать класс [ApplicationViewTitleBar](https://docs.microsoft.com/uwp/api/windows.ui.viewmanagement.applicationviewtitlebar) вместе со свойством [ApplicationView.TitleBar](https://docs.microsoft.com/uwp/api/windows.ui.viewmanagement.applicationview.titlebar) и методом [Window.SetTitleBar](https://docs.microsoft.com/uwp/api/windows.ui.viewmanagement.applicationview.titlebar) для замены содержимого заголовка окон по умолчанию на собственное содержимое XAML. Содержимое XAML обрабатывается как «системный хром», поэтому события ввода будут обрабатываться не вашим приложением, а операционной системой Windows. Это означает, что пользователь может перетаскивать окно и изменять его размеры, даже щелкая пользовательское содержимое заголовка окна.

## <a name="web"></a>Интернет

Функция | Описание
 :---- | :----
Microsoft Edge | Microsoft Edge — это новый браузер, который используется по умолчанию в Windows 10. Дополнительную информацию, а также обзор стандартов и возможностей Microsoft Edge для разработчиков, включая новейшие возможности JavaScript, см. в [Руководстве для разработчика по Microsoft Edge](https://developer.microsoft.com/microsoft-edge/platform/documentation/dev-guide).
Просмотр с помощью WebView | Элемент управления [WebView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview) использует тот же модуль отрисовки, что и новый браузер Microsoft Edge. Он предоставляет самый точный режим отрисовки HTML, совместимый со всеми стандартами.
WebView вне потока | Можно указать значение [WebView.ExecutionMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.executionmode), чтобы включить обработку и отображение веб-содержимого в отдельном фоновом потоке. Это может повысить производительность в определенных, специализированных сценариях.
Событие WebView.UnsupportedUriSchemeIdentified | Новое событие [WebView.UnsupportedUriSchemeIdentified](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.unsupportedurischemeidentified) позволяет указать, как ваше приложение будет обрабатывать неподдерживаемую схему URI. Можно обработать это событие, чтобы ваше приложение по-своему обрабатывало неподдерживаемые схемы URI. Что касается элемента управления HTML WebView, изучите раздел, посвященный событию [MSWebViewUnsupportedUriSchemeIdentified](https://docs.microsoft.com/previous-versions/windows/apps/dn803906(v=win.10)).
Событие WebView.NewWindowRequested | Новое событие [WebView.NewWindowRequested](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.newwindowrequested) позволяет реагировать на запрос сценарием в WebView нового окна браузера. Что касается элемента управления HTML WebView, изучите раздел, посвященный событию [MSWebViewNewWindowRequested](https://docs.microsoft.com/microsoft-edge/webview).
Событие WebView.PermissionRequested | Новое событие [WebView.PermissionRequested](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.permissionrequested) позволяет содержимому WebView задействовать новые интерфейсы HTML5 API, имеющие богатый набор функций и требующих специального разрешения пользователя, например определение географического расположения. Что касается элемента управления HTML WebView, изучите раздел, посвященный событию [MSWebViewPermissionRequested](https://docs.microsoft.com/previous-versions/windows/apps/dn806030(v=win.10)).
Событие WebView.UnviewableContentIdentified | Новое событие [WebView.UnviewableContentIdentified](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.unviewablecontentidentified) позволяет реагировать на переход WebView к другому содержимому, например PDF-файлу или документу Office. Элементы управления HTML WebView описаны в разделе, посвященном событию [MSWebViewUnviewableContentIdentified](https://docs.microsoft.com/microsoft-edge/webview).
Метод WebView.AddWebAllowedObject | Можно вызвать новый метод [WebView.AddWebAllowedObject](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.addweballowedobject) для вставки объекта WinRT в XAML WebView, а затем вызвать соответствующие функции из надежного кода JavaScript, размещенного в WebView. Например, веб-содержимое может отображать системные уведомления, запросив у родительского приложения вызов интерфейса WinRT API [ToastNotificationManager](https://docs.microsoft.com/uwp/api/windows.ui.notifications.toastnotificationmanager). Сведения об элементе управления HTML WebView см. в разделе, посвященном методу [addWebAllowedObject](https://docs.microsoft.com/microsoft-edge/webview).
Метод WebView.ClearTemporaryWebDataAsync | Если пользователь взаимодействует с веб-содержимым в XAML WebView, элемент управления WebView перехватывает данные на основе пользовательского сеанса. Можно вызвать метод [ClearTemporaryWebDataAsync](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.cleartemporarywebdataasync) для очистки этого кэша. Например, можно очистить кэш, если один пользователь выходит из приложения, чтобы другой пользователь не смог получить доступ к любым данным предыдущего сеанса.
