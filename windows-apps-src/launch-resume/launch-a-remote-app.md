---
author: TylerMSFT
title: "Запуск приложения на удаленном устройстве"
description: "Узнайте, как запустить приложение на удаленном устройстве с помощью проекта &quot;Рим&quot;."
translationtype: Human Translation
ms.sourcegitcommit: ff8e16d0e376d502157ae42b9cdae11875008554
ms.openlocfilehash: d8c3783d68a1b3b216058790d84255a7fb4b612c

---

# Запуск приложения на удаленном устройстве

В этой статье описывается, как запустить приложение универсальной платформы Windows (UWP) или классическое приложение для Windows на удаленном устройстве.

Начиная с Windows 10 версии 1607, приложения UWP могут запускать другие приложения UWP или классические приложения для Windows удаленно на другом устройстве с Windows 10 версии 1607 или более поздней версии.

Один из вариантов использования функции запуска приложения на удаленном устройстве состоит в том, чтобы позволить пользователю начать задачу на одном устройстве и завершить на другом. Например, если вы слушаете музыку на телефоне по дороге домой, вы можете использовать удаленный запуск для передачи воспроизведения на консоль Xbox, когда окажетесь дома. Вы можете передавать данные удаленному приложению, чтобы предоставить ему контекст для продолжения выполнения задачи.

## Добавление возможности RemoteSystem

Чтобы приложение могло запускать другое приложение на удаленном устройстве, вам потребуется добавить возможность <uap3:Capability Name="remoteSystem"/> в манифест пакета приложения. Вы можете использовать конструктор манифестов приложений для добавления этой возможности, выбрав **Удаленная система** на вкладке **Возможности**. Вы также можете выполнить работу конструктора манифестов приложений вручную и добавить следующий код в файл Package.appxmanifest.

``` xml
<Capabilities>
   <uap3:Capability Name="remoteSystem"/>
 </Capabilities>
```
## Поиск удаленного устройства

Сначала вам потребуется найти устройство, к которому нужно подключиться. 
              В статье [Обнаружение удаленных устройств](discover-remote-devices.md) подробно описано, как это сделать. Мы воспользуемся простым способом, не прибегая к фильтрации по типу устройства или подключения. Мы создадим наблюдатель удаленных систем для поиска удаленных устройств и создадим обработчики событий, получающие уведомления об удалении или обнаружении устройств, на которых используется та же учетная запись Майкрософт. Так мы получим коллекцию удаленных устройств.

В коде из этих примеров предполагается, что в вашем файле имеется оператор `using Windows.System.RemoteSystems`.

[!code-cs[Основной блок](./code/RemoteLaunchScenario/MainPage.xaml.cs#SnippetBuildDeviceList)]

Перед удаленным запуском необходимо сначала вызвать метод `RemoteSystem.RequestAccessAsync()`. Проверьте полученное значение и убедитесь, что у вашего приложения есть разрешение на доступ к удаленным устройствам. Эта проверка может не удаться, если вы не добавили возможность `remoteSystem` в приложение.

Обработчики событий наблюдателя систем вызываются при обнаружении устройства, к которому можно подключиться, или прекращении доступа к нему. Мы будем использовать эти обработчики событий для ведения актуального списка устройств, к которым можно подключиться.

[!code-cs[Основной блок](./code/RemoteLaunchScenario/MainPage.xaml.cs#SnippetEventHandlers)]

Мы будет отслеживать устройства по идентификатору удаленной системы с помощью словаря. Для содержания исчисляемого списка устройств используется класс ObservableCollection. Класс ObservableCollection также упрощает привязку списка устройств к пользовательскому интерфейсу, но мы не будем этого делать в нашем примере.

[!code-cs[Основной блок](./code/RemoteLaunchScenario/MainPage.xaml.cs#SnippetMembers)]

Добавьте вызов метода `BuildDeviceList()` в код запуска приложения перед запуском удаленного приложения.

## Запуск приложения на удаленном устройстве

Запустите приложение удаленно, указав устройство, к которому требуется подключиться, в API [RemoteLauncher.LaunchUri](https://msdn.microsoft.com/en-us/library/windows/apps/windows.system.remotelauncher.launchuriasync.aspx). Для этой функции существует три перегрузки. В самой простой из них, используемой в этом примере, указывается универсальный код ресурса (URI), с помощью которого активируется приложение на удаленном устройстве. В этом примере с помощью URI открывается приложение "Карты" на удаленной системе с трехмерным представлением башни Спейс-Нидл.

Другие перегрузки **RemoteLauncher.LaunchUriAsync** позволяют указывать такие параметры, как URI веб-сайта для проверки возможности запуска приложения, способного обработать этот URI, на удаленном устройстве, и необязательный список имен семейства пакетов, который можно использовать для запуска этого URI на удаленном устройстве. Вы также можете предоставить данные в виде пар "ключ-значение". Вы можете передать данные приложению, запускаемому на удаленном устройстве, чтобы предоставить контекст для удаленного приложения, например название песни, которую требуется воспроизвести, и текущее расположение воспроизведения при передаче воспроизведения с одного устройства на другое.

На практике вы можете предоставить пользовательский интерфейс для выбора устройства, которое следует использовать. Но для упрощения этого примера мы воспользуемся первым элементом списка для совершения удаленного вызова.

[!code-cs[Основной блок](./code/RemoteLaunchScenario/MainPage.xaml.cs#SnippetRemoteUriLaunch)]

Перечисление [RemoteLaunchUriStatus](https://msdn.microsoft.com/en-us/library/windows/apps/windows.system.remotelaunchuristatus.aspx), возвращаемое методом **RemoteLauncher.LaunchUriAsync()**, содержит сведения об успешном удаленном запуске или причинах его сбоя.

## Связанные статьи

[Справочник по API удаленных систем](https://msdn.microsoft.com/en-us/library/windows/apps/Windows.System.RemoteSystems)  
[Обзор подключенных приложений и устройств (проект "Рим")](connected-apps-and-devices.md)  
[Пример удаленных систем](https://github.com/Microsoft/Windows-universal-samples/tree/dev/Samples/RemoteSystems ) демонстрирует, как обнаружить удаленную систему, запустить приложение в удаленной системе и использовать службы приложений для передачи сообщений между приложениями, работающими в двух системах.



<!--HONumber=Aug16_HO5-->


