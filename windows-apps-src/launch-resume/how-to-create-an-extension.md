---
author: TylerMSFT
title: Создание и использование расширения приложения
description: Создавайте и размещайте расширения приложений универсальной платформы Windows (UWP), позволяющие расширить приложение с помощью пакетов, которые пользователи могут установить через Microsoft Store.
keywords: расширение приложения, служба приложения, фоновый режим
ms.author: twhitney
ms.date: 10/05/2017
ms.topic: article
ms.localizationpriority: medium
ms.openlocfilehash: c4c326dbafa719273c4535a42d58184c7ce360fe
ms.sourcegitcommit: e2fca6c79f31e521ba76f7ecf343cf8f278e6a15
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/15/2018
ms.locfileid: "6972202"
---
# <a name="create-and-host-an-app-extension"></a>Создание и размещение расширения приложения

В этой статье показано, как создать расширение приложения UWP и разместить его в приложении UWP.

Эта статья сопровождается примером кода:
- Скачайте и распакуйте [пример кода расширения Math Extension](https://github.com/MicrosoftDocs/windows-topic-specific-samples/archive/MathExtensionSample.zip).
- В Visual Studio 2017 откройте MathExtensionSample.sln. В качестве типа сборки установите x86 (**Сборка** > **Диспетчер конфигураций**, затем измените значение в поле **Платформа** на **x86** для обоих проектов).
- Разверните решение: **Сборка** > **Развернуть решение**.

## <a name="introduction-to-app-extensions"></a>Введение в расширения приложений

На универсальной платформе Windows (UWP) расширения приложений предоставляют возможности, аналогичные подключаемым модулям и надстройкам на других платформах. Например, расширения Microsoft Edge являются расширениями приложений UWP. Расширения приложений UWP появились в юбилейном обновлении Windows 10 (версия 1607, сборка 10.0.14393).

Расширения приложений UWP— это приложения UWP с объявлением расширения, которое позволяет им обмениваться содержимым и событиями развертывания с основным приложением. Приложение расширения может предоставить несколько расширений.

Поскольку расширения приложения представляют собой приложения UWP, они также могут выполнять все функции приложений, размещать расширения и предоставлять их другим приложениям без необходимости создания отдельных пакетов приложений.

При создании основного приложения для расширения вы создаете возможность разработать экосистему на основе вашего приложения, в рамках которой другие разработчики могут улучшить ваше приложение в таких направлениях, на которые вы, возможно, не рассчитывали или не имели ресурсов. Взгляните на расширения Microsoft Office, Visual Studio, браузера и т. п. Они расширяют изначальные возможности этих приложений. Расширения могут увеличить полезность и долговечность приложения.

**Обзор**

В целом, для настройки отношения расширения приложения необходимо сделать следующее.

1. Объявить приложение в качестве основного приложения для расширений.
2. Объявить приложение в качестве расширения.
3. Выбрать способ реализации расширения— в качестве службы приложения, фоновой задачи или иной вариант.
4. Определить способ обмена данными между основным приложением и его расширениями.
5. Использовать API-интерфейс [Windows.ApplicationModel.AppExtensions](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.AppExtensions) в основном приложении для доступа к расширениям.

Давайте узнаем, как это сделать. Для этого ознакомимся с [примером кода расширения Math Extension](https://github.com/MicrosoftDocs/windows-topic-specific-samples/archive/MathExtensionSample.zip), который реализует гипотетический калькулятор, в который можно добавить новые функции с помощью расширений. В Microsoft Visual Studio 2017 загрузите **MathExtensionSample.sln** из примера кода.

![Пример кода расширения Math Extension](images/mathextensionhost-calctab.png)

## <a name="declare-an-app-to-be-an-extension-host"></a>Объявление приложения в качестве основного приложения для расширений

Чтобы приложение определяло себя как основное приложение для расширений, необходимо объявить элемент `<AppExtensionHost>` в соответствующем файле Package.appxmanifest. Чтобы узнать, как это сделать, см. файл **Package.appxmanifest** в проекте **MathExtensionHost**.

_Package.appxmanifest в проекте MathExtensionHost_
```xml
<Package
  ...
  xmlns:uap3="http://schemas.microsoft.com/appx/manifest/uap/windows10/3"
  IgnorableNamespaces="uap uap3 mp">
  ...
    <Applications>
      <Application Id="App" ... >
        ...
        <Extensions>
            <uap3:Extension Category="windows.appExtensionHost">
                <uap3:AppExtensionHost>
                  <uap3:Name>com.microsoft.mathext</uap3:Name>
                </uap3:AppExtensionHost>
          </uap3:Extension>
        </Extensions>
      </Application>
    </Applications>
    ...
</Package>
```

Обратите внимание на `xmlns:uap3="http://..."` и наличие `uap3` в `IgnorableNamespaces`. Эти элементы необходимы, так как мы используем пространство имен uap3.

`<uap3:Extension Category="windows.appExtensionHost">` определяет это приложение как основное приложение для расширений.

Элемент **Name** в `<uap3:AppExtensionHost>` представляет собой имя _контракта расширения_. Если в расширении указано то же имя контракта расширения, основное приложение сможет его найти. Традиционно мы рекомендуем создавать имя контракта расширения на основе имени приложения или издателя, чтобы избежать возможных конфликтов с другими именами контрактов расширения.

Можно определить несколько основных приложений и расширений в одном приложении. В этом примере мы объявим одно основное приложение. Расширение определяется в другом приложении.

## <a name="declare-an-app-to-be-an-extension"></a>Объявление приложения в качестве расширения

Чтобы приложение определяло себя как расширение приложения, необходимо объявить элемент `<uap3:AppExtension>` в соответствующем файле **Package.appxmanifest**. Чтобы узнать, как это сделать, откройте файл **Package.appxmanifest** в проекте **MathExtension**.

_Package.appxmanifest в проекте MathExtension:_
```xml
<Package
  ...
  xmlns:uap3="http://schemas.microsoft.com/appx/manifest/uap/windows10/3"
  IgnorableNamespaces="uap uap3 mp">
  ...
    <Applications>
      <Application Id="App" ... >
        ...
        <Extensions>
          ...
          <uap3:Extension Category="windows.appExtension">
            <uap3:AppExtension Name="com.microsoft.mathext"
                               Id="power"
                               DisplayName="x^y"
                               Description="Exponent"
                               PublicFolder="Public">
              <uap3:Properties>
                <Service>com.microsoft.powservice</Service>
              </uap3:Properties>
              </uap3:AppExtension>
          </uap3:Extension>
        </Extensions>
      </Application>
    </Applications>
    ...
</Package>
```

И снова обратите внимание на строку `xmlns:uap3="http://..."` и наличие `uap3` в `IgnorableNamespaces`. Эти элементы необходимы, так как мы используем пространство имен `uap3`.

`<uap3:Extension Category="windows.appExtension">` определяет это приложение как расширение.

Значения атрибутов `<uap3:AppExtension>` выглядят следующим образом.

|Атрибут|Описание|Обязателен|
|---------|-----------|:------:|
|**Name**|Это имя контракта расширения. Если оно соответствует элементу **Name**, объявленному в основном приложении, это приложение сможет найти данное расширение.| :heavy_check_mark: |
|**ID**| Служит уникальным идентификатором этого расширения. Так как сразу несколько расширений могут использовать одно и то же имя контракта расширения (например, приложение для рисования с поддержкой нескольких расширений), различать их можно с помощью идентификатора. Основные приложения расширений могут использовать идентификатор для получения предположительных сведений о типе расширения. Например, одно расширение может предназначаться для классических приложений, а другое— для мобильных, при этом различаться они будут идентификаторами. Также для этого можно использовать элемент **Properties**, как описано ниже.| :heavy_check_mark: |
|**DisplayName**| Этот атрибут можно использовать в основном приложении, чтобы определить расширение для пользователя. Он запрашивается из [новой системы управления ресурсами](https://docs.microsoft.com/windows/uwp/app-resources/using-mrt-for-converted-desktop-apps-and-games) (`ms-resource:TokenName`) для локализации, а также может использовать ее. Локализованное содержимое загружается из пакета расширения приложения, а не из основного приложения. | |
|**Description** | Этот атрибут можно использовать в основном приложении, чтобы описать расширение для пользователя. Он запрашивается из [новой системы управления ресурсами](https://docs.microsoft.com/windows/uwp/app-resources/using-mrt-for-converted-desktop-apps-and-games) (`ms-resource:TokenName`) для локализации, а также может использовать ее. Локализованное содержимое загружается из пакета расширения приложения, а не из основного приложения. | |
|**PublicFolder**|Имя папки, относящейся к корневому каталогу пакета, в которой можно обмениваться содержимым с основным приложением расширения. Традиционно в качестве имени используется "Public", но можно использовать любое имя, совпадающее с именем папки в расширении.| :heavy_check_mark: |

`<uap3:Properties>` является необязательным элементом, содержащим пользовательские метаданные, которые основные приложения могут считывать во время выполнения. В примере кода расширение реализовано как служба приложения, поэтому основному приложению нужен способ получения имени службы приложения для ее вызова. Имя службы приложения определяется в элементе <Service>, который уже определен (ему можно дать любое имя). Основное приложение в примере кода находит это свойство во время выполнения, чтобы получить имя службы приложения.

## <a name="decide-how-you-will-implement-the-extension"></a>Выбор способа реализации расширения.

В [сеансе Build 2016, посвященном расширениям приложений](https://channel9.msdn.com/Events/Build/2016/B808), демонстрируется, как использовать общую папку, доступ к которой предоставлен основному приложению и расширениям. В этом примере расширение реализовано с помощью файла Javascript, хранящегося в общей папке, которую вызывает основное приложение. Преимущества этого подхода заключаются в том, что он прост, не требует компиляции и поддерживает создание целевой страницы по умолчанию, которая предоставляет инструкции для расширения и ссылку на страницу основного приложения в Microsoft Store. Подробные сведения см. в разделе [Пример кода расширения приложения в Build 2016](https://github.com/Microsoft/App-Extensibility-Sample). В частности, обратите внимание на проект **InvertImageExtension** и `InvokeLoad()` в ExtensionManager.cs в проекте **ExtensibilitySample**.

В этом примере для реализации расширения используется служба приложения. Службы приложений обладают следующими преимуществами.

- При сбое расширения основное приложение продолжит работать, так как это приложение выполняется в собственном процессе.
- Для реализации службы можно использовать любой язык. Не обязательно использовать язык, с помощью которого было реализовано основное приложение.
- У службы приложения есть доступ к собственному контейнеру приложения, возможности которого могут отличаться от основного приложения.
- Данные в службе изолированы от данных в основном приложении.

### <a name="host-app-service-code"></a>Код службы основного приложения

Ниже представлен код основного приложения, вызывающий службу приложения расширения.

_ExtensionManager.cs в проекте MathExtensionHost_
```cs
public async Task<double> Invoke(ValueSet message)
{
    if (Loaded)
    {
        try
        {
            // make the app service call
            using (var connection = new AppServiceConnection())
            {
                // service name is defined in appxmanifest properties
                connection.AppServiceName = _serviceName;
                // package Family Name is provided by the extension
                connection.PackageFamilyName = AppExtension.Package.Id.FamilyName;

                // open the app service connection
                AppServiceConnectionStatus status = await connection.OpenAsync();
                if (status != AppServiceConnectionStatus.Success)
                {
                    Debug.WriteLine("Failed App Service Connection");
                }
                else
                {
                    // Call the app service
                    AppServiceResponse response = await connection.SendMessageAsync(message);
                    if (response.Status == AppServiceResponseStatus.Success)
                    {
                        ValueSet answer = response.Message as ValueSet;
                        if (answer.ContainsKey("Result")) // When our app service returns "Result", it means it succeeded
                        {
                            return (double)answer["Result"];
                        }
                    }
                }
            }
        }
        catch (Exception)
        {
             Debug.WriteLine("Calling the App Service failed");
        }
    }
    return double.NaN; // indicates an error from the app service
}
```

Это обычный код для вызова службы приложения. Подробные инструкции по реализации и вызову службы приложения см. в разделе [Создание и использование службы приложения](how-to-create-and-consume-an-app-service.md).

Следует отметить процедуру определения имени службы приложения, которую требуется вызвать. Поскольку у основного приложения нет сведений о реализации расширения, расширение должно предоставить имя его службы приложения. В примере кода расширение объявляет имя службы приложения в соответствующем файле в элементе `<uap3:Properties>`:

_Package.appxmanifest в проекте MathExtension_
```xml
    ...
    <uap3:Extension Category="windows.appExtension">
      <uap3:AppExtension ...>
        <uap3:Properties>
          <Service>com.microsoft.powservice</Service>
        </uap3:Properties>
        </uap3:AppExtension>
    </uap3:Extension>
```

Можно определить собственный код XML в элементе `<uap3:Properties>`. В этом случае мы определяем имя службы приложения, чтобы основное приложение использовало его при вызове расширения.

Когда основное приложение загружает расширение, подобный код извлекает имя службы из свойств, определенных в файле Package.appxmanifest расширения:

_`Update()` в ExtensionManager.cs в проекте MathExtensionHost_
```cs
...
var properties = await ext.GetExtensionPropertiesAsync() as PropertySet;

...
#region Update Properties
// update app service information
_serviceName = null;
if (_properties != null)
{
   if (_properties.ContainsKey("Service"))
   {
       PropertySet serviceProperty = _properties["Service"] as PropertySet;
       this._serviceName = serviceProperty["#text"].ToString();
   }
}
#endregion
```

Имя службы приложения хранится в `_serviceName`, поэтому основное приложение может использовать его для вызова службы приложения.

Для вызова службы приложения также необходимо имя семейства пакета, содержащего эту службу приложения. К счастью, API-интерфейс расширения приложения предоставляет эти сведения, которые можно получить в следующей строке: `connection.PackageFamilyName = AppExtension.Package.Id.FamilyName;`

### <a name="define-how-the-host-and-the-extension-will-communicate"></a>Определение способа обмена данными между основным приложением и его расширением

Для обмена информацией службы приложений используют [ValueSet](https://docs.microsoft.com/uwp/api/windows.foundation.collections.valueset). Как создателю основного приложения вам необходимо разработать гибкий протокол обмена данными с расширениями. В примере кода это означает необходимость учесть расширения, которые в дальнейшем могут потребовать 1, 2 или больше аргументов.

В этом примере в качестве протокола для аргументов используется класс **ValueSet**, содержащий пары "ключ-значение" с именем "Arg" + номер аргумента, например `Arg1` и `Arg2`. Основное приложение передает все аргументы классу **ValueSet**, после чего расширение использует нужные ему аргументы. Если расширение может вычислить результат, основное приложение ожидает от него возврата **ValueSet**, чтобы получить ключ с именем `Result`, который содержит значение расчета. Если этот ключ отсутствует, основное приложение делает вывод, что расширению не удалось выполнить расчет.

### <a name="extension-app-service-code"></a>Код службы приложения расширения

В примере кода службы приложения расширения не реализована как фоновая задача. Вместо этого в ней используется модель однопроцессной службы приложения, согласно которой служба приложения выполняется в том же процессе, что и приложение расширения, в котором она размещена. Этот процесс по-прежнему отличен от основного приложения, что обеспечивает преимущества разделения процессов и возможность повысить производительность за счет исключения обмена данными между процессом расширения и фоновым процессом, реализующим службу приложения. Различия между службами приложения, запущенной в виде фоновой задачи и работающей в том же процессе, что и основное приложение, см. в разделе [Преобразование службы приложения для запуска в одном процессе с ее основным приложением](convert-app-service-in-process.md).

Система вызывает метод `OnBackgroundActivate()` при активации службы приложения. Этот код настраивает обработчики событий на обработку фактического вызова службы приложения при его поступлении (`OnAppServiceRequestReceived()`), а также для обработки вспомогательных событий, таких как получение объекта отсрочки, обрабатывающего событие отмены или закрытия.

_App.xaml.cs в проекте MathExtension._
```cs
protected override void OnBackgroundActivated(BackgroundActivatedEventArgs args)
{
    base.OnBackgroundActivated(args);

    if ( _appServiceInitialized == false ) // Only need to setup the handlers once
    {
        _appServiceInitialized = true;

        IBackgroundTaskInstance taskInstance = args.TaskInstance;
        taskInstance.Canceled += OnAppServicesCanceled;

        AppServiceTriggerDetails appService = taskInstance.TriggerDetails as AppServiceTriggerDetails;
        _appServiceDeferral = taskInstance.GetDeferral();
        _appServiceConnection = appService.AppServiceConnection;
        _appServiceConnection.RequestReceived += OnAppServiceRequestReceived;
        _appServiceConnection.ServiceClosed += AppServiceConnection_ServiceClosed;
    }
}
```

Код, выполняющий функции расширения, находится в `OnAppServiceRequestReceived()`. Эта функция вызывается при вызове службы приложения для выполнения расчета. Она извлекает необходимые значения из класса **ValueSet**. Если возможно выполнить расчет, результат под ключом с именем **Result** помещается в класс **ValueSet**, который возвращается основному приложению. Как мы уже знаем, согласно определенному протоколу обмена данными между этим основным приложением и его расширениями, наличие ключа **Result** свидетельствует об успехе, а его отсутствие— о неудаче.

_App.xaml.cs в проекте MathExtension._
```cs
private async void OnAppServiceRequestReceived(AppServiceConnection sender, AppServiceRequestReceivedEventArgs args)
{
    // Get a deferral because we use an awaitable API below (SendResponseAsync()) to respond to the message
    // and we don't want this call to get cancelled while we are waiting.
    AppServiceDeferral messageDeferral = args.GetDeferral();
    ValueSet message = args.Request.Message;
    ValueSet returnMessage = new ValueSet();

    double? arg1 = Convert.ToDouble(message["arg1"]);
    double? arg2 = Convert.ToDouble(message["arg2"]);
    if (arg1.HasValue && arg2.HasValue)
    {
        returnMessage.Add("Result", Math.Pow(arg1.Value, arg2.Value)); // For this sample, the presence of a "Result" key will mean the call succeeded
    }

    await args.Request.SendResponseAsync(returnMessage);
    messageDeferral.Complete();
}
```

## <a name="manage-extensions"></a>Управление расширениями

Мы узнали, как реализовать отношение между основным приложением и его расширениями. Теперь узнаем, как основное приложение находит установленные в системе расширения и реагирует на добавление и удаление пакетов, содержащих расширения.

Microsoft Store предоставляет расширения в виде пакетов. Класс [AppExtensionCatalog](https://docs.microsoft.com/uwp/api/windows.applicationmodel.appextensions.appextensioncatalog) находит установленные пакеты с расширениями, соответствующие имени контракта расширения основного приложения, и предоставляет события, происходящие при установке или удалении пакета расширения приложения, относящегося к основному приложению.

В примере кода класс `ExtensionManager` (определен **ExtensionManager.cs** в проекте **MathExtensionHost**) содержит логику для загрузки расширений и реагирования на установку и удаление пакета расширения.

Конструктор `ExtensionManager` использует `AppExtensionCatalog` для поиска расширений приложений в системе, имеющих то же имя контракта расширения, что и основное приложение.

_ExtensionManager.cs в проекте MathExtensionHost project._
```cs
public ExtensionManager(string extensionContractName)
{
   // catalog & contract
   ExtensionContractName = extensionContractName;
   _catalog = AppExtensionCatalog.Open(ExtensionContractName);
   ...
}
```

При установке пакета расширения `ExtensionManager` собирает сведения о расширениях в этом пакете, имеющих то же имя контракта расширения, что и основное приложение. Установка может представлять обновление, в случае которого сведения о затронутом расширении обновляются. При удалении пакета расширения `ExtensionManager` удаляет сведения о затронутых расширениях, чтобы пользователь знал, какие расширения уже недоступны.

Класс `Extension` (определен в **ExtensionManager.cs** в проекте **MathExtensionHost**) был создан для предоставления примеру кода доступа к идентификатору, описанию и логотипу расширения, а также к связанным с приложением сведениям, например включил ли пользователь расширение.

Если расширение загружено (см. `Load()` в **ExtensionManager.cs**), значит состояние пакета в порядке, а мы получили его идентификатор, логотип, описание и общую папку (в данном примере не используется и указана, только чтобы показать процедуру ее получения). Сам пакет расширения не загружается.

Концепция выгрузки используется для отслеживания расширений, которые больше не следует предоставлять пользователю.

`ExtensionManager` предоставляет коллекцию экземпляров `Extension`, благодаря чему расширения, их имена, описания и логотипы можно связать посредством данных с пользовательским интерфейсом. Страница **ExtensionsTab** связывается с этой коллекцией и предоставляет пользовательский интерфейс для включения и отключения расширений, а также для их удаления.

![Пример пользовательского интерфейса вкладки расширений](images/mathextensionhost-extensiontab.png)

 При удалении расширения система предлагает пользователю подтвердить удаление пакета, содержащего данное расширение (и, возможно, другие расширения). С согласия пользователя пакет удаляется, а `ExtensionManager` удаляет расширение в удаленном пакете из списка расширений, доступных основному приложению.

 ![Пользовательский интерфейс удаления](images/mathextensionhost-uninstall.png)

## <a name="debugging-app-extensions-and-hosts"></a>Отладка расширений и основных приложений

Часто основное приложение и его расширение относятся к разным решениям. В этом случае для отладки основного приложения и его расширения необходимо сделать следующее.

1. Загрузите проект основного приложения в одном экземпляре Visual Studio.
2. Загрузите расширение в другом экземпляре Visual Studio.
3. Запустите основное приложение в отладчике.
4. Запустите приложение расширения в отладчике. (Если вам требуется развернуть расширение, а не отладить его, для тестирования события установки пакета основного приложения выберите **Сборка &gt; Развертывание решения**).

Теперь вы сможете достичь точек останова в основном приложении и его расширении.
Если начать отладку самого приложения расширения, отобразится пустое окно приложения. Чтобы пустое окно не отображалось, измените параметры отладки таким образом, чтобы проект расширения не запускал приложение, а выполнял его отладку при открытии (щелкните правой кнопкой мыши проект расширения и выберите **Свойства** > **Отладка** > **Не запускать, а отлаживать мой код при открытии**). Отладку проекта расширения по-прежнему необходимо будет запустить (**F5**), но он подождет, пока основное приложение активирует расширение и будут достигнуты точки останова в расширении.

**Отладка примера кода**

В примере кода основное приложение и его расширение расположены в одном и том же решении. Для отладки выполните следующие действия.

1. Убедитесь, что **MathExtensionHost** является запускаемым проектом (щелкните правой кнопкой мыши проект **MathExtensionHost** и выберите пункт **Назначить запускаемым проектом**).
2. Разместите точку останова на `Invoke` в ExtensionManager.cs в проекте **MathExtensionHost**.
3. Нажмите клавишу **F5**, чтобы запустить проект **MathExtensionHost**.
4. Разместите точку останова на `OnAppServiceRequestReceived` в App.xaml.cs в проекте **MathExtension**.
5. Запустите отладку проекта **MathExtension** (щелкните правой кнопкой мыши проект **MathExtension** и выберите пункты **Отладка > Запустить новый экземпляр**). При этом проект будет развернут, а в основном приложении активируется событие установки пакета.
6. В приложении **MathExtensionHost** перейдите на страницу **Вычисление** и щелкните **x^y**, чтобы активировать расширение. Точка останова `Invoke()` достигается первой; при этом можно наблюдать выполнение вызова службы приложения расширения. Затем достигается метод `OnAppServiceRequestReceived()` в расширении; при этом можно наблюдать, как служба приложения вычисляет результат и возвращает его.

**Реализация отладки расширений в виде службы приложений**

Если основное приложение не может подключиться к службе приложения для расширения, убедитесь, что атрибут `<uap:AppService Name="...">` соответствует значению элемента `<Service>`. Если они не совпадают, имя службы, предоставленное основному приложению расширением, не будет соответствовать имени службы реализованного приложения, а основное приложение не сможет активировать расширение.

_Package.appxmanifest в проекте MathExtension:_
```xml
<Extensions>
   <uap:Extension Category="windows.appService">
     <uap:AppService Name="com.microsoft.sqrtservice" />      <!-- This must match the contents of <Service>...</Service> -->
   </uap:Extension>
   <uap3:Extension Category="windows.appExtension">
     <uap3:AppExtension Name="com.microsoft.mathext" Id="sqrt" DisplayName="Sqrt(x)" Description="Square root" PublicFolder="Public">
       <uap3:Properties>
         <Service>com.microsoft.powservice</Service>   <!-- this must match <uap:AppService Name=...> -->
       </uap3:Properties>
     </uap3:AppExtension>
   </uap3:Extension>
</Extensions>   
```

## <a name="a-checklist-of-basic-scenarios-to-test"></a>Контрольный список базовых сценариев для тестирования

После сборки основного приложения для расширения воспользуйтесь этими базовыми сценариями, чтобы протестировать, насколько хорошо оно поддерживает расширения:

- Запустите основное приложение, а затем разверните приложение расширения.  
    - Принимает ли основное приложение новые расширения, поступающие в процессе его работы?  
- Запустите приложение расширения, а затем разверните и запустите основное приложение.
    - Принимает ли основное приложение уже существующие расширения?  
- Запустите основное приложение, а затем удалите приложение расширения.
    - Верно ли основное приложение обнаруживает удаление?
- Запустите основное приложение, а затем обновите приложение расширения до более новой версии.
    - Обнаруживает ли основное приложение изменение и верно ли выгружает прежние версии расширения?  

**Сложные сценарии для тестирования:**

- Запустите основное приложение, переместите приложение расширения на съемный носитель и извлеките носитель.
    - Обнаруживает ли основное приложение изменение состояния пакета и отключает ли расширение?
- Запустите основное приложение, а затем повредите приложение расширения (сделайте его недействительным, измените его подпись и т. д.)
    - Обнаруживает ли основное приложение несанкционированные изменения в расширении и принимает ли необходимые меры?
- Запустите основное приложение, а затем разверните приложение расширения с недопустимым содержимым или свойствами
    - Обнаруживает ли основное приложение недействительное содержимое и принимает ли необходимые меры?

## <a name="design-considerations"></a>Вопросы оформления

- Предоставьте пользовательский интерфейс, с помощью которого пользователь может видеть доступные расширения, а также включать и отключать их. Также можно добавить глифы для расширений, которые становятся недоступными из-за перехода пакета в автономный режим и т. д.
- Покажите пользователю, где получить расширения. Возможно, на странице расширения можно предоставить запрос поиска Microsoft Store, выводящий список расширений, которые можно использовать в вашем приложении.
- Найдите способ уведомлять пользователя о добавлении и удалении расширений. Можно создать уведомление об установке нового расширения с предложением пользователю включить его. По умолчанию расширения должны быть отключены, чтобы решение оставалось за пользователем.

## <a name="how-app-extensions-differ-from-optional-packages"></a>Отличия расширений приложений от дополнительных пакетов

Главные отличия между [дополнительными пакетами](https://docs.microsoft.com/windows/uwp/packaging/optional-packages) и расширениями приложений заключаются в отличии открытой экосистемы от закрытой и зависимого пакета от независимого.

Расширения приложений входят в состав открытой экосистемы. Если ваше приложение может размещать расширения, любой разработчик может создать расширение для вашего основного приложения при условии следования методу передачи и получения данных в расширении. Дополнительные пакеты, в свою очередь, входят в закрытую экосистему, в которой издатель решает, кому можно создать дополнительный пакет, который можно использовать в приложении.

Расширения приложений являются независимыми пакетами и могут быть отдельными приложениями. У них не может быть зависимости развертывания от другого приложения.Дополнительные пакеты требуют основной пакет и не могут запуститься без него.

Пакет расширения для игры служит хорошим примером дополнительного пакета, так как он тесно связан с игрой и не может запуститься независимо от нее. Кроме того, вы вряд ли разрешите любому разработчику в экосистеме создавать пакеты расширения.

Если в этой игре есть настраиваемые надстройки пользовательского интерфейса или темы, можно использовать расширение приложения, так как приложение, предоставляющее расширение, может работать автономно, и его может создать любой сторонний разработчик.

## <a name="remarks"></a>Примечания

В этом разделе представлены общие сведения о расширениях приложений. Важнейшие аспекты— создание основного приложения и его объявление таковым в соответствующем файле Package.appxmanifest, создание расширения и его объявление таковым в соответствующем файле Package.appxmanifest, определение способа реализации расширения (например, в виде службы приложения, фоновой задачи или иным способом), определение способа обмена данными между основным приложением и расширениями, а также использование [API-интерфейса AppExtensions](https://docs.microsoft.com/uwp/api/windows.applicationmodel.appextensions) для доступа к расширениям и управления ими.

## <a name="related-topics"></a>Статьи по теме

* [Введение в расширения приложений](https://blogs.msdn.microsoft.com/appinstaller/2017/05/01/introduction-to-app-extensions/)
* [Сеанс Build 2016, посвященный расширениям приложений](https://channel9.msdn.com/Events/Build/2016/B808)
* [Пример кода расширения приложения в Build 2016](https://github.com/Microsoft/App-Extensibility-Sample)
* [Поддержка приложения с помощью фоновых задач](support-your-app-with-background-tasks.md)
* [Создание и использование службы приложений](how-to-create-and-consume-an-app-service.md).
* [Пространство имен AppExtensions](https://docs.microsoft.com/uwp/api/windows.applicationmodel.appextensions)
* [Расширение приложения за счет служб, расширений и пакетов](https://docs.microsoft.com/windows/uwp/launch-resume/extend-your-app-with-services-extensions-packages)
