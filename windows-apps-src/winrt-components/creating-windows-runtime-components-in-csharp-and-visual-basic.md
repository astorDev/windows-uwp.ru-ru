---
author: msatranjr
title: "Создание компонентов среды выполнения Windows в C# и Visual Basic"
description: "Начиная с .NET Framework 4.5 можно создавать собственные типы среды выполнения Windows, упакованные в компонент среды выполнения Windows, с помощью управляемого кода."
ms.assetid: A5672966-74DF-40AB-B01E-01E3FCD0AD7A
ms.sourcegitcommit: 4c32b134c704fa0e4534bc4ba8d045e671c89442
ms.openlocfilehash: e8fd48b99d6a05af57e67e503c7bd3058b07569c

---

# Создание компонентов среды выполнения Windows в C# и Visual Basic


\[ Обновлено для приложений UWP в Windows10. Статьи для Windows 8.x см. в [архиве](http://go.microsoft.com/fwlink/p/?linkid=619132) \]

Начиная с .NET Framework 4.5 можно создавать собственные типы среды выполнения Windows, упакованные в компонент среды выполнения Windows, с помощью управляемого кода. Этот компонент можно использовать в приложениях универсальной платформы Windows (UWP), написанных на C++, JavaScript, Visual Basic или C#. В данной статье описываются правила создания компонента и рассматриваются некоторые аспекты поддержки среды выполнения Windows в .NET Framework. Как правило, такая поддержка разрабатывается таким образом, чтобы быть прозрачной для разработчиков .NET Framework. Однако при создании компонента, использующего JavaScript или C++, следует учитывать различия в том, как эти языки поддерживают среду выполнения Windows.

Если вы создаете компонент для использования только в приложениях UWP на Visual Basic или C#, и он не содержит элементы управления UWP, рассмотрите возможность использования шаблона **Библиотека классов** вместо шаблона **Компонент среды выполнения Windows**. У простой библиотеки классов меньше ограничений.

В данной статье содержатся следующие разделы:

## Объявление типов в компонентах среды выполнения Windows


Внутри компонента типы среды выполнения Windows могут использовать любые функции .NET Framework, разрешенные в универсальном приложении для Windows. (Дополнительные сведения см. в обзоре [Платформа .NET для приложений UWP](https://msdn.microsoft.com/library/windows/apps/xaml/mt185501.aspx).) Снаружи члены ваших типов могут предоставлять доступ только к параметрам и возвращаемым значениями типов среды выполнения Windows. В следующем списке описаны ограничения, действующие для типов .NET Framework, которые доступны в компонентах среды выполнения Windows.

-   Поля, параметры и возвращаемые значения всех открытых типов и членов в ваших компонентах должны относиться к типам среды выполнения Windows.

    Это ограничение включает типы среды выполнения Windows, которые вы создаете, а также типы, предоставляемые средой выполнения Windows. Кроме того, оно включает некоторые типы .NET Framework. Поддержка этих типов .NET Framework позволяет более естественным образом использовать среду выполнения Windows в управляемом коде: код использует привычные типы .NET Framework вместо соответствующих типов среды выполнения Windows. Например, можно использовать простые типы .NET Framework, такие как Int32 и Double, некоторые фундаментальные типы, такие как DateTimeOffset и Uri, а также некоторые часто используемые универсальные типы интерфейсов, такие как IEnumerable&lt;T&gt; (IEnumerable(Of T) в Visual Basic) и IDictionary&lt;TKey,TValue&gt;. (Обратите внимание, что аргументы этих общих типов должны представлять собой типы среды выполнения Windows.) Это описано в данной статье в разделах "Передача типов среды выполнения Windows в управляемый код" и "Передача управляемых типов в среду выполнения Windows".

-   Открытые классы и интерфейсы могут содержать методы, свойства и события. Можно объявить делегаты для событий либо использовать делегат EventHandler&lt;T&gt;. Открытые классы и интерфейсы не могут:

    -   быть универсальными;
    -   реализовывать интерфейсы, отличные от интерфейсов среды выполнения Windows. (Однако вы можете создать собственные интерфейсы среды выполнения Windows и реализовать их.);
    -   быть созданы путем наследования типов отсутствующих в среде выполнения Windows, таким как System.Exception и System.EventArgs.
-   Корневое пространство имен всех открытых типов должно совпадать с именем сборки, а имя сборки не должно начинаться на «Windows».

    > 
            **Подсказка.** По умолчанию имена пространств имен в проектах Visual Studio совпадают с именами сборок. В Visual Basic оператор Namespace для данного пространства имен по умолчанию в коде не отображается.

-   Открытые структуры не могут иметь членов, отличных от открытых полей, а эти поля должны иметь тип значения или строковый тип.
-   Открытые классы должны быть **запечатанными** (**NotInheritable** в Visual Basic). Если модель программирования требует полиморфизма, можно создать открытый интерфейс и реализовать его в классах, которые должны быть полиморфными.

## Отладка компонента


Если универсальное приложение для Windows и компонент построены с использованием управляемого кода, их можно отлаживать одновременно.

При тестировании компонента как части универсального приложения для Windows с использованием C++ можно одновременно отлаживать управляемый и машинный код. По умолчанию может отлаживаться только машинный код.

## **Одновременная отладка машинного кода C++ и управляемого кода**

1.  Откройте контекстное меню проекта Visual C++ и выберите пункт **Свойства**.
2.  На страницах свойств в разделе **Свойства конфигурации** выберите **Отладка**.
3.  Выберите **Тип отладчика** и в раскрывающемся списке измените значение **Только машинный код** на **Смешанный (управляемый и машинный)**. Нажмите кнопку **ОК**.
4.  Установите точки останова в машинном и управляемом коде.

При тестировании компонента как части универсального приложения Windows с использованием JavaScript решение по умолчанию находится в режиме отладки JavaScript. В Visual Studio невозможно отлаживать JavaScript и управляемый код одновременно.

## **Отладка управляемого кода вместо кода JavaScript**

1.  Откройте контекстное меню проекта JavaScript и выберите пункт **Свойства**.
2.  На страницах свойств в разделе **Свойства конфигурации** выберите **Отладка**.
3.  Выберите **Тип отладчика** и в раскрывающемся списке замените значение **Только скрипт** на **Только управляемый код**. Нажмите кнопку **ОК**.
4.  Установите точки останова в управляемом коде и выполните отладку обычным образом.

## Передача типов среды выполнения Windows в управляемый код


Как было сказано в разделе Объявление типов в компонентах среды выполнения Windows, некоторые типы .NET Framework могут встречаться в сигнатурах членов открытых классов. Это является частью возможностей .NET Framework, обеспечивающих естественное использование среды выполнения Windows в управляемом коде. Эти возможности включают простые типы, а также некоторые классы и интерфейсы. Когда компонент используется из JavaScript или из кода C++, важно знать, как типы .NET Framework представляются в вызывающем объекте. Примеры с JavaScript см. в разделе [ Пошаговое руководство. Создание простого компонента в C# или Visual Basic и его вызов из кода JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md). В этом разделе рассматриваются часто используемые типы.

В .NET Framework у простых типов, таких как структура Int32, имеется множество полезных свойств и методов, например метод TryParse. В среде выполнения Windows, напротив, простые типы имеют только поля. При передаче этих типов в управляемый код они представляются типами .NET Framework, и свойства и методы таких типов .NET Framework можно использовать обычным образом. В следующем списке перечислены подстановки, которые автоматически выполняются в интегрированной среде разработки:

-   вместо простых типов среды выполнения Windows Int32, Int64, Single, Double, Boolean, String (неизменяемая коллекция символов Юникода), Enum, UInt32, UInt64 и Guid используются одноименные типы из пространства имен System;
-   вместо UInt8 используется тип System.Byte;
-   вместо Char16 используется тип System.Char;
-   вместо интерфейса IInspectable используется тип System.Object.

Если в языке C# или Visual Basic имеется ключевое слово для какого-либо из этих типов, можно использовать это ключевое слово языка.

Помимо простых типов в управляемом коде в форме эквивалентов из .NET Framework используются некоторые распространенные типы среды выполнения Windows. Предположим, например, что в коде JavaScript используется класс Windows.Foundation.Uri, и соответствующий объект необходимо передать методу C# или Visual Basic. Эквивалентным типом в управляемом коде будет класс .NET Framework System.Uri, и именно он будет типом параметра метода. Можно легко понять, в каких случаях тип среды выполнения Windows представляется типом .NET Framework, поскольку при написании управляемого кода система IntelliSense в Visual Studio скрывает тип среды выполнения Windows и представляет эквивалентный тип .NET Framework. (Обычно имена таких двух типов совпадают. Но следует иметь в виду, что структура Windows.Foundation.DateTime отображается в управляемом коде как System.DateTimeOffset, а не как System.DateTime.)

Для некоторых часто используемых типов коллекций сопоставление устанавливается между интерфейсами, которые реализуются типом среды выполнения Windows, и интерфейсами, которые реализуются соответствующим типом .NET Framework. Как и в случае вышеупомянутых типов, параметры объявляются с использованием типов .NET Framework. Это позволяет скрывать некоторые различия между типами и делает написание кода .NET Framework более естественным. В следующей таблице перечислены наиболее распространенные из этих типов универсальных интерфейсов, а также другие сопоставления часто используемых классов и интерфейсов. Полный список типов среды выполнения Windows, с которыми имеется сопоставление в .NET Framework, см. в разделе "Сопоставления типов среды выполнения Windows в .NET Framework".

| Среда выполнения Windows                                  | .NET Framework                                    |
|--------------------------------------------------|---------------------------------------------------|
| IIterable&lt;T&gt;                               | IEnumerable&lt;T&gt;                              |
| IVector&lt;T&gt;                                 | IList&lt;T&gt;                                    |
| IVectorView&lt;T&gt;                             | IReadOnlyList&lt;T&gt;                            |
| IMap&lt;K, V&gt;                                 | IDictionary&lt;TKey, TValue&gt;                   |
| IMapView&lt;K, V&gt;                             | IReadOnlyDictionary&lt;TKey, TValue&gt;           |
| IKeyValuePair&lt;K, V&gt;                        | KeyValuePair&lt;TKey, TValue&gt;                  |
| IBindableIterable                                | IEnumerable                                       |
| IBindableVector                                  | IList                                             |
| Windows.UI.Xaml.Data.INotifyPropertyChanged      | System.ComponentModel.INotifyPropertyChanged      |
| Windows.UI.Xaml.Data.PropertyChangedEventHandler | System.ComponentModel.PropertyChangedEventHandler |
| Windows.UI.Xaml.Data.PropertyChangedEventArgs    | System.ComponentModel.PropertyChangedEventArgs    |

 

Если тип реализует несколько интерфейсов, в качестве типа параметра или типа возвращаемого значения члена можно использовать любой из этих интерфейсов. Например, можно передавать или возвращать тип Dictionary&lt;int, string&gt; (Dictionary(Of Integer, String) в Visual Basic) в качестве типа IDictionary&lt;int, string&gt;, IReadOnlyDictionary&lt;int, string&gt; или IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;&gt;.


            **Важно!** В коде JavaScript используется интерфейс, занимающий первую позицию в списке интерфейсов, реализуемых управляемым типом. Например, если в код JavaScript возвращается тип Dictionary&lt;int, string&gt;, он отображается как IDictionary&lt;int, string&gt; независимо от того, какой интерфейс указан в качестве типа возвращаемого значения. Это означает, что если первый интерфейс не включает элемент, который отображается в последующих интерфейсах, этот элемент не будет видимым в JavaScript.

В среде выполнения Windows перебор IMap&lt;K, V&gt; и IMapView&lt;K, V&gt; осуществляется с помощью IKeyValuePair. При передаче этих типов в управляемый код они отображаются как IDictionary&lt;TKey, TValue&gt; и IReadOnlyDictionary&lt;TKey, TValue&gt;, поэтому чтобы перечислить их, можно использовать тип System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;.

Представление интерфейсов в управляемом коде влияет на представление типов, реализующих эти интерфейсы. Например, класс PropertySet реализует IMap&lt;K, V&gt;, который представлен в управляемом коде в качестве типа IDictionary&lt;TKey, TValue&gt;. PropertySet отображается как реализующий тип IDictionary&lt;TKey, TValue&gt; вместо IMap&lt;K, V&gt;, поэтому в управляемом коде у него присутствует метод Add, который ведет себя как метод Add в словарях .NET Framework. А метод Insert у этого типа отсутствует. Этот пример представлен в статье [Пошаговое руководство. Создание простого компонента в C# или Visual Basic и его вызов из кода JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).

## Передача управляемых типов в среду выполнения Windows


Как было описано в предыдущем разделе, некоторые типы среды выполнения Windows могут представляться типами .NET Framework в сигнатурах методов компонентов или в сигнатурах членов среды выполнения Windows при их использовании в интегрированной среде разработки. При передаче типов .NET Framework в эти члены или использовании их в качестве возвращаемых значений в членах компонентов они представляются на другой стороне как соответствующие типы среды выполнения Windows. Примеры последствий вызова компонента из кода JavaScript см. в разделе "Возвращение управляемых типов из компонента" статьи [Пошаговое руководство. Создание простого компонента в C# или Visual Basic и его вызов из кода JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).

## Перегруженные методы


В среде выполнения Windows методы можно перегружать. Однако если объявляется несколько перегруженных методов с одинаковым количеством параметров, необходимо применить атрибут [Windows.Foundation.Metadata.DefaultOverloadAttribute](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.defaultoverloadattribute.aspx) только к одной из этих перегрузок. Это будет единственная перегрузка, которую можно вызывать из JavaScript. Например, в следующем коде перегрузка, которая принимает значение **int** (**Integer** в Visual Basic), является перегрузкой по умолчанию.

> [!div class="tabbedCodeSnippets"]
> ```csharp
> public string OverloadExample(string s)
> {
>     return s;
> }
> [Windows.Foundation.Metadata.DefaultOverload()]
> public int OverloadExample(int x)
> {
>     return x;
> }
> ```
> ```vb
> Public Function OverloadExample(ByVal s As String) As String
>     Return s
> End Function
> <Windows.Foundation.Metadata.DefaultOverload> _
> Public Function OverloadExample(ByVal x As Integer) As Integer
>     Return x
> End Function
> ```

 [!div class="tabbedCodeSnippets"] 
            **Внимание!** JavaScript позволяет передавать в OverloadExample любое значение и приводит это значение к типу, который требуется параметром. Можно вызвать OverloadExample со значением "forty-two", "42" или 42.3, но все они будут переданы перегруженному методу по умолчанию.

В предыдущем примере перегруженный метод по умолчанию возвращает значения 0, 42 и 42 соответственно. Нельзя применять атрибут DefaultOverloadAttribute к конструкторам.

## Все конструкторы в классе должны иметь различное число параметров.


Реализация IStringable Начиная с Windows 8,1 среда выполнения Windows включает интерфейс IStringable, единственный метод которого, IStringable.ToString, обеспечивает базовую поддержку форматирования, сравнимую с методом Object.ToString.

-   Если вы решите реализовывать IStringable в общем управляемом типе, экспортированном в компонент среды выполнения Windows, применяются следующие ограничения:

    ```cs
    public class NewClass : IStringable
    ```

    Интерфейс IStringable можно определить только в отношении "class implements", как в следующем коде С#:

    ```vb
    Public Class NewClass : Implements IStringable
    ```

-   или в следующем коде Visual Basic:
-   Нельзя реализовать IStringable в интерфейсе.
-   Нельзя объявить параметр типа IStringable.
-   IStringable не может быть возвращаемым типом метода, свойства или поля.

    ```cs
    public class NewClass : IStringable
    {
       public new string ToString()
       {
          return "New ToString in NewClass";
       }
    }
    ```

    Нельзя скрывать реализацию IStringable от базовых классов с помощью определения метода, как, например, показано ниже: Вместо этого реализация IStringable.ToString должна всегда переопределять реализацию базового класса.

Реализацию ToString можно скрыть только путем вызова этого метода в строго типизированном экземпляре класса.

## Следует учитывать, что в самых разных случаях вызовы из машинного кода в управляемый тип, реализующий IStringable или скрывающий свою реализацию ToString, могут привести к неожиданному поведению.


Асинхронные операции

Чтобы реализовать асинхронный метод в компоненте, добавьте "Async" в конце имени метода и верните один из интерфейсов среды выполнения Windows, которые представляют асинхронные действия и операции: IAsyncAction, IAsyncActionWithProgress&lt;TProgress&gt;, IAsyncOperation&lt;TResult&gt; или IAsyncOperationWithProgress&lt;TResult, TProgress&gt;. Для реализации асинхронных методов можно использовать задачи .NET Framework (класс [Task](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) и универсальный класс [Task&lt;TResult&gt;](https://msdn.microsoft.com/library/dd321424.aspx)). Необходимо вернуть задачу, которая представляет текущую операцию, например задачу, возвращаемую из асинхронного метода, который написан на C# или Visual Basic, или задачу, возвращаемую из метода [Task.Run](https://msdn.microsoft.com/library/system.threading.tasks.task.run.aspx).

При создании задачи с помощью конструктора необходимо перед возвращением задачи вызвать метод [Task.Start](https://msdn.microsoft.com/library/system.threading.tasks.task.start.aspx). Метод, который использует await (Await в Visual Basic), требует ключевого слова **async** (**Async** в Visual Basic).

Если такой метод предоставляется компонентом среды выполнения Windows, ключевое слово **async** следует применять к делегату, передаваемому в метод Run. Для асинхронных действий и операций, которые не поддерживают отчеты об отмене или ходе выполнения, можно использовать метод расширения [WindowsRuntimeSystemExtensions.AsAsyncAction](https://msdn.microsoft.com/library/system.windowsruntimesystemextensions.asasyncaction.aspx) или [AsAsyncOperation&lt;TResult&gt;](https://msdn.microsoft.com/library/hh779745.aspx), чтобы заключить задачу в соответствующий интерфейс. Например, следующий код реализует асинхронный метод с помощью метода Task.Run&lt;TResult&gt;, запускающего задачу.

> [!div class="tabbedCodeSnippets"]
> ```csharp
> public static IAsyncOperation<IList<string>> DownloadAsStringsAsync(string id)
> {
>     return Task.Run<IList<string>>(async () =>
>     {
>         var data = await DownloadDataAsync(id);
>         return ExtractStrings(data);
>     }).AsAsyncOperation();
> }
> ```
> ```vb
> Public Shared Function DownloadAsStringsAsync(ByVal id As String) _
>      As IAsyncOperation(Of IList(Of String))
>
>     Return Task.Run(Of IList(Of String))(
>         Async Function()
>             Dim data = Await DownloadDataAsync(id)
>             Return ExtractStrings(data)
>         End Function).AsAsyncOperation()
> End Function
> ```

Метод расширения AsAsyncOperation&lt;TResult&gt; возвращает задачу в качестве асинхронной операции среды выполнения Windows. [!div class="tabbedCodeSnippets"] Следующий код JavaScript показывает, как можно вызывать метод с помощью объекта [WinJS.Promise](https://msdn.microsoft.com/library/windows/apps/br211867.aspx).

```javascript
function asyncExample(id) {

    var result = SampleComponent.Example.downloadAsStringAsync(id).then(
        function (stringList) {
            // Place code that uses the returned list of strings here.
        });
}
```

Функция, которая передается методу then, выполняется при завершении асинхронного вызова. Параметр stringList содержит список строк, возвращаемый методом DownloadAsStringAsync, а функция выполняет все необходимые действия по обработке.

Для асинхронных действий и операций, которые поддерживают отчеты об отмене и ходе выполнения, следует с помощью класса [AsyncInfo](https://msdn.microsoft.com/library/system.runtime.interopservices.windowsruntime.asyncinfo.aspx) создавать запущенную задачу и реализовывать функции отчетов об отмене и ходе выполнения с помощью аналогичных функций соответствующего интерфейса среды выполнения Windows. Пример, в котором реализована поддержка отчетов об отмене и ходе выполнения, см. в статье [Пошаговое руководство. Создание простого компонента в C# или Visual Basic и его вызов из кода JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md). Обратите внимание, что методы класса AsyncInfo можно использовать даже в том случае, если асинхронный метод не поддерживает отчеты об отмене и ходе выполнения. При использовании лямбда-функции Visual Basic или анонимного метода C# не указывайте параметры токена и интерфейса [IProgress&lt;T&gt;](https://msdn.microsoft.com/library/hh138298.aspx).

> [!div class="tabbedCodeSnippets"]
> ```csharp
> public static IAsyncOperation<IList<string>> DownloadAsStringsAsync(string id)
> {
>     return AsyncInfo.Run<IList<string>>(async (token) =>
>     {
>         var data = await DownloadDataAsync(id);
>         return ExtractStrings(data);
>     });
> }
> ```
> ```vb
> Public Shared Function DownloadAsStringsAsync(ByVal id As String) _
>     As IAsyncOperation(Of IList(Of String))
>
>     Return AsyncInfo.Run(Of IList(Of String))(
>         Async Function()
>             Dim data = Await DownloadDataAsync(id)
>             Return ExtractStrings(data)
>         End Function)
> End Function
> ```

При использовании лямбда-функции C# указывайте параметр токена, но игнорируйте его.

## Предыдущий пример, в котором используется метод AsAsyncOperation&lt;TResult&gt;, будет выглядеть следующим образом, если вместо этого использовать перегрузку метода [AsyncInfo.Run&lt;TResult&gt;(Func&lt;CancellationToken, Task&lt;TResult&gt;&gt;](https://msdn.microsoft.com/library/hh779740.aspx)).


[!div class="tabbedCodeSnippets"] При создании асинхронного метода, который может поддерживать отчеты об отмене и ходе выполнения, попробуйте добавить перегруженные версии без параметров токена отмены или интерфейса IProgress&lt;T&gt;.

Создание исключений Можно создавать исключения любого типа, включенного в .NET для приложений для Windows.

-   В компоненте среды выполнения Windows нельзя объявлять собственные открытые типы исключений, но можно объявлять и создавать неоткрытые типы. Если компонент не обрабатывает исключение, соответствующее исключение передается в код, который вызвал данный компонент. Представление этого исключения на вызывающей стороне зависит от того, каким образом язык вызова поддерживает среду выполнения Windows.

    > В JavaScript исключение представляется объектом, в котором сообщение исключения заменено на трассировку стека. При отладке приложения в Visual Studio исходный текст сообщения можно видеть в диалоговом окне исключений отладчика с пометкой "Сведения WinRT".

-   Исходный текст сообщения недоступен из кода JavaScript. 
            **Подсказка**. В настоящее время трассировка стека содержит тип управляемого исключения, однако анализировать трассировку для определения типа исключения не рекомендуется. Вместо этого лучше использовать значение HRESULT, описанное далее в этом разделе. В C++ исключение является исключением платформы. Если свойство HResult управляемого исключения может быть сопоставлено значению HRESULT конкретного исключения платформы, то используется конкретное исключение; в противном случае создается исключение [Platform::COMException](https://msdn.microsoft.com/library/windows/apps/xaml/hh710414.aspx).
-   Текст сообщения управляемого исключения недоступен в коде C++.

Если было создано конкретное исключение платформы, отображается текст сообщения по умолчанию для этого типа исключений; в противном случае текст не отображается. См. статью [Исключения (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh699896.aspx).

> В C# и Visual Basic используется обычное управляемое исключение. При создании в компоненте исключения можно упростить его обработку в вызывающем коде JavaScript или C++, если создавать исключения неоткрытых типов, свойство HResult которых связано с конкретным компонентом.

## Значение HRESULT доступно в вызывающем коде JavaScript через свойство number объекта исключения, а в коде C++ — через свойство [COMException::HResult](https://msdn.microsoft.com/library/windows/apps/xaml/hh710415.aspx).


            **Примечание.** Используйте для HRESULT отрицательное значение. Положительное значение интерпретируется как успех, и исключение в вызывающем коде JavaScript или C++ не создается. Объявление и вызов событий

При объявлении типа, в котором будут храниться данные вашего события, создавайте класс, производный от Object, а не от EventArgs, поскольку EventArgs не является типом среды выполнения Windows. Используйте [EventHandler&lt;TEventArgs&gt;](https://msdn.microsoft.com/library/db0etb8x.aspx) в качестве типа события и тип аргумента события в качестве аргумента универсального типа. Вызов событий осуществляется так же, как и в приложениях .NET Framework.

Когда компонент среды выполнения Windows вызывается из JavaScript или C++, событие выполняется в соответствии с шаблоном событий среды выполнения Windows, ожидаемым этими языками. Когда компонент вызывается из C# или Visual Basic, событие представляется обычным событием .NET Framework. Пример приведен в статье [Пошаговое руководство. Создание простого компонента в C# или Visual Basic и его вызов из кода JavaScript]().

## При реализации пользовательских методов доступа к событиям (событие объявляется с ключевым словом **Custom** в Visual Basic) в такой реализации необходимо соблюдать шаблон событий среды выполнения Windows.


См. раздел [Пользовательские события и методы доступа к событиям в компонентах среды выполнения Windows](custom-events-and-event-accessors-in-windows-runtime-components.md). Обратите внимание, что при обработке события в коде C# или Visual Basic оно все равно представляется обычным событием .NET Framework. Дальнейшие действия

После создания компонента среды выполнения Windows для собственного использования вы можете обнаружить, что заключенная в нем функциональность будет полезна и другим разработчикам.

## Есть два способа упаковки компонента для распространения среди других разработчиков.

* [См. раздел [Распространение управляемого компонента среды выполнения Windows](https://msdn.microsoft.com/library/jj614475.aspx).](https://msdn.microsoft.com/library/windows/apps/xaml/br230302.aspx)
* [Дополнительные сведения о функциях языка Visual Basic и C# и поддержке платформой .NET Framework среды выполнения Windows можно найти в статье [Справочник по языкам Visual Basic и C#](https://msdn.microsoft.com/library/windows/apps/xaml/br212458.aspx).](https://msdn.microsoft.com/library/windows/apps/xaml/mt185501.aspx)
* [Связанные разделы](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)



<!--HONumber=Jun16_HO5-->


