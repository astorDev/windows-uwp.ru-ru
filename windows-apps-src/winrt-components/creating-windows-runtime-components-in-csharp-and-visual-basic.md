---
title: Среда выполнения Windows компонентов с C# и Visual Basic
description: Начиная с .NET 4,5, можно использовать управляемый код для создания собственных типов среда выполнения Windows, упакованных в компонент среда выполнения Windows.
ms.assetid: A5672966-74DF-40AB-B01E-01E3FCD0AD7A
ms.date: 12/04/2018
ms.topic: article
dev_langs:
- csharp
- vb
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 351d59cbecd0941cdc6218d02672b2a679cf3fce
ms.sourcegitcommit: d38e2f31c47434cd6dbbf8fe8d01c20b98fabf02
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/06/2019
ms.locfileid: "70393728"
---
# <a name="windows-runtime-components-with-c-and-visual-basic"></a>Среда выполнения Windows компонентов с C# и Visual Basic

Управляемый код можно использовать для создания собственных типов среда выполнения Windows и их упаковки в среда выполнения Windows компонент. Компонент можно использовать в приложениях универсальная платформа Windows (UWP), написанных на C++языках, JavaScript, Visual Basic или. C# В этом разделе описываются правила создания компонента и обсуждаются некоторые аспекты поддержки .NET для среда выполнения Windows. Как правило, поддержка является прозрачной для программиста .NET. Однако при создании компонента, использующего JavaScript или C++, следует учитывать различия в том, как эти языки поддерживают среду выполнения Windows.

Если вы создаете компонент для использования только в приложениях UWP, написанных на Visual Basic или C#, а компонент не содержит элементов управления UWP, то сначала используйте шаблон **библиотеки классов** вместо проекта **компонента Среда выполнения Windows** . шаблон в Microsoft Visual Studio. У простой библиотеки классов меньше ограничений.

## <a name="declaring-types-in-windows-runtime-components"></a>Объявление типов в компонентах среда выполнения Windows

На внутреннем уровне среда выполнения Windows типы в компоненте могут использовать любые функции .NET, разрешенные в приложении UWP. Дополнительные сведения см. в разделе [.NET для приложений UWP](https://docs.microsoft.com/dotnet/api/index?view=dotnet-uwp-10.0).

Внешние члены типов могут предоставлять только типы среда выполнения Windows для их параметров и возвращаемых значений. В следующем списке описаны ограничения на типы .NET, предоставляемые из компонента среда выполнения Windows.

- Поля, параметры и возвращаемые значения всех открытых типов и членов в ваших компонентах должны относиться к типам среды выполнения Windows. Это ограничение включает в себя созданные вами типы среда выполнения Windows, а также типы, предоставляемые среда выполнения Windows. Он также включает несколько типов .NET. Включение этих типов является частью поддержки, предоставляемой .NET для того, чтобы обеспечить естественное использование среда выполнения Windows в управляемом коде&mdash;, когда код кажется использовать знакомые типы .NET вместо базовых типов Среда выполнения Windows. Например, можно использовать примитивные типы .NET, такие как **Int32** и **Double**, определенные фундаментальные типы, такие как **DateTimeOffset** и **URI**, и некоторые часто используемые универсальные типы интерфейса, такие как **&lt;IEnumerable T.&gt;** (IEnumerable (Of T) в Visual Basic) и **IDictionary&lt;TKey, TValue&gt;** . Обратите внимание, что аргументы типа для этих универсальных типов должны быть среда выполнения Windows типами. Это описано в разделах [передача типов Среда выполнения Windows в управляемый код](#passing-windows-runtime-types-to-managed-code) и [передача управляемых типов в среда выполнения Windows](#passing-managed-types-to-the-windows-runtime)далее в этом разделе.

- Открытые классы и интерфейсы могут содержать методы, свойства и события. Можно объявить делегаты для событий или воспользоваться делегатом **EventHandler&lt;T&gt;**  . Открытый класс или интерфейс не могут:
    - быть универсальными;
    - Реализуйте интерфейс, который не является интерфейсом среда выполнения Windows (Однако можно создавать собственные интерфейсы среда выполнения Windows и реализовывать их).
    - Наследовать от типов, которые не находятся в среда выполнения Windows, таких как **System. Exception** и **System. EventArgs**.

- Корневое пространство имен всех открытых типов должно совпадать с именем сборки, а имя сборки не должно начинаться на «Windows».

    > **Совет**. По умолчанию в проектах Visual Studio имена пространств имен совпадают с именами сборок. В Visual Basic оператор Namespace для данного пространства имен по умолчанию в коде не отображается.

- Открытые структуры не могут иметь членов, отличных от открытых полей, а эти поля должны иметь тип значения или строковый тип.
- Открытые классы должны быть **запечатанными** (**NotInheritable** в Visual Basic). Если для модели программирования требуется полиморфизм, можно создать открытый интерфейс и реализовать этот интерфейс в классах, которые должны быть превышены.

## <a name="debugging-your-component"></a>Отладка компонента

Если приложение UWP и компонент построены с помощью управляемого кода, их можно отлаживать одновременно.

При тестировании компонента в составе приложения UWP с помощью C++можно одновременно выполнять отладку управляемого и машинного кода. По умолчанию может отлаживаться только машинный код.

## <a name="to-debug-both-native-c-code-and-managed-code"></a>Одновременная отладка машинного кода C++ и управляемого кода
1.  Откройте контекстное меню проекта Visual C++ и выберите пункт **Свойства**.
2.  На страницах свойств в разделе **Свойства конфигурации** выберите **Отладка**.
3.  Выберите **Тип отладчика** и в раскрывающемся списке измените значение **Только машинный код** на **Смешанный (управляемый и машинный)** . Нажмите кнопку **ОК**.
4.  Установите точки останова в машинном и управляемом коде.

При тестировании компонента как части приложения UWP, использующего JavaScript, по умолчанию решение находится в режиме отладки JavaScript. В Visual Studio невозможно отлаживать JavaScript и управляемый код одновременно.

## <a name="to-debug-managed-code-instead-of-javascript"></a>Отладка управляемого кода вместо кода JavaScript
1.  Откройте контекстное меню проекта JavaScript и выберите пункт **Свойства**.
2.  На страницах свойств в разделе **Свойства конфигурации** выберите **Отладка**.
3.  Выберите **Тип отладчика** и в раскрывающемся списке замените значение **Только скрипт** на **Только управляемый код**. Нажмите кнопку **ОК**.
4.  Установите точки останова в управляемом коде и выполните отладку обычным образом.

## <a name="passing-windows-runtime-types-to-managed-code"></a>Передача типов среды выполнения Windows в управляемый код
Как упоминалось ранее в разделе [объявление типов в среда выполнения Windows компонентах](#declaring-types-in-windows-runtime-components), некоторые типы .NET могут отображаться в сигнатурах членов открытых классов. Это является частью поддержки, предоставляемой .NET, чтобы обеспечить естественное использование среда выполнения Windows в управляемом коде. Эти возможности включают простые типы, а также некоторые классы и интерфейсы. Если компонент используется из JavaScript или из C++ кода, важно иметь представление о том, как типы .NET отображаются вызывающему объекту. Примеры использования JavaScript см. в разделе [Пошаговое руководство C# по созданию компонента Visual Basic среда выполнения Windows и его вызов из JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md) . В этом разделе рассматриваются часто используемые типы.

В .NET примитивные типы, такие как структура **Int32** , имеют много полезных свойств и методов, таких как метод **TryParse** . В среде выполнения Windows, напротив, простые типы имеют только поля. При передаче этих типов в управляемый код они выглядят как типы .NET, и вы можете использовать свойства и методы типов .NET, как обычно. В следующем списке перечислены подстановки, которые автоматически выполняются в интегрированной среде разработки:

-   Для среда выполнения Windows примитивов **Int32**, **Int64**, **Single**, **Double**, **Boolean**, **String** (неизменяемая коллекция символов Юникода), **enum**, **UInt32**, **UInt64**и **GUID** , используйте тип с тем же именем в пространстве имен System.
-   Для **Uint8**используйте **System. Byte**.
-   Для **Char16**используйте **System. Char**.
-   Для интерфейса **IInspectable** используйте **System. Object**.

Если C# или Visual Basic предоставляет ключевое слово языка для любого из этих типов, вместо него можно использовать ключевое слово Language.

Помимо типов-примитивов, некоторые основные, часто используемые среда выполнения Windows типы отображаются в управляемом коде в качестве их эквивалентов .NET. Например, предположим, что код JavaScript использует класс **Windows. Foundation. URI** и вы хотите передать его в метод C# или Visual Basic. Эквивалентный тип в управляемом коде — это класс **System. URI** .NET, который используется для параметра метода. Можно указать, когда тип среда выполнения Windows отображается как тип .NET, поскольку IntelliSense в Visual Studio скрывает тип среда выполнения Windows при написании управляемого кода и представляет эквивалентный тип .NET. (Обычно имена таких двух типов совпадают. Однако обратите внимание, что структура **Windows. Foundation. DateTime** отображается в управляемом коде как **System. DateTimeOffset** , а не как **System. DateTime**.)

Для некоторых часто используемых типов коллекций сопоставление осуществляется между интерфейсами, которые реализуются типом среда выполнения Windows и интерфейсами, реализуемыми соответствующим типом .NET. Как и в упомянутых выше типах, типы параметров объявляются с помощью типа .NET. Это скрывает некоторые различия между типами и делает написание кода .NET более естественным.

В следующей таблице перечислены наиболее распространенные из этих типов универсальных интерфейсов, а также другие сопоставления часто используемых классов и интерфейсов. Полный список типов среда выполнения Windows, которые сопоставлены с .NET, см. в разделе [сопоставления .NET типов Среда выполнения Windows](net-framework-mappings-of-windows-runtime-types.md).

| Среда выполнения Windows                                  | .NET                                    |
|-|-|
| Иитерабле&lt;T&gt;                               | IEnumerable&lt;T&gt;                              |
| IVector&lt;T&gt;                                 | IList&lt;T&gt;                                    |
| IVectorView&lt;T&gt;                             | Иреадонлилист&lt;T&gt;                            |
| IMAP&lt;K, V&gt;                                 | IDictionary&lt;TKey, TValue&gt;                   |
| IMapView&lt;K, V&gt;                             | IReadOnlyDictionary&lt;TKey, TValue&gt;           |
| IKeyValuePair&lt;K, V&gt;                        | KeyValuePair&lt;TKey, TValue&gt;                  |
| IBindableIterable                                | IEnumerable                                       |
| IBindableVector                                  | IList                                             |
| Windows.UI.Xaml.Data.INotifyPropertyChanged      | System.ComponentModel.INotifyPropertyChanged      |
| Windows.UI.Xaml.Data.PropertyChangedEventHandler | System.ComponentModel.PropertyChangedEventHandler |
| Windows.UI.Xaml.Data.PropertyChangedEventArgs    | System.ComponentModel.PropertyChangedEventArgs    |

Если тип реализует несколько интерфейсов, в качестве типа параметра или типа возвращаемого значения члена можно использовать любой из этих интерфейсов. Например, можно передать или вернуть **словарь&lt;int, String&gt;**  (**словарь (целое число, строка)** в Visual Basic) как **IDictionary&lt;int, String&gt;** , **IReadOnlyDictionary int,String&gt;или IEnumerable System. Collections. Generic. KeyValuePair TKey, TValue. &lt;** **&gt;&gt;&lt;&lt;**

> [!IMPORTANT]
> JavaScript использует интерфейс, который отображается первым в списке интерфейсов, реализуемых управляемым типом. Например, если вы возвращаете **словарь&lt;int, String&gt;**  в код JavaScript, **&gt; он отображается как IDictionary&lt;int,** а не вне зависимости от того, какой интерфейс указан в качестве возвращаемого типа. Это означает, что если первый интерфейс не включает элемент, который отображается в последующих интерфейсах, этот элемент не будет видимым в JavaScript.

В среда выполнения Windows, **&lt;IMAP k,&gt; v** и **IMapView&lt;K&gt;**  просматриваются с помощью IKeyValuePair. При передаче в управляемый код они отображаются как **IDictionary&lt;TKey, TValue&gt;**  и **IReadOnlyDictionary&lt;TKey, TValue&gt;** , поэтому естественно использовать  **System. Collections. Generic.&lt;KeyValuePair TKey,&gt; TValue** для перечисления.

Представление интерфейсов в управляемом коде влияет на представление типов, реализующих эти интерфейсы. Например, класс **свойств** реализует **IMAP&lt;K&gt;, V**, который отображается в управляемом коде как **IDictionary&lt;TKey, TValue.&gt;** Набор **свойств** выглядит так, как если бы он реализовал **&lt;IDictionary&gt; TKey, TValue** вместо **IMAP&lt;K&gt;, V**, поэтому в управляемом коде он выглядит как метод **Add** , который ведет себя как и метод **Add** в словарях .NET. Он не имеет метода **INSERT** . Этот пример можно увидеть в разделе [Пошаговое руководство по созданию C# компонента Visual Basic среда выполнения Windows и его вызову из JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).

## <a name="passing-managed-types-to-the-windows-runtime"></a>Передача управляемых типов в среду выполнения Windows

Как обсуждалось в предыдущем разделе, некоторые типы среда выполнения Windows могут отображаться в виде типов .NET в сигнатурах членов компонента или в сигнатурах среда выполнения Windows членов при их использовании в интегрированной среде разработки. При передаче типов .NET для этих элементов или их использовании в качестве возвращаемых значений членов компонента они отображаются в коде на другой стороне в качестве соответствующего типа среда выполнения Windows. Примеры эффектов, которые могут иметься при вызове компонента из JavaScript, см. в подразделе «возвращение управляемых типов из компонента» раздела [Пошаговое руководство по C# созданию компонента Visual Basic среда выполнения Windows и его вызову из JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).

## <a name="overloaded-methods"></a>Перегруженные методы

В среде выполнения Windows методы можно перегружать. Однако при объявлении нескольких перегрузок с одинаковым количеством параметров необходимо применить атрибут [**Windows. Foundation. Metadata. DefaultOverloadAttribute**](/uwp/api/windows.foundation.metadata.defaultoverloadattribute) только к одной из этих перегрузок. Это будет единственная перегрузка, которую можно вызывать из JavaScript. Например, в следующем коде перегрузка, которая принимает значение **int** (**Integer** в Visual Basic), является перегрузкой по умолчанию.

```csharp
public string OverloadExample(string s)
{
    return s;
}

[Windows.Foundation.Metadata.DefaultOverload()]
public int OverloadExample(int x)
{
    return x;
}
```

```vb
Public Function OverloadExample(ByVal s As String) As String
    Return s
End Function

<Windows.Foundation.Metadata.DefaultOverload> _
Public Function OverloadExample(ByVal x As Integer) As Integer
    Return x
End Function
```

> СУЩЕСТВЕННО JavaScript позволяет передавать любое значение в **оверлоадексампле**и приводит значение к типу, который требуется для параметра. Можно вызвать **оверлоадексампле** с "42", "42" или 42,3, но все эти значения передаются в перегрузку по умолчанию. Перегрузка по умолчанию в предыдущем примере возвращает 0, 42 и 42 соответственно.

К конструкторам нельзя применять атрибут **дефаултоверлоадаттрибут**e. Все конструкторы в классе должны иметь различное число параметров.

## <a name="implementing-istringable"></a>Реализация IStringable

Начиная с Windows 8.1, среда выполнения Windows содержит интерфейс **IStringable** , единственный метод которого **IStringable. ToString**обеспечивает базовую поддержку форматирования, сравнимую с, обеспечиваемую **объектом Object. ToString**. Если вы решили реализовать **IStringable** в общедоступном управляемом типе, экспортированном в среда выполнения Windows компоненте, применяются следующие ограничения.

-   Интерфейс **IStringable** можно определить только в связи «класс реализует», как в C#следующем коде:

    ```cs
    public class NewClass : IStringable
    ```

    или в следующем коде Visual Basic:

    ```vb
    Public Class NewClass : Implements IStringable
    ```

-   Невозможно реализовать **IStringable** в интерфейсе.
-   Нельзя объявить параметр типа **IStringable**.
-   **IStringable** не может быть типом возвращаемого значения метода, свойства или поля.
-   Невозможно скрыть реализацию **IStringable** из базовых классов с помощью определения метода, как показано ниже:

    ```cs
    public class NewClass : IStringable
    {
       public new string ToString()
       {
          return "New ToString in NewClass";
       }
    }
    ```

    Вместо этого реализация **IStringable. ToString** должна всегда переопределять реализацию базового класса. Можно скрыть реализацию **ToString** , вызвав ее в строго типизированном экземпляре класса.

> [!NOTE]
> При различных условиях вызовы из машинного кода в управляемый тип, реализующий **IStringable** или скрывая его реализацию **ToString** , могут привести к непредвиденному поведению.

## <a name="asynchronous-operations"></a>Асинхронные операции

Чтобы реализовать асинхронный метод в компоненте, добавьте "Async" в конец имени метода и возвратите один из среда выполнения Windows интерфейсов, представляющих асинхронные действия или операции: **IAsyncAction**, **IAsyncActionWithProgress&lt;TProgress&gt;** , **IAsyncOperation&lt;TResultили&gt;** **IAsyncOperationWithProgressTResult,&lt;TProgress &gt;** .

Для реализации асинхронного метода можно использовать задачи .NET (класс [**Task**](/dotnet/api/system.threading.tasks.task) и класс "базовый" [**задачи&lt;TResult&gt;** ](/dotnet/api/system.threading.tasks.task-1) ). Необходимо вернуть задачу, которая представляет текущую операцию, например задачу, возвращаемую асинхронным методом, написанным на C# или Visual Basic, или задачу, возвращаемую методом [Task. Run](/dotnet/api/system.threading.tasks.task.run) . При создании задачи с помощью конструктора необходимо перед возвращением задачи вызвать метод [Task.Start](/dotnet/api/system.threading.tasks.task.start).

Для метода `await` , использующего`Await` (в Visual Basic), `async` требуется ключевое слово (`Async` в Visual Basic). Если вы предоставляете такой метод из среда выполнения Windows компонента, примените `async` ключевое слово к делегату, который передается в метод **Run** .

Для асинхронных действий и операций, которые не поддерживают отчеты об отмене или ходе выполнения, можно использовать метод расширения [WindowsRuntimeSystemExtensions.AsAsyncAction](https://docs.microsoft.com/dotnet/api/system?redirectedfrom=MSDN) или [AsAsyncOperation&lt;TResult&gt;](https://docs.microsoft.com/dotnet/api/system?redirectedfrom=MSDN), чтобы заключить задачу в соответствующий интерфейс. Например, следующий код реализует асинхронный метод с помощью метода **Task. Run&lt;&gt; TResult** для запуска задачи. Метод **расширения&lt;асасинкоператион&gt; TResult** возвращает задачу в виде асинхронной операции среда выполнения Windows.

```csharp
public static IAsyncOperation<IList<string>> DownloadAsStringsAsync(string id)
{
    return Task.Run<IList<string>>(async () =>
    {
        var data = await DownloadDataAsync(id);
        return ExtractStrings(data);
    }).AsAsyncOperation();
}
```

```vb
Public Shared Function DownloadAsStringsAsync(ByVal id As String) _
     As IAsyncOperation(Of IList(Of String))

    Return Task.Run(Of IList(Of String))(
        Async Function()
            Dim data = Await DownloadDataAsync(id)
            Return ExtractStrings(data)
        End Function).AsAsyncOperation()
End Function
```

В следующем коде JavaScript показано, как можно вызвать метод с помощью объекта [**WinJS. Promise**](https://docs.microsoft.com/previous-versions/windows/apps/br211867(v=win.10)) . Функция, которая передается методу then, выполняется при завершении асинхронного вызова. Параметр Стринглист содержит список строк, возвращаемых методом **довнлоадасстрингасинк** , а функция выполняет необходимую обработку.

```javascript
function asyncExample(id) {

    var result = SampleComponent.Example.downloadAsStringAsync(id).then(
        function (stringList) {
            // Place code that uses the returned list of strings here.
        });
}
```

Для асинхронных действий и операций, которые поддерживают отчеты об отмене или состоянии, используйте класс [**асинЦинфо**](/dotnet/api/system.runtime.interopservices.windowsruntime) для создания запущенной задачи и для подключения функций отчетов об отмене и ходе выполнения задачи с отменой и ходом выполнения. функции создания отчетов соответствующего интерфейса среда выполнения Windows. Пример, поддерживающий как отмену, так и отчеты о ходе выполнения, см. в разделе [Пошаговое руководство C# по созданию компонента Visual Basic среда выполнения Windows и его вызов из JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).

Обратите внимание, что методы класса **асинЦинфо** можно использовать, даже если асинхронный метод не поддерживает отчеты об отмене или ходе выполнения. При использовании Visual Basic лямбда-функции или C# анонимного метода не указывайте параметры для интерфейса Token и [ипрогресс&lt;t.&gt; ](https://docs.microsoft.com/dotnet/api/system.iprogress-1?redirectedfrom=MSDN) При использовании лямбда-функции C# указывайте параметр токена, но игнорируйте его. Предыдущий пример, в котором использовался метод&lt;асасинкоператион&gt; TResult, выглядит следующим образом при использовании [**асинЦинфо. Run&lt;TResult&gt;(Func&lt;CancellationToken, Task&lt;TResult)вместоэтогометодаперегрузки&gt;&gt;** ](https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.windowsruntime?redirectedfrom=MSDN).

```csharp
public static IAsyncOperation<IList<string>> DownloadAsStringsAsync(string id)
{
    return AsyncInfo.Run<IList<string>>(async (token) =>
    {
        var data = await DownloadDataAsync(id);
        return ExtractStrings(data);
    });
}
```

```vb
Public Shared Function DownloadAsStringsAsync(ByVal id As String) _
    As IAsyncOperation(Of IList(Of String))

    Return AsyncInfo.Run(Of IList(Of String))(
        Async Function()
            Dim data = Await DownloadDataAsync(id)
            Return ExtractStrings(data)
        End Function)
End Function
```

При создании асинхронного метода, который дополнительно поддерживает отчеты об отмене или ходе выполнения, рассмотрите возможность добавления перегрузок без параметров для токена отмены **или&lt;ипрогресс&gt; t** -интерфейса.

## <a name="throwing-exceptions"></a>Создание исключений

Можно создавать исключения любого типа, включенного в .NET для приложений для Windows. В компоненте среды выполнения Windows нельзя объявлять собственные открытые типы исключений, но можно объявлять и создавать неоткрытые типы.

Если компонент не обрабатывает исключение, соответствующее исключение передается в код, который вызвал данный компонент. Представление этого исключения на вызывающей стороне зависит от того, каким образом язык вызова поддерживает среду выполнения Windows.

-   В JavaScript исключение представляется объектом, в котором сообщение исключения заменено на трассировку стека. При отладке приложения в Visual Studio исходный текст сообщения можно видеть в диалоговом окне исключений отладчика с пометкой "Сведения WinRT". Исходный текст сообщения недоступен из кода JavaScript.

    > **Совет**. В настоящее время трассировка стека содержит управляемый тип исключения, но мы не рекомендуем анализировать трассировку для выявления типа исключения. Вместо этого лучше использовать значение HRESULT, описанное далее в этом разделе.

-   В C++ исключение является исключением платформы. Если свойство HResult управляемого исключения может быть сопоставлено со значением HRESULT определенного исключения платформы, используется конкретное исключение. в противном случае выдается исключение [**Platform:: COMException**](https://docs.microsoft.com/cpp/cppcx/platform-comexception-class) . Текст сообщения управляемого исключения недоступен в коде C++. Если было создано конкретное исключение платформы, отображается текст сообщения по умолчанию для этого типа исключений; в противном случае текст не отображается. См. статью [Исключения (C++/CX)](https://docs.microsoft.com/cpp/cppcx/exceptions-c-cx).
-   В C# и Visual Basic используется обычное управляемое исключение.

При создании в компоненте исключения можно упростить его обработку в вызывающем коде JavaScript или C++, если создавать исключения неоткрытых типов, свойство HResult которых связано с конкретным компонентом. Значение HRESULT доступно вызывающему объекту JavaScript через свойство Number объекта Exception и C++ вызывающему объекту через свойство [COMException:: HRESULT](https://docs.microsoft.com/cpp/cppcx/platform-comexception-class#hresult) .

> [!NOTE]
> Используйте отрицательное значение для HRESULT. Положительное значение интерпретируется как успех, и исключение в вызывающем коде JavaScript или C++ не создается.

## <a name="declaring-and-raising-events"></a>Объявление и вызов событий

При объявлении типа, в котором будут храниться данные вашего события, создавайте класс, производный от Object, а не от EventArgs, поскольку EventArgs не является типом среды выполнения Windows. Используйте [**EventHandler&lt;тевентаргс&gt;** ](https://docs.microsoft.com/dotnet/api/system.eventhandler-1?redirectedfrom=MSDN) в качестве типа события и используйте тип аргумента события в качестве аргумента универсального типа. Создайте событие так же, как в приложении .NET.

Когда компонент среды выполнения Windows вызывается из JavaScript или C++, событие выполняется в соответствии с шаблоном событий среды выполнения Windows, ожидаемым этими языками. При использовании компонента из C# или Visual Basic событие отображается как обычное событие .NET. Пример приведен в [пошаговом руководстве по созданию C# компонента Visual Basic среда выполнения Windows и его вызову из JavaScript](/windows/uwp/winrt-components/walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript).

При реализации пользовательских методов доступа к событиям (событие объявляется с ключевым словом **Custom** в Visual Basic) в такой реализации необходимо соблюдать шаблон событий среды выполнения Windows. См. раздел [пользовательские события и методы доступа к событиям в компонентах среда выполнения Windows](custom-events-and-event-accessors-in-windows-runtime-components.md). Обратите внимание, что при обработке события C# из или Visual Basic кода он по-прежнему выглядит как обычное событие .NET.

## <a name="next-steps"></a>Следующие шаги

После создания компонента среды выполнения Windows для собственного использования вы можете обнаружить, что заключенная в нем функциональность будет полезна и другим разработчикам. Есть два способа упаковки компонента для распространения среди других разработчиков. См. раздел [Распространение управляемого компонента среды выполнения Windows](https://docs.microsoft.com/previous-versions/windows/apps/jj614475(v=vs.140)).

Дополнительные сведения о функциях Visual Basic C# и языка, а также о поддержке .net для Среда выполнения Windows см. в разделе [Справочник по Visual Basic C# и языку](https://docs.microsoft.com/visualstudio/welcome-to-visual-studio-2015?view=vs-2015).

## <a name="related-topics"></a>См. также
* [.NET для приложений UWP](https://docs.microsoft.com/dotnet/api/index?view=dotnet-uwp-10.0)
* [Пошаговое руководство C# по созданию компонента Visual Basic среда выполнения Windows и его вызову из JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)
