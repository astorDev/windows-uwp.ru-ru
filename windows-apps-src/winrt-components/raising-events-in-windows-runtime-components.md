---
author: msatranjr
title: Создание событий в компонентах среды выполнения Windows
ms.assetid: 3F7744E8-8A3C-4203-A1CE-B18584E89000
description: Как вызвать событие типа делегата, определяемого пользователем в фоновом потоке, таким образом, чтобы JavaScript получит событие.
ms.author: misatran
ms.date: 07/19/2018
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 2dddd170f5f056de18c4729b6b6b5b4b6cbcea7b
ms.sourcegitcommit: 086001cffaf436e6e4324761d59bcc5e598c15ea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/26/2018
ms.locfileid: "5704666"
---
# <a name="raising-events-in-windows-runtime-components"></a>Создание событий в компонентах среды выполнения Windows
> [!NOTE]
> Чтобы узнать, как вызывать события в [C + +/ WinRT](../cpp-and-winrt-apis/intro-to-using-cpp-with-winrt.md) компонента среды выполнения Windows, см. в разделе [Создание событий в C + +/ WinRT](../cpp-and-winrt-apis/author-events.md).

Если ваш компонент среды выполнения Windows вызывает событие типа делегата, определенного пользователем, в фоновом (рабочем) потоке и вы хотите, чтобы среда JavaScript могла получить его, можно реализовать и вызвать событие одним из следующих способов.

-   Вариант 1: создать событие с помощью [Windows.UI.Core.CoreDispatcher](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.aspx), чтобы маршалировать его в контекст потока JavaScript. Хотя обычно это оптимальный вариант, в некоторых случаях он не обеспечивает максимальную производительность.
-   Вариант 2: использовать [Windows.Foundation.EventHandler ](https://msdn.microsoft.com/library/windows/apps/br206577.aspx)&lt;Object&gt;, но с потерей сведений о типе события. Если вариант 1 не приемлем или его производительности недостаточно, то это хороший метод, если потеря сведений о типе не критична для вас.
-   Вариант 3: создать собственный прокси и заглушку для компонента. Этот вариант сложнее всего реализовать, но он сохраняет сведения о типе и может обеспечивать более высокую, чем вариант 1, производительность для ресурсоемких сценариев.

Если создать событие в фоновом потоке без использования одного из этих вариантов, клиент JavaScript просто не получит его.

## <a name="background"></a>Общие сведения

Все компоненты и приложения среды выполнения Windows — это COM-объекты независимо от того, какой язык используется для их создания. В API Windows большая часть компонентов представляет собой динамичные COM-объекты, способные одинаково хорошо взаимодействовать с объектами в фоновом потоке и в потоке пользовательского интерфейса. Если COM-объект не может быть динамичным, ему требуются вспомогательные объекты, прокси и заглушки, для связи с другими COM-объектами в потоке пользовательского интерфейса и фоновом потоке. (С точки зрения модели COM такую связь называют связью между подразделениями потока.)

Большинство объектов в API Windows динамичные или содержат встроенные прокси и заглушки. Однако прокси и заглушки невозможно создать для универсальных типов, таких как Windows.Foundation.[TypedEventHandler&lt;TSender, TResult&gt;](https://msdn.microsoft.com/library/windows/apps/br225997.aspx), поскольку они не представляют собой полные типы, если не указать аргумент типа. Отсутствие прокси и заглушек становится проблемой только для клиентов JavaScript, но если вы хотите, чтобы ваш компонент можно было использовать из JavaScript так же, как из C++ или языка .NET, необходимо использовать один из следующих трех вариантов.

## <a name="option-1-raise-the-event-through-the-coredispatcher"></a>Вариант 1: создание события с помощью CoreDispatcher

Вы можете отправлять события любого типа делегата, определяемого пользователем, с помощью [Windows.UI.Core.CoreDispatcher](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.aspx), и JavaScript получит их. Если вы не знаете точно, какой вариант использовать, сначала попробуйте этот. Если задержка между срабатыванием события и его обработкой становится проблемой, попробуйте один из других вариантов.

В следующем примере показано, как с помощью CoreDispatcher создать строго типизированное событие. Обратите внимание, что аргумент типа — Toast, а не Object.

```csharp
public event EventHandler<Toast> ToastCompletedEvent;
private void OnToastCompleted(Toast args)
{
    var completedEvent = ToastCompletedEvent;
    if (completedEvent != null)
    {
        completedEvent(this, args);
    }
}

public void MakeToastWithDispatcher(string message)
{
    Toast toast = new Toast(message);
    // Assume you have a CoreDispatcher at class scope.
    // Initialize it here, then use it from the background thread.
    var window = Windows.UI.Core.CoreWindow.GetForCurrentThread();
    m_dispatcher = window.Dispatcher;

    Task.Run( () =>
    {
        if (ToastCompletedEvent != null)
        {
            m_dispatcher.RunAsync(CoreDispatcherPriority.Normal,
            new DispatchedHandler(() =>
            {
                this.OnToastCompleted(toast);
            })); // end m_dispatcher.RunAsync
         }
     }); // end Task.Run
}
```

## <a name="option-2-use-eventhandlerltobjectgt-but-lose-type-information"></a>Вариант 2: использование EventHandler&lt;Object&gt;, но с потерей сведений о типе 

Другой способ отправлять события из фонового потока — использовать [Windows.Foundation.EventHandler](https://msdn.microsoft.com/library/windows/apps/br206577.aspx)&lt;Object&gt; в качестве типа события. Windows предоставляет этот экземпляр универсального типа, а также прокси и заглушку для него. Недостаток состоит в том, что сведения о типе аргументов и отправителя события теряются. Клиенты C++ и .NET должны знать, в какой тип следует преобразовать экземпляр при получении события. Эти сведения берутся из документации. Клиентам JavaScript не нужна информация об исходном типе. Они находят свойства аргументов на основе их имен в метаданных.

В этом примере показано, как использовать Windows.Foundation.EventHandler&lt;Object&gt; на языке C#:

```csharp
public sealed Class1
{
// Declare the event
public event EventHandler<Object> ToastCompletedEvent;

    // Raise the event
    public async void MakeToast(string message)
    {
        Toast toast = new Toast(message);
        // Fire the event from a background thread to allow this thread to continue
        Task.Run(() =>
        {
            if (ToastCompletedEvent != null)
            {
                OnToastCompleted(toast);
            }
        });
    }

    private void OnToastCompleted(Toast args)
    {
        var completedEvent = ToastCompletedEvent;
        if (completedEvent != null)
        {
            completedEvent(this, args);
        }
    }
}
```

Это событие используется в части JavaScript следующим образом:

```javascript
toastCompletedEventHandler: function (event) {
   var toastType = event.toast.toastType;
   document.getElementById("toasterOutput").innerHTML = "<p>Made " + toastType + " toast</p>";
}
```

## <a name="option-3-create-your-own-proxy-and-stub"></a>Вариант 3: создание собственных прокси и заглушки

Для повышения производительности с определяемыми пользователем типами событий, которые полностью сохраняют сведения о типе, необходимо создать собственные объекты прокси и заглушки и внедрить их в пакет приложения. Обычно этот вариант следует использовать только в тех редких случаях, когда ни один из других вариантов не пригоден. Кроме того, нет гарантии, что этот метод обеспечит лучшую производительность, чем остальные. Фактическая производительность зависит от множества факторов. Используйте профилировщик Visual Studio или другие средства профилирования для измерения фактической производительности в приложении и определите, действительно ли событие — это "узкое место".

Далее в этой статье показано, как использовать C# для создания простого компонента среды выполнения Windows, а затем использовать C++ для создания библиотеки DLL для прокси и заглушки, которые позволят JavaScript использовать событие Windows.Foundation.TypedEventHandler&lt;TSender, TResult&gt;, вызываемое компонентом в асинхронной операции. (Вы также можете использовать C++ или Visual Basic для создания компонента. Действия, относящиеся к созданию прокси и заглушек, аналогичны.) Это пошаговое руководство основано на примере создания внутрипроцессного компонента среды выполнения Windows (C++/CX) и объясняет его назначение.

Пошаговое руководство содержит следующие компоненты:

-   Здесь вы создаете два базовых класса среды выполнения Windows. Один класс предоставляет событие типа [Windows.Foundation.TypedEventHandler&lt;TSender, TResult&gt;](https://msdn.microsoft.com/library/windows/apps/br225997.aspx), а другой класс — это тип, возвращаемый среде JavaScript в качестве аргумента TValue. Эти классы не могут взаимодействовать с JavaScript, если не выполнить последующие действия.
-   Это приложение активирует объект основного класса, вызывает метод и обрабатывает событие, вызываемое компонентом среды выполнения Windows.
-   Это необходимо для средств, создающих классы прокси и заглушки.
-   Затем вы используете файл IDL для генерации исходного кода C для прокси и заглушки.
-   Зарегистрируйте объекты прокси и заглушки, чтобы среда выполнения COM могла их найти, и добавьте ссылку на соответствующую библиотеку DLL в проект приложения.

## <a name="to-create-the-windows-runtime-component"></a>Создание компонента среды выполнения Windows

В Visual Studio в строке меню выберите **Файл &gt;Создатьпроект**. В диалоговом окне **Создание проекта** разверните узел **JavaScript &gt; Универсальное приложение для Windows** и выберите **Пустое приложение**. Назовите проект ToasterApplication и нажмите кнопку **ОК** .

Добавьте компонент среды выполнения Windows на C# в решение: в обозревателе решений откройте контекстное меню для нужного решения и выберите **Добавить &gt; Новый проект**. Разверните **Visual C# &gt; Microsoft Store** , а затем выберите **Компонента среды выполнения Windows**. Назовите проект ToasterComponent и нажмите кнопку **ОК**. ToasterComponent будет корневым пространством имен для компонентов, которые вы создадите позднее.

В обозревателе решений откройте контекстное меню решения и выберите пункт **Свойства**. В диалоговом окне **Страницы свойств** выберите элемент **Свойства конфигурации** в левой области, а затем в верхней части диалогового окна задайте для параметра **Конфигурация** значение **Отладка**, а для параметра **Платформа** выберите "x86", "x64" или "ARM". Нажмите кнопку **ОК**.

**Важные**платформы = любой ЦП не будут работать, так как он не является допустимым для машинного кода Win32 DLL, которую вы добавите в решение позже.

В обозревателе решений переименуйте файл class1.cs на ToasterComponent.cs, чтобы он соответствовал имени проекта. Visual Studio автоматически переименует класс в файле.

Добавьте в CS-файл директиву using для пространства имен Windows.Foundation, чтобы добавить TypedEventHandler в область действия.

Если вам необходимы прокси и заглушки, компонент должен использовать интерфейсы, чтобы предоставлять доступ к открытым членам. В файле ToasterComponent.cs укажите интерфейс для тостера и интерфейс для всплывающего уведомления, которое создает тостер.

**Примечание**в C# этот шаг можно пропустить. Вместо этого сначала создайте класс, а затем откройте его контекстное меню и выберите **Рефакторинг &gt; Извлечь интерфейс**. В созданном коде вручную сделайте интерфейсы общедоступными.

```csharp
    public interface IToaster
        {
            void MakeToast(String message);
            event TypedEventHandler<Toaster, Toast> ToastCompletedEvent;

        }
        public interface IToast
        {
            String ToastType { get; }
        }
```

Интерфейс IToast содержит строку, которую можно извлечь для описания типа всплывающего уведомления. Интерфейс IToaster содержит метод для создания всплывающего уведомления и событие для уведомления об этом. Поскольку это событие возвращает определенный элемент (т. е. тип) всплывающего уведомления, его называют типизированным событием.

Затем нам понадобятся открытые классы, реализующие эти интерфейсы, которые будут доступны из приложения JavaScript, созданного позже.

```csharp
    public sealed class Toast : IToast
        {
            private string _toastType;

            public string ToastType
            {
                get
                {
                    return _toastType;
                }
            }
            internal Toast(String toastType)
            {
                _toastType = toastType;
            }

        }
        public sealed class Toaster : IToaster
        {
            public event TypedEventHandler<Toaster, Toast> ToastCompletedEvent;

            private void OnToastCompleted(Toast args)
            {
                var completedEvent = ToastCompletedEvent;
                if (completedEvent != null)
                {
                    completedEvent(this, args);
                }
            }

            public void MakeToast(string message)
            {
                Toast toast = new Toast(message);
                // Fire the event from a thread-pool thread to enable this thread to continue
                Windows.System.Threading.ThreadPool.RunAsync(
                (IAsyncAction action) =>
                {
                    if (ToastCompletedEvent != null)
                    {
                        OnToastCompleted(toast);
                    }
                });
           }
        }
```

В предыдущем фрагменте кода мы создаем всплывающее уведомление, а затем выполняем операции с пулом потоков для вызова уведомления. Хотя среда IDE может порекомендовать применить ключевое слово await в асинхронном вызове, в данном случае это необязательно, поскольку метод не выполняет никаких действий, которые зависят от результатов операции.

**Примечание**асинхронный вызов в предыдущем коде использует метод ThreadPool.RunAsync только для демонстрации простого способа события в фоновом потоке. Вы можете написать этот метод, как показано в следующем примере, и он будет работать, так как планировщик заданий .NET автоматически маршалирует асинхронные вызовы и вызовы await в поток пользовательского интерфейса.
  
```csharp
    public async void MakeToast(string message)
    {
        Toast toast = new Toast(message)
        await Task.Delay(new Random().Next(1000));
        OnToastCompleted(toast);
    }
```

При создании проекта теперь необходимо создать четко.

## <a name="to-program-the-javascript-app"></a>Приложения JavaScript

Теперь мы можем добавить кнопку приложение JavaScript, чтобы заставить его для использования в класс, который мы определили сделать всплывающего уведомления. Прежде чем мы делаем это, мы необходимо добавить ссылку на проект ToasterComponent, который мы только что создали. В обозревателе решений откройте контекстное меню в проект ToasterApplication, выберите **Добавить &gt; ссылки**, а затем нажмите кнопку **Добавить новую ссылку** . В диалоговом окне Добавить ссылку на левой панели в разделе решений выберите проект компонента и затем на центральной панели выберите ToasterComponent. Нажмите кнопку **ОК**.

В обозревателе решений откройте контекстное меню в проект ToasterApplication и выберите **Назначить запускаемым проектом**.

В конце файла default.js добавьте пространство имен для размещения функций для вызова компонента и обратный вызов, его. Пространство имен будет иметь две функции, сделать всплывающего уведомления и обработать событие завершения всплывающего уведомления. Реализация makeToast создает объект тостер, регистрируется обработчик событий и делает всплывающего уведомления. На данный момент обработчик событий ничего не делает, как показано ниже:

```javascript
    WinJS.Namespace.define("ToasterApplication"), {
       makeToast: function () {

          var toaster = new ToasterComponent.Toaster();
          //toaster.addEventListener("ontoastcompletedevent", ToasterApplication.toastCompletedEventHandler);
          toaster.ontoastcompletedevent = ToasterApplication.toastCompletedEventHandler;
          toaster.makeToast("Peanut Butter");
       },

       toastCompletedEventHandler: function(event) {
           // The sender of the event (the delegate's first type parameter)
           // is mapped to event.target. The second argument of the delegate
           // is contained in event, which means in this case event is a
           // Toast class, with a toastType string.
           var toastType = event.toastType;

           document.getElementById('toastOutput').innerHTML = "<p>Made " + toastType + " toast</p>";
        },
    });
```

Функцию makeToast необходимо подключить к кнопке. Обновление default.html кнопки и место на диске для вывода результатов, что всплывающее уведомление:

```html
    <body>
        <h1>Click the button to make toast</h1>
        <button onclick="ToasterApplication.makeToast()">Make Toast!</button>
        <div id="toasterOutput">
            <p>No Toast Yet...</p>
        </div>
    </body>
```

Если мы не TypedEventHandler, мы теперь сможет запустить приложение на локальном компьютере и нажмите кнопку, чтобы сделать всплывающего уведомления. Но в нашем приложении ничего не происходит. Чтобы узнать, почему, давайте отладка управляемого кода, который запускает ToastCompletedEvent. Остановите проект, а затем в строке меню выберите **Отладка &gt; свойства приложения тостер**. Измените **Тип отладчика** **только управляемый код**. Еще раз в строке меню выберите **Отладка &gt; исключения**, а затем выберите **Исключения среды CLR**.

Теперь запустите приложение и нажмите кнопку всплывающего уведомления сделать. Отладчик перехватывает исключение недопустимого приведения. Несмотря на то, что не очевидно из его сообщения, это исключение происходит из-за отсутствия для этого интерфейса прокси-серверы.

![отсутствует прокси-сервера](./images/debuggererrormissingproxy.png)

Первый шаг в создании прокси и заглушку для компонента является добавление уникальный идентификатор или идентификатор GUID с интерфейсами. Однако формат GUID для использования отличается в зависимости от ли вы кодируете в C#, Visual Basic или другом языке .NET или C++.

## <a name="to-generate-guids-for-the-components-interfaces-c-and-other-net-languages"></a>Чтобы создать GUID для интерфейсов компонентов (C# и других языках .NET)

В строке меню выберите средства &gt; создать GUID. В диалоговом окне выберите 5. \[GUID ("xxxxxxxx-xxxx … xxxx) \]. Нажмите кнопку «новое значение GUID» и нажмите кнопку «Копировать».

![генератора GUID](./images/guidgeneratortool.png)

Вернитесь к определению интерфейса, а затем вставьте новый идентификатор GUID непосредственно перед интерфейс IToaster, как показано в следующем примере. (Не используйте GUID в примере. Каждый уникальный интерфейс должен быть собственный GUID.)

```cpp
[Guid("FC198F74-A808-4E2A-9255-264746965B9F")]
        public interface IToaster...
```

Добавить с помощью директиву для пространства имен System.Runtime.InteropServices.

Повторите эти действия для интерфейс IToast.

## <a name="to-generate-guids-for-the-components-interfaces-c"></a>Чтобы создать GUID для интерфейсов компонента (C++)

В строке меню выберите средства &gt; создать GUID. В диалоговом окне выберите 3. статическое const структуры GUID = {...}. Нажмите кнопку «новое значение GUID» и нажмите кнопку «Копировать».

Вставьте идентификатор GUID непосредственно перед определением интерфейс IToaster. После вставки, GUID должен выглядеть примерно так. (Не используйте GUID в примере. Каждый уникальный интерфейс должен быть собственный GUID.)
```cpp
// {F8D30778-9EAF-409C-BCCD-C8B24442B09B}
    static const GUID <<name>> = { 0xf8d30778, 0x9eaf, 0x409c, { 0xbc, 0xcd, 0xc8, 0xb2, 0x44, 0x42, 0xb0, 0x9b } };
```
Добавить с помощью директив для Windows.Foundation.Metadata преобразовывать GuidAttribute в область действия.

Теперь ручное преобразование const GUID GuidAttribute таким образом, чтобы он отформатирован, как показано в следующем примере. Обратите внимание, что фигурные скобки заменяются скобки и скобки и удалить конечные точки с запятой.
```cpp
// {E976784C-AADE-4EA4-A4C0-B0C2FD1307C3}
    [GuidAttribute(0xe976784c, 0xaade, 0x4ea4, 0xa4, 0xc0, 0xb0, 0xc2, 0xfd, 0x13, 0x7, 0xc3)]
    public interface IToaster
    {...
```
Повторите эти действия для интерфейс IToast.

Теперь у интерфейсы уникальные идентификаторы, мы можно создать файл IDL путем передачи файла .winmd в это средство командной строки winmdidl и затем создания исходного кода C для прокси и заглушки, смешивают этого файла IDL в это средство командной строки MIDL. Visual Studio выполнять для нас, если мы создаем события после построения, как показано на следующих этапах.

## <a name="to-generate-the-proxy-and-stub-source-code"></a>Чтобы создать прокси и заглушки исходного кода

Чтобы добавить пользовательское событие после построения, в обозревателе решений, откройте контекстное меню в проект ToasterComponent и выберите свойства. В левой области страницы свойств выберите события сборки и затем нажмите кнопку Изменить событие после построения. Добавьте следующие команды в командной строке после сборки. (Пакетный файл должен вызываться сначала настроить переменные среды для поиска средство winmdidl.)

```cpp
call "$(DevEnvDir)..\..\vc\vcvarsall.bat" $(PlatformName)
winmdidl /outdir:output "$(TargetPath)"
midl /metadata_dir "%WindowsSdkDir%References\CommonConfiguration\Neutral" /iid "$(ProjectDir)$(TargetName)_i.c" /env win32 /h "$(ProjectDir)$(TargetName).h" /winmd "Output\$(TargetName).winmd" /W1 /char signed /nologo /winrt /dlldata "$(ProjectDir)dlldata.c" /proxy "$(ProjectDir)$(TargetName)_p.c" "Output\$(TargetName).idl"
```

**Важные**для ARM или x64 конфигурации проекта, измените параметр/env MIDL x64 или arm32.

Чтобы убедиться, что файл IDL создается заново каждый раз при изменении файла .winmd, измените, чтобы **Выполнить событие после построения** **при построении обновлений выходной файл проекта.**
Страница свойств события сборки должен выглядеть примерно следующим образом: ![события построения](./images/buildevents.png)

Перестройте решение для создания и компиляции IDL.

Вы можете проверить, правильно скомпилированные MIDL решение просмотрев ToasterComponent.h, ToasterComponent_i.c, ToasterComponent_p.c и dlldata.c в каталоге проекта ToasterComponent.

## <a name="to-compile-the-proxy-and-stub-code-into-a-dll"></a>Для компиляции прокси и заглушки кода в библиотеку DLL

Теперь у вас есть необходимые файлы для устройств, можно скомпилировать их для получения DLL, которая представляет собой файл C++. Чтобы сделать это максимально, добавьте новый проект для поддержки создания прокси-серверы. Откройте контекстное меню решения ToasterApplication и выберите команду **Добавить > Новый проект**. В левой области диалогового окна « **Новый проект** » разверните **Visual C++ &gt; Windows &gt; Windows перестанут**и затем на центральной панели выберите **DLL (приложения UWP)**. (Обратите внимание, что это не проект компонента среды выполнения Windows C++). Назовите проект прокси-серверов, а затем нажмите кнопку « **ОК** ». Эти файлы обновляются с помощью событий после построения при каких-либо изменений в классе C#.

По умолчанию проект прокси-серверы создает файлы заголовков .h и .cpp C++. Так как библиотеки DLL создается из файлов, созданные в MIDL, файлы .h и .cpp не требуются. В обозревателе решений откройте контекстное меню для них, выберите **Удалить**и затем подтвердить удаление.

Теперь, когда проект пуст, вы можете добавить обратно MIDL создаваемые файлы. Откройте контекстное меню проекта прокси-серверов, а затем выберите **Добавить > существующий элемент.** В диалоговом окне перейдите в каталог проекта ToasterComponent и выберите эти файлы: файлы ToasterComponent.h, ToasterComponent_i.c, ToasterComponent_p.c и dlldata.c. Нажмите кнопку « **Добавить** ».

В проекте прокси-серверы создайте DEF-файл для определения экспорта библиотеки DLL, описанные в dlldata.c. Откройте контекстное меню проекта, а затем выберите **Добавить > новый элемент**. В левой области диалогового окна выберите код, а затем на центральной панели выберите файл определения модуля. Назовите proxies.def файла и нажмите кнопку **Добавить** . Откройте этот DEF-файл и измените его, чтобы включить экспорт, которые определены в dlldata.c:

```cpp
EXPORTS
    DllCanUnloadNow         PRIVATE
    DllGetClassObject       PRIVATE
```

При создании проекта теперь она завершится ошибкой. Чтобы правильно скомпилировать этого проекта, вам придется вносить изменения как проекта компилируется и связывается. В обозревателе решений откройте контекстное меню проекта прокси-серверы и выберите **Свойства**. Измените на страницах свойств следующим образом.

На левой панели выберите **C/C++ > препроцессора**, а затем в области справа выберите **Определения препроцессора**, нажмите кнопку со стрелкой вниз и выберите **Изменить**. Добавьте эти определения в поле:

```cpp
WIN32;_WINDOWS
```
В разделе **C/C++ > предварительно скомпилированные заголовки**, изменить **Предварительно скомпилированный заголовок** **Не с помощью предварительно скомпилированные заголовки**, а затем нажмите кнопку **Применить** .

В разделе **Компоновщик > Общие**, измените **Пропустить библиотеку импорта** **Ye**s, а затем нажмите кнопку **Применить** .

В разделе **Компоновщик > ввод**выберите **Дополнительные зависимости**, нажмите кнопку со стрелкой вниз, а затем выберите **Изменить**. Добавьте этот текст в поле:

```cpp
rpcrt4.lib;runtimeobject.lib
```

Не вставить эти библиотеки непосредственно в строке списка. Используйте поле **Редактировать** , чтобы MSBuild в Visual Studio будет правильно Дополнительные зависимости.

После внесения этих изменений, нажмите кнопку **ОК** в диалоговом окне **Страницы свойств** .

Затем выполните зависимости в проект ToasterComponent. Это гарантирует, что тостер описывается создание до сборки проекта прокси-сервера. Это необходимо, поскольку проект тостер отвечает за создание файлов для создания прокси-сервера.

Откройте контекстное меню проекта прокси-серверов, а затем выберите зависимости проекта. Установите флажки, чтобы указать, что проект прокси-серверы, зависит от ToasterComponent проекта, чтобы убедиться, что Visual Studio создает их в правильном порядке.

Проверка правильности построения решения, выбрав **сборка > Перестроить решение** в строке меню Visual Studio.


## <a name="to-register-the-proxy-and-stub"></a>Для регистрации прокси и заглушки

В проект ToasterApplication откройте контекстное меню для package.appxmanifest и выберите **Открыть с помощью**. В диалоговом окне Открыть с помощью выберите **Текстовый редактор XML** и затем нажмите кнопку « **ОК** ». Мы будем вставьте в некоторых XML, в котором содержатся регистрацию расширения windows.activatableClass.proxyStub, каким основаны на GUID в прокси-сервера. Чтобы найти идентификаторы GUID для использования в файле .appxmanifest, откройте ToasterComponent_i.c. Поиск записи, похожие те в следующем примере. Также Обратите внимание, определения для IToast, IToaster и интерфейс — типизированным событием обработчик, который имеет два параметра: тостера и всплывающих уведомлений. Это соответствует событию, которое определяется в классе тостер. Обратите внимание, что идентификаторы GUID для IToast и IToaster соответствуют идентификаторы GUID, которые определены в интерфейсы в файле C#. Поскольку интерфейс обработчика типизированным событием, автоматически созданных GUID для этого интерфейса может автоматически созданных.

```cpp
MIDL_DEFINE_GUID(IID, IID___FITypedEventHandler_2_ToasterComponent__CToaster_ToasterComponent__CToast,0x1ecafeff,0x1ee1,0x504a,0x9a,0xf5,0xa6,0x8c,0x6f,0xb2,0xb4,0x7d);

MIDL_DEFINE_GUID(IID, IID___x_ToasterComponent_CIToast,0xF8D30778,0x9EAF,0x409C,0xBC,0xCD,0xC8,0xB2,0x44,0x42,0xB0,0x9B);

MIDL_DEFINE_GUID(IID, IID___x_ToasterComponent_CIToaster,0xE976784C,0xAADE,0x4EA4,0xA4,0xC0,0xB0,0xC2,0xFD,0x13,0x07,0xC3);
```

Теперь мы копируем идентификаторы GUID, вставьте их в файле package.appxmanifest в узел, который мы добавляем и имя расширения и затем переформатировать их. Запись манифеста приведенной в следующем примере, но опять же, не забудьте задать собственные идентификаторы GUID. Обратите внимание, что идентификатор класса GUID в XML-ФАЙЛ так же, как ITypedEventHandler2. Это связано с тем, GUID является первым, перечисленных в ToasterComponent_i.c. GUID здесь не учитывается. Вместо вручную переформатирование идентификаторы GUID для IToast и IToaster, можно вернуться в определения интерфейса и получите значение GuidAttribute, который имеет правильный формат. В C++ существует GUID правильно отформатированы в комментарии. В любом случае необходимо вручную переформатировать GUID, который используется для то при вводе и обработчик событий.

```cpp
      <Extensions> <!--Use your own GUIDs!!!-->
        <Extension Category="windows.activatableClass.proxyStub">
          <ProxyStub ClassId="1ecafeff-1ee1-504a-9af5-a68c6fb2b47d">
            <Path>Proxies.dll</Path>
            <Interface Name="IToast" InterfaceId="F8D30778-9EAF-409C-BCCD-C8B24442B09B"/>
            <Interface Name="IToaster"  InterfaceId="E976784C-AADE-4EA4-A4C0-B0C2FD1307C3"/>  
            <Interface Name="ITypedEventHandler_2_ToasterComponent__CToaster_ToasterComponent__CToast" InterfaceId="1ecafeff-1ee1-504a-9af5-a68c6fb2b47d"/>
          </ProxyStub>      
        </Extension>
      </Extensions>
```

Вставьте узел расширения XML в качестве прямого дочерний узел пакет и однорангового элемента, например, узел ресурсов.

Перед переходом очень важно убедиться, что:

-   Идентификатор класса ProxyStub устанавливается первый идентификатор GUID в файле ToasterComponent\_i.c. Используйте первый GUID, который определяется в этот файл на то при вводе. (Это может быть так же, как GUID для ITypedEventHandler2.)
-   Путь — это относительный путь пакета двоичного прокси-сервера. (В этом пошаговом руководстве proxies.dll находится в той же папке, что ToasterApplication.winmd.)
-   Идентификаторы GUID, являются в нужном формате. (Это можно легко получить неверный.)
-   Интерфейс идентификаторы в манифесте соответствовать идентификаторы IID в файле ToasterComponent\_i.c.
-   Имена интерфейсов являются уникальными в манифесте. Поскольку они не используется системой, вы можете выбрать значения. Рекомендуется выбрать имена интерфейсов, которые точно соответствовать интерфейсы, которые вы определили. Созданный интерфейсов имена должны быть указывает созданный интерфейсов. Можно использовать файл ToasterComponent\_i.c помогают создавать имена интерфейсов.

При попытке запустить решение, теперь вы получите сообщение об ошибке, proxies.dll не является частью полезных данных. Откройте контекстное меню для **ссылки на** папку в проект ToasterApplication и выберите **Добавить ссылку**. Установите флажок рядом с проектом прокси-серверы. Кроме того убедитесь, что установлен флажок рядом с ToasterComponent. Нажмите кнопку **ОК**.

Теперь следует создавать проект. Запустите проект и убедитесь, что вы можете сделать всплывающего уведомления.

## <a name="related-topics"></a>Еще по теме

* [Создание компонентов среды выполнения Windows на C++](creating-windows-runtime-components-in-cpp.md)
