---
author: msatranjr
title: Создание событий в компонентах среды выполнения Windows
ms.assetid: 3F7744E8-8A3C-4203-A1CE-B18584E89000
description: Как событие пользовательских делегатами в фоновом потоке, таким образом, может получать событие JavaScript.
ms.author: misatran
ms.date: 07/19/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 89c021bb2c094aafc9b534acef9b009817669461
ms.sourcegitcommit: 9c79fdab9039ff592edf7984732d300a14e81d92
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/23/2018
ms.locfileid: "2819567"
---
# <a name="raising-events-in-windows-runtime-components"></a>Создание событий в компонентах среды выполнения Windows
> [!NOTE]
> Чтобы узнать, как повысить события в [C + +/ WinRT](../cpp-and-winrt-apis/intro-to-using-cpp-with-winrt.md) компонента среды выполнения Windows увидеть [создавать события в C + +/ WinRT](../cpp-and-winrt-apis/author-events.md).

Если ваш компонент среды выполнения Windows вызывает событие типа делегата, определенного пользователем, в фоновом (рабочем) потоке и вы хотите, чтобы среда JavaScript могла получить его, можно реализовать и вызвать событие одним из следующих способов.

-   Вариант 1: создать событие с помощью [Windows.UI.Core.CoreDispatcher](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.aspx), чтобы маршалировать его в контекст потока JavaScript. Хотя обычно это оптимальный вариант, в некоторых случаях он не обеспечивает максимальную производительность.
-   Вариант 2: использовать [Windows.Foundation.EventHandler ](https://msdn.microsoft.com/library/windows/apps/br206577.aspx)&lt;Object&gt;, но с потерей сведений о типе события. Если вариант 1 не приемлем или его производительности недостаточно, то это хороший метод, если потеря сведений о типе не критична для вас.
-   Вариант 3: создать собственный прокси и заглушку для компонента. Этот вариант сложнее всего реализовать, но он сохраняет сведения о типе и может обеспечивать более высокую, чем вариант 1, производительность для ресурсоемких сценариев.

Если создать событие в фоновом потоке без использования одного из этих вариантов, клиент JavaScript просто не получит его.

## <a name="background"></a>Общие сведения

Все компоненты и приложения среды выполнения Windows — это COM-объекты независимо от того, какой язык используется для их создания. В API Windows большая часть компонентов представляет собой динамичные COM-объекты, способные одинаково хорошо взаимодействовать с объектами в фоновом потоке и в потоке пользовательского интерфейса. Если COM-объект не может быть динамичным, ему требуются вспомогательные объекты, прокси и заглушки, для связи с другими COM-объектами в потоке пользовательского интерфейса и фоновом потоке. (С точки зрения модели COM такую связь называют связью между подразделениями потока.)

Большинство объектов в API Windows динамичные или содержат встроенные прокси и заглушки. Однако прокси и заглушки невозможно создать для универсальных типов, таких как Windows.Foundation.[TypedEventHandler&lt;TSender, TResult&gt;](https://msdn.microsoft.com/library/windows/apps/br225997.aspx), поскольку они не представляют собой полные типы, если не указать аргумент типа. Отсутствие прокси и заглушек становится проблемой только для клиентов JavaScript, но если вы хотите, чтобы ваш компонент можно было использовать из JavaScript так же, как из C++ или языка .NET, необходимо использовать один из следующих трех вариантов.

## <a name="option-1-raise-the-event-through-the-coredispatcher"></a>Вариант 1: создание события с помощью CoreDispatcher

Вы можете отправлять события любого типа делегата, определяемого пользователем, с помощью [Windows.UI.Core.CoreDispatcher](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.aspx), и JavaScript получит их. Если вы не знаете точно, какой вариант использовать, сначала попробуйте этот. Если задержка между срабатыванием события и его обработкой становится проблемой, попробуйте один из других вариантов.

В следующем примере показано, как с помощью CoreDispatcher создать строго типизированное событие. Обратите внимание, что аргумент типа — Toast, а не Object.

```csharp
public event EventHandler<Toast> ToastCompletedEvent;
private void OnToastCompleted(Toast args)
{
    var completedEvent = ToastCompletedEvent;
    if (completedEvent != null)
    {
        completedEvent(this, args);
    }
}

public void MakeToastWithDispatcher(string message)
{
    Toast toast = new Toast(message);
    // Assume you have a CoreDispatcher at class scope.
    // Initialize it here, then use it from the background thread.
    var window = Windows.UI.Core.CoreWindow.GetForCurrentThread();
    m_dispatcher = window.Dispatcher;

    Task.Run( () =>
    {
        if (ToastCompletedEvent != null)
        {
            m_dispatcher.RunAsync(CoreDispatcherPriority.Normal,
            new DispatchedHandler(() =>
            {
                this.OnToastCompleted(toast);
            })); // end m_dispatcher.RunAsync
         }
     }); // end Task.Run
}
```

## <a name="option-2-use-eventhandlerltobjectgt-but-lose-type-information"></a>Вариант 2: использование EventHandler&lt;Object&gt;, но с потерей сведений о типе 

Другой способ отправлять события из фонового потока — использовать [Windows.Foundation.EventHandler](https://msdn.microsoft.com/library/windows/apps/br206577.aspx)&lt;Object&gt; в качестве типа события. Windows предоставляет этот экземпляр универсального типа, а также прокси и заглушку для него. Недостаток состоит в том, что сведения о типе аргументов и отправителя события теряются. Клиенты C++ и .NET должны знать, в какой тип следует преобразовать экземпляр при получении события. Эти сведения берутся из документации. Клиентам JavaScript не нужна информация об исходном типе. Они находят свойства аргументов на основе их имен в метаданных.

В этом примере показано, как использовать Windows.Foundation.EventHandler&lt;Object&gt; на языке C#:

```csharp
public sealed Class1
{
// Declare the event
public event EventHandler<Object> ToastCompletedEvent;

    // Raise the event
    public async void MakeToast(string message)
    {
        Toast toast = new Toast(message);
        // Fire the event from a background thread to allow this thread to continue
        Task.Run(() =>
        {
            if (ToastCompletedEvent != null)
            {
                OnToastCompleted(toast);
            }
        });
    }

    private void OnToastCompleted(Toast args)
    {
        var completedEvent = ToastCompletedEvent;
        if (completedEvent != null)
        {
            completedEvent(this, args);
        }
    }
}
```

Это событие используется в части JavaScript следующим образом:

```javascript
toastCompletedEventHandler: function (event) {
   var toastType = event.toast.toastType;
   document.getElementById("toasterOutput").innerHTML = "<p>Made " + toastType + " toast</p>";
}
```

## <a name="option-3-create-your-own-proxy-and-stub"></a>Вариант 3: создание собственных прокси и заглушки

Для повышения производительности с определяемыми пользователем типами событий, которые полностью сохраняют сведения о типе, необходимо создать собственные объекты прокси и заглушки и внедрить их в пакет приложения. Обычно этот вариант следует использовать только в тех редких случаях, когда ни один из других вариантов не пригоден. Кроме того, нет гарантии, что этот метод обеспечит лучшую производительность, чем остальные. Фактическая производительность зависит от множества факторов. Используйте профилировщик Visual Studio или другие средства профилирования для измерения фактической производительности в приложении и определите, действительно ли событие — это "узкое место".

Далее в этой статье показано, как использовать C# для создания простого компонента среды выполнения Windows, а затем использовать C++ для создания библиотеки DLL для прокси и заглушки, которые позволят JavaScript использовать событие Windows.Foundation.TypedEventHandler&lt;TSender, TResult&gt;, вызываемое компонентом в асинхронной операции. (Вы также можете использовать C++ или Visual Basic для создания компонента. Действия, относящиеся к созданию прокси и заглушек, аналогичны.) Это пошаговое руководство основано на примере создания внутрипроцессного компонента среды выполнения Windows (C++/CX) и объясняет его назначение.

Пошаговое руководство содержит следующие компоненты:

-   Здесь вы создаете два базовых класса среды выполнения Windows. Один класс предоставляет событие типа [Windows.Foundation.TypedEventHandler&lt;TSender, TResult&gt;](https://msdn.microsoft.com/library/windows/apps/br225997.aspx), а другой класс — это тип, возвращаемый среде JavaScript в качестве аргумента TValue. Эти классы не могут взаимодействовать с JavaScript, если не выполнить последующие действия.
-   Это приложение активирует объект основного класса, вызывает метод и обрабатывает событие, вызываемое компонентом среды выполнения Windows.
-   Это необходимо для средств, создающих классы прокси и заглушки.
-   Затем вы используете файл IDL для генерации исходного кода C для прокси и заглушки.
-   Зарегистрируйте объекты прокси и заглушки, чтобы среда выполнения COM могла их найти, и добавьте ссылку на соответствующую библиотеку DLL в проект приложения.

## <a name="to-create-the-windows-runtime-component"></a>Создание компонента среды выполнения Windows

В Visual Studio в строке меню выберите **Файл &gt;Создатьпроект**. В диалоговом окне **Создание проекта** разверните узел **JavaScript &gt; Универсальное приложение для Windows** и выберите **Пустое приложение**. Назовите проект ToasterApplication и нажмите кнопку **ОК** .

Добавьте компонент среды выполнения Windows на C# в решение: в обозревателе решений откройте контекстное меню для нужного решения и выберите **Добавить &gt; Новый проект**. Разверните узел **Visual C# &gt; хранилища Майкрософт** , а затем выберите **Компонент среды выполнения Windows**. Назовите проект ToasterComponent и нажмите кнопку **ОК**. ToasterComponent будет корневым пространством имен для компонентов, которые вы создадите позднее.

В обозревателе решений откройте контекстное меню решения и выберите пункт **Свойства**. В диалоговом окне **Страницы свойств** выберите элемент **Свойства конфигурации** в левой области, а затем в верхней части диалогового окна задайте для параметра **Конфигурация** значение **Отладка**, а для параметра **Платформа** выберите "x86", "x64" или "ARM". Нажмите кнопку **ОК**.

**Важно!** Значение "Любой ЦП" не подойдет, поскольку оно недопустимо для библиотеки DLL с собственным кодом Win32, которую вы добавите в решение позже.

В обозревателе решений переименуйте файл class1.cs на ToasterComponent.cs, чтобы он соответствовал имени проекта. Visual Studio автоматически переименует класс в файле.

Добавьте в CS-файл директиву using для пространства имен Windows.Foundation, чтобы добавить TypedEventHandler в область действия.

Если вам необходимы прокси и заглушки, компонент должен использовать интерфейсы, чтобы предоставлять доступ к открытым членам. В файле ToasterComponent.cs укажите интерфейс для тостера и интерфейс для всплывающего уведомления, которое создает тостер.

**Примечание.** Для C# этот шаг можно пропустить. Вместо этого сначала создайте класс, а затем откройте его контекстное меню и выберите **Рефакторинг &gt; Извлечь интерфейс**. В созданном коде вручную сделайте интерфейсы общедоступными.

```csharp
    public interface IToaster
        {
            void MakeToast(String message);
            event TypedEventHandler<Toaster, Toast> ToastCompletedEvent;

        }
        public interface IToast
        {
            String ToastType { get; }
        }
```

Интерфейс IToast содержит строку, которую можно извлечь для описания типа всплывающего уведомления. Интерфейс IToaster содержит метод для создания всплывающего уведомления и событие для уведомления об этом. Поскольку это событие возвращает определенный элемент (т. е. тип) всплывающего уведомления, его называют типизированным событием.

Затем нам понадобятся открытые классы, реализующие эти интерфейсы, которые будут доступны из приложения JavaScript, созданного позже.

```csharp
    public sealed class Toast : IToast
        {
            private string _toastType;

            public string ToastType
            {
                get
                {
                    return _toastType;
                }
            }
            internal Toast(String toastType)
            {
                _toastType = toastType;
            }

        }
        public sealed class Toaster : IToaster
        {
            public event TypedEventHandler<Toaster, Toast> ToastCompletedEvent;

            private void OnToastCompleted(Toast args)
            {
                var completedEvent = ToastCompletedEvent;
                if (completedEvent != null)
                {
                    completedEvent(this, args);
                }
            }

            public void MakeToast(string message)
            {
                Toast toast = new Toast(message);
                // Fire the event from a thread-pool thread to enable this thread to continue
                Windows.System.Threading.ThreadPool.RunAsync(
                (IAsyncAction action) =>
                {
                    if (ToastCompletedEvent != null)
                    {
                        OnToastCompleted(toast);
                    }
                });
           }
        }
```

В предыдущем фрагменте кода мы создаем всплывающее уведомление, а затем выполняем операции с пулом потоков для вызова уведомления. Хотя среда IDE может порекомендовать применить ключевое слово await в асинхронном вызове, в данном случае это необязательно, поскольку метод не выполняет никаких действий, которые зависят от результатов операции.

**Примечание.** Асинхронный вызов в предыдущем коде использует метод ThreadPool.RunAsync только для демонстрации простого способа активации события в фоновом потоке. Вы можете написать этот метод, как показано в следующем примере, и он будет работать, так как планировщик заданий .NET автоматически маршалирует асинхронные вызовы и вызовы await в поток пользовательского интерфейса.
  
```csharp
    public async void MakeToast(string message)
    {
        Toast toast = new Toast(message)
        await Task.Delay(new Random().Next(1000));
        OnToastCompleted(toast);
    }
```

При построении проекта теперь следует создавать без ошибок.

## <a name="to-program-the-javascript-app"></a>Программирование приложений JavaScript

Теперь можно добавить кнопку для приложения JavaScript, чтобы использовать класс, который мы определили внесение всплывающего уведомления. До этого мы, необходимо добавить ссылку на только что созданный проект ToasterComponent. В обозревателе решений откройте контекстное меню для проекта ToasterApplication, выберите **Добавить &gt; ссылки**, а затем нажмите кнопку **Добавить ссылку** . В диалоговом окне Добавление ссылки в левой области в разделе решения выберите проект, компонент и выберите ToasterComponent в средней области. Нажмите кнопку **ОК**.

В обозревателе решений откройте контекстное меню для проекта ToasterApplication и затем выберите команду **Назначить запускаемым проектом**.

В конце файла default.js добавьте пространство имен содержит функции для вызова компонента и по его. Пространство имен будут иметь две функции: одно — чтобы сделать всплывающего уведомления, другая — для обработки событий выполнения всплывающего уведомления. Реализация makeToast создает объект Toaster, регистрируется обработчик событий и делает всплывающего уведомления. На данный момент обработчика событий ничего не делает, как показано ниже:

```javascript
    WinJS.Namespace.define("ToasterApplication"), {
       makeToast: function () {

          var toaster = new ToasterComponent.Toaster();
          //toaster.addEventListener("ontoastcompletedevent", ToasterApplication.toastCompletedEventHandler);
          toaster.ontoastcompletedevent = ToasterApplication.toastCompletedEventHandler;
          toaster.makeToast("Peanut Butter");
       },

       toastCompletedEventHandler: function(event) {
           // The sender of the event (the delegate's first type parameter)
           // is mapped to event.target. The second argument of the delegate
           // is contained in event, which means in this case event is a
           // Toast class, with a toastType string.
           var toastType = event.toastType;

           document.getElementById('toastOutput').innerHTML = "<p>Made " + toastType + " toast</p>";
        },
    });
```

Функция makeToast необходимо подключить к кнопке. Обновление default.html для включения кнопки и место для вывода в результате внесения всплывающего уведомления:

```html
    <body>
        <h1>Click the button to make toast</h1>
        <button onclick="ToasterApplication.makeToast()">Make Toast!</button>
        <div id="toasterOutput">
            <p>No Toast Yet...</p>
        </div>
    </body>
```

Если мы не были TypedEventHandler, мы теперь сможет запустить приложение на локальном компьютере и нажмите кнопку, чтобы сделать всплывающего уведомления. Однако в нашем приложения ничего не происходит. Чтобы выяснить, почему, давайте отладку управляемого кода, которое вызывается ToastCompletedEvent. Остановить проект, а затем в строке меню выберите **отладки &gt; свойства приложения Toaster**. Измените **Тип отладчика** к **управляемым только**. Еще раз в строке меню щелкните **отладки &gt; исключения**, а затем выберите **Исключения среды CLR**.

Теперь запустите приложение и нажмите кнопку сделать всплывающее. Отладчик перехватывает исключение недопустимого приведения. Несмотря на то, что не очевидно из его сообщения, это исключение происходит из-за отсутствия этого интерфейса прокси-серверы.

![отсутствует прокси-сервера](./images/debuggererrormissingproxy.png)

Первым шагом для создания прокси-сервер и заглушку компонент — это добавление уникальный идентификатор или идентификатор GUID в интерфейсы. Тем не менее формат GUID отличается в зависимости от того, было ли вы написания кода на C#, Visual Basic или другой язык .NET или C++.

## <a name="to-generate-guids-for-the-components-interfaces-c-and-other-net-languages"></a>Для создания идентификаторов GUID для компонента интерфейсов (C# и другие языки .NET)

В строке меню щелкните Сервис &gt; создания идентификаторов GUID. В диалоговом окне выберите 5. \[GUID ("xxxxxxxx-xxxx... xxxx) \]. Нажмите кнопку новый GUID, а затем нажмите кнопку Копировать.

![Средство создания GUID](./images/guidgeneratortool.png)

Вернитесь к определению интерфейса и затем вставьте новый GUID перед интерфейс IToaster, как показано в следующем примере. (Не используйте идентификатор GUID в примере. Каждый уникальный интерфейс должен иметь собственный GUID.)

```cpp
[Guid("FC198F74-A808-4E2A-9255-264746965B9F")]
        public interface IToaster...
```

Добавьте using директив для пространства имен System.Runtime.InteropServices.

Повторите эти шаги для интерфейса IToast.

## <a name="to-generate-guids-for-the-components-interfaces-c"></a>Для создания идентификаторов GUID для интерфейсов компонента (C++)

В строке меню щелкните Сервис &gt; создания идентификаторов GUID. В диалоговом окне выберите 3. статические const struct GUID = {...}. Нажмите кнопку новый GUID, а затем нажмите кнопку Копировать.

Вставьте идентификатор GUID непосредственно перед определением интерфейса IToaster. После вставки, идентификатор GUID должен иметь следующий вид: (Не используйте идентификатор GUID в примере. Каждый уникальный интерфейс должен иметь собственный GUID.)
```cpp
// {F8D30778-9EAF-409C-BCCD-C8B24442B09B}
    static const GUID <<name>> = { 0xf8d30778, 0x9eaf, 0x409c, { 0xbc, 0xcd, 0xc8, 0xb2, 0x44, 0x42, 0xb0, 0x9b } };
```
Добавьте using директив для Windows.Foundation.Metadata для переноса GuidAttribute в области действия.

Теперь вручную преобразуйте const GUID GuidAttribute таким образом, чтобы он имеет формат, как показано в следующем примере. Обратите внимание на то, что фигурные скобки заменяются скобки и скобки и удаленными конечные точки с запятой.
```cpp
// {E976784C-AADE-4EA4-A4C0-B0C2FD1307C3}
    [GuidAttribute(0xe976784c, 0xaade, 0x4ea4, 0xa4, 0xc0, 0xb0, 0xc2, 0xfd, 0x13, 0x7, 0xc3)]
    public interface IToaster
    {...
```
Повторите эти шаги для интерфейса IToast.

Теперь, когда интерфейсы иметь уникальные идентификаторы, мы Создание файла IDL путем передачи данных в файл .winmd в winmdidl средства командной строки и затем создать исходный код C для прокси-сервер и заглушку путем передачи данных, IDL-файл в инструмент командной строки MIDL. Visual Studio для этого нам нужно создать события после построения, как показано на следующем этапе.

## <a name="to-generate-the-proxy-and-stub-source-code"></a>Чтобы создать прокси и заглушка исходный код

Добавление настраиваемого события после построения, в окне Обозреватель решений откройте контекстное меню для проекта ToasterComponent и выберите пункт Свойства. В левой области страницы свойств выберите события построения и затем нажмите кнопку изменить после построения. Добавьте следующие команды в командной строке после построения. (Пакетный файл должна вызываться сначала настроить переменные среды для поиска средство winmdidl.)

```cpp
call "$(DevEnvDir)..\..\vc\vcvarsall.bat" $(PlatformName)
winmdidl /outdir:output "$(TargetPath)"
midl /metadata_dir "%WindowsSdkDir%References\CommonConfiguration\Neutral" /iid "$(ProjectDir)$(TargetName)_i.c" /env win32 /h "$(ProjectDir)$(TargetName).h" /winmd "Output\$(TargetName).winmd" /W1 /char signed /nologo /winrt /dlldata "$(ProjectDir)dlldata.c" /proxy "$(ProjectDir)$(TargetName)_p.c" "Output\$(TargetName).idl"
```

**Важные**  Для ARM или x64 конфигурации проекта, измените параметр/env MIDL на x64 или arm32.

Чтобы IDL-файл ключа каждый раз при изменении файла .winmd, изменить для **запуска события после построения** **при построении обновляются выходные данные проекта.**
Страница свойств события построения должен выглядеть примерно следующим образом: ![события построения](./images/buildevents.png)

Повторное построение решения для создания и компиляции IDL.

Вы можете проверить, что MIDL правильно компиляции решения ищет ToasterComponent.h, ToasterComponent_i.c, ToasterComponent_p.c и dlldata.c в каталоге проекта ToasterComponent.

## <a name="to-compile-the-proxy-and-stub-code-into-a-dll"></a>Чтобы скомпилировать прокси и заглушка кода в DLL-ФАЙЛ

Теперь, когда у вас необходимые файлы, их необходимо создать библиотеку DLL, которая представляет собой файл C++ можно компилировать. Чтобы сделать этот процесс, добавьте новый проект для поддержки создания прокси-серверов. Откройте контекстное меню для решения ToasterApplication и выберите **Добавить > Создать проект**. В левой области диалогового окна **Новый проект** разверните узел **Visual C++ &gt; Windows &gt; Univeral Windows**и выберите **библиотеку DLL (UWP приложения)** в средней области. (Обратите внимание на то, что это не проект C++ компонента среды выполнения Windows). Назовите проект прокси-серверы, а затем нажмите кнопку **ОК** . Эти файлы будут обновлены с события после построения при каких-либо изменений в классе C#.

По умолчанию прокси-серверы проекта создает заголовок h-файлы и C++ CPP-файлы. Так как из файлов, создаваемый из MIDL построения библиотеки DLL, h-файл и расширением CPP файлы не требуются. В обозревателе решений откройте контекстное меню для них, выберите команду **Удалить**и подтвердите удаление.

Теперь, когда проект не задано, можно добавить обратно MIDL созданные файлы. Откройте контекстное меню для проекта прокси-серверов и нажмите кнопку **Добавить > существующий элемент.** В диалоговом окне перейдите к каталогу проекта ToasterComponent и выберите эти файлы: ToasterComponent.h, ToasterComponent_i.c, ToasterComponent_p.c и dlldata.c файлы. Нажмите кнопку **Добавить** .

В проекте прокси-серверов создайте DEF-файл, чтобы определить экспорта библиотеки DLL, описанной в dlldata.c. Откройте контекстное меню для проекта и нажмите кнопку **Добавить > создать элемент**. В левой области диалогового окна выберите код и затем в средней области, выберите файл определения модуля. Имя файла proxies.def и затем нажмите кнопку **Добавить** . Откройте этот DEF-файл и измените его, выполнив экспорт, которые определены в dlldata.c:

```cpp
EXPORTS
    DllCanUnloadNow         PRIVATE
    DllGetClassObject       PRIVATE
```

Если построение проекта теперь она завершится с ошибкой. Чтобы скомпилировать этот проект правильно, необходимо изменить компилируется и связанного проекта. В обозревателе решений откройте контекстное меню для проекта прокси-серверы и выберите пункт **Свойства**. Изменение страницы свойств следующим образом.

В левой области выберите **C/C++ > препроцессор**и затем в области справа выберите **Препроцессор определения**, нажмите кнопку со стрелкой вниз и выберите **Изменить**. Добавьте следующие определения в поле:

```cpp
WIN32;_WINDOWS
```
В разделе **C/C++ > предварительно скомпилированные заголовки**, изменить **Предварительно скомпилированный заголовок** **Не использовать предварительно скомпилированный заголовок**и затем нажмите кнопку **Применить** .

В разделе **компоновщика > Общие**, измените **Пропустить библиотеку импорта** на s **имеет значение yes**и затем нажмите кнопку **Применить** .

В разделе **компоновщика > ввода**, установите **Следующие дополнительные зависимости**, нажмите кнопку со стрелкой вниз и выберите **Изменить**. Добавьте этот текст в поле:

```cpp
rpcrt4.lib;runtimeobject.lib
```

Не вставить этих библиотек непосредственно в строку списка. Убедитесь, что MSBuild в Visual Studio будет поддерживать правильное Дополнительные зависимости с помощью поля **редактирования** .

После внесения изменений нажмите кнопку **ОК** в диалоговом окне **Страницы свойств** .

Рассмотрим процедуру выполните зависимости проекта ToasterComponent. Это гарантирует, что Toaster выполняет построение перед построения проекта прокси-сервера. Это необходимо, так как проект Toaster несет ответственность за создание файлов для создания прокси-сервера.

Откройте контекстное меню для проекта прокси-серверы и затем выберите команду зависимости проекта. Установите флажки, чтобы указать, что прокси-серверы проекта зависит от ToasterComponent проекта, чтобы убедиться, что Visual Studio выполняет построение их в правильном порядке.

Проверьте правильность построения решения, выбрав **Построение > Перестроить решение** в панели меню Visual Studio.


## <a name="to-register-the-proxy-and-stub"></a>Чтобы зарегистрировать прокси-сервер и заглушку

В проекте ToasterApplication откройте контекстное меню для package.appxmanifest и выберите **Открыть с помощью**. В диалоговом окне Открыть с помощью выберите **Текстовый редактор XML** и затем нажмите кнопку **ОК** . Мы собираемся вставить в некоторых XML, который включает сведения о регистрации расширения windows.activatableClass.proxyStub и который основаны на издателе в прокси-сервера. Чтобы найти GUID для использования в файле .appxmanifest, откройте ToasterComponent_i.c. Поиск записи, похожие из них в следующем примере. Также Обратите внимание на то определения для IToast, IToaster и интерфейс — обработчику типизированных событий, который имеет два параметра: Toaster и всплывающего уведомления. Это соответствует события, определенного в классе Toaster. Обратите внимание на то, что идентификаторы GUID для IToast и IToaster соответствующие идентификаторы GUID, определенные на интерфейсы в файле C#. Так как интерфейс обработчика событий типизированных создается автоматически, идентификатор GUID для этого интерфейса также создается автоматически.

```cpp
MIDL_DEFINE_GUID(IID, IID___FITypedEventHandler_2_ToasterComponent__CToaster_ToasterComponent__CToast,0x1ecafeff,0x1ee1,0x504a,0x9a,0xf5,0xa6,0x8c,0x6f,0xb2,0xb4,0x7d);

MIDL_DEFINE_GUID(IID, IID___x_ToasterComponent_CIToast,0xF8D30778,0x9EAF,0x409C,0xBC,0xCD,0xC8,0xB2,0x44,0x42,0xB0,0x9B);

MIDL_DEFINE_GUID(IID, IID___x_ToasterComponent_CIToaster,0xE976784C,0xAADE,0x4EA4,0xA4,0xC0,0xB0,0xC2,0xFD,0x13,0x07,0xC3);
```

Теперь мы скопируйте идентификаторы GUID, вставьте их в package.appxmanifest в узел, мы добавлять и имя расширения и их переформатировать. Манифеста запись выглядит следующим образом, но еще раз, не забудьте свои собственные идентификаторы GUID. Обратите внимание, что идентификатор GUID ClassId в XML-КОДЕ то же, что ITypedEventHandler2. Это, так как этот идентификатор GUID является первым, указанный в ToasterComponent_i.c. Идентификаторы GUID здесь регистр не учитывается. Вместо вручную форматирования идентификаторы GUID для IToast и IToaster, можно вернуться в определения интерфейса и получить значение GuidAttribute, имеет правильный формат. В C++ это правильный формат GUID в комментарии. В любом случае необходимо вручную переформатировать идентификатор GUID, который используется для ClassId и обработчика событий.

```cpp
      <Extensions> <!--Use your own GUIDs!!!-->
        <Extension Category="windows.activatableClass.proxyStub">
          <ProxyStub ClassId="1ecafeff-1ee1-504a-9af5-a68c6fb2b47d">
            <Path>Proxies.dll</Path>
            <Interface Name="IToast" InterfaceId="F8D30778-9EAF-409C-BCCD-C8B24442B09B"/>
            <Interface Name="IToaster"  InterfaceId="E976784C-AADE-4EA4-A4C0-B0C2FD1307C3"/>  
            <Interface Name="ITypedEventHandler_2_ToasterComponent__CToaster_ToasterComponent__CToast" InterfaceId="1ecafeff-1ee1-504a-9af5-a68c6fb2b47d"/>
          </ProxyStub>      
        </Extension>
      </Extensions>
```

Вставьте расширения XML-узла в качестве прямым потомком узел пакетов и однорангового узла, например, узел ресурсы.

Перед перемещением не важно, чтобы убедиться, что:

-   В файле ToasterComponent\_i.c ProxyStub ClassId имеет значение первого GUID. Используйте первый идентификатор GUID, который определен в этот файл на classId. (Это может быть таким же, как идентификатор GUID для ITypedEventHandler2.)
-   Путь — это относительный путь пакет двоичных прокси-сервера. (В этом пошаговом руководстве proxies.dll находится в той же папке, что ToasterApplication.winmd.)
-   Идентификаторы GUID находятся в правильном формате. (Это легко получить неверный.)
-   Интерфейс идентификаторы в манифесте соответствующие идентификаторы IID в файле ToasterComponent\_i.c.
-   Имена интерфейсов должны быть уникальными в манифесте. Так как они не используются в системе, можно выбрать значения. Рекомендуется выбрать имена интерфейсов, четко соответствующие интерфейсы, которые определены. Для созданного интерфейсов имена должно быть указывает созданный интерфейсов. Файл ToasterComponent\_i.c можно использовать для создания имени интерфейса.

При попытке запуска решения теперь вы появится сообщение об ошибке, proxies.dll не является частью полезных данных. Откройте контекстное меню для папки **ссылок** в проекте ToasterApplication и затем выберите команду **Добавить ссылку**. Установите флажок рядом с проектом, прокси-серверы. Кроме того убедитесь в том, что установлен флажок рядом с полем ToasterComponent. Нажмите кнопку **ОК**.

Теперь следует создать проект. Запустите проект и убедитесь, что можно сделать всплывающего уведомления.

## <a name="related-topics"></a>Еще по теме

* [Создание компонентов среды выполнения Windows на C++](creating-windows-runtime-components-in-cpp.md)
