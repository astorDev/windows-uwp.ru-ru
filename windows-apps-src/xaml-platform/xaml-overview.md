---
author: jwmsft
description: "В этой статье мы представляем разработчикам приложений среды выполнения Windows язык XAML и его принципы и описываем различные способы объявления объектов и установки атрибутов в XAML при создании приложения среды выполнения Windows."
title: "Обзор языка XAML"
ms.assetid: 48041B37-F1A8-44A4-BB8E-1D4DE30E7823
ms.author: jimwalk
ms.date: 02/08/2017
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp
ms.openlocfilehash: 60b47a2c2c072efbf3ccedfcc48b9cba1611a370
ms.sourcegitcommit: 909d859a0f11981a8d1beac0da35f779786a6889
translationtype: HT
---
# <a name="xaml-overview"></a>Обзор языка XAML

\[ Обновлено для приложений UWP в Windows10. Статьи о Windows 8.x, см. в [архиве](http://go.microsoft.com/fwlink/p/?linkid=619132) \]

В этой статье мы представляем разработчикам приложений среды выполнения Windows язык XAML и его принципы и описываем различные способы объявления объектов и установки атрибутов в XAML при создании приложения среды выполнения Windows.

## <a name="what-is-xaml"></a>Что такое XAML?

XAML— это декларативный язык. В частности, XAML позволяет инициализировать объекты и задавать их свойства с помощью языковой структуры, которая отражает иерархические связи между множеством объектов, а также с помощью соглашения о резервных типах, предусматривающего возможность расширения типов. Вы можете создать видимые элементы пользовательского интерфейса в декларативной разметке XAML. Затем можно сопоставить каждый файл XAML с отдельным файлом кода программной части, отвечающим за обработку событий и манипуляции с объектами, которые были первоначально объявлены в коде XAML.

Язык XAML поддерживает обмен источниками между разными инструментами и ролями процесса разработки— например, обмен источниками XAML между средствами разработки и интерфейсом IDE либо между главными разработчиками и локализаторами. При использовании XAML в качестве формата обмена можно разделять или объединять роли конструктора и разработчика, а в процессе производства приложения конструкторы и разработчики могут повторять операции.

В составе проектов приложений среды выполнения Windows файлы XAML представляют собой XML-файлы с расширением .xaml.

## <a name="basic-xaml-syntax"></a>Базовый синтаксис языка XAML

Базовый синтаксис языка XAML основан на XML. Согласно определению, допустимый код XAML должен быть также допустимым кодом XML. Однако некоторые синтаксические принципы XAML имеют другое, более полное значение, будучи допустимыми в XML согласно спецификации XML1.0. Например, XAML поддерживает *синтаксис элементов свойств*, при котором значения свойств могут быть установлены в элементах, а не в качестве строковых значений в атрибутах или в качестве содержимого. Для обычного XML элемент свойства XAML— это элемент, в имени которого содержится точка, то есть он является допустимым, но имеет другое значение.

## <a name="xaml-and-microsoft-visual-studio"></a>XAML и Microsoft Visual Studio

Microsoft Visual Studio помогает соблюдать правила синтаксиса XAML как в текстовом редакторе языка XAML, так и на поверхности разработки XAML, более ориентированной на графику. Поэтому, разрабатывая код XAML для приложения при помощи Visual Studio, не стоит слишком беспокоиться о синтаксисе. Интерфейс IDE помогает обеспечить правильность синтаксиса XAML, предоставляя подсказки автозаполнения, отображая варианты в списках Microsoft IntelliSense, предоставляя библиотеки элементов пользовательского интерфейса на панели инструментов и используя другие методы. Если это ваш первый опыт создания кода XAML, будет полезно ознакомиться с правилами синтаксиса, особенно с терминами, которые иногда используются в справочных и других разделах для обозначения ограничений или вариантов выбора при описании синтаксиса XAML. Эти особенности синтаксиса XAML мы рассмотрим в отдельном разделе: [Синтаксис языка XAML](xaml-syntax-guide.md).

## <a name="xaml-namespaces"></a>Пространства имен XAML

В общем контексте программирования пространство имен— это принцип организации, определяющий правила интерпретации идентификаторов, ссылающихся на сущности программирования. С помощью пространств имен в инфраструктуре программирования можно отделить идентификаторы, объявленные пользователем, от идентификаторов, объявленных самой инфраструктурой, устранить неоднозначность идентификаторов, используя квалификаторы пространства имен, выполнить правила для определения областей имен ит.д. В языке XAML эту функцию выполняет собственная концепция пространства имен XAML. Вот как в языке XAML применяются и развиваются понятия пространств имен XML.

-   XAML использует зарезервированный атрибут XML **xmlns** для объявления пространства имен. Значением атрибута обычно является универсальный код ресурса (URI)—соглашение, унаследованное от XML.
-   Пространства имен не по умолчанию объявляются в XAML с назначением им префиксов, которые затем указываются в элементах и атрибутах для ссылки на соответствующее пространство имен.
-   В XAML существует понятие пространства имен по умолчанию, которое используется в отсутствие префиксов в объявлении или использовании пространства имен. Пространство имен по умолчанию можно определить по-разному для каждой платформы программирования XAML.
-   Определения пространств имен в XAML-файле или конструкции наследуются от родительского элемента к дочернему. Например, если определить пространство имен в корневом элементе XAML-файла, то все элементы в этом файле унаследуют данное определение пространства имен. Если пространство имен будет переопределено в некотором элементе далее вниз по структуре страницы, то потомки этого элемента унаследуют новое определение.
-   Атрибуты элемента наследуют его пространства имен. Атрибуты XAML довольно редко имеют префиксы.

В корневом элементе XAML-файла почти всегда объявляется пространство имен XAML по умолчанию. Пространство имен XAML по умолчанию определяет, какие элементы можно объявить без указания уточняющего префикса. В стандартных проектах приложений среды выполнения Windows такое пространство имен по умолчанию содержит полный встроенный словарь XAML для среды выполнения Windows, который используется для определений пользовательского интерфейса: элементы управления по умолчанию, текстовые элементы, графика и анимации XAML, типы привязки данных и поддержки стилей ит.д. Таким образом, в большинстве случаев при написании кода XAML для приложений среды выполнения Windows можно избежать использования пространств имен и префиксов XAML при ссылках на распространенные элементы пользовательского интерфейса.

Приведенный здесь фрагмент кода представляет собой созданный по шаблону корневой элемент [**Page**](https://msdn.microsoft.com/library/windows/apps/br227503) начальной страницы приложения (в упрощенном виде и только с открывающим тегом). Он объявляет пространство имен по умолчанию и пространство имен **x** (о котором пойдет речь ниже).

```xml
<Page
    x:Class="Application1.BlankPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
>
```

## <a name="the-xaml-language-xaml-namespace"></a>Собственное пространство имен языка XAML

Среди пространств имен XAML можно выделить одно, которое объявляется почти в каждом XAML-файле среды выполнения Windows,— это пространство имен языка XAML. В него входят элементы и понятия, которые определяются в спецификации языка XAML. По соглашению, с собственным пространством имен языка XAML сопоставлен префикс x. В шаблонах проектов и файлов по умолчанию для проектов приложений среды выполнения Windows в качестве части корневого элемента всегда определены пространство имен XAML по умолчанию (без префикса, используется только `xmlns=`) и собственное пространство имен языка XAML (с префиксом x).

Префикс x (собственное пространство имен языка XAML) содержит несколько программных конструкций, которые часто используются в XAML-коде. Здесь приведены наиболее распространенные.

| Термин | Описание |
|------|-------------|
| [x:Key](x-key-attribute.md) | Задает определяемый пользователем уникальный ключ для каждого ресурса в [**ResourceDictionary**](https://msdn.microsoft.com/library/windows/apps/br208794) XAML. Строка токена этого ключа служит аргументом для расширения разметки **StaticResource**, а затем этот ключ будет использоваться для получения ресурса XAML из фрагмента XAML в другой части приложения. |
| [x:Class](x-class-attribute.md) | Определяет пространство имен кода и имя класса, предоставляющего код программной части для XAML-страницы. Таким образом задается имя класса, который создается или присоединяется действиями при сборке приложения. Эти действия при сборке поддерживают компилятор разметки XAML и объединяют разметку и код программной части во время компиляции приложения. Такой класс необходим для поддержки кода программной части XAML-страницы. [**Window.Content**](https://msdn.microsoft.com/library/windows/apps/br209051) в модели активации среды выполнения Windows по умолчанию. |
| [x:Name](x-name-attribute.md) | Задает имя объекта времени выполнения для экземпляра, существующего в коде времени выполнения после обработки элемента объекта в XAML-коде. Определение **x:Name** в XAML можно представить как объявление именованной переменной в программном коде. Далее вы увидите, что, когда XAML загружается в качестве компонента для приложения среды выполнения Windows, все происходит именно так. <br/><div class="alert">**Примечание.** Свойство [**FrameworkElement.Name**](https://msdn.microsoft.com/library/windows/apps/br208735) в платформе несет аналогичную функцию, но его поддерживают не все элементы. Поэтому **x:Name** используется для идентификации элементов, тип которых не поддерживает **FrameworkElement.Name**. |
| [x:Uid](x-uid-directive.md) | Определяет элементы, которые должны использовать локализованные ресурсы для некоторых значений их свойств. Подробнее об использовании **x:Uid** см. в разделе [Краткое руководство: перевод ресурсов пользовательского интерфейса](https://msdn.microsoft.com/library/windows/apps/xaml/hh965329). |
| [Встроенные типы данных в языке XAML](xaml-intrinsic-data-types.md) | Эти типы могут указывать значения для простых типов значений, если это требуется для некоторого атрибута или ресурса. Такие встроенные типы соответствуют простым типам значений, которые обычно задаются во встроенных определениях каждого языка программирования. Например, вам может потребоваться объект, представляющий логическое значение **true**, для использования в раскадрованном визуальном состоянии [**ObjectAnimationUsingKeyFrames**](https://msdn.microsoft.com/library/windows/apps/br210320). В XAML для этого значения используется встроенный тип **x:Boolean** в качестве элемента объекта, например так: <code>&lt;x:Boolean&gt;True&lt;/x:Boolean&gt;</code> | 

Другие программные конструкции из собственного пространства имен языка XAML используются не так часто.

## <a name="mapping-custom-types-to-xaml-namespaces"></a>Сопоставление настраиваемых типов с пространствами имен XAML

Одной из сильных сторон языка XAML является простота расширения словаря XAML для приложений среды выполнения Windows. Вы можете определить собственные настраиваемые типы на языке программирования, выбранном для приложения, а затем ссылаться на них в разметке XAML. Поддержка расширения за счет настраиваемых типов— фундаментальный и неотъемлемый принцип функционирования языка XAML. Разработчики платформ и приложений отвечают за создание базовых объектов, на которые ссылается XAML. Ни платформы, ни разработчики приложений не ограничены спецификациями возможного содержимого и возможных действий объектов в словарях. Необходимо соблюдать лишь базовые правила синтаксиса XAML. (В отношении типов пространства имен XAML в языке XAML есть некоторые ожидания, однако среда выполнения Windows предоставляет всю необходимую поддержку.)

Если вы используете XAML для типов, полученных не из основных библиотек и метаданных среды выполнения Windows, а из других библиотек, вы должны объявить пространство имен XAML и сопоставить с ним префикс. Указывайте этот префикс при использовании элементов для ссылки на типы, которые определены в вашей библиотеке. Сопоставления с префиксом объявляются как атрибуты **xmlns**, обычно в корневом элементе вместе с другими определениями пространств имен XAML.

Чтобы создать собственное определение пространства имен со ссылкой на настраиваемые типы, сначала нужно указать ключевое слово **xmlns:**, а затем—желаемый префикс. Значение этого атрибута должно содержать ключевое слово **using:** в качестве первой части значения. Оставшаяся часть значения является строковым токеном, ссылающимся по имени на код конкретного базового пространства имен, содержащего настраиваемые типы.

Префикс задает токен для ссылки на это пространство имен XAML в оставшейся части разметки этого файла XAML. Префикс отделяется двоеточием (:) от элемента в пространстве имен XAML, на который он ссылается.

Например, синтаксис атрибута для сопоставления префикса `myTypes` с пространством имен `myCompany.myTypes` выглядит как `    xmlns:myTypes="using:myCompany.myTypes"`, а образец использования элемента следующий: `<myTypes:CustomButton/>`

Подробнее о сопоставлении пространств имен XAML для настраиваемых типов, а также особые вопросы работы с расширениями компонентов Visual C++ (C++/CX) см. в разделе [Пространства имен XAML и сопоставление пространств имен](xaml-namespaces-and-namespace-mapping.md).

## <a name="other-xaml-namespaces"></a>Другие пространства имен XAML

Часто встречаются XAML-файлы, в которых определены префиксы d (для пространства имен конструктора) и mc (для совместимости разметки). Как правило, они используются для поддержки инфраструктуры либо для включения сценариев в средство для определения времени разработки. Подробнее см. в [разделе "Другие пространства имен XAML" темы о пространствах имен XAML](xaml-namespaces-and-namespace-mapping.md#other-XAML-namespaces).

## <a name="markup-extensions"></a>Расширения разметки

Расширения разметки—это структура языка XAML, которая часто используется при реализации XAML в среде выполнения Windows. Расширения разметки часто представляют собой своего рода "ярлык", при помощи которого в XAML-файле можно получать доступ к тому или иному значению или поведению. Это не простое объявление элементов на основе базовых типов. Некоторые расширения разметки могут задавать свойства с простыми строками или с дополнительными вложенными элементами, чтобы упростить синтаксис или разделение кода на различные XAML-файлы.

В синтаксисе атрибутов XAML фигурные скобки "{" и "}" обозначают использование расширения разметки XAML. Они предписывают обработчику XAML отклониться от общей процедуры обработки значений атрибутов как строковых литералов или значений, напрямую преобразуемых в строки. Вместо этого средство синтаксического анализа языка XAML вызывает код, который обеспечивает работу данного расширения разметки, и этот код предоставляет альтернативный результат в виде объекта или поведения, необходимого средству синтаксического анализа. Расширения разметки могут иметь аргументы, которые следуют за именем расширения разметки и также заключаются в фигурные скобки. Обычно расширение разметки после вычисления предоставляет возвращаемое значение объекта. Во время синтаксического анализа это возвращаемое значение вставляется в дереве объектов в ту позицию, где расширение разметки использовалось в исходном XAML.

Реализация XAML в среде выполнения Windows использует следующие расширения разметки, которые определены в пространстве имен XAML по умолчанию и распознаются синтаксическим анализатором XAML среды выполнения Windows:

-   [{xBind}](x-bind-markup-extension.md): поддерживает привязку данных, которая откладывает оценку свойства до времени выполнения путем выполнения одноцелевого кода, создаваемого во время компиляции. Расширение разметки поддерживает широкий диапазон аргументов.
-   [{Binding}](binding-markup-extension.md): поддерживает привязку данных, которая откладывает оценку свойства до времени выполнения путем запуска универсальной проверки объекта среды выполнения. Расширение разметки поддерживает широкий диапазон аргументов.
-   [{StaticResource}](staticresource-markup-extension.md): поддерживает ссылки на значения ресурсов, определенные в [**ResourceDictionary**](https://msdn.microsoft.com/library/windows/apps/br208794). Эти ресурсы могут находиться в другом XAML-файле, но в конечном итоге средство синтаксического анализа XAML должно иметь возможность найти их во время загрузки. Аргумент, задаваемый при использовании `{StaticResource}`, определяет ключ (имя) для ресурса с ключом в [**ResourceDictionary**](https://msdn.microsoft.com/library/windows/apps/br208794).
-   [{ThemeResource}](themeresource-markup-extension.md): аналогично [{StaticResource}](staticresource-markup-extension.md), но может отвечать на изменения в теме в среде выполнения. {ThemeResource} довольно часто встречается в шаблонах XAML по умолчанию для среды выполнения Windows, поскольку большинство таких шаблонов предназначены для обеспечения совместимости в ситуации, когда пользователь переключает тему во время работы приложения.
-   [{TemplateBinding}](templatebinding-markup-extension.md): особый случай [{Binding}](binding-markup-extension.md), который поддерживает шаблоны элемента управления в XAML и их возможное использование в среде выполнения.
-   [{RelativeSource}](relativesource-markup-extension.md): обеспечивает особую форму привязки шаблонов, в которой значения берутся из родительского шаблона.
-   [{CustomResource}](customresource-markup-extension.md): для сценариев поиска дополнительных ресурсов.

Среда выполнения Windows также поддерживает расширение разметки [{x:Null}](x-null-markup-extension.md). Используйте его, чтобы установить значение **null** для значений [**Nullable**](https://msdn.microsoft.com/library/windows/apps/xaml/b3h38hb0.aspx) в XAML. Например, его можно использовать в шаблоне элемента управления для [**CheckBox**](https://msdn.microsoft.com/library/windows/apps/br209316), который интерпретирует значение **null** как неопределенное состояние флажка (что запускает визуальное состояние Indeterminate).

Расширение разметки обычно возвращает существующий экземпляр из какой-либо другой части графа объектов приложения или откладывает определение значения до начала выполнения. Поскольку расширение разметки можно использовать в качестве значения атрибута и это использование является основным, часто встречаются расширения разметки, предоставляющие значения для свойств ссылочного типа, что в прочих случаях может потребовать синтаксиса элемента свойства.

Например, так выглядит синтаксис для ссылки на многократно используемое свойство [**Style**](https://msdn.microsoft.com/library/windows/apps/br208849) из [**ResourceDictionary**](https://msdn.microsoft.com/library/windows/apps/br208794): `<Button Style="{StaticResource SearchButtonStyle}"/>` [**Style**](https://msdn.microsoft.com/library/windows/apps/br208849)—это ссылочный тип, а не простое значение, поэтому без использования `{StaticResource}` потребовался бы элемент свойства `<Button.Style>` и заданное в нем определение `<Style>`, чтобы задать свойство [**FrameworkElement.Style**](https://msdn.microsoft.com/library/windows/apps/br208743).

При использовании расширений разметки каждое свойство, которое можно установить в XAML, потенциально можно установить в синтаксисе атрибута. Синтаксис атрибута можно использовать для задания ссылочных значений свойства, даже если последнее в остальных случаях не поддерживает синтаксис атрибута для непосредственного создания экземпляра объекта. Также можно включить конкретное расширение функциональности, которое будет откладывать выполнение общего требования о том, что свойства XAML должны заполняться типами значений или вновь созданными ссылочными типами.

Например, в следующем примере кода XAML значение свойства [**Style**](https://msdn.microsoft.com/library/windows/apps/br208743) элемента [**Border**](https://msdn.microsoft.com/library/windows/apps/br209250) устанавливается с использованием синтаксиса атрибута. Свойство [**Style**](https://msdn.microsoft.com/library/windows/apps/br208743) принимает экземпляр класса [**Style**](https://msdn.microsoft.com/library/windows/apps/br208849) ссылочного типа, который по умолчанию не может создаваться с помощью строки синтаксиса атрибута. Но в данном случае атрибут ссылается на конкретное расширение разметки— [StaticResource](staticresource-markup-extension.md). После обработки это расширение разметки возвращает ссылку на элемент **Style**, который был ранее определен как ресурс с ключом в словаре ресурсов.

```xml
<Canvas.Resources>
  <Style TargetType="Border" x:Key="PageBackground">
    <Setter Property="BorderBrush" Value="Blue"/>
    <Setter Property="BorderThickness" Value="5"/>
  </Style>
</Canvas.Resources>
...
<Border Style="{StaticResource PageBackground}">
  ...
</Border>
```

Расширения разметки можно делать вложенными. Сначала вычисляется самое внутреннее расширение.

Из-за расширений разметки требуется особый синтаксис для значения литерала "{" в атрибуте. Подробнее: [Синтаксис языка XAML](xaml-syntax-guide.md).

## <a name="events"></a>События

XAML— декларативный язык для объявления объектов и их свойств, но он также содержит синтаксис для назначения обработчиков событий объектам в разметке. Синтаксис событий XAML позволяет затем интегрировать события, объявленные в коде XAML, через модель программирования среды выполнения Windows. Имя события задается как имя атрибута объекта, в котором обрабатывается событие. В качестве значения атрибута указывается имя функции обработчика событий, которая определяется в коде. Обработчик XAML использует это имя для создания представления делегирования в загруженном дереве объектов и добавляет указанный обработчик во внутренний список обработчиков. Почти все приложения среды выполнения Windows определяются на основе как источников разметки, так и источников кода программной части.

Приведем простой пример. Класс [**Button**](https://msdn.microsoft.com/library/windows/apps/br209265) поддерживает событие [**Click**](https://msdn.microsoft.com/library/windows/apps/br227737). Вы можете создать обработчик для **Click**, запускающий код, который должен вызываться после того, как пользователь щелкнет **Button**. В XAML **Click** указывается как атрибут для **Button**. В качестве значения атрибута следует задать строку, содержащую название метода обработчика.

```xml
<Button Click="showUpdatesButton-Click">Show updates</Button>
```

Теперь компилятор ожидает, что метод `showUpdatesButton-Click` будет определен в файле кода программной части в пространстве имен, объявленном в значении [x:Class](x-class-attribute.md) на XAML-странице. Этот метод должен также удовлетворять условиям контракта делегирования для события [**Click**](https://msdn.microsoft.com/library/windows/apps/br227737). Пример.

> [!div class="tabbedCodeSnippets"]
```csharp
namespace App1
{
    public sealed partial class MainPage: Page {
        ...
        private void showUpdatesButton-Click (object sender, RoutedEventArgs e) {
            //your code
        }
    }
}
```
```vb
' Namespace included at project level
Public NotInheritable Class MainPage
    Inherits Page
        ...
        Private Sub showUpdatesButton-Click (sender As Object, e As RoutedEventArgs e)
            ' your code
        End Sub
    ...
End Class
```
```cpp
// .h
namespace App1
{
    public ref class MainPage sealed {
        ...
    private:
        void showUpdatesButton-Click (Object^ sender, RoutedEventArgs^ e);
    };
}
```

В проекте код XAML записывается в виде файла .xaml, а файл кода программной части создается на предпочитаемом вами языке (C#, Visual Basic, C++/CX). Когда при сборке проекта компилируется разметка файла XAML, расположение файла кода программной части для каждой XAML-страницы задается указанием пространства имен и класса как атрибута [x:Class](x-class-attribute.md) корневого элемента XAML-страницы. Дополнительные сведения о работе этих механизмов в языке XAML и их связи с моделями программирования и приложений см. в разделе [Обзор событий и перенаправленных событий](events-and-routed-events-overview.md).

**Примечание.** В C++/CX существует два файла кода программной части, один из которых является заголовком (.xaml.h), а второй— реализацией (.xaml.cpp). Реализация ссылается на заголовок, и технически именно заголовок представляет точку входа для подключения кода программной части.

## <a name="resource-dictionaries"></a>Словари ресурсов

Создание [**ResourceDictionary**](https://msdn.microsoft.com/library/windows/apps/br208794) является стандартной задачей, которая обычно сопровождается разработкой словаря ресурсов в виде области страницы XAML или отдельного файла XAML. Словари ресурсов и их использование— это объемная концептуальная область, выходящая за рамки данного раздела. Дополнительные сведения см. в разделе [Ссылки на ресурсы ResourceDictionary и XAML](https://msdn.microsoft.com/library/windows/apps/mt187273).

## <a name="xaml-and-xml"></a>XAML и XML 

Язык XAML имеет в своей основе язык XML. Но XAML значительно расширяет XML. В частности, он иначе интерпретирует понятие схемы ввиду его связи с понятием резервного типа, а также добавляет языковые элементы, такие как прикрепленные члены и расширения разметки. **xml:lang** допускается в XAML, но оказывает влияние на среду выполнения, а не на порядок синтаксического анализа, и обычно является псевдонимом для свойства уровня платформы. Подробнее см. в разделе [**FrameworkElement.Language**](https://msdn.microsoft.com/library/windows/apps/hh702066). **xml:base** допускается в разметке, но игнорируется средствами синтаксического анализа. **xml:space** допускается, но релевантно только для сценариев, описанных в разделе [XAML и пустое пространство](xaml-and-whitespace.md). Атрибут **encoding** является допустимым в XAML. Поддерживаются только кодировки UTF-8 и UTF-16. Кодировка UTF-32 не поддерживается.

###  <a name="case-sensitivity-in-xaml"></a> Учет регистра в XAML

В языке XAML учитывается регистр символов. Это еще одно следствие того, что язык XAML основан на XML, в котором регистр имеет значение. Имена элементов и атрибутов XAML чувствительны к регистру. В значениях атрибутов регистр может быть важен, но на деле все зависит от того, как эти значения обрабатываются для конкретных свойств. Например, если в значении атрибута объявляется имя участника перечисления, то встроенное поведение, которое преобразует тип строки имени участника, чтобы затем возвратить значение участника перечисления, нечувствительно к регистру. В отличие от этого, значение свойства **Name** и служебные методы для работы с объектами по имени, объявленному в свойстве **Name**, интерпретируют строку имени с учетом регистра.

## <a name="xaml-namescopes"></a>Пространства имен XAML

В языке XAML определяется понятие области имен XAML. Оно влияет на то, как обработчики XAML должны интерпретировать значение **x:Name** или **Name**, присвоенное элементам XAML, и особенно на области, в которых ожидается, что имена будут уникальными идентификаторами. Области имен XAML более подробно описываются в специальном разделе [Области имен XAML](xaml-namescopes.md).

## <a name="the-role-of-xaml-in-the-development-process"></a>Роль XAML в процессе разработки

Язык XAML играет ряд важных ролей в процессе разработки приложений.

-   XAML— это основной формат объявления пользовательского интерфейса приложения и элементов этого интерфейса, если вы программируете на C#, Visual Basic или C++/CX. Обычно по крайней мере один XAML-файл в проекте представляет в приложении метафору страницы для первоначально отображаемого пользовательского интерфейса. В других XAML-файлах могут объявляться дополнительные страницы для навигации в пользовательском интерфейсе. В прочих XAML-файлах могут объявляться ресурсы, такие как шаблоны или стили.
-   Формат XAML используется для объявления стилей и шаблонов, применяемых к элементам управления и пользовательскому интерфейсу приложения.
-   Вы можете использовать стили и шаблоны для создания по шаблону существующих элементов управления или при определении элемента управления, поставляющего шаблон по умолчанию в составе своего пакета. Когда вы используете формат XAML для определения стилей и шаблонов, соответствующий XAML-код часто оформляется в виде отдельного XAML-файла с корневым элементом [**ResourceDictionary**](https://msdn.microsoft.com/library/windows/apps/br208794).
-   XAML—это распространенный формат для поддержки конструктора, позволяющий создавать пользовательский интерфейс приложения и обмениваться макетом пользовательского интерфейса между различными приложениями для конструирования. Особое внимание следует обратить на возможность обмена XAML-кодом приложения между различными средствами разработки XAML (и разными окнами в средствах разработки).
-   Есть также ряд других технологий, в которых базовый пользовательский интерфейс определяется на XAML. Будучи родственным языкам Windows Presentation Foundation (WPF) XAML и Microsoft Silverlight XAML, язык XAML для среды выполнения Windows использует тот же универсальный код ресурса (URI) для общего пространства имен XAML по умолчанию. Словарь XAML для среды выполнения Windows существенно пересекается со словарем XAML для пользовательского интерфейса, который также используется в Silverlight и—в несколько меньшей степени—в WPF. Таким образом, язык XAML— это эффективный способ переноса пользовательских интерфейсов, которые первоначально определялись для предшествующих технологий, также использовавших XAML.
-   Код на XAML задает внешний вид пользовательского интерфейса, а связанный с ним файл программной части кода— логику работы. При этом вы можете корректировать макет пользовательского интерфейса, не внося изменений в программную часть. XAML упрощает взаимодействие между дизайнерами и разработчиками.
-   Благодаря возможностям визуального конструктора и тому, что поверхность разработки поддерживает язык XAML, в XAML-коде можно быстро создавать прототип пользовательского интерфейса на ранних этапах разработки.

В зависимости от вашей роли в процессе разработки вы, возможно, не будете работать в большом объеме с XAML-кодом. Степень вашего взаимодействия с файлами XAML зависит также от используемой среды разработки, от применения интерактивных функций, таких как панели элементов и редакторы свойств, а также от объема функциональности и назначения вашего приложения среды выполнения Windows. Тем не менее весьма вероятно, что в ходе разработки приложения вам придется редактировать файл XAML на уровне элементов с помощью текстового редактора или редактора XML. Пользуясь приведенной здесь информацией, вы сможете уверенно редактировать код XAML в текстовом или XML-представлении и соблюдать допустимость объявлений в файле XAML с учетом его цели, когда этот файл служит входными данными для инструментов, операций компиляции разметки или выполнения вашего приложения среды выполнения Windows.

## <a name="optimize-your-xaml-for-load-performance"></a>Оптимизация кода XAML для производительности загрузки

Далее приведено несколько советов по определению элементов пользовательского интерфейса в XAML на основе оптимальных методов повышения производительности. Многие из этих советов относятся к использованию ресурсов XAML, но для удобства приведены здесь, в общем обзоре языка XAML. Подробнее о ресурсах XAML: [ResourceDictionary и ссылки на ресурсы XAML](https://msdn.microsoft.com/library/windows/apps/mt187273). Дополнительные советы по повышению производительности, включая код XAML, специально демонстрирующий приводящие к низкой производительности приемы, которых следует избегать при программировании на XAML, см. в разделе [Оптимизация разметки XAML](https://msdn.microsoft.com/library/windows/apps/mt204779).

-   Если вы часто используете в коде XAML одну и ту же цветную кисть, определите [**SolidColorBrush**](https://msdn.microsoft.com/library/windows/apps/br242962) в качестве ресурса, вместо того чтобы каждый раз использовать именованный цвет как значение атрибута.
-   Если вы используете один и тот же ресурс на нескольких страницах пользовательского интерфейса, рекомендуется определить его в [**Application.Resources**](https://msdn.microsoft.com/library/windows/apps/br242338), а не на каждой странице. И наоборот, если ресурс используется только на одной странице, не определяйте его в **Application.Resources**. Определите его только для страницы, на которой он нужен. Это оптимальный подход и для разделения XAML на составляющие в ходе разработки приложения, и для обеспечения производительности во время синтаксического анализа XAML.
-   Среди ресурсов, которые упаковывает ваше приложение, поищите неиспользуемые ресурсы (имеющие ключ, но без ссылки [StaticResource](staticresource-markup-extension.md) в приложении, которое использует эти ресурсы). Удалите их из кода XAML перед выпуском приложения.
-   Если вы используете отдельные файлы XAML, предоставляющие ресурсы проектирования ([**MergedDictionaries**](https://msdn.microsoft.com/library/windows/apps/br208801)), рекомендуется прокомментировать или удалить неиспользуемые ресурсы из этих файлов. Даже если у вас есть код XAML, который вы используете как отправную точку в нескольких приложениях или который предоставляет общие ресурсы для всех ваших приложений, именно приложение каждый раз упаковывает ресурсы XAML и в некоторых случаях вынуждено загружать их.
-   Не определяйте элементы пользовательского интерфейса, которые не нужны для композиции, и по возможности всегда используйте шаблоны элементов управления по умолчанию (эти шаблоны уже протестированы и проверены на предмет производительности загрузки).
-   Используйте контейнеры, такие как [**Border**](https://msdn.microsoft.com/library/windows/apps/br209250), вместо того чтобы специально перерисовывать элементы пользовательского интерфейса. В целом не следует рисовать один и тот же пиксель несколько раз. Подробнее об избыточной отрисовке и о том, как убедиться в ее отсутствии: [**DebugSettings.IsOverdrawHeatMapEnabled**](https://msdn.microsoft.com/library/windows/apps/hh701823).
-   Используйте шаблоны элементов по умолчанию для [**ListView**](https://msdn.microsoft.com/library/windows/apps/br242878) или [**GridView**](https://msdn.microsoft.com/library/windows/apps/br242705). Они имеют особую логику **Presenter**, которая устраняет проблемы с производительностью при сборке визуального дерева для большого числа элементов списка.

## <a name="debugging-xaml"></a>Отладка XAML

Так как XAML—это язык разметки, некоторые стандартные стратегии для отладки в Microsoft Visual Studio недоступны. Например, отсутствует способ для определения точки останова в XAML-файле. Тем не менее существуют другие методы, которые помогут вам выполнить отладку проблем в определениях пользовательского интерфейса или другой разметке XAML еще во время разработки вашего приложения.

Проблемы в XAML-файле, как правило, приведут к тому, что система или ваше приложение вызовет исключение анализа XAML. Если вызывается исключение анализа XAML, значит, в XAML-коде, загруженном с помощью средства синтаксического анализа XAML, не удалось создать допустимое дерево объектов. В некоторых случаях, например когда XAML представляет первую "страницу" вашего приложения, загруженную как корневой визуальный элемент, исключение анализа XAML не восстанавливается.

XAML-код часто изменяют в интегрированной среде разработки, например в программе Visual Studio и одной из ее поверхностей разработки XAML. Когда вы вносите изменения, Visual Studio в большинстве случаев предоставляет для исходного XAML-кода проверку времени разработки и проверку на наличие ошибок. Например, как только вы введете неправильное значение атрибута, она может подчеркнуть его волнистой линией в текстовом редакторе XAML и вам даже не придется ждать этапа компиляции XAML, чтобы понять, что с вашим определением пользовательского интерфейса что-то не так.

Если после фактического запуска приложения существуют ошибки анализа XAML, которые не были обнаружены во время разработки, среда CLR сообщит о них в виде [**XamlParseException**](https://msdn.microsoft.com/library/windows/apps/hh673774). Подробнее о том, что можно сделать при появлении **XamlParseException** времени выполнения, см. в разделе [Обработка исключений для приложений среды выполнения Windows на C# или Visual Basic](https://msdn.microsoft.com/library/windows/apps/dn532194).

**Примечание.** Приложения, использующие для кода расширения C++/CX, не имеют специального [**XamlParseException**](https://msdn.microsoft.com/library/windows/apps/hh673774). При этом в сообщении исключения поясняется, что источник ошибки связан с XAML, и указывается контекстная информация, например номера строк в XAML-файле, как и в исключении **XamlParseException**.

Подробнее об отладке приложения среды выполнения Windows см. в разделе [Запуск сеанса отладки](https://msdn.microsoft.com/library/windows/apps/xaml/hh781607.aspx).

