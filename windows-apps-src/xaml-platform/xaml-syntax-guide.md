---
description: Здесь разъясняются правила синтаксиса языка XAML и терминология, описывающая доступные для этого синтаксиса ограничения и варианты.
title: Руководство по синтаксису XAML
ms.assetid: A57FE7B4-9947-4AA0-BC99-5FE4686B611D
ms.date: 02/08/2017
ms.topic: article
keywords: windows 10, uwp
ms.localizationpriority: medium
ms.openlocfilehash: 4ab2ed7bea6a353ae30bb3c245e00c77365fb5af
ms.sourcegitcommit: a20457776064c95a74804f519993f36b87df911e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/27/2019
ms.locfileid: "71339919"
---
# <a name="xaml-syntax-guide"></a>Руководство по синтаксису XAML


Здесь разъясняются правила синтаксиса языка XAML и терминология, описывающая доступные для этого синтаксиса ограничения и варианты. Этот раздел будет полезен для тех, кто только знакомится с языком XAML, тех, кто хочет освежить в памяти терминологию или отдельные аспекты синтаксиса, а также для тех, кто интересуется принципами работы XAML и нуждается в дополнительной общей информации и контексте.

## <a name="xaml-is-xml"></a>Язык XAML — часть языка XML

Базовый синтаксис языка XAML основывается на XML, поэтому допустимая разметка XAML по определению должна быть допустимой разметкой XML. Но в XAML имеются и собственные синтаксические концепции, расширяющие XML. Определенный объект XML работает и в обычном XML, но в языке XAML его синтаксис будет иметь другое, более полное значение. В настоящем разделе разъясняются указанные концепции синтаксиса XAML.

## <a name="xaml-vocabularies"></a>Словари XAML

В отличие от большинства вариантов использования XML, в языке XAML обычно не применяется схема, например XSD-файл. Дело в том, что язык XAML предполагает возможность расширения — именно это означает буква «X» в аббревиатуре XAML. После завершения синтаксического анализа XAML элементы и атрибуты, на которые вы ссылаетесь в XAML, должны существовать в каком-либо представлении базового кода: либо в основных типах, определенных средой выполнения Windows, либо в типах, которые расширяют среду выполнения Windows или опираются не на нее. Иногда документация SDK ссылается на типы, которые уже встроены в среду выполнения Windows и могут использоваться в XAML как *словарь XAML* для среды выполнения Windows. С помощью Microsoft Visual Studio можно создавать разметку, которая будет действительна в таком словаре XAML. В Visual Studio вы можете также включить свои настраиваемые типы для использования в XAML, при условии, что в проекте указана правильная ссылка на исходный код этих типов. Подробнее о языке XAML и настраиваемых типах см. в разделе [Пространства имен XAML и их сопоставление](xaml-namespaces-and-namespace-mapping.md).

##  <a name="declaring-objects"></a>Объявление объектов

Программисты часто думают в терминах объектов и участников, тогда как основными концепциями языка разметки являются элементы и атрибуты. В общем смысле элемент, декларируемый в разметке языка XAML, становится объектом в представлении объектов базовой среды выполнения. Для создания объекта среды выполнения для приложения в разметке XAML декларируется элемент XAML. Такой объект создается при загрузке XAML средой выполнения Windows.

XAML-файл всегда имеет строго один элемент, служащий в качестве корневого и объявляющий объект, который будет концептуальной основой для определенной структуры программирования, например страницы или графа объекта полного определения приложения для среды выполнения.

В синтаксисе XAML имеются три способа объявить объекты в XAML.

-   **Непосредственно, с использованием синтаксиса объектного элемента:** При этом используются открывающий и закрывающий теги для создания экземпляра объекта в виде элемента XML-Form. Вы можете применять этот синтаксис для объявления корневых объектов или создания вложенных объектов, задающих значения свойств.
-   **Косвенно, с использованием синтаксиса атрибутов:** В этом случае используется встроенное строковое значение, которое содержит инструкции по созданию объекта. Средство синтаксического анализа XAML использует данную строку для задания значения свойства создаваемому опорному значению. Поддержка его ограничена определенными общими объектами и свойствами.
-   Использование расширения разметки.

Это не означает, что у вас всегда есть выбор синтаксиса для создания объекта в словаре XAML. Некоторые объекты можно создать только с использованием синтаксиса объектного элемента. Некоторые объекты могут создаваться только путем изначальной установки в атрибуте. В действительности объектов, которые можно создать как с помощью синтаксиса объектного элемента, так и с помощью синтаксиса атрибута, сравнительно немного в словарях XAML. Даже при возможности обоих синтаксических форм один из синтаксисов будет более употребительным с точки зрения стиля.
Кроме того, для XAML имеются методики привязки существующих объектов вместо создания новых значений. Существующие объекты могут быть определены в других областях XAML или существовать неявно, за счет поведения платформы и ее приложения либо моделей программирования.

### <a name="declaring-an-object-by-using-object-element-syntax"></a>Объявление объекта с помощью синтаксиса объектного элемента

Для объявления объекта с помощью синтаксиса объектного элемента следует написать теги вида `<objectName>  </objectName>`, где *objectName* — имя типа объекта, экземпляр которого следует создать. Ниже представлено использование объектного элемента для объявления объекта [**Canvas**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Canvas):

```xml
<Canvas>
</Canvas>
```

Если объект не содержит другие объекты, объектный элемент можно объявить с помощью объединения открывающего и закрывающего тегов вместо пары "открывающий-закрывающий": `<Canvas />`

### <a name="containers"></a>Контейнеры

Многие объекты, используемые как элементы пользовательского интерфейса, например [**Canvas**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Canvas), могут содержать другие объекты. Такие объекты часто именуются контейнерами. В примере ниже показан контейнер **Canvas**, содержащий один элемент — [**Rectangle**](/uwp/api/Windows.UI.Xaml.Shapes.Rectangle).

```xml
<Canvas>
  <Rectangle />
</Canvas>
```

### <a name="declaring-an-object-by-using-attribute-syntax"></a>Объявление объекта с помощью синтаксиса атрибута

Поскольку указанная реакция на событие привязана к параметрам свойств, рассмотрим ее подробнее в следующих разделах.

### <a name="initialization-text"></a>Текст инициализации

Для некоторых объектов новые значения можно объявлять при помощи внутреннего текста, используемого в качестве значений инициализации при выполнении построения. В языке XAML такие методика и синтаксис именуются *текстом инициализации*. Принципиально текст инициализации похож на вызов конструктора, обладающего параметрами. Текст инициализации полезен при установке начальных значений определенных структур.

Синтаксис объектного элемента с текстом инициализации зачастую используется, когда требуется значение структуры с **x:Key** в [**ResourceDictionary**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.ResourceDictionary). Он может потребоваться, если вы намереваетесь сделать значение этой структуры общим для нескольких целевых свойств. В случае некоторых структур использование синтаксиса атрибута для установки значений структуры невозможно: текст инициализации является единственным вариантом создания полезных общих ресурсов [**CornerRadius**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.CornerRadius), [**Thickness**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Thickness), [**GridLength**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.GridLength) или [**Color**](https://docs.microsoft.com/uwp/api/Windows.UI.Color)

В это сокращенном примере использован текст инициализации, чтобы указать значения для [**Thickness**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Thickness), это значения, которые в данном случае установят для **Left** и **Right** значение 20, а для **Top** и **Bottom** — значение 10. В примере показан элемент **Thickness**, созданный как ресурс с ключом, а затем ссылка на этот ресурс. Подробнее о тексте инициализации [**Thickness**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Thickness) см. в разделе [**Thickness**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Thickness).

```xml
<UserControl ...>
  <UserControl.Resources>
    <Thickness x:Key="TwentyTenThickness">20,10</Thickness>
    ....
  </UserControl.Resources>
  ...
  <Grid Margin="{StaticResource TwentyTenThickness}">
  ...
  </Grid>
</UserControl ...>
```

**Примечание**@no__t-структуры 1Some нельзя объявлять как элементы объекта. Текст инициализации не поддерживается, и их нельзя использовать в качестве ресурсов. Чтобы задать такие значения для свойств в языке XAML, следует использовать синтаксис атрибута. Эти типы: [**Длительность**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Duration), [**RepeatBehavior**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Media.Animation.RepeatBehavior), [**Point**](https://docs.microsoft.com/uwp/api/Windows.Foundation.Point), [**Rect**](https://docs.microsoft.com/uwp/api/Windows.Foundation.Rect) и [**size**](https://docs.microsoft.com/uwp/api/Windows.Foundation.Size).

## <a name="setting-properties"></a>Определение свойств

Для объявленных объектов можно задавать свойства, используя синтаксис объектных элементов. Для задания свойств в XAML есть несколько способов:

-   С использованием синтаксиса атрибута.
-   С использованием синтаксиса элементов свойств.
-   С использованием синтаксиса элемента, когда содержимое (внутренний текст или дочерние элементы) задает свойство содержимого XAML некоторого объекта.
-   С использованием синтаксиса коллекций (обычно это неявный синтаксис коллекций).

Как и в случае с объявлением объекта, существование такого списка не означает, что любое свойство может задаваться при помощи каждой из методик. Некоторые свойства поддерживают только одну методику.
Другие свойства поддерживают более одной формы. Например, определенные свойства могут использовать синтаксис элемента свойства или синтаксис атрибута. Фактические возможности зависят как от свойства, так и от типа объектов, которые оно использует. Возможные варианты использования XAML описаны в справочных материалах по API среды выполнения Windows в разделе **Синтаксис**. Иногда имеется альтернативный вариант использования, также работающий, но более подробный. Такие подробные варианты использования приводятся не всегда, поскольку мы стараемся показывать вам лучшие способы и реальные сценарии использования свойства в XAML. Руководство по синтаксису XAML изложено в разделах **Использование языка XAML** страниц справки свойств, которые можно задавать в XAML.

Некоторые свойства объектов вообще нельзя задать в XAML, а можно только установить, используя код. Как правило, это свойства, более подходящие для работы с кодом, а не с языком XAML.

Свойство "только для чтения" задать в XAML невозможно. Даже в коде для определения типа владельца должен быть предусмотрен какой-либо другой способ, например перегрузка конструктора, метод вспомогательного приложения или поддержка вычисляемого свойства. Вычисляемое свойство полагается на значения других устанавливаемых свойств, а иногда также и на событие со встроенным управлением. Такие возможности доступны в системе свойств зависимостей. Подробнее о применении свойств зависимостей для поддержки вычисляемого свойства см. в разделе [Обзор свойств зависимостей](dependency-properties-overview.md).

Синтаксис коллекций в языке XAML позволяет нам сделать вид, что мы задаем свойство для чтения, хотя на самом деле это не так. См. ниже раздел "Задание свойства с помощью синтаксиса коллекций" данной темы.

### <a name="setting-a-property-by-using-attribute-syntax"></a>Задание свойства с помощью синтаксиса атрибутов

Установка значения атрибута — обычный способ установки значения свойства в языках разметки, таких как XML или HTML. Задание атрибутов в XAML производится аналогично заданию значений атрибутов в XML. Имя атрибута указывается после имени элемента, заключается в теги и отделяется от имени элемента минимум одним пробелом. За именем атрибута следует знак равенства. Значение атрибута заключается в кавычки. Кавычки могут быть двойными или одинарными при условии, что они совпадают и заключают в себе значение. Само значение атрибута должно быть выражаемым как строка. Строка зачастую содержит символы чисел, но в XAML все значения атрибутов являются строковыми значениями, пока средство синтаксического анализа XAML не будет задействовано и не выполнит некоторые базовые преобразования значений.

В данном примере используется синтаксис атрибутов для четырех атрибутов, чтобы задать свойства [**Name**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.name), [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width), [**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height) и [**Fill**](/uwp/api/Windows.UI.Xaml.Shapes.Shape.Fill) объекта [**Rectangle**](/uwp/api/Windows.UI.Xaml.Shapes.Rectangle).

```xml
<Rectangle Name="rectangle1" Width="100" Height="100" Fill="Blue" />
```

### <a name="setting-a-property-by-using-property-element-syntax"></a>Определение свойства с помощью синтаксиса элементов свойств

Многие свойства объектов можно задать с помощью синтаксиса элементов свойства. Элемент свойства имеет вид `<`*объект*`.`*свойство*`>`.

При использовании синтаксиса элементов свойства создаются элементы свойств XAML для свойства, которое следует задать. В стандартном XML этот элемент просто был бы сочтен элементом, в имени которого есть точка. Но в языке XAML точка в имени элемента определяет элемент как элемент свойства, где *свойство* должно быть членом *объекта* в резервной реализации объектной модели. Чтобы использовать синтаксис элементов свойства, необходимо иметь возможность указать объектный элемент для "заполнения" тегов элемента свойства. Элемент свойства всегда будет иметь определенное содержимое (один элемент, несколько элементов либо внутренний текст); невозможно иметь самодостаточный элемент свойства.

В следующей грамматической конструкции *свойство* — имя свойства, которое следует задать, а *propertyValueAsObjectElement* — одиночный объектный элемент, который должен удовлетворять требованиям типа значения данного свойства.

`<`*объектами*`>`

@no__t *-0,* *свойство*`.` `>`

*пропертивалуеасобжектелемент*

@no__t *-0,* *свойство*`.` `>`

`</`*объектами*`>`

В следующем примере используется синтаксис элемента свойства, чтобы определить элемент [**Fill**](/uwp/api/Windows.UI.Xaml.Shapes.Shape.Fill) для [**Rectangle**](/uwp/api/Windows.UI.Xaml.Shapes.Rectangle) с помощью объектного элемента [**SolidColorBrush**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Media.SolidColorBrush). (В **SolidColorBrush** [**Цвет**](/uwp/api/Windows.UI.Xaml.Media.SolidColorBrush.Color) задается как атрибут.) Проанализированный результат этого XAML идентичен предыдущему примеру XAML, заданному с помощью синтаксиса атрибутов **Fill** .

```xml
<Rectangle
  Name="rectangle1"
  Width="100" 
  Height="100"
> 
  <Rectangle.Fill> 
    <SolidColorBrush Color="Blue"/> 
  </Rectangle.Fill>
</Rectangle>
```

### <a name="xaml-vocabularies-and-object-oriented-programming"></a>Словари XAML и объектно-ориентированное программирование

Свойства и события, появляющиеся в качестве членов XAML типа XAML среды выполнения Windows, часто наследуются от базовых типов. Рассмотрим пример: `<Button Background="Blue" .../>`. Свойство [**Background**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.background) не объявляется непосредственно в классе [**Button**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Button). Вместо этого **Background** наследуется от базового класса [**Control**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Control). На самом деле, если взглянуть на раздел справки по **кнопке** , вы увидите, что списки членов содержат по крайней мере один наследуемый член из цепочки последовательных базовых классов: [**ButtonBase**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Primitives.ButtonBase), [**Control**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Control), [**FrameworkElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.FrameworkElement), [**UIElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.UIElement), [**DependencyObject**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.DependencyObject). В списке **Свойства** все свойства чтения-записи и свойства коллекции в части словаря XAML наследуются. Также наследуются события (например, различные события [**UIElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.UIElement)).

Если вы используете для справки по XAML руководство по среде выполнения Windows, учитывайте, что имя элемента, показанного в синтаксисе или даже в примере кода, иногда дается для типа, который изначально определяет свойство, поскольку данный раздел справки объединяет сведения о всех возможных типах, наследующих его от базового класса. При использовании IntelliSense для XAML из Visual Studio в редакторе XML технология IntelliSense и ее раскрывающиеся списки значительно способствуют объединению наследованных элементов и предоставляют точный список атрибутов, которые можно установить, когда начата работа с элементом объекта как экземпляром класса.

### <a name="xaml-content-properties"></a>Свойства содержимого в языке XAML

Некоторые типы определяют одно из своих свойств так, что оно разрешает синтаксис содержимого XAML. При указании свойства содержимого в языке XAML можно опускать элемент данного свойства определенного типа. Или же можно задать свойство как значение внутреннего текста, вставив этот внутренний текст прямо внутри тегов объектного элемента типа-владельца. Свойства содержимого XAML поддерживают синтаксис непосредственной разметки для такого свойства и улучшают восприятие языка XAML пользователем за счет уменьшения вложений.

Если для свойства доступен синтаксис содержимого XAML, он приводится в разделе "Язык XAML" статьи **Синтаксис** справочной документации среды выполнения Windows для данного свойства. Например, страница свойства [**Child**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.border.child) для [**Border**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Border) показывает синтаксис содержимого XAML вместо синтаксиса элемента свойства, чтобы установить значение **Border.Child** одного объекта для **Border**, как показано далее:

```xml
<Border>
  <Button .../>
</Border>
```

Если свойство, объявленное как свойство содержимого XAML, принадлежит к типу **Object** или типу **String**, синтаксис содержимого XAML поддерживает часть, которая изначально является внутренним текстом модели документа XML, а именно строку между открывающим и закрывающим тегами объекта. Например, страница свойства [**Text**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.textblock.text) для [**TextBlock**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.TextBlock) отображает синтаксис содержимого XAML, имеющий значение внутреннего текста для определения **Text**, но строка Text никогда не появляется в разметке. Вот пример использования:

```xml
<TextBlock>Hello!</TextBlock>
```

Если свойство содержимого XAML существует для класса, это указывается в разделе справки для данного класса в подразделе "Атрибуты". Ищите значение [**ContentPropertyAttribute**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Markup.ContentPropertyAttribute). Данный атрибут использует поле с именем Name. Значение Name — это имя свойства класса, являющееся свойством содержимого XAML. Например, на странице ссылка на [**границу**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Border) вы увидите следующее: Контентпроперти ("Name = Child").

Одно из важных правил синтаксиса XAML, которое следует упомянуть, — невозможность смешения свойства содержимого XAML и других элементов свойств, установленных для элемента. Свойство содержимого XAML должно устанавливаться либо полностью перед всеми элементами свойств, либо полностью после. Например, такой код XAML недопустим:

``` syntax
<StackPanel>
  <Button>This example</Button>
  <StackPanel.Resources>
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>
  </StackPanel.Resources>
  <Button>... is illegal XAML</Button>
</StackPanel>
```

## <a name="collection-syntax"></a>Синтаксис коллекций

Все образцы синтаксиса выше задавали свойства для отдельных объектов. Но многие сценарии пользовательского интерфейса требуют, чтобы у определенного родительского элемента было несколько дочерних элементов. Например, в пользовательском интерфейсе формы для ввода должно быть несколько текстовых полей, надписей и, возможно, кнопка "Отправить". Но если для доступа ко всем элементам использовать объектную модель программирования, они, как правило, будут элементами в одном свойстве коллекции (вместо каждого элемента как значения отдельного свойства). XAML поддерживает наличие нескольких дочерних элементов, а также поддерживает типичную реализацию базовой коллекции, рассматривая свойства, использующие тип коллекции как неявный, и проводя специальную обработку всех дочерних элементов типа коллекции.

Многие свойства коллекции также определяются как свойство содержимого XAML для данного класса. Объединение неявной обработки коллекции и синтаксиса содержимого XAML часто наблюдается в типах, используемых для компоновки органов управления, таких как панели, представления или элементы управления. Ниже приведены примеры простейшего возможного синтаксиса XAML для объединения двух одноранговых элементов пользовательского интерфейса внутри [**StackPanel**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.StackPanel).

```xml
<StackPanel>
  <TextBlock>Hello</TextBlock>
  <TextBlock>World</TextBlock>
</StackPanel>
```

### <a name="the-mechanism-of-xaml-collection-syntax"></a>Механизм синтаксиса коллекций языка XAML

На первый взгляд может показаться, что XAML применяет здесь "набор" свойства коллекции только для чтения. На самом деле XAML применяет добавление элементов к существующей коллекции. Язык XAML и процессоры XAML, реализующие поддержку XAML, полагаются на соглашение в резервных типах коллекций, чтобы сделать возможным этот синтаксис. Как правило, существует резервное свойство, такое как индексатор, или свойство **Items**, относящееся к конкретным элементам коллекции. Обычно это свойство не является явным в синтаксисе XAML. Для коллекций базовым механизмом синтаксического анализа XAML является не свойство, а метод. В большинстве случаев это метод **Add**. Когда процессор XAML обрабатывает один или несколько объектных элементов в синтаксисе коллекции XAML, каждый из таких объектов сначала создается из элемента. Затем все созданные объекты по порядку добавляются к содержащей их коллекции с помощью метода **Add** коллекции.

Когда средство синтаксического анализа XAML добавляет элементы в коллекцию, именно логика метода **Add** определяет, является ли конкретный элемент XAML допустимым дочерним элементом объекта коллекции. Многие типы коллекций строго определяются резервной реализацией. Поэтому предполагается, что данные, которые переданы с помощью параметра ввода **Add**, будут иметь тип, совпадающий с типом параметра **Add**.

В отношении свойств коллекций внимательно отнеситесь к явному указанию коллекции как объектного элемента. Средство синтаксического анализа XAML создает новый объект при любом обнаружении объектного элемента. Если используемое свойство коллекции относится к типу "только для чтения", исключение анализа XAML можно отбросить. Используйте синтаксис неявной коллекции, и такое исключение исчезнет.

## <a name="when-to-use-attribute-or-property-element-syntax"></a>Когда стоит использовать синтаксис атрибутов, а когда — элементов свойств

Все свойства, которые можно задать в языке XAML, поддерживают синтаксис атрибутов или элементов свойств для прямого задания значений. Но не для всех свойств эти виды синтаксиса взаимозаменяемы. Некоторые свойства поддерживают оба вида синтаксиса, некоторые поддерживают дополнительные варианты синтаксиса, такие как свойство содержимого XAML. Тип синтаксиса XAML, поддерживаемого свойством, зависит от типа объекта, который свойство использует как свой тип. Если тип свойства — это простой тип, например double (число с плавающей точкой или десятичное), integer, Boolean или string, свойство всегда будет поддерживать синтаксис атрибутов.

Синтаксис атрибутов также можно использовать для задания свойства, если тип объектов, используемый для задания этого свойства, можно получить путем обработки строки. Для примитивов это работает всегда, тип преобразования встроен в средство синтаксического анализа. Но некоторые другие типы объектов также можно создать, используя строку, указанную как значение атрибута вместо объектного элемента внутри элемента свойства. Чтобы это работало, требуется преобразование основообразующего типа, поддерживаемое либо указанным свойством, либо поддерживаемое в целом для всех значений, использующих данный тип свойства. Строковый параметр атрибута используется, чтобы задать свойства, важные для инициализации нового объектного значения. Преобразователь определенного типа также потенциально может создавать различные подклассы обычного типа свойств в зависимости от своего уникального способа обработки информации в строке. У типов объектов, поддерживающих такое поведение, в разделе справочной документации, посвященном синтаксису, будет приведена специальная грамматическая конструкция. В качестве примера синтаксис XAML для [**Brush**](/uwp/api/Windows.UI.Xaml.Media.Brush) демонстрирует использование синтаксиса атрибута для создания нового значения [**SolidColorBrush**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Media.SolidColorBrush) для любого свойства типа **Brush** (при этом существует множество свойств **Brush** в XAML среды выполнения Windows).

## <a name="xaml-parsing-logic-and-rules"></a>Логика и правила синтаксического анализа языка XAML

Иногда бывает информативно выполнять чтение XAML аналогично тому, как это делает средство синтаксического анализа XAML: как набор строковых маркеров, обнаруживаемых в линейном порядке. Средство синтаксического анализа XAML должно интерпретировать данные маркеры в рамках набора правил, являющихся частью определения метода работы XAML.

Установка значения атрибута — обычный способ установки значения свойства в языках разметки, таких как XML или HTML. В следующем синтаксисе *objectName* — объект, экземпляр которого следует создать, *propertyName* — имя свойства, которое нужно задать для этого объекта, а *propertyValue* — значение, которое следует задать.

```xml
<objectName propertyName="propertyValue" .../>

-or-

<objectName propertyName="propertyValue">

...<!--element children -->

</objectName>
```

Оба варианта синтаксиса позволяют объявить объект и задать свойство для этого объекта. Хотя первый пример ограничивается единственным элементом в разметке, синтаксический анализ этой разметки процессором XAML будет состоять из отдельных шагов.

Сначала присутствие объектного элемента укажет, что необходимо создать экземпляр нового объекта *objectName*. Только после создания такого экземпляра для него можно задать свойство экземпляра *propertyName*.

Другим правилом XAML является возможность установки атрибутов любого элемента в любом порядке. Например, нет различия между `<Rectangle Height="50" Width="100" />` и `<Rectangle Width="100"  Height="50" />`. Применяемый порядок является вопросом стиля.

**Примечание**  XAML конструкторы часто доказывает соглашения о заказах при использовании областей конструктора, отличных от редактора XML, но можно свободно редактировать этот XAML-код позже, чтобы изменить порядок атрибутов или добавить новые.

## <a name="attached-properties"></a>Вложенные свойства

Язык XAML расширяет XML, добавляя элемент синтаксиса, известный как *присоединенное свойство*. Аналогично синтаксису элемента свойства синтаксис присоединенного свойства содержит точку, и эта точка имеет особое значение при анализе XAML. В частности, точка отделяет поставщика-владельца присоединенного свойства от имени свойства.

В XAML присоединенные свойства задаются с помощью синтаксиса *AttachedPropertyProvider*.*PropertyName* Ниже приведен пример определения присоединенного свойства [**Canvas.Left**](https://docs.microsoft.com/dotnet/api/system.windows.controls.canvas.left) в XAML.

```xml
<Canvas>
  <Button Canvas.Left="50">Hello</Button>
</Canvas>
```

Можно задать присоединенное свойство для элементов, которые не имеют свойств с таким именем в резервном типе, и в таком случае оно будет работать подобно глобальному свойству или атрибуту, определенному другим пространством имен XML, как атрибут **xml:space**.

В XAML среды выполнения Windows имеются присоединенные свойства, поддерживающие такие сценарии:

-   Дочерние элементы могут информировать родительские панели контейнеров о том, как они должны вести себя в макете: [**Холст**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Canvas), [**Grid**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Grid), [**вариаблесизедврапгрид**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.VariableSizedWrapGrid).
-   Использование элементов управления может повлиять на поведение важной управляющей части, поступающих из шаблона элемента управления: [**ScrollViewer**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ScrollViewer), [**VirtualizingStackPanel**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.VirtualizingStackPanel).
-   Используя службу, доступную в связанном классе, в которой служба и класс, использующие ее, не имеют общего доступа к наследованию: [**Типография**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Documents.Typography), [**VisualStateManager**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.VisualStateManager), [**AutomationProperties**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Automation.AutomationProperties), [**ToolTipService**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ToolTipService).
-   Нацеленность на анимацию: [**Раскадровка**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Media.Animation.Storyboard).

Подробнее см. в разделе [Общие сведения о присоединенных свойствах](attached-properties-overview.md).

## <a name="literal--values"></a>Значения литералов с символом "{"

Поскольку символ открывающей скобки \{ является открытием последовательности расширения разметки, для указания строкового литерального значения, начинающегося с "\{", используется управляющая последовательность. Escape-последовательность — "\{ @ no__t-1". Например, чтобы указать строковое значение, которое представляет собой отдельную открывающую фигурную скобку, укажите значение атрибута "\{ @ no__t-1 @ no__t-2". Также можно использовать альтернативные кавычки (например, **"** в значении атрибута, разделенном **" "** ), чтобы предоставить значение" \{ "в виде строки.

**Примечание**   "\\}" также работает, если оно находится внутри атрибута в кавычках.
 
## <a name="enumeration-values"></a>Значения перечисления

Многие свойства API среды выполнения Windows используют в качестве значений перечисления. Если таким членом является свойство типа "чтение-запись", для его установки можно задать значение атрибута. Значение перечисления, используемое как значение свойства, указывается при помощи неполной формы имени константы. Например, в языке XAML определение [**UIElement.Visibility**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.visibility) происходит следующим образом: `<Button Visibility="Visible"/>`. Здесь Visible как строка напрямую сопоставляется с именованной константой перечисления [**Visibility**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Visibility)**Visible**.

-   Не используйте полную форму, такой способ не даст результата. Например, такой код XAML недопустим: `<Button Visibility="Visibility.Visible"/>`
-   Не используйте значение константы. Другими словами, не используйте целое число перечисления, присутствующее явным или неявным образом в зависимости от определения перечисления. На первый взгляд такой способ работает, однако в XAML и в коде это крайне нежелательно, поскольку есть вероятность, что вы полагаетесь на временные данные о реализации. Например, не делайте так: `<Button Visibility="1"/>`.

**Примечание**  in. справочные разделы по API, которые используют XAML и используют перечисления, щелкните ссылку на тип перечисления в разделе " **значение свойства** " **синтаксиса**. Ссылка ведет на страницу перечисления, где вы найдете именованные константы для данного перечисления.

Перечисления могут быть перечислениями флагов — это означает, что они имеют атрибут **FlagsAttribute**. Если требуется указать комбинацию значений для этих перечислений флагов как значение атрибута XAML, используйте имена констант перечисления, разделяя их запятыми без пробелов (","). Подобные атрибуты не часто встречаются в словаре XAML среды выполнения Windows, однако [**ManipulationModes**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Input.ManipulationModes) является примером, в котором поддерживается определение значения перечисления флагов в XAML.

## <a name="interfaces-in-xaml"></a>Интерфейсы в XAML

Иногда можно встретить синтаксис XAML, где типом свойства является интерфейс. В системе типов XAML тип, в котором реализован этот интерфейс, при анализе принимается как значение. Необходимо создать экземпляр такого типа, который будет служить значением. Интерфейс используется в синтаксисе XAML в качестве типа в свойствах [**Command**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.buttonbase.command) и [**CommandParameter**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.buttonbase.commandparameter) класса [**ButtonBase**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Primitives.ButtonBase). Эти свойства поддерживают шаблоны проектирования Model-View-ViewModel (MVVM), где интерфейс **ICommand** является контрактом взаимодействия представлений и моделей.

## <a name="xaml-placeholder-conventions-in-windows-runtime-reference"></a>Соглашения о заполнителях XAML в справке среды выполнения Windows

Если вы знакомились с разделом **Синтаксис** в справочных материалах по API среды выполнения Windows, которые могут использовать XAML, вероятно, вы обратили внимание на значительное количество заполнителей в синтаксисе. Синтаксис XAML отличается от синтаксиса C#, Visual Basic или расширений Visual C++ Component ExtensionsC++(/CX), поскольку синтаксис XAML является синтаксисом использования. Он предлагает конечный вариант использования в ваших собственных файлах XAML, но не слишком ограничивает значения, которые вы можете использовать. Обычно использование описывает тип грамматики, в которой одновременно применяются литералы и заполнители, и определяет некоторые заполнители в разделе **Значения XAML**.

Имена типов и элементов, используемые в синтаксисе XAML для свойства, относятся к типу, который определяет свойство в исходном варианте. Однако XAML среды выполнения Windows поддерживает модель наследования класса для классов на основе [**DependencyObject**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.DependencyObject). Поэтому зачастую можно использовать атрибут для класса, который не является в прямом смысле определяющим классом, а представляет собой производный класс от класса, изначально определявшего свойство или атрибут. Например, можно установить [**Visibility**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.visibility) в качестве атрибута в любом производном классе [**UIElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.UIElement), используя для этого глубокое наследование. Пример: `<Button Visibility="Visible" />`. Поэтому не следует слишком буквально воспринимать имя элемента, отображаемое в синтаксисе XAML; синтаксис может быть применим для элементов, представляющих данный класс, а также для элементов, представляющих производный класс. В тех случаях, когда в реальном синтаксисе очень сложно или невозможно использовать тип, показанный в качестве определяющего элемента, имя этого типа намеренно используется в синтаксисе в нижнем регистре. Например, синтаксис для **UIElement.Visibility** следующий:

``` syntax
<uiElement Visibility="Visible"/>
-or-
<uiElement Visibility="Collapsed"/>
```

Многие разделы синтаксиса XAML включают заполнители в группу "Использование", а затем определяют их в разделе **Значения XAML** , следующем сразу после раздела **Синтаксис** .

В разделах использования XAML применяются также различные подготовленные к использованию заполнители. Такие заполнители не определяются каждый раз в **Значениях XAML**, так как постепенно вы станете догадываться или запомните, что они обозначают. По нашему мнению, большинству читателей надоест снова и снова видеть их в **Значениях XAML**, поэтому мы исключили их из определений. Ниже приведен для справки список некоторых таких заполнителей и их значений в общем случае.

-   *объект*: теоретически любое значение объекта, но на практике зачастую ограничено некоторыми типами объектов, такими как выбор "строка или объект"; за дополнительной информацией следует обратиться к разделу "Примечания" на странице справки.
-   *свойство*объекта: сочетание *Свойства* *объекта* используется в случаях, когда показан синтаксис, который можно использовать в качестве значения атрибута для многих свойств. Например, **Использование атрибута XAML** , показанное для [**кисти**](/uwp/api/Windows.UI.Xaml.Media.Brush) , включает: < *свойство* *объекта* = "*предефинедколорнаме*"/>
-   *обработчик событий*: Он отображается как значение атрибута для каждого синтаксиса XAML, отображаемого для атрибута события. Здесь вводится имя для функции обработчика событий. Эту функцию следует определить в выделенном коде для страницы XAML. На уровне программирования эта функция должна соответствовать подписи делегата обрабатываемого события, в противном случае код вашего приложения скомпилировать не удастся. Однако этот момент касается программирования, а не XAML, поэтому мы ничего не говорим о типе делегата в синтаксисе XAML. Если вы хотите узнать, какой из делегатов следует реализовать для события, обратитесь к разделу **Информация о событии** в справке для данного события (строка таблицы **Делегат**).
-   *enumMemberName*: отображается в синтаксисе атрибутов для всех перечислений. Существует сходный заполнитель для свойств, использующих значение перечисления, но обычно он предшествует заполнителю с указанием на имя перечисления. Например, синтаксис для [**FrameworkElement.FlowDirection**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.flowdirection) следующий: <*frameworkElement* **FlowDirection**="* flowDirectionMemberName*"/>. Если вы находитесь на одной из справочных страниц для свойств, нажмите ссылку на тип перечисления, приведенную в разделе **Значение свойства**, рядом с надписью **Тип:** . В качестве значения атрибута свойства, использующего перечисление, можно использовать любую строку, указанную в столбце **Член** списка **Члены**.
-   *Double*, *int*, *String*, *bool*: Это примитивные типы, известные языку XAML. Если программирование осуществляется на C# или Visual Basic, эти типы сопоставляются с эквивалентными типами Microsoft .NET, например [**Double**](https://docs.microsoft.com/dotnet/api/system.double), [**Int32**](https://docs.microsoft.com/dotnet/api/system.int32), [**String**](https://docs.microsoft.com/dotnet/api/system.string) и [**Boolean**](https://docs.microsoft.com/dotnet/api/system.boolean), и в таких типах .NET можно использовать любые члены при работе со значениями, определенными в XAML, в выделенном коде .NET. Если программирование выполняется на C++/CX, можно использовать примитивные типы C++, однако можно также считать их эквивалентами типов, определенных в пространстве имен [**Platform**](https://docs.microsoft.com/cpp/cppcx/platform-namespace-c-cx), например [**Platform::String**](https://docs.microsoft.com/cpp/cppcx/platform-string-class). Иногда для конкретных свойств могут существовать дополнительные ограничения на значения. Но обычно соответствующее примечание дается в разделе **Значение свойства** или "Примечания", а не в разделе XAML, поскольку такие ограничения относятся как к использованию в коде, так и к использованию в XAML.

## <a name="tips-and-tricks-notes-on-style"></a>Советы и рекомендации, замечания по стилю

-   Расширения разметки в целом описаны в основном [обзоре языка XAML](xaml-overview.md). Но в наибольшей степени на руководство в этой теме влияет расширение разметки [StaticResource](staticresource-markup-extension.md) (и связанное [ThemeResource](themeresource-markup-extension.md)). Функция расширения разметки StaticResource — разрешить разложение языка XAML на повторно используемые ресурсы из [**ResourceDictionary**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.ResourceDictionary) в XAML. Практически всегда шаблоны элементов управления и соответствующие стили определяются в **ResourceDictionary**. Часто составляющие определения шаблонов элементов управления или особого стиля приложения также определяются в **ResourceDictionary**, например [**SolidColorBrush**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Media.SolidColorBrush) для цвета, применяемого приложением к различным элементам пользовательского интерфейса более одного раза. За счет использования StaticResource любое свойство, для установки которого при других обстоятельствах требуется применение элемента свойства, теперь может устанавливаться в синтаксисе атрибута. Но преимущества разложения языка XAML для повторного использования не ограничиваются обычным упрощением синтаксиса уровня страницы. Подробнее: [ResourceDictionary и ссылки на ресурсы XAML](https://docs.microsoft.com/windows/uwp/controls-and-patterns/resourcedictionary-and-xaml-resource-references).
-   Несколько различных соглашений по применению пробела и перевода строки в XAML включены в соответствующие примеры. В частности, имеется ряд соглашений по разрыву объектных элементов, для которых установлено большое количество различных атрибутов. Это — вопрос стиля. XML-редактор Visual Studio по умолчанию применяет некоторые стилистические правила при редактировании языка XAML, но это можно изменить в настройках. Лишь в редких случаях пробел в файле на XAML считается значимым; дополнительные сведения см. в разделе [XAML и пробел](xaml-and-whitespace.md).

## <a name="related-topics"></a>См. также

* [Обзор языка XAML](xaml-overview.md)
* [Пространства имен и сопоставление пространств имен XAML](xaml-namespaces-and-namespace-mapping.md)
* [Ссылки на ресурсы ResourceDictionary и XAML](https://docs.microsoft.com/windows/uwp/controls-and-patterns/resourcedictionary-and-xaml-resource-references)
 

