---
author: jwmsft
description: В этом разделе мы рассмотрим понятие присоединенного свойства в языке XAML и приведем несколько примеров.
title: Общие сведения о присоединенных свойствах
ms.assetid: 098C1DE0-D640-48B1-9961-D0ADF33266E2
ms.author: jimwalk
ms.date: 02/08/2017
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp
ms.localizationpriority: medium
dev_langs:
- csharp
- vb
- cpp
ms.openlocfilehash: 7f92b12ab9c8962fe98d8eed22b21e7d10330c99
ms.sourcegitcommit: 106aec1e59ba41aae2ac00f909b81bf7121a6ef1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/15/2018
ms.locfileid: "4622351"
---
# <a name="attached-properties-overview"></a>Общие сведения о присоединенных свойствах

*Присоединенное свойство* является концепцией языка XAML. Присоединенные свойства позволяют задавать дополнительные пары свойств или значений для объекта, но при этом они не является частью первоначального определения объекта. Присоединенные свойства обычно определяются как специализированная форма свойства зависимостей, у которого нет обычной оболочки в объектной модели типа владельца.

## <a name="prerequisites"></a>Требования к читателю

Данный текст предполагает, что вы знакомы с основной концепцией свойств зависимостей и прочли [Общие сведения о свойствах зависимостей](dependency-properties-overview.md).

## <a name="attached-properties-in-xaml"></a>Присоединенные свойства XAML

В языке XAML присоединенные свойства задаются с помощью синтаксиса _AttachedPropertyProvider.PropertyName_. Приведем пример установки свойства [**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/hh759771) в языке XAML.

```xaml
<Canvas>
  <Button Canvas.Left="50">Hello</Button>
</Canvas>
```

> [!NOTE]
> Мы просто используем [**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/hh759771) как примером присоединенного свойства без подробных объяснений, зачем нужно его. Чтобы получить подробную информацию о назначении свойства **Canvas.Left** и о том, как [**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267) обрабатывает представления его дочерних элементов, см. связанный раздел [**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267) или [Определение макетов с помощью XAML](https://msdn.microsoft.com/library/windows/apps/mt228350).

## <a name="why-use-attached-properties"></a>Зачем нужны присоединенные свойства?

Присоединенные свойства являются способом избежать соглашений кодирования, которые позволяют разным родственным объектам не сообщать друг другу информацию во время работы приложения. Конечно, можно поместить свойства в обычный базовый класс, чтобы каждый объект мог просто получать и устанавливать это свойство. Но со временем абсолютное число сценариев, где бы вы хотели это сделать, переполнит ваши базовые классы, которые содержат свойства, находящиеся в общем доступе. Это также касается случаев, когда только два потомка из сотен пытаются использовать свойство. Это не лучший способ проектирования класса. Чтобы решить эту проблему, принцип присоединенного свойства позволяет объекту присвоить значение свойству, которое не определяется структурой его собственного класса. Определяющий класс может считывать данное значение с дочерних объектов во время выполнения, после того как в дереве объектов будут созданы различные объекты.

Например, дочерние элементы могут использовать присоединенные свойства, чтобы передавать сведения своему родительскому элементу о том, как их необходимо представить в пользовательском интерфейсе. Именно так обстоит дело с присоединенным свойством [**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/hh759771). Свойство **Canvas.Left** создается как присоединенное свойство, поскольку оно чаще устанавливается для элементов, входящих в состав элемента [**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267), чем для самого **Canvas**. Любые возможные дочерние элементы затем используют **Canvas.Left** и [**Canvas.Top**](https://msdn.microsoft.com/library/windows/apps/hh759772) для указания смещения макета внутри родительского контейнера макета **Canvas**. Присоединенные свойства позволяют использовать такой подход, не засоряя объектную модель базового элемента массой свойств, каждое из которых относится лишь к одному из многих возможных контейнеров макетов. Вместо этого многие из контейнеров макетов реализуют свой собственный набор присоединенных свойств.

Для реализации присоединенного свойства класс [**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267) определяет статическое поле [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) с именем [**Canvas.LeftProperty**](https://msdn.microsoft.com/library/windows/apps/br209272). Затем **Canvas** предоставляет методы [**SetLeft**](https://msdn.microsoft.com/library/windows/apps/br209273) и [**GetLeft**](https://msdn.microsoft.com/library/windows/apps/br209269) в качестве открытых методов доступа для присоединенного свойства, чтобы сделать возможными как настройку XAML, так и доступ к значению во время выполнения. В языке XAML и системе свойств зависимостей данный набор API удовлетворяет шаблону, который подключает определенный синтаксис XAML для присоединенных свойств и сохраняет значение в хранилище свойства зависимостей.

## <a name="how-the-owning-type-uses-attached-properties"></a>Использование присоединенных свойств типом-владельцем

Хотя присоединенные свойства можно задавать для любого элемента языка XAML (или базового [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356)), это еще не означает, что задание свойства даст какой-либо ощутимый результат или значение свойства вообще будет доступно. Тип, определяющий присоединенное свойство, обычно придерживается одного из следующих сценариев.

- Тип, определяющий присоединенное свойство, является родителем по отношению к другим объектам. Дочерние объекты будут устанавливать значения для присоединенного свойства. Тип-владелец присоединенного свойства имеет некоторое наследуемое поведение, которое повторяется в дочерних элементах, получает значения и работает с этими значениями в некоторой точке жизненного цикла объекта (выполняет такие действия, как создание структуры, [**SizeChanged**](https://msdn.microsoft.com/library/windows/apps/br208742) и т. д.).
- Тип, определяющий присоединенное свойство, используется в качестве дочернего элемента для ряда возможных родительских элементов и моделей содержимого, но информация не обязательно содержит информацию о структуре.
- Присоединенное свойство сообщает информацию службе, а не другому элементу пользовательского интерфейса.

Более подробную информацию об этих сценариях и типах-владельцах см. в разделе "Подробно о Canvas.Left" темы [Пользовательские присоединенные свойства](custom-attached-properties.md).

## <a name="attached-properties-in-code"></a>Присоединенные свойства в коде 

У присоединенных свойств нет обычных оболочек свойств для простого доступа к методам доступа get/set, как у прочих свойств зависимостей. Причина этого в том, что присоединенное свойство не обязательно является частью объектной модели экземпляров (основанной на коде), для которых задано свойство. (Можно, хотя это обычно и не делается, определить свойство как присоединенное свойство, которое другие типы могут задавать для самих себя, и как используемое в качестве обычного свойства типом-владельцем.)

Есть два пути задания присоединенного свойства в коде: использование API системы свойств или использование шаблона метода доступа XAML. Данные методики в значительной степени равнозначны с точки зрения конечного результата, так что выбор одной из них зависит больше от предпочитаемого стиля программирования.

### <a name="using-the-property-system"></a>Использование системы свойств

Присоединенные свойства для среды выполнения Windows реализуются как свойства зависимостей, чтобы система свойств могла сохранить их значения в хранилище общих свойств зависимостей. Поэтому присоединенные свойства предоставляют идентификатор свойства зависимостей в классе-владельце.

Для задания присоединенного свойства в коде вызовите метод [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) и передайте поле [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362), служащее идентификатором этого присоединенного свойства. (Также можно передать значение, которое следует задать.)

Для получения значения присоединенного свойства в коде вызовите метод [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359), опять же передавая поле [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362), которое служит идентификатором.

### <a name="using-the-xaml-accessor-pattern"></a>Использование шаблона метода доступа языка XAML

Процессор XAML должен иметь возможность установить значения присоединенного свойства, когда синтаксический анализ преобразует XAML в дерево объектов. Тип-владелец присоединенного свойства должен реализовать специальные методы доступа с именем в виде **получения *** PropertyName* и **задать *** PropertyName*. Эти специальные методы доступа также являются одним из способов получения или задания присоединенного свойства через код. С точки зрения кода присоединенное свойство подобно резервному полю, у которого методы доступа к свойствам заменены на методы доступа к методам и которое может существовать в любом объекте, не нуждаясь в специальном определении.

Следующий пример показывает, как можно задать присоединенное свойство в коде, используя API метода доступа XAML. В этом примере `myCheckBox` является экземпляром класса [**CheckBox**](https://msdn.microsoft.com/library/windows/apps/br209316). Собственно задает значение последняя строка кода, строки перед ней просто устанавливают экземпляры и их иерархическое отношение. Раскомментированная последняя строка является синтаксисом, если вы используете систему свойств. Закомментированная последняя строка является синтаксисом, если вы используете шаблон метода доступа XAML.

```csharp
    Canvas myC = new Canvas();
    CheckBox myCheckBox = new CheckBox();
    myCheckBox.Content = "Hello";
    myC.Children.Add(myCheckBox);
    myCheckBox.SetValue(Canvas.TopProperty,75);
    //Canvas.SetTop(myCheckBox, 75);
```

```vb
    Dim myC As Canvas = New Canvas()
    Dim myCheckBox As CheckBox= New CheckBox()
    myCheckBox.Content = "Hello"
    myC.Children.Add(myCheckBox)
    myCheckBox.SetValue(Canvas.TopProperty,75)
    ' Canvas.SetTop(myCheckBox, 75)
```

```cppwinrt
Canvas myC;
CheckBox myCheckBox;
myCheckBox.Content(winrt::box_value(L"Hello"));
myC.Children().Append(myCheckBox);
myCheckBox.SetValue(Canvas::TopProperty(), winrt::box_value(75));
// Canvas::SetTop(myCheckBox, 75);
```

```cpp
    Canvas^ myC = ref new Canvas();
    CheckBox^ myCheckBox = ref new CheckBox();
    myCheckBox->Content="Hello";
    myC->Children->Append(myCheckBox);
    myCheckBox->SetValue(Canvas::TopProperty,75);
    // Canvas::SetTop(myCheckBox, 75);
```

## <a name="custom-attached-properties"></a>Пользовательские присоединенные свойства

Примеры кода, определяющие особые присоединенные свойства, а также дополнительные сведения о сценариях использования присоединенных свойств см. в разделе [Особые присоединенные свойства](custom-attached-properties.md).

## <a name="special-syntax-for-attached-property-references"></a>Специальный синтаксис для ссылок на присоединенные свойства

Точка в имени присоединенного свойства является ключевой частью шаблона идентификации. Иногда синтаксис или ситуация приписывают этой точке еще какое-то значение, приводя к двусмысленностям. Например, точка может быть сочтена обходом объектной модели для пути привязки. В большинстве случаев у привязанных свойств есть специальный синтаксис, благодаря которому синтаксический анализ все равно распознает внутреннюю точку как разделитель _владелец_**.**_свойство_ присоединенного свойства.

- Чтобы обозначить присоединенное свойство как часть конечного пути для анимации, заключите имя присоединенного свойства в круглые скобки («()»), например, «(Canvas.Left)». Дополнительную информацию см. в разделе [Синтаксис Property-path](property-path-syntax.md).

> [!WARNING]
> Существующее ограничение реализации XAML среды выполнения Windows является то, что вы не можете анимировать пользовательское присоединенное свойство.

- Чтобы обозначить присоединенное свойство как целевое свойство для ссылки на ресурс из файла ресурса на **x:Uid**, используйте специальный синтаксис для вставки полного объявления **using:** в стиле кода внутрь квадратных скобок («\[\]»), чтобы создать преднамеренный разрыв области. Например, предположим, что существует элемент `<TextBlock x:Uid="Title" />`, ключ ресурса в файле ресурсов, которое ориентировано на **Canvas.Top** значение этого экземпляра, — это «Title.\[using:Windows.UI.Xaml.Controls\]Canvas.Top». Подробнее о файле ресурсов и языке XAML см. в разделе [Краткое руководство: перевод ресурсов пользовательского интерфейса](https://msdn.microsoft.com/library/windows/apps/xaml/hh965329).

## <a name="related-topics"></a>Связанные темы

- [Пользовательские присоединенные свойства](custom-attached-properties.md)
- [Общие сведения о свойствах зависимостей](dependency-properties-overview.md)
- [Определение макетов с помощью XAML](https://msdn.microsoft.com/library/windows/apps/mt228350)
- [Краткое руководство: перевод ресурсов интерфейса](https://msdn.microsoft.com/library/windows/apps/hh943060)
- [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361)
- [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359)
