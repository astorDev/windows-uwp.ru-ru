---
description: Мы описываем концепцию программирования событий в среда выполнения Windows приложении, при использовании C#Visual Basic или расширений визуальных C++ компонентов (C++/CX) в качестве языка программирования, а также XAML для определения пользовательского интерфейса.
title: Общие сведения о событиях и перенаправленных событиях
ms.assetid: 34C219E8-3EFB-45BC-8BBD-6FD937698832
ms.date: 07/12/2018
ms.topic: article
keywords: Windows 10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: 759e47348198feedbf7b1e3ee2c0bfc2da1da671
ms.sourcegitcommit: f561efbda5c1d47b85601d91d70d86c5332bbf8c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/21/2019
ms.locfileid: "72690397"
---
# <a name="events-and-routed-events-overview"></a>Общие сведения о событиях и перенаправленных событиях

**Важные API**
- [**UIElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.UIElement)
- [**RoutedEventArgs**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.RoutedEventArgs)

Мы описываем концепцию программирования событий в среда выполнения Windows приложении, при использовании C#Visual Basic или расширений визуальных C++ компонентов (C++/CX) в качестве языка программирования, а также XAML для определения пользовательского интерфейса. Можно назначить обработчики для событий как часть объявлений для элементов пользовательского интерфейса в XAML или добавить обработчики в код. Среда выполнения Windows поддерживает *перенаправленные события*: определенные события ввода и события данных могут обрабатываться объектами, находящими за объектом, запустившим событие. Перенаправленные события полезны при определении шаблонов элементов управления или при использовании страниц или контейнеров макета.

## <a name="events-as-a-programming-concept"></a>События как концепция программирования

В целом, понятия о событиях при программировании среда выполнения Windows приложения похожи на модель событий в наиболее популярных языках программирования. Если вы умеете работать с Microsoft .NET или C++ событиями, вы можете начать с головного подразделения. Но вам не нужно знать, что во многом о концепциях модели событий для выполнения некоторых основных задач, таких как присоединение обработчиков.

При использовании C#, Visual Basic или C++/CX в качестве языка программирования, Пользовательский интерфейс определяется в разметке (XAML). В синтаксисе разметки XAML некоторые принципы соединения событий между элементами разметки и сущностями кода среды выполнения аналогичны другим веб-технологиям, таким как ASP.NET или HTML5.

**Обратите внимание** ,  код, предоставляющий логику среды выполнения для пользовательского интерфейса, определяемого XAML, часто называется *кодом программной части* или файлом кода программной части. В представлениях решения Microsoft Visual Studio это отношение отображается графически, а файл кода программной части — зависимый и вложенный файл по сравнению с XAML-страницей, на которую он ссылается.

## <a name="buttonclick-an-introduction-to-events-and-xaml"></a>Кнопка. Щелкните: введение в события и XAML

Одной из наиболее распространенных задач программирования для среда выполнения Windows приложения является захват пользовательских данных в пользовательском интерфейсе. Например, в пользовательском интерфейсе может быть кнопка, которую пользователь должен щелкнуть для отправки сведений или изменения состояния.

Пользовательский интерфейс для приложения среда выполнения Windows определяется путем создания XAML. Этот XAML обычно является выходными данными из области конструктора в Visual Studio. Вы также можете написать XAML-код в текстовом редакторе или в редакторе XAML стороннего разработчика. При создании этого XAML можно насоединять обработчики событий для отдельных элементов пользовательского интерфейса одновременно с определением всех других атрибутов XAML, устанавливающих значения свойств этого элемента пользовательского интерфейса.

Для передачи событий в XAML необходимо указать строковое имя метода обработчика, который уже был определен или будет определен позже в коде программной части. Например, этот XAML определяет объект [**кнопки**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Button) с другими свойствами ([атрибут x:Name](x-name-attribute.md), [**содержимое**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentcontrol.content)), назначенный в качестве атрибутов, и связывает обработчик для события [**нажатия**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.buttonbase.click) кнопки, ссылаясь на метод с именем `ShowUpdatesButton_Click`:

```xaml
<Button x:Name="showUpdatesButton"
  Content="{Binding ShowUpdatesText}"
  Click="ShowUpdatesButton_Click"/>
```

  *Связывание событий* TIP — это программный термин. Он относится к процессу или коду, в котором указывается, что при возникновении события должно вызываться именованный метод обработчика. В большинстве процедурных моделей кода связывание событий является неявным или явным кодом «AddHandler», который именует как событие, так и метод и обычно включает экземпляр целевого объекта. В XAML неявным является «AddHandler», и связывание событий полностью состоит в том, что именование события является именем атрибута элемента Object, а имя обработчика называется значением этого атрибута.

Вы пишете фактический обработчик на языке программирования, который вы используете для всего кода приложения и кода программной части. С помощью `Click="ShowUpdatesButton_Click"`атрибута вы создали контракт, который когда XAML компилируется и анализируется разметкой, и шаг компиляции разметки XAML в действии сборки интегрированной среды разработки, и в конечном итоге синтаксический анализ XAML при загрузке приложения может найти метод с именем `ShowUpdatesButton_Click` как часть Co приложения ru. `ShowUpdatesButton_Click` должен быть методом, реализующим совместимую сигнатуру метода (на основе делегата) для любого обработчика события [**щелчка**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.buttonbase.click) . Например, этот код определяет обработчик `ShowUpdatesButton_Click`.

```csharp
private void ShowUpdatesButton_Click (object sender, RoutedEventArgs e) 
{
    Button b = sender as Button;
    //more logic to do here...
}
```

```vb
Private Sub ShowUpdatesButton_Click(ByVal sender As Object, ByVal e As RoutedEventArgs)
    Dim b As Button = CType(sender, Button)
    '  more logic to do here...
End Sub
```

```cppwinrt
void winrt::MyNamespace::implementation::BlankPage::ShowUpdatesButton_Click(Windows::Foundation::IInspectable const& sender, Windows::UI::Xaml::RoutedEventArgs const& e)
{
    auto b{ sender.as<Windows::UI::Xaml::Controls::Button>() };
    // More logic to do here.
}
```

```cpp
void MyNamespace::BlankPage::ShowUpdatesButton_Click(Platform::Object^ sender, Windows::UI::Xaml::RoutedEventArgs^ e) 
{
    Button^ b = (Button^) sender;
    //more logic to do here...
}
```

В этом примере метод `ShowUpdatesButton_Click` основан на делегате [**RoutedEventHandler**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.routedeventhandler) . Вы узнаете, что это делегат для использования, так как вы увидите, что делегат с именем в синтаксисе метода [**Click**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.buttonbase.click) .

**Совет** .  Visual Studio предоставляет удобный способ именования обработчика событий и определения метода обработчика при редактировании XAML. При предоставлении имени атрибута события в текстовом редакторе XAML подождите, пока не отобразится список Microsoft IntelliSense. Если нажать кнопку **&lt;создать обработчик событий&gt;** из списка, Microsoft Visual Studio предложит имя метода на основе элемента **x:Name** (или имени типа), имени события и числового суффикса. Затем можно щелкнуть правой кнопкой мыши имя выбранного обработчика событий и выбрать пункт " **Переход к обработчику событий**". Это приведет непосредственно к добавленному определению обработчика событий, как показано в представлении кода программной части для страницы XAML. Обработчик событий уже имеет правильную сигнатуру, включая параметр *sender* и класс данных события, которые использует событие. Кроме того, если в коде программной части уже существует метод обработчика с правильной подписью, имя этого метода отображается в раскрывающемся списке автозавершение вместе с параметром **&lt;новый обработчик событий&gt;** . Можно также нажать клавишу TAB в качестве ярлыка вместо того, чтобы щелкнуть элементы списка IntelliSense.

## <a name="defining-an-event-handler"></a>Определение обработчика событий

Для объектов, которые являются элементами пользовательского интерфейса и объявлены в XAML, код обработчика событий определяется в разделяемом классе, который служит в качестве кода программной части для страницы XAML. Обработчики событий — это методы, которые пишутся как часть разделяемого класса, связанного с XAML. Эти обработчики событий основываются на делегатах, используемых определенным событием. Методы обработчика событий могут быть открытыми или закрытыми. Частный доступ работает, так как обработчик и экземпляр, созданные с помощью XAML, в конечном итоге соединяются при формировании кода. В общем случае рекомендуется сделать методы обработчика событий частными в классе.

**Примечание** .  обработчики C++ событий для не определяются в разделяемых классах, они объявляются в заголовке как член закрытого класса. Действия сборки для C++ проекта позаботится о создании кода, поддерживающего систему типов XAML и модель кода программной части для C++.

### <a name="the-sender-parameter-and-event-data"></a>Параметры *отправителя* и данные события

Обработчик, который вы пишете для события, может получить доступ к двум значениям, которые доступны в качестве входных данных для каждого случая, когда вызывается обработчик. Первое такое значение — *sender*, которое является ссылкой на объект, к которому присоединен обработчик. Параметр *sender* типизирован как тип базового **объекта** . Распространенный прием заключается в приведении *отправителя* к более точному типу. Эта методика полезна, если вы планируете проверить или изменить состояние объекта *отправителя* . Основываясь на разработке собственного приложения, обычно известно, какой тип можно присвоить *отправителю* , в зависимости от того, где прикрепляется обработчик, или какие-либо другие особенности разработки.

Второе значение — это данные события, которые обычно отображаются в определениях синтаксиса в качестве параметра *e* . Чтобы узнать, какие свойства данных событий доступны, просмотрите параметр *e* делегата, который назначен для обрабатываемого события, а затем используйте IntelliSense или обозреватель объектов в Visual Studio. Также можно использовать справочную документацию по среда выполнения Windows.

Для некоторых событий значения конкретного свойства данных события важны так, как известно, что событие произошло. Это особенно справедливо для входных событий. Для событий указателя расположение указателя при возникновении события может быть важным. Для событий клавиатуры все возможные нажатия клавиш вызывают событие [**KeyDown**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.keydown) и [**KeyUp**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.keyup) . Чтобы определить, какой ключ пользователь нажал, необходимо получить доступ к [**кэйраутедевентаргс**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Input.KeyRoutedEventArgs) , доступному для обработчика событий. Дополнительные сведения об обработке входных событий см. в разделе [взаимодействие с клавиатурой](https://docs.microsoft.com/windows/uwp/input-and-devices/keyboard-interactions) и [обработка входных указателей](https://docs.microsoft.com/windows/uwp/input-and-devices/handle-pointer-input). Входные события и входные сценарии часто имеют дополнительные соображения, которые не рассматриваются в этом разделе, такие как захват указателя для событий указателей, клавиши модификаторов и коды клавиш платформы для событий клавиатуры.

### <a name="event-handlers-that-use-the-async-pattern"></a>Обработчики событий, использующие шаблон **Async**

В некоторых случаях необходимо использовать интерфейсы API, которые используют **асинхронный** шаблон в обработчике событий. Например, вы можете использовать [**кнопку**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Button) в [**панель приложений**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.AppBar) , чтобы отобразить средство выбора файлов и взаимодействовать с ним. Однако многие API средства выбора файлов являются асинхронными. Они должны вызываться внутри области **асинхронного**/аваитабле, и компилятор будет применять это. Итак, что можно сделать, добавьте в обработчик событий ключевое слово **Async** , чтобы обработчик стал **асинхронным** **void**. Теперь обработчику событий разрешено выполнять **асинхронные**вызовы/аваитабле.

Пример обработки событий взаимодействия с пользователем с помощью шаблона **Async** см. в разделе [доступ к файлам и выборки](https://docs.microsoft.com/previous-versions/windows/apps/jj655411(v=win.10)) (часть руководства[Создание первого среда выполнения Windows приложения с помощью C# или Visual Basic](https://docs.microsoft.com/previous-versions/windows/apps/hh974581(v=win.10)) Series). См. также [вызов асинхронных API в C).

## <a name="adding-event-handlers-in-code"></a>Добавление обработчиков событий в код

XAML — не единственный способ назначения обработчика событий объекту. Для добавления обработчиков событий к любому объекту в коде, в том числе к объектам, которые не могут использоваться в XAML, можно использовать синтаксис, зависящий от языка, для добавления обработчиков событий.

В C#синтаксисе используется оператор`+=`. Вы регистрируете обработчик, ссылаясь на имя метода обработчика событий в правой части оператора.

Если вы используете код для добавления обработчиков событий к объектам, отображаемым в пользовательском интерфейсе времени выполнения, то обычно добавляйте такие обработчики в ответ на событие времени жизни объекта или обратный вызов, например [**Loaded**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.loaded) или [**OnApplyTemplate**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.onapplytemplate), чтобы обработчики событий в соответствующий объект готов для инициированных пользователем событий во время выполнения. В этом примере показана структура XAML структуры страницы, а затем предоставляется синтаксис C# языка для добавления обработчика событий в объект.

```xaml
<Grid x:Name="LayoutRoot" Loaded="LayoutRoot_Loaded">
  <StackPanel>
    <TextBlock Name="textBlock1">Put the pointer over this text</TextBlock>
...
  </StackPanel>
</Grid>
```

```csharp
void LayoutRoot_Loaded(object sender, RoutedEventArgs e)
{
    textBlock1.PointerEntered += textBlock1_PointerEntered;
    textBlock1.PointerExited += textBlock1_PointerExited;
}
```

**Обратите внимание** ,  существует более подробный синтаксис. В 2005 добавлена C# функция, называемая выводом делегата, которая позволяет компилятору вычислять новый экземпляр делегата и включать предыдущий, более простой синтаксис. Синтаксис подробных данных функционально идентичен предыдущему примеру, но явно создает новый экземпляр делегата перед его регистрацией, тем самым не используя преимущества вывода делегата. Этот явный синтаксис менее распространен, но вы по-прежнему можете увидеть его в некоторых примерах кода.

```csharp
void LayoutRoot_Loaded(object sender, RoutedEventArgs e)
{
    textBlock1.PointerEntered += new PointerEventHandler(textBlock1_PointerEntered);
    textBlock1.PointerExited += new MouseEventHandler(textBlock1_PointerExited);
}
```

Существует два варианта синтаксиса Visual Basic. Одним из них является параллельный C# синтаксис и присоединение обработчиков непосредственно к экземплярам. Для этого требуется ключевое слово **AddHandler** , а также оператор **AddressOf** , который отменяет ссылку на имя метода обработчика.

Другой вариант синтаксиса Visual Basic заключается в использовании ключевого слова **Handles** в обработчиках событий. Этот метод подходит для случаев, когда обработчики должны существовать на объектах во время загрузки и сохраняться в течение всего времени существования объекта. Использование **дескрипторов** для объекта, определенного в XAML, требует указания **имени** / **x:Name**. Это имя становится квалификатором экземпляра, который требуется для компонента *instance. Event* синтаксиса **Handles** . В этом случае для инициации присоединения других обработчиков событий не требуется обработчик событий на основе времени существования объекта. соединения **обработчиков** создаются при компиляции страницы XAML.

```vb
Private Sub textBlock1_PointerEntered(ByVal sender As Object, ByVal e As PointerRoutedEventArgs) Handles textBlock1.PointerEntered
' ...
End Sub
```

**Обратите внимание** ,  Visual Studio и область конструктора XAML обычно передают метод обработки экземпляра вместо ключевого слова **Handles** . Это обусловлено тем, что создание привязки обработчика событий в XAML является частью обычного рабочего процесса разработчика конструктора, а методика использования ключевого слова **Handles** несовместима с связыванием обработчиков событий в XAML.

В C++языке/CX также используется синтаксис **+=** , но существуют различия в базовой C# форме:

- Вывод делегата не существует, поэтому для экземпляра делегата необходимо использовать **ref new** .
- Конструктор делегата имеет два параметра, и в качестве первого параметра требуется целевой объект. Обычно **это**указывается.
- Конструктор делегата требует адрес метода в качестве второго параметра, поэтому **&** оператор ссылки предшествует имени метода.

```cppwinrt
textBlock1().PointerEntered({this, &MainPage::TextBlock1_PointerEntered });
```

```cpp
textBlock1->PointerEntered += 
ref new PointerEventHandler(this, &BlankPage::textBlock1_PointerEntered);
```

### <a name="removing-event-handlers-in-code"></a>Удаление обработчиков событий в коде

Обычно нет необходимости удалять обработчики событий в коде, даже если они были добавлены в код. Во время существования объекта для большинства среда выполнения Windows объектов, таких как страницы и элементы управления, объекты удаляются, когда они отключаются от главного [**окна**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Window) и его визуального дерева, и все ссылки на делегаты уничтожаются. .NET делает это с помощью сборки мусора, а C++среда выполнения Windows с помощью/CX по умолчанию использует слабые ссылки.

В некоторых редких случаях необходимо явно удалить обработчики событий. К ним относятся:

- Обработчики, добавленные для статических событий, которые не могут собирать мусор обычным образом. Примерами статических событий в среда выполнения Windows API являются события классов [**CompositionTarget**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Media.CompositionTarget) и [**Clipboard**](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.DataTransfer.Clipboard) .
- Тестовый код, в котором требуется, чтобы время удаления обработчика было немедленным, или код, в котором нужно поменять старые или новые обработчики событий для события во время выполнения.
- Реализация пользовательского метода доступа **Remove** .
- Пользовательские статические события.
- Обработчики для переходов по страницам.

[**FrameworkElement. выгруженные**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.unloaded) или [**Page. навигатедфром**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.page.onnavigatedfrom) — это возможные триггеры событий, которые имеют соответствующие позиции в управлении состоянием и времени существования объектов, так что их можно использовать для удаления обработчиков для других событий.

Например, можно удалить обработчик событий с именем **textBlock1\_поинтерентеред** из целевого объекта **textblock1** , используя этот код.

```csharp
textBlock1.PointerEntered -= textBlock1_PointerEntered;
```

```vb
RemoveHandler textBlock1.PointerEntered, AddressOf textBlock1_PointerEntered
```

Можно также удалить обработчики для случаев, когда событие было добавлено с помощью атрибута XAML, что означает, что обработчик был добавлен в созданный код. Это проще сделать, если вы указали значение **имени** для элемента, в котором был присоединен обработчик, поскольку он предоставляет ссылку на объект для кода позже; Однако можно также проанализировать дерево объектов, чтобы найти необходимую ссылку на объект в случаях, когда у объекта нет **имени**.

Если необходимо удалить обработчик событий в C++/CX, вам потребуется маркер регистрации, полученный из возвращаемого значения регистрации обработчика событий`+=`. Это связано с тем, что значение, используемое в правой части `-=` отмены регистрации в синтаксисе C++/CX, — это токен, а не имя метода. Для C++кода/CX нельзя удалить обработчики, которые были добавлены как атрибут XAML, так C++как созданный кодом/CX код не сохраняет маркер.

## <a name="routed-events"></a>Перенаправленные события

Среда выполнения Windows с C#, Microsoft Visual Basic или C++/CX поддерживает концепцию перенаправленного события для набора событий, которые имеются в большинстве элементов пользовательского интерфейса. Эти события предназначены для сценариев ввода и взаимодействия с пользователем, и они реализуются в базовом классе [**UIElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.UIElement) . Ниже приведен список событий ввода, которые являются перенаправленными событиями:

- [**брингинтовиеврекуестед**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.bringintoviewrequested)
- [**чарактеррецеивед**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.characterreceived)
- [**контекстканцелед**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.contextcanceled)
- [**контекстрекуестед**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.contextrequested)
- [**даублетаппед**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.doubletapped)
- [**DragEnter**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dragenter)
- [**DragLeave**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dragleave)
- [**DragOver**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dragover)
- [**драгстартинг**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dragstarting)
- [**Тени**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.drop)
- [**дропкомплетед**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dropcompleted)
- [**жеттингфокус**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.gettingfocus)
- [**Фокус**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.gotfocus)
- [**Держит**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.holding)
- [**Клавиш**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.keydown)
- [**KeyUp**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.keyup)
- [**лосингфокус**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.losingfocus)
- [**LostFocus**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.lostfocus)
- [**ManipulationCompleted**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.manipulationcompleted)
- [**ManipulationDelta**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.manipulationdelta)
- [**ManipulationInertiaStarting**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.manipulationinertiastarting)
- [**ManipulationStarted**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.manipulationstarted)
- [**ManipulationStarting**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.manipulationstarting)
- [**нофокускандидатефаунд**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.nofocuscandidatefoundeventargs)
- [**поинтерканцелед**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointercanceled)
- [**поинтеркаптурелост**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointercapturelost)
- [**поинтерентеред**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointerentered)
- [**поинтерекситед**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointerexited)
- [**поинтермовед**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointermoved)
- [**поинтерпрессед**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointerpressed)
- [**поинтеррелеасед**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointerreleased)
- [**поинтервхилчанжед**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointerwheelchanged)
- [**PreviewKeyDown**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.previewkeydown.md)
- [**превиевкэйуп**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.previewkeyup.md)
- [**поинтервхилчанжед**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointerwheelchanged)
- [**ригхттаппед**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.righttapped)
- [**Полученные**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.tapped)

Перенаправленное событие — это событие, потенциально передаваемое (*перенаправленное*) от дочернего объекта к каждому из последовательных родительских объектов в дереве объектов. Структура XAML в пользовательском интерфейсе приблизительно соответствует этому дереву с корнем этого дерева, который является корневым элементом в XAML. Истинное дерево объектов может отличаться от вложенного элемента XAML, поскольку дерево объектов не включает возможности языка XAML, такие как теги элементов свойств. Можно занимать перенаправленное событие как *восходящая* из любого дочернего элемента объекта XAML, который запускает событие, в сторону родительского элемента объекта, содержащего его. Событие и его данные события могут обрабатываться на нескольких объектах в маршруте события. Если ни один из элементов не содержит обработчиков, маршрут потенциально продолжает работать до тех пор, пока не будет достигнут корневой элемент.

Если вы знакомы с веб-технологиями, такими как Dynamic HTML (DHTML) или HTML5, возможно, вы уже знакомы с концепцией события *восходящей маршрутизации* .

Когда перенаправленное событие направляется через маршрут события, все подключенные обработчики событий обращаются к общему экземпляру данных события. Таким образом, если какие-либо данные события могут быть записаны обработчиком, любые изменения данных события будут переданы следующему обработчику и могут больше не представлять исходные данные события из события. Если событие имеет поведение перенаправленного события, в справочную документацию будут включены примечания или другие представления о перенаправленном поведении.

### <a name="the-originalsource-property-of-routedeventargs"></a>Свойство **оригиналсаурце** объекта **RoutedEventArgs**

Когда событие передается вверх по маршруту события, *отправитель* больше не является объектом, вызывающим событие. Вместо этого *отправитель* — это объект, в котором присоединен обработчик, который вызывается.

В некоторых случаях *отправитель* не является интересным, и вы хотите получить такие сведения, как о возможных дочерних объектах, на которые наведен указатель при возникновении события указателя, или о том, какой объект в большом пользовательском интерфейсе имеет фокус при нажатии пользователем клавиши клавиатуры. В этих случаях можно использовать значение свойства [**оригиналсаурце**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.routedeventargs.originalsource) . Во всех точках маршрута **оригиналсаурце** сообщает исходный объект, который вызвал событие, а не объект, к которому присоединен обработчик. Однако для событий ввода [**UIElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.UIElement) этот исходный объект часто является объектом, который не отображается сразу в XAML определения пользовательского интерфейса на уровне страницы. Вместо этого исходный исходный объект может быть частью шаблона элемента управления. Например, если пользователь наводит указатель мыши на самый край [**кнопки**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Button), для большинства событий указателя **оригиналсаурце** является частью шаблона [**границы**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Border) в [**шаблоне**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.template), а не самой **кнопкой** .

**Совет**  восходящая маршрутизация событий особенно полезна, если вы создаете шаблонный элемент управления. Любой элемент управления, имеющий шаблон, может иметь новый шаблон, примененный его потребителем. Потребитель, пытающийся воссоздать рабочий шаблон, может случайно устранить некоторые события, объявленные в шаблоне по умолчанию. Вы по-прежнему можете обеспечить обработку событий на уровне элемента управления, присоединив обработчики как часть переопределения [**OnApplyTemplate**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.onapplytemplate) в определении класса. Затем можно перехватить входные события, которые поднимаются к корню элемента управления при создании экземпляра.

### <a name="the-handled-property"></a>Свойство **Handled**

Несколько классов данных событий для определенных перенаправленных событий содержат свойство с именем **Handled**. Примеры см. в разделе [**поинтерраутедевентаргс. handleding**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.input.pointerroutedeventargs.handled), [**кэйраутедевентаргс. handleded**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.input.keyroutedeventargs.handled), [**DragEventArgs. Handled**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.handled). Во всех случаях **обрабатывается** настраиваемое логическое свойство.

Присвоение свойству **Handled** значения **true** влияет на поведение системы событий. Если параметр **Handled** имеет **значение true**, маршрутизация останавливается для большинства обработчиков событий. Это событие не продолжает маршрут, чтобы уведомлять другие присоединенные обработчики этого случая события. То, что обрабатывается, означает в контексте события, а также о том, как ваше приложение отвечает на него. По сути, **Обработка** — это простой протокол, позволяющий коду приложения определить, что возникновение события не должно быть пузырьковой в какие-либо контейнеры. логика приложения позаботится о том, что необходимо сделать. И наоборот, необходимо быть внимательным, чтобы не обрабатывать события, которые, возможно, должны быть пузырьковой, чтобы обеспечить выполнение встроенных поведений системы или управления. Например, обработка низкоуровневых событий внутри частей или элементов элемента управления Selection может быть негативной. Элемент управления Selection может искать входные события, чтобы убедиться, что выделение должно быть изменено.

Не все перенаправленные события могут отменять маршрут таким образом, и вы можете определить, что они не имеют **обработанного** свойства. Например, [**Получение фокуса**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.gotfocus) и [**Потеря фокуса**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.lostfocus) выполняется пузырьковым, но они всегда перемещаются в корневую папку, а классы данных событий не имеют **обработанного** свойства, которое может повлиять на это поведение.

##  <a name="input-event-handlers-in-controls"></a>Входные обработчики событий в элементах управления

Некоторые элементы управления среда выполнения Windows иногда используют **обрабатываемое** понятие для внутренних событий ввода. Это может показаться, что событие ввода никогда не происходит, так как пользовательский код не может его справиться. Например, класс [**Button**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Button) включает логику, намеренно обрабатывающую общее [**поинтерпрессед**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.pointerpressed)событие ввода. Это происходит потому, что кнопки вызывают событие [**щелчка**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.buttonbase.click) , которое инициируется нажатием клавиши вводом указателя, а также другими режимами ввода, такими как обработка ключей, таких как клавиша ВВОД, которые могут вызывать кнопку, когда она фокуса. В целях разработки класса **Button**событие необработанного ввода концептуально обработано, а потребители классов, такие как пользовательский код, могут взаимодействовать с событием **щелчка** , соответствующим элементу управления. Темы для конкретных классов элементов управления в справочнике по API среда выполнения Windows часто зависят от поведения обработки событий, реализуемого классом. В некоторых случаях поведение можно изменить, **переопределив методы**_событий_ . Например, можно изменить способ реагирования производного класса [**TextBox**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.TextBox) на ввод ключа путем переопределения [**Control. OnKeyDown**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.onkeydown).

##  <a name="registering-handlers-for-already-handled-routed-events"></a>Регистрация обработчиков для уже обработанных перенаправленных событий

Ранее было сказано, что параметр, **обработанный** в **значение true** , не позволяет вызывать большинство обработчиков. Но метод [**AddHandler**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.addhandler) предоставляет метод, с помощью которого можно присоединить обработчик, который всегда вызывается для маршрута, даже если для какого-либо другого обработчика, установленного ранее в маршруте, **было задано** значение **true** в общих данных события. Этот метод полезен, если в используемом элементе управления обрабатывается событие во внутренней компоновке или для логики конкретного элемента управления. но вы все равно хотите ответить на него из экземпляра элемента управления или пользовательского интерфейса приложения. Но этот метод следует использовать с осторожностью, поскольку он может противоречить намерениям **обрабатывать** и, возможно, нарушить предполагаемые взаимодействия элемента управления.

Только перенаправленные события, имеющие соответствующий идентификатор перенаправленного события, могут использовать метод обработки событий [**AddHandler**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.addhandler) , поскольку идентификатор является обязательным входом метода **AddHandler** . Список событий, имеющих доступные идентификаторы перенаправленных событий, см. в справочной документации по [**AddHandler**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.addhandler) . В большинстве случаев это тот же список перенаправленных событий, который мы показали ранее. Исключением является то, что последние два в списке: [**Получение**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.gotfocus) и [**потеря**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.lostfocus) данных не имеют идентификатора перенаправленного события, поэтому для них нельзя использовать **AddHandler** .

## <a name="routed-events-outside-the-visual-tree"></a>Перенаправленные события за пределами визуального дерева

Некоторые объекты участвуют в связи с основным визуальным деревом, что концептуально похоже на то, что накладывается на основные визуальные элементы. Эти объекты не являются частью обычных отношений типа «родители-потомки», которые соединяют все элементы дерева с корнем визуального элемента. Это случай для любого отображаемого [**всплывающего окна**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Primitives.Popup) или [**всплывающей подсказки**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.ToolTip). Если требуется обработка перенаправленных событий из **всплывающего окна** или **всплывающей подсказки**, поместите обработчики на определенные элементы пользовательского интерфейса, находящиеся внутри **всплывающего окна** или **всплывающей** подсказки, а не сами элементы **всплывающего окна** или **всплывающей подсказки** . Не полагайтесь на маршрутизацию внутри любых композиций, выполняемых для **всплывающего окна** или **всплывающей подсказки** . Это обусловлено тем, что маршрутизация событий для перенаправленных событий работает только в основном визуальном дереве. **Всплывающее окно** или **Подсказка** не считается родителем дочерних элементов пользовательского интерфейса и никогда не получает перенаправленное событие, даже если оно пытается использовать нечто вроде фона **всплывающего окна** по умолчанию в качестве области захвата для событий ввода.

## <a name="hit-testing-and-input-events"></a>События проверки нажатия и ввода

Определение того, что и где в пользовательском интерфейсе элемент является видимым для мыши, сенсорного ввода и пера, называется *проверкой нажатия*. Для действий касания, а также для событий, связанных с взаимодействием или манипуляций, которые являются последствиями сенсорного действия, элемент должен быть видимым для проверки попадания в качестве источника события и запуска события, связанного с действием. В противном случае действие проходит через элемент к любым базовым элементам или родительским элементам в визуальном дереве, которые могут взаимодействовать с этими входными данными. Существует несколько факторов, влияющих на проверку попадания, но можно определить, может ли данный элемент запустить события ввода, проверив свойство [**IsHitTestVisible**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.ishittestvisible) . Это свойство возвращает **значение true** , только если элемент соответствует следующим критериям:

- Значение свойства [**видимости**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.visibility) элемента является [**видимым**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Visibility).
- Значение свойства **Background** или **Fill** элемента не равно **null**. Значение **null** [**кисти**](/uwp/api/Windows.UI.Xaml.Media.Brush) приводит к прозрачности и невидимости проверки попадания. (Чтобы сделать элемент прозрачным, но при этом он должен быть проверен, используйте [**прозрачную**](https://docs.microsoft.com/uwp/api/windows.ui.colors.transparent) кисть вместо **null**.)

**Примечание.**   **фон** и **Заливка** не определяются [**UIElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.UIElement)и определяются различными производными классами, такими как [**элемент управления**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Control) и [**форма**](/uwp/api/Windows.UI.Xaml.Shapes.Shape). Однако влияние кистей, используемых для свойств переднего плана и фона, одинаково для проверки попадания и событий ввода, независимо от того, какой подкласс реализует свойства.

- Если элемент является элементом управления, его значение свойства « [**включил**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.isenabled) » должно быть **true**.
- Элемент должен иметь фактические измерения в макете. Элемент, в котором [**ActualHeight**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.actualheight) и [**ActualWidth**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.frameworkelement.actualwidth) имеют значение 0, не запускает события ввода.

Некоторые элементы управления имеют специальные правила для проверки попадания. Например, [**TextBlock**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.TextBlock) не имеет свойства **Background** , но все равно может быть проверено во всей области его измерений. Проверка попадания элементов управления [**Image**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Image) и [**MediaElement**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) осуществляется по определенным размерам прямоугольника независимо от прозрачного содержимого, такого как альфа-канал в отображаемом медиа-файле источника данных. Элементы управления [**WebView**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.WebView) имеют особое поведение проверки нажатия, так как входные данные могут обрабатываться размещаемыми HTML и событиями скрипта.

Большинство классов [**панелей**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Panel) и [**границ**](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Border) не поддаются проверке на их собственном фоне, но могут по-прежнему работать с событиями ввода, которые направляются из элементов, которые они содержат.

Можно определить, какие элементы находятся в той же позиции, что и событие пользовательского ввода, независимо от того, подпадают ли элементы для проверки на попадание. Для этого вызовите метод [**финделементсинхосткурдинатес**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.visualtreehelper.findelementsinhostcoordinates) . Как предполагает имя, этот метод находит элементы в расположении относительно указанного элемента узла. Однако примененные преобразования и изменения макета могут корректировать относительную систему координат элемента и, таким образом, влиять на то, какие элементы находятся в определенном месте.

## <a name="commanding"></a>Системе команд

Небольшое количество элементов пользовательского интерфейса поддерживают *команды*. Команда использует перенаправленные события, связанные с входом, в своей базовой реализации и позволяет обрабатывать связанные входные данные пользовательского интерфейса (определенное действие указателя, определенный ключ сочетания клавиш), вызывая один обработчик команд. Если для элемента пользовательского интерфейса доступна команда, рассмотрите возможность использования API командной строки вместо каких-либо дискретных событий ввода. Ссылка на **привязку** обычно используется в свойствах класса, определяющего модель представления для данных. Свойства содержат именованные команды, реализующие шаблон команд **ICommand** , зависящий от языка. Дополнительные сведения см. в разделе [**ButtonBase. Command**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.buttonbase.command).

## <a name="custom-events-in-the-windows-runtime"></a>Пользовательские события в среда выполнения Windows

В целях определения пользовательских событий, способ добавления события и то, что это означает для разработки класса, сильно зависит от используемого языка программирования.

- Для C# и Visual Basic вы определяете событие CLR. Можно использовать стандартный шаблон событий .NET, если вы не используете пользовательские методы доступа (**add**/**Remove**). Дополнительные советы.
    - Для обработчика событий рекомендуется использовать [**System. EventHandler<TEventArgs>** ](https://docs.microsoft.com/dotnet/api/system.eventhandler-1) , так как он содержит встроенное преобразование в [**обработчик события EventHandler<T>** ](https://docs.microsoft.com/uwp/api/windows.foundation.eventhandler)среда выполнения Windows универсальных событий.
    - Не следует основывать класс данных события в [**System. EventArgs**](https://docs.microsoft.com/dotnet/api/system.eventargs) , так как он не преобразуется в среда выполнения Windows. Используйте существующий класс данных события или вообще не пользуйтесь базовым классом.
    - Если вы используете пользовательские методы доступа, см. раздел [пользовательские события и методы доступа к событиям в среда выполнения Windows компонентов](https://docs.microsoft.com/previous-versions/windows/apps/hh972883(v=vs.140)).
    - Если вы не уверены в стандартном шаблоне событий .NET, см. раздел [Определение событий для пользовательских классов Silverlight](https://docs.microsoft.com/previous-versions/windows/). Это написано для Microsoft Silverlight, но по-прежнему является хорошим суммированием кода и концепций для стандартного шаблона событий .NET.
- Для C++/CX см. [события (C++/CX)](https://docs.microsoft.com/cpp/cppcx/events-c-cx).
    - Используйте именованные ссылки, даже при использовании пользовательских событий. Не используйте лямбда для пользовательских событий, он может создать циклическую ссылку.

Нельзя объявить пользовательское перенаправленное событие для среда выполнения Windows; перенаправленные события ограничены набором, который поступает из среда выполнения Windows.

Определение пользовательского события обычно выполняется в рамках упражнения по определению пользовательского элемента управления. Это общий шаблон для создания свойства зависимостей с обратным вызовом, измененным свойством, а также для определения пользовательского события, запускаемого обратным вызовом свойства зависимостей в некоторых или во всех случаях. Потребители вашего элемента управления не имеют доступа к определенному вами ответу, измененному свойством, но наличие события уведомления является следующим лучшим делом. Дополнительные сведения см. в разделе [пользовательские свойства зависимостей](custom-dependency-properties.md).

## <a name="related-topics"></a>Связанные разделы

* [Общие сведения о XAML](xaml-overview.md)
* [Краткое руководство. сенсорный ввод](https://docs.microsoft.com/previous-versions/windows/apps/hh465387(v=win.10))
* [Взаимодействие с клавиатурой](https://docs.microsoft.com/windows/uwp/input-and-devices/keyboard-interactions)
* [События и делегаты .NET](https://go.microsoft.com/fwlink/p/?linkid=214364)
* [Создание компонентов среда выполнения Windows](https://docs.microsoft.com/previous-versions/windows/apps/hh441572(v=vs.140))
* [**AddHandler**](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.addhandler)
