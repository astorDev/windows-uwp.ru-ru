---
author: jwmsft
description: "Расширение разметки xBind в качестве альтернативы для Binding. Расширение разметки xBind не имеет некоторых функций Binding, но оно быстрее запускается, требует меньше памяти, чем Binding, и поддерживает более эффективную отладку."
title: "Расширение разметки xBind"
ms.assetid: 529FBEB5-E589-486F-A204-B310ACDC5C06
translationtype: Human Translation
ms.sourcegitcommit: 2dc706412684ded7fe4e98c6d01fb75ae65abd5f
ms.openlocfilehash: b7d1dd183ba35e4b694a80d3e43628c928b218e5

---

# Расширение разметки x:Bind

\[ Обновлено для приложений UWP в Windows10. Статьи о Windows8.x см. в [архиве](http://go.microsoft.com/fwlink/p/?linkid=619132) \]

**Примечание.**  Общие сведения об использовании привязки данных в приложении с **{x:Bind}** (и комплексное сравнение между **{x:Bind}** и **{Binding}**) см. в разделе [Подробно о привязке данных](https://msdn.microsoft.com/library/windows/apps/mt210946).

Расширение разметки **{x:Bind}**—новая функция для Windows10—является альтернативой для **{Binding}**. Расширение разметки **{x:Bind}** не имеет некоторых функций **{Binding}**, но оно быстрее запускается, требует меньше памяти, чем **{Binding}**, и поддерживает более эффективную отладку.

Во время компиляции XAML **{x:Bind}** преобразуется в код, который получает значения из свойства в источнике данных и устанавливает его для свойства, определенного в разметке. Объект привязки можно дополнительно настроить таким образом, чтобы он регистрировал изменения значений свойства источника данных и сам обновлялся на основании этих данных. Кроме того, его можно настроить, чтобы он отправлял изменения собственного значения назад к свойству источника. Как правило, объекты привязки, создаваемые с помощью расширений разметки **{x:Bind}** и **{Binding}**, выполняют аналогичные функции. Однако **{x:Bind}** выполняет специальный код, который генерируется во время компиляции, а **{Binding}** использует универсальную проверку объектов среды выполнения. В результате привязки **{x:Bind}** (часто именуемые компилированными привязками) имеют большую производительность, обеспечивают проверку ваших выражений привязки и поддерживают отладку, позволяя задавать точки останова в файлах кода, которые создаются как разделяемый класс для вашей страницы. Эти файлы можно найти в папке `obj` с такими именами, как `<view name>.g.cs` (для C#).

**Примеры приложений с расширением разметки {x:Bind}**

-   [Пример {x:Bind}](http://go.microsoft.com/fwlink/p/?linkid=619989)
-   [QuizGame](https://github.com/Microsoft/Windows-appsample-quizgame)
-   [Пример базовых характеристик пользовательского интерфейса XAML](http://go.microsoft.com/fwlink/p/?linkid=619992)

## Использование атрибутов XAML

``` syntax
<object property="{x:Bind}" .../>
-or-
<object property="{x:Bind propertyPath}" .../>
-or-
<object property="{x:Bind bindingProperties}" .../>
-or-
<object property="{x:Bind propertyPath, bindingProperties}" .../>
```

| Термин | Описание |
|------|-------------|
| _propertyPath_ | Строка, указывающая путь свойства для привязки. Подробную информацию см. в разделе [Путь свойства](#property-path) ниже. |
| _bindingProperties_ |
| _propName_=_value_\[, _propName_=_value_\]* | Одна или несколько привязок свойств, указанных с помощью синтаксиса пары "имя/значение". |
| _propName_ | Имя строки свойства для установки на объекте привязки. Например, Converter. |
| _value_ | Значение, которое следует задать для свойства. Синтаксис аргумента зависит от задаваемого свойства. Вот пример использования _propName_=_значение_, где значение само является расширением разметки: `Converter={StaticResource myConverterClass}`. Дополнительную информацию см. в разделе [Свойства, которые можно задать с помощью расширения разметки {x:Bind}](#properties-you-can-set) ниже. | 

## Путь свойства

*PropertyPath* задает значение **Path** для выражения **{x:Bind}**. **Path**—путь к свойству, в котором определено значение свойства, подсвойства, поля или метода, к которому выполняется привязка (источник). Можно упомянуть точное имя свойства **Path**: `{Binding Path=...}`. Или его можно не указывать: `{Binding ...}`.

### Разрешение пути свойства

Расширение разметки **{x:Bind}** не использует **DataContext** в качестве источника по умолчанию—оно использует страницу или пользовательский элемент управления. Таким образом оно будет выглядеть в коде программной части вашей страницы или пользовательского элемента управления для свойств, полей и методов. Чтобы предоставить модель представления для расширения разметки **{x:Bind}**, обычно нужно добавить новые поля или свойства в код программной части для страницы или пользовательского элемента управления. Этапы в пути к свойству разделены точками (.), и вы можете добавить несколько разделителей для прохождения по иерархии. Используйте разделительные точки независимо от языка программирования, используемого для реализации объекта, к которому осуществляется привязка.

Например, на странице: **Text="{x:Bind Employee.FirstName}"** будет искать участника **Employee** на странице, а затем участника **FirstName** в объекте, возвращенном участником **Employee**. Если бы элемент управления элементами привязывался к свойству, содержащему подчиненных сотрудников, то путем свойства мог бы быть Employee.Dependents, а шаблон элемента управления элементами, отобразил бы элементы в Dependents.

В случае использования языков C++/CX **{x:Bind}** нельзя привязать к частным полям и свойствам в модели страницы или данных—вам потребуется открытое свойство для выполнения привязки. Контактную зону для привязки необходимо предоставлять в качестве классов/интерфейсов CX, чтобы можно было получить соответствующие метаданные. Атрибут **\[Bindable\]**, как правило, не требуется.

При использовании **x:Bind** вам не нужно применять **ElementName=xxx** как часть выражения привязки. **x:Bind** позволяет использовать имя элемента в качестве первой части пути для привязки, поскольку именованные элементы становятся полями на странице или в пользовательском элементе управления, который представляет собой источник привязки корня.

### Коллекции

Если источником данных выступает коллекция, то в пути свойства можно указывать элементы коллекции по их позиции или индексу. Пример: Teams\[0\].Players. Здесь в "\[\]" заключается индекс "0", который запрашивает первый элемент в коллекции, индексируемой от нуля.

Чтобы воспользоваться индексатором, модели необходимо реализовать **IList&lt;T&gt;** или **IVector&lt;T&gt;** в типе свойства, которое подлежит индексации. Если тип индексированного свойства поддерживает **INotifyCollectionChanged** или **IObservableVector**, а привязка относится к типу OneWay или TwoWay, то она будет принимать и регистрировать уведомления об изменениях на этих интерфейсах. Логика отслеживания изменений обновляется с учетом всех изменений коллекции, даже если эти изменения не влияют на конкретное индексированное значение. Это обусловлено тем, что логика ожидания передачи данных общая для всех экземпляров коллекции.

Если источником данных выступает словарь или карта, то в пути свойства можно указывать элементы коллекции по имени строки. Например **&lt;TextBlock Text="{x:Bind Players\['Иван Иванов'\]" /&gt;** будет искать в словаре элемент с именем "Иван Иванов". Имя необходимо заключить в кавычки, которые могут быть как двойными, так и одинарными. Для экранирования кавычек в строках можно использовать символ карет (^). Зачастую проще всего использовать кавычки, отличные от тех, что используются для атрибута XAML.

Чтобы воспользоваться индексатором строки, модели необходимо реализовать **IDictionary&lt;string, T&gt;** or **IMap&lt;string, T&gt;** в типе свойства, которое подлежит индексации. Если тип индексированного свойства поддерживает **IObservableMap**, а привязка относится к типу OneWay или TwoWay, то она будет принимать и регистрировать уведомления об изменениях на этих интерфейсах. Логика отслеживания изменений обновляется с учетом всех изменений коллекции, даже если эти изменения не влияют на конкретное индексированное значение. Это обусловлено тем, что логика ожидания передачи данных общая для всех экземпляров коллекции.

### Присоединенные свойства

Для привязки присоединенных свойств необходимо ввести имена класса и свойства в круглых скобках после точки. Например, **Text="{x:Bind Button22.(Grid.Row)}"**. Если свойство не объявляется в пространстве имен Xaml, нужно установить для него префикс пространства имен xml, которое необходимо сопоставить с пространством имен кода в заголовке документа.

### Приведение

Скомпилированные привязки строго типизированы и распознают тип каждого этапа в пути. Если возвращаемый тип не содержит элемент, во время компиляции будет возвращена ошибка. Можно сообщать привязке реальный тип объекта, определив приведение. В следующем случае **obj** является свойством объекта типа, но содержит текстовое поле, что позволяет использовать **Text="{x:Bind ((TextBox)obj).Text}"** или **Text="{x:Bind obj.(TextBox.Text)}"**.
Поле **groups3** в **Text="{x:Bind ((data:SampleDataGroup)groups3\[0\]).Title}"** является словарем объектов, поэтому необходимо привести его к **data:SampleDataGroup**. Обратите внимание на то, как используется префикс пространства имен XML **data:** для сопоставления типа объектов с пространством имен кода, не являющимся частью пространства имен XAML по умолчанию.

_Примечание. Синтаксис приведения в стиле C# более гибок, чем синтаксис присоединенного свойства и рекомендуется для использования в дальнейшем._

## Функции в путях привязки

Начиная с Windows 10 версии 1607 **{x: Bind}** поддерживает использование функции на конечном этапе шаге пути привязки. Это обеспечивает следующее.
- Более простой способ преобразования значения
- Привязки могут зависеть от нескольких параметров

> [!NOTE]
> Чтобы использовать функции с **{x: Bind}**, минимальная версия целевого пакета SDK вашего приложения должна быть 14393 или более поздней. Если ваше приложение предназначено для более ранних версий Windows 10, вы не сможете использовать функции. Дополнительные сведения о целевых версиях см. в статье [Адаптивный к версии код](https://msdn.microsoft.com/windows/uwp/debug-test-perf/version-adaptive-code).

В следующем примере фон и передний план элемента привязаны к функциям для выполнения преобразования на основе параметра цвета

``` Xamlmarkup
<DataTemplate x:DataType="local:ColorEntry">
    <Grid Background="{x:Bind Brushify(Color)}" Width="240">
        <TextBlock Text="{x:Bind ColorName}" Foreground="{x:Bind TextColor(Color)}" Margin="10,5" />
    </Grid>
</DataTemplate>
```
``` C#
class ColorEntry
{
    public string ColorName { get; set; }
    public Color Color { get; set; }

    public static SolidColorBrush Brushify(Color c)
    {
        return new SolidColorBrush(c);
    }

    public static SolidColorBrush TextColor(Color c)
    {
        return new SolidColorBrush(((c.R * 0.299 + c.G * 0.587 + c.B * 0.114) > 150) ? Colors.Black : Colors.White);
    }
}

```
### Синтаксис функции
``` Syntax
Text="{x:Bind MyModel.Order.CalculateShipping(MyModel.Order.Weight, MyModel.Order.ShipAddr.Zip, 'Contoso'), Mode=OneTime}"
             |      Path to function         |    Path argument   |       Path argument       | Const arg |  Bind Props
```

### Путь к функции
Путь к функции определяется аналогично другим путям свойств и может содержать точки (.), индексаторы или приведения.

Статические функции можно указывать с помощью синтаксиса XMLNamespace:ClassName.MethodName. Например **&lt;CalendarDatePicker Date="\{x:Bind sys:DateTime.Parse(TextBlock1.Text)\}" /&gt;** указывает на функцию DateTime.Parse, при условии, что в верхней части страницы указано **xmlns:sys="using:System"**.

Если выбран режим привязки OneWay или TwoWay, будет произведено отслеживание изменений пути функции, и привязка будет обработана заново при наличии изменений в данных объектах.

Требования к функции, к которой осуществляется привязка:
- Доступность для кода и метаданных. В С# будут работать внутренние и частные методы, однако в C++/CX необходимо использовать открытые методы WinRT
- Перегрузка основана на количестве, а не типе аргументов и будет пытаться попытается соответствовать первой перегрузке с указанным количеством аргументов
- Типы аргументов должны соответствовать передаваемым данным — сужающие преобразования не производятся
- Возвращаемый тип функции должен соответствовать типу свойства, использующего привязку


### Аргументы функции
Можно указать несколько аргументов функции, разделенных запятой (,)
- Синтаксис пути привязки аналогичен синтаксису привязки непосредственно к объекту.
  - Если выбран режим привязки OneWay или TwoWay, будет произведено отслеживание изменений, и привязка будет обработана заново при изменении объектов
- Строковые константы заключаются в кавычки. Они необходимы для обозначения строки. Для экранирования кавычек в строках можно использовать символ карет (^)
- Числовые константы, например 123.456
- Логические константы — обозначаются как "x:True" или "x:False"

### Двухсторонняя привязка функции
При двусторонней привязке следует определить вторую функцию для обратного направления привязки. Для этого используется свойство привязки **BindBack**, например **Text="\{x:Bind a.MyFunc(b), BindBack=a.MyFunc2\}"**. Функция должна принимать один аргумент, представляющий собой значение, которое будет быть возвращено модели.

## Привязка события

Привязка события– это уникальная функция для компилированной привязки. Она позволяет определять обработчик для события с использованием привязки, а не применяется в качестве метода в коде программной части. Например, **Click="{x:Bind rootFrame.GoForward}"**.

В случае работы с событиями метод не должен быть перегружен; он должен соответствовать таким условиям:

-   соответствовать подписи события;
-   или не иметь параметров;
-   или иметь такое же количество параметров типов, которые назначаются из типов параметров событий.

В созданном коде программной части скомпилированная привязка обрабатывает событие и направляет его к методу в модели, анализируя путь выражения привязки при возникновении события. Это означает, что, в отличие от привязок свойства, она не отслеживает изменения в модели.

Дополнительную информацию о синтаксисе строк для пути свойства см. в разделе [Синтаксис пути свойства](property-path-syntax.md), учитывая отличия **{x:Bind}**, описанные в данной статье.

##  Свойства, которые можно задать с помощью расширения разметки {x:Bind}


**{x:Bind}** демонстрируется с помощью замещающего синтаксиса *bindingProperties*, поскольку есть несколько свойств, доступных для чтения и записи, которые можно задавать в данном случае использования расширения разметки. Свойства можно задавать в любом порядке с парами *propName*=*value*, разделенными запятыми. Обратите внимание, что разрывы строк недопустимы в выражении привязки. Для некоторых свойств требуются типы, не предусматривающие преобразования; им необходимы их собственные расширения разметки, вложенные в **{x:Bind}**.

Эти свойства работают практически так же, как и свойства класса [**Binding**](https://msdn.microsoft.com/library/windows/apps/br209820).

| Свойство | Описание |
|----------|-------------|
| **Путь** | См. раздел [Путь к свойству](#property-path) выше. |
| **Converter** | Указывает объект преобразователя, вызываемый механизмом привязки. Преобразователь можно задать в коде XAML, но только в случае, если вы ссылаетесь на экземпляр объекта, присвоенный в ссылке на [расширение разметки {StaticResource}](staticresource-markup-extension.md) этому объекту в словаре ресурсов. |
| **ConverterLanguage** | Указывает язык и региональные параметры, используемые преобразователем. (Если задается свойство **ConverterLanguage**, также следует задать свойство **Converter**.) Язык и региональные параметры задаются как стандартный идентификатор. Подробнее: [**ConverterLanguage**](https://msdn.microsoft.com/library/windows/apps/hh701880). |
| **ConverterParameter** | Указывает параметр преобразователя, который можно использовать в логике преобразователя. (Если задается **ConverterParameter**, также следует задать свойство **Converter**.) Большая часть преобразователей использует простую логику для получения всей необходимой информации из переданного значения, и им не нужно значение **ConverterParameter**. Параметр **ConverterParameter** используется для более расширенных преобразователей, у которых больше одной логики и которым недостаточно информации, переданной в **ConverterParameter**. Вы также можете написать преобразователь, который использует нестроковые значения, но это используется редко. Подробнее см. в разделе "Примечания" статьи [**ConverterParameter**](https://msdn.microsoft.com/library/windows/apps/br209827). |
| **FallbackValue** | Задает значение, которое отображается, когда не удается разрешить источник или путь. |
| **Mode** | Указывает режим привязки как одну из этих строк: OneTime, OneWay или TwoWay. Значение по умолчанию—OneTime. Обратите внимание, что это поведение отличается от шаблона по умолчанию для привязки **{Binding}**, которая в большинстве случаев имеет значение OneWay. |
| **TargetNullValue** | Задает значение, которое отображается, когда значение источника разрешается, но оно явно равно **null**. |
| **BindBack** | Определяет функцию, используемую для обратного направления двусторонней привязки. | 

**Примечание.**  Если вы преобразуете разметку **{Binding}** в **{x:Bind}**, следует учитывать различия между значениями по умолчанию для свойства **Mode**.
 
## Комментарии

Поскольку **{x:Bind}** использует сформированный код, во время компиляции ему необходима информация о типе, чтобы воспользоваться всеми доступными преимуществами. Это означает, что, не зная заранее тип, вы не сможете выполнить привязку к свойствам. По этой причине невозможно использовать **{x:Bind}** со свойством **DataContext**, которое относится к типу **Object** и может во время выполнения изменяться.

При использовании **{x:Bind}** с шаблонами данных необходимо указать тип, к которому будет выполняться привязка, установив значение **x:DataType**, как показано в следующем примере. Вы также можете задавать тип для интерфейса или базового класса, а затем использовать приведения, если понадобится сформулировать полное выражение.

Скомпилированные привязки зависят от создания кода. Если вы используете **{x:Bind}** в словаре ресурсов, тогда словарь ресурсов должен иметь класс кода программной части. Пример кода см. в разделе [Словари ресурсов с привязкой {x:Bind}](../data-binding/data-binding-in-depth.md#resource-dictionaries-with-x-bind).

Страницы и пользовательские элементы управления, содержащие скомпилированные привязки, имеют в сформированном коде свойство "Bindings". Включены следующие методы:
- **Update()** — обновляет значения всех скомпилированных привязок. Все односторонние или двухсторонние привязки имеют прослушиватели для отслеживания изменений.
- **Initialize()** — Если привязки еще не инициализированы, будет вызван метод Update() для инициализации привязок.
- **StopTracking()** — отключает все прослушиватели, созданные для одно- и двухсторонних привязок. Прослушиватели можно инициализировать повторно с помощью метода Update().

> [!NOTE]
> Начиная с Windows 10 версии 1607, платформа XAML предоставляет встроенный преобразователь Boolean в Visibility. Преобразователь сопоставляет значение **true** значению перечисления **Visible**, а значение **false** значению **Collapsed**, поэтому можно осуществить привязку свойства Visibility к Boolean без создания преобразователя. Для использования встроенного преобразователя минимальная версия целевого пакета SDK вашего приложения должна быть 14393 или более поздней. Вы не сможете использовать преобразователь, если ваше приложение предназначено для более ранних версий Windows 10. Дополнительные сведения о целевых версиях см. в статье [Адаптивный к версии код](https://msdn.microsoft.com/windows/uwp/debug-test-perf/version-adaptive-code).

**Совет.** Если в значении необходимо указать одну фигурную скобку, как, например, в [**Path**](https://msdn.microsoft.com/library/windows/apps/br209830) или [**ConverterParameter**](https://msdn.microsoft.com/library/windows/apps/br209827), поставьте перед ней обратную косую черту: `\{`. Также можно включить всю строку, содержащую скобки, которые нужно преобразовать, в дополнительный набор кавычек, например: `ConverterParameter='{Mix}'`.

[**Converter**](https://msdn.microsoft.com/library/windows/apps/br209826), [**ConverterLanguage**](https://msdn.microsoft.com/library/windows/apps/hh701880) и **ConverterLanguage** связаны сценарием преобразования значения или типа из источника привязки в тип или значение, совместимые со свойством целевого объекта привязки. Более подробную информацию и примеры см. в разделе "Преобразования данных" статьи [Подробно о привязке данных](https://msdn.microsoft.com/library/windows/apps/mt210946).

**{x:Bind}** является исключительно расширением разметки и не дает возможности создавать или управлять такими привязками программным способом. Подробнее о расширениях разметки см. в разделе [Обзор языка XAML](xaml-overview.md).

## Примеры.

```XML
<Page x:Class="QuizGame.View.HostView" ... >
    <Button Content="{x:Bind Path=ViewModel.NextButtonText, Mode=OneWay}" ... />
</Page>
```

В этом примере кода XAML используется **{x:Bind}** со свойством **ListView.ItemTemplate**. Обратите внимание на объявление значения **x:DataType**.

```XML
  <DataTemplate x:Key="SimpleItemTemplate" x:DataType="data:SampleDataGroup">
    <StackPanel Orientation="Vertical" Height="50">
      <TextBlock Text="{x:Bind Title}"/>
      <TextBlock Text="{x:Bind Description}"/>
    </StackPanel>
  </DataTemplate>
```



<!--HONumber=Nov16_HO1-->


