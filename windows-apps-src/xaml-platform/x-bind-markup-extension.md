---
author: jwmsft
description: "Расширение разметки xBind в качестве альтернативы для Binding. Расширение разметки xBind не имеет некоторых функций Binding, но оно быстрее запускается, требует меньше памяти, чем Binding, и поддерживает более эффективную отладку."
title: "Расширение разметки xBind"
ms.assetid: 529FBEB5-E589-486F-A204-B310ACDC5C06
ms.sourcegitcommit: 98b9bca2528c041d2fdfc6a0adead321737932b4
ms.openlocfilehash: ceb5562ae08d7cc966f80fdb7e23f12afe040430

---

# Расширение разметки x:Bind

\[ Обновлено для приложений UWP в Windows10. Статьи о Windows8.x см. в [архиве](http://go.microsoft.com/fwlink/p/?linkid=619132) \]


            **Примечание.**  Общие сведения об использовании привязки данных в приложении с **{x:Bind}** (и комплексное сравнение между **{x:Bind}** и **{Binding}**) см. в разделе [Подробно о привязке данных](https://msdn.microsoft.com/library/windows/apps/mt210946).

Расширение разметки **{x:Bind}**—новая функция для Windows10—является альтернативой для **{Binding}**. 
            Расширение разметки **{x:Bind}** не имеет некоторых функций **{Binding}**, но оно быстрее запускается, требует меньше памяти, чем **{Binding}**, и поддерживает более эффективную отладку.

Во время загрузки XAML **{x:Bind}** преобразуется в то, что может считаться объектом привязки, и этот объект получает значение из свойства в источнике данных. Объект привязки можно дополнительно настроить таким образом, чтобы он регистрировал изменения значений свойства источника данных и сам обновлялся на основании этих данных. Кроме того, его можно настроить, чтобы он отправлял изменения собственного значения назад к свойству источника. Как правило, объекты привязки, создаваемые с помощью расширений разметки **{x:Bind}** и **{Binding}**, выполняют аналогичные функции. Однако **{x:Bind}** выполняет специальный код, который генерируется во время компиляции, а **{Binding}** использует универсальную проверку объектов среды выполнения. В результате привязки **{x:Bind}** (часто именуемые компилированными привязками) имеют большую производительность, обеспечивают проверку ваших выражений привязки и поддерживают отладку, позволяя задавать точки останова в файлах кода, которые создаются как разделяемый класс для вашей страницы. Эти файлы можно найти в папке `obj` с такими именами, как `<view name>.g.cs` (для C#).

**Примеры приложений с расширением разметки {x:Bind}**

-   [Пример {x:Bind}](http://go.microsoft.com/fwlink/p/?linkid=619989)
-   [QuizGame](https://github.com/Microsoft/Windows-appsample-quizgame)
-   [Пример базовых характеристик пользовательского интерфейса XAML](http://go.microsoft.com/fwlink/p/?linkid=619992)

## Использование атрибутов XAML

``` syntax
<object property="{x:Bind}" .../>
-or-
<object property="{x:Bind propertyPath}" .../>
-or-
<object property="{x:Bind bindingProperties}" .../>
-or-
<object property="{x:Bind propertyPath, bindingProperties}" .../>
```

| Термин | Описание |
|------|-------------|
| _propertyPath_ | Строка, указывающая путь свойства для привязки. Подробную информацию см. в разделе [Путь свойства](#property-path) ниже. |
| _bindingProperties_ |
| 
            _propName_
            =
            _value_\[, _propName_=_value_\]* | Одна или несколько привязок свойств, указанных с помощью синтаксиса пары "имя/значение". |
| _propName_ | Имя строки свойства для установки на объекте привязки. Например, Converter. | 
| _value_ | Значение, которое следует задать для свойства. Синтаксис аргумента зависит от задаваемого свойства. Вот пример использования _propName_=_значение_, где значение само является расширением разметки: `Converter={StaticResource myConverterClass}`. Дополнительную информацию см. в разделе [Свойства, которые можно задать с помощью расширения разметки {x:Bind}](#properties-you-can-set) ниже. | 

## Путь свойства


            *PropertyPath* задает значение **Path** для выражения **{x:Bind}**. 
            **Path**—путь к свойству, в котором определено значение свойства, подсвойства, поля или метода, к которому выполняется привязка (источник). Можно упомянуть точное имя свойства **Path**: `{Binding Path=...}`. Или его можно не указывать: `{Binding ...}`.


            Расширение разметки **{x:Bind}** не использует **DataContext** в качестве источника по умолчанию—оно использует страницу или пользовательский элемент управления. Таким образом оно будет выглядеть в коде программной части вашей страницы или пользовательского элемента управления для свойств, полей и методов. Чтобы предоставить модель представления для расширения разметки **{x:Bind}**, обычно нужно добавить новые поля или свойства в код программной части для страницы или пользовательского элемента управления. Этапы в пути к свойству разделены точками (.), и вы можете добавить несколько разделителей для прохождения по иерархии. Используйте разделительные точки независимо от языка программирования, используемого для реализации объекта, к которому осуществляется привязка.

Например, на странице: **Text="{x:Bind Employee.FirstName}"** будет искать участника **Employee** на странице, а затем участника **FirstName** в объекте, возвращенном участником **Employee**. Если бы элемент управления элементами привязывался к свойству, содержащему подчиненных сотрудников, то путем свойства мог бы быть Employee.Dependents, а шаблон элемента управления элементами, отобразил бы элементы в Dependents.

В случае использования языков C++/CX **{x:Bind}** нельзя привязать к частным полям и свойствам в модели страницы или данных—вам потребуется открытое свойство для выполнения привязки. Контактную зону для привязки необходимо предоставлять в качестве классов/интерфейсов CX, чтобы можно было получить соответствующие метаданные. Атрибут **\[Bindable\]**, как правило, не требуется.

Если источником данных выступает коллекция, то в пути свойства можно указывать элементы коллекции по их позиции или индексу. Пример: Teams\[0\].Players. Здесь в "\[\]" заключается индекс "0", который запрашивает первый элемент в коллекции, индексируемой от нуля.

Чтобы воспользоваться индексатором, модели необходимо реализовать **IList&lt;T&gt;** или **IVector&lt;T&gt;** в типе свойства, которое подлежит индексации. Если тип индексированного свойства поддерживает **INotifyCollectionChanged** или **IObservableVector**, а привязка относится к типу OneWay или TwoWay, то она будет принимать и регистрировать уведомления об изменениях на этих интерфейсах. Логика отслеживания изменений обновляется с учетом всех изменений коллекции, даже если эти изменения не влияют на конкретное индексированное значение. Это обусловлено тем, что логика ожидания передачи данных общая для всех экземпляров коллекции.

Для привязки присоединенных свойств необходимо ввести имена класса и свойства в круглых скобках после точки. Например, **Text="{x:Bind Button22.(Grid.Row)}"**. Если свойство не объявляется в пространстве имен Xaml, нужно установить для него префикс пространства имен xml, которое необходимо сопоставить с пространством имен кода в заголовке документа.

Скомпилированные привязки строго типизированы и распознают тип каждого этапа в пути. Если возвращаемый тип не содержит элемент, во время компиляции будет возвращена ошибка. Можно сообщать привязке реальный тип объекта, определив приведение. В следующем случае **obj** является свойством объекта типа, но содержит текстовое поле, что позволяет использовать **Text="{x:Bind obj.(TextBox.Text)}"**.

Поле **groups3** в **Text="{x:Bind groups3\[0\].(data:SampleDataGroup.Title)}"** является словарем объектов, поэтому необходимо привести его к **data:SampleDataGroup**. Обратите внимание на то, как используется префикс пространства имен **data:** для сопоставления типа объектов с пространством имен, не являющимся частью пространства имен XAML по умолчанию.

При использовании **x:Bind** вам не нужно применять **ElementName=xxx** как часть выражения привязки. **x:Bind** позволяет использовать имя элемента в качестве первой части пути для привязки, поскольку именованные элементы становятся полями на странице или в пользовательском элементе управления, который представляет собой источник привязки корня.

Привязка события– это новая функция для компилированной привязки. Она позволяет определять обработчик для события с использованием привязки, а не применяется в качестве метода в коде программной части. Например, **Click="{x:Bind rootFrame.GoForward}"**.

В случае работы с событиями метод не должен быть перегружен; он должен соответствовать таким условиям:

-   соответствовать подписи события;
-   или не иметь параметров;
-   или иметь такое же количество параметров типов, которые назначаются из типов параметров событий.

В созданном коде программной части скомпилированная привязка обрабатывает событие и направляет его к методу в модели, анализируя путь выражения привязки при возникновении события. Это означает, что, в отличие от привязок свойства, она не отслеживает изменения в модели.

Дополнительную информацию о синтаксисе строк для пути свойства см. в разделе [Синтаксис пути свойства](property-path-syntax.md), учитывая отличия **{x:Bind}**, описанные в данной статье.

##  Свойства, которые можно задать с помощью расширения разметки {x:Bind}



            **{x:Bind}** демонстрируется с помощью замещающего синтаксиса *bindingProperties*, поскольку есть несколько свойств, доступных для чтения и записи, которые можно задавать в данном случае использования расширения разметки. Свойства можно задавать в любом порядке с парами *propName*=*value*, разделенными запятыми. Обратите внимание, что разрывы строк недопустимы в выражении привязки. Для некоторых свойств требуются типы, не предусматривающие преобразования; им необходимы их собственные расширения разметки, вложенные в **{x:Bind}**.

Эти свойства работают практически так же, как и свойства класса [**Binding**](https://msdn.microsoft.com/library/windows/apps/br209820).

| Свойство | Описание |
|----------|-------------|
| **Путь** | См. раздел [Путь к свойству](#property-path) выше. |
| **Converter** | Указывает объект преобразователя, вызываемый механизмом привязки. Преобразователь можно задать в коде XAML, но только в случае, если вы ссылаетесь на экземпляр объекта, присвоенный в ссылке на [расширение разметки {StaticResource}](staticresource-markup-extension.md) этому объекту в словаре ресурсов. |
| **ConverterLanguage** | Указывает язык и региональные параметры, используемые преобразователем. (Если задается свойство **ConverterLanguage**, также следует задать свойство **Converter**.) Язык и региональные параметры задаются как стандартный идентификатор. Подробнее: [**ConverterLanguage**](https://msdn.microsoft.com/library/windows/apps/hh701880). |
| **ConverterParameter** | Указывает параметр преобразователя, который можно использовать в логике преобразователя. (Если задается **ConverterParameter**, также следует задать свойство **Converter**.) Большая часть преобразователей использует простую логику для получения всей необходимой информации из переданного значения, и им не нужно значение **ConverterParameter**. Параметр **ConverterParameter** используется для более расширенных преобразователей, у которых больше одной логики и которым недостаточно информации, переданной в **ConverterParameter**. Вы также можете написать преобразователь, который использует нестроковые значения, но это используется редко. Подробнее см. в разделе "Примечания" статьи [**ConverterParameter**](https://msdn.microsoft.com/library/windows/apps/br209827). |
| **FallbackValue** | Задает значение, которое отображается, когда не удается разрешить источник или путь. |
| **Mode** | Указывает режим привязки как одну из этих строк: OneTime, OneWay или TwoWay. Значение по умолчанию—OneTime. Обратите внимание, что это поведение отличается от шаблона по умолчанию для привязки **{Binding}**, которая в большинстве случаев имеет значение OneWay. |
| **TargetNullValue** | Задает значение, которое отображается, когда значение источника разрешается, но оно явно равно **null**. | 


            **Примечание.**  Если вы преобразуете разметку **{Binding}** в **{x:Bind}**, следует учитывать различия между значениями по умолчанию для свойства **Mode**.
 
## Комментарии

Поскольку **{x:Bind}** использует сформированный код, во время компиляции ему необходима информация о типе, чтобы воспользоваться всеми доступными преимуществами. Это означает, что, не зная заранее тип, вы не сможете выполнить привязку к свойствам. По этой причине невозможно использовать **{x:Bind}** со свойством **DataContext**, которое относится к типу **Object** и может во время выполнения изменяться.

При использовании **{x:Bind}** с шаблонами данных необходимо указать тип, к которому будет выполняться привязка, установив значение **x:DataType**, как показано в следующем примере. Вы также можете задавать тип для интерфейса или базового класса, а затем использовать приведения, если понадобится сформулировать полное выражение.

Скомпилированные привязки зависят от создания кода. Если вы используете **{x:Bind}** в словаре ресурсов, тогда словарь ресурсов должен иметь класс кода программной части. Пример кода см. в разделе [Словари ресурсов с привязкой {x:Bind}](../data-binding/data-binding-in-depth.md#resource-dictionaries-with-x-bind).


            **Важно!** Если установить локальное значение для свойства, локальное значение которого ранее предоставлялось расширением разметки **{x:Bind}**, то привязка полностью удаляется.


            **Совет.** Если в значении необходимо указать одну фигурную скобку, как, например, в [**Path**](https://msdn.microsoft.com/library/windows/apps/br209830) или [**ConverterParameter**](https://msdn.microsoft.com/library/windows/apps/br209827), поставьте перед ней обратную косую черту: `\{`. Также можно включить всю строку, содержащую скобки, которые нужно преобразовать, в дополнительный набор кавычек, например: `ConverterParameter='{Mix}'`.


            [
              **Converter**
            ](https://msdn.microsoft.com/library/windows/apps/br209826), [**ConverterLanguage**](https://msdn.microsoft.com/library/windows/apps/hh701880) и **ConverterLanguage** связаны сценарием преобразования значения или типа из источника привязки в тип или значение, совместимые со свойством целевого объекта привязки. Более подробную информацию и примеры см. в разделе "Преобразования данных" статьи [Подробно о привязке данных](https://msdn.microsoft.com/library/windows/apps/mt210946).


            **{x:Bind}** является исключительно расширением разметки и не дает возможности создавать или управлять такими привязками программным способом. Подробнее о расширениях разметки см. в разделе [Обзор языка XAML](xaml-overview.md).

## Примеры.

```XML
<Page x:Class="QuizGame.View.HostView" ... >
    <Button Content="{x:Bind Path=ViewModel.NextButtonText, Mode=OneWay}" ... />
</Page>
```

В этом примере кода XAML используется **{x:Bind}** со свойством **ListView.ItemTemplate**. Обратите внимание на объявление значения **x:DataType**.

```XML
  <DataTemplate x:Key="SimpleItemTemplate" x:DataType="data:SampleDataGroup">
    <StackPanel Orientation="Vertical" Height="50">
      <TextBlock Text="{x:Bind Title}"/>
      <TextBlock Text="{x:Bind Description}"/>
    </StackPanel>
  </DataTemplate>
```




<!--HONumber=Jun16_HO4-->


