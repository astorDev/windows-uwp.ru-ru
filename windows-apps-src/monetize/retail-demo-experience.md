---
author: joannaleecy
title: "Создание приложения для демонстрации в розничных магазинах"
description: "Создание приложения для демонстрации в розничных магазинах (RDX-приложения) — приложения, которое можно запускать как в демонстрационном, так и в обычном режиме"
ms.assetid: f83f950f-7fdd-4f18-8127-b92a8f400061
translationtype: Human Translation
ms.sourcegitcommit: ccc7cfea885cc9c8803cfc70d2e043192a7fee84
ms.openlocfilehash: ca9e27944cc4504400191ef1620949b1e8b64ff2

---
#  <a name="create-a-retail-demo-experience-rdx-app"></a>Создание приложения для демонстрации в розничных магазинах (RDX)

Отправляясь в розничный магазин, покупатели рассчитывают опробовать в действии новейшие компьютеры и мобильные телефоны. Устройства, выставляемые для этой цели в магазинах, называются демонстрационными устройствами для розничных магазинов. Именно демонстрационные устройства и установленное на них содержимое в наибольшей степени формируют впечатления покупателей от посещения магазина, поскольку покупатели зачастую проводят немало времени, экспериментируя с такими устройствами.

Приложения, устанавливаемые на этих компьютерах и мобильных телефонах, должны представлять собой приложения для демонстрации в розничных магазинах (RDX-приложения). В этой статье рассказывается, как спроектировать и разработать демонстрационную версию приложения, предназначенную для установки на компьютерах и мобильных устройствах в розничных магазинах.

Приложение для демонстрации в розничных магазинах представляет собой единую сборку, которая может запускаться в одном из двух режимов: _обычном_ или _розничном_. С точки зрения наших пользователей приложение только одно и, чтобы помочь им различать две его версии, рекомендуется, чтобы при запуске в демонстрационной версии в строке заголовка или другом заметном месте приложения присутствовало слово «Демо».

Помимо требований, предъявляемых к приложениям Магазином, RDX-приложения также должны быть полностью совместимы с системой настройки, очистки и обновления демонстрационных устройств для розничных магазинов, чтобы покупатели устройств в магазинах неизменно получали положительные впечатления.

## <a name="design-principles"></a>Принципы проектирования

### <a name="show-your-best"></a>Покажите лучшее, на что способно ваше приложение

Используйте демонстрационный режим, чтобы дать покупателю понять, в чем преимущества вашего приложения.  Скорее всего, это будет первое знакомство покупателя с вашим приложением, поэтому покажите его с самой выгодной стороны.
    
### <a name="show-it-fast"></a>Демонстрируйте приложение быстро

Покупатель может быть нетерпелив, поэтому чем быстрее он ощутит преимущества вашего приложения, тем лучше. 
    
### <a name="keep-the-story-simple"></a>Не усложняйте процесс
    
Помните, что демонстрационный режим — это «речь в лифте» вашего приложения.
    
### <a name="focus-on-the-experience"></a>Позаботьтесь о комфорте пользователя

Дайте покупателю время «переварить» то, что он видит в вашем приложении.  Хотя ваша задача — как можно быстрее добраться до самого интересного в вашем приложении, возможно, имеет смысл предусмотреть логические паузы.

## <a name="technical-requirements"></a>Технические требования

Поскольку приложения для демонстрации в розничных магазинах предназначены для демонстрации основных преимуществ вашего приложения покупателям в розничных магазинах, необходимо, чтобы они соответствовали перечисленным ниже техническим требованиям и правилам в отношении конфиденциальности, предусмотренным в Магазине для RDX-приложений.
Эти требования также можно использовать в качестве контрольного списка для подготовки к процессу проверки и внесения ясности в тестирование. Обратите внимание, что приложение должно соответствовать этим требованиям не только при прохождении проверки, но и в течение всего жизненного цикла RDX-приложения, т. е. всего времени его использования на демонстрационных устройствах в розничных магазинах.

### <a name="critical-level-requirements"></a>Критические требования
   
RDX-приложения, которые не соответствуют этим критическим требованиям, будут при первой же возможности удалены со всех демонстрационных устройствах в розничных магазинах.

* Отсутствие запросов персональных данных

    Приложение не должно запрашивать у пользователей никаких персональных данных.  К таким данным относятся любая информация об учетной записи Майкрософт, контактная информация и т. д.
    
* Отсутствие ошибок

    Ваше приложение должно работать без ошибок. Кроме того, на демонстрационных устройствах не должны выводиться никакие всплывающие или иные уведомления об ошибках. Это важно, поскольку мы хотим демонстрировать устройства и приложения покупателям с лучшей стороны; значит, ошибки должны быть исключены. 
    Ошибки отрицательно сказываются на самом приложении, имидже вашей торговой марки, устройстве, на котором запущено приложение, имидже торговой марки изготовителя устройства и торговой марки Майкрософт.
    
* Пробный режим для платных приложений

    Для установки приложения на демонстрационных устройствах для розничных магазинов приложение должно быть бесплатным или в нем должен быть предусмотрен пробный режим.  Покупатели вряд ли захотят оплачивать работу с приложением в магазине. Подробнее см. в статье [Исключение или ограничение функций в пробной версии](https://msdn.microsoft.com/windows/uwp/monetize/exclude-or-limit-features-in-a-trial-version-of-your-app).

### <a name="high-priority-requirements"></a>Высокоприоритетные требования
    
RDX-приложения, которые не соответствуют перечисленным ниже высокоприоритетным требованиям, необходимо незамедлительно изучить и внести исправление. Если сразу же исправить приложение не удается, возможно, оно будет удалено со всех демонстрационных устройств для розничных магазинов.

* Запоминающаяся работа в автономном режиме

    RDX-приложение должно предусматривать комфортную работу в автономном режиме, поскольку около 50% устройств в магазинах не подключены к Интернету. Так покупатели, взаимодействующие с вашим приложением, все равно смогут получить положительные впечатления от работы с ним.
    
* Актуальное содержимое в любой момент времени

    Чтобы обеспечить покупателю наилучшие впечатление, приложение должно всегда быть актуальным, и при подключении к Интернету покупатели не должны видеть запросов на обновление приложения.
        
* Отсутствие возможностей для анонимной связи

    Поскольку покупатель, пользующийся демонстрационным устройством в магазине, является анонимным пользователем, у него не должно быть возможности отправлять с устройства сообщения или какое-либо содержимое.
    
* Единообразие взаимодействия для всех пользователей (наличие процесса очистки)

    Состояние устройства и приложений на нем должно быть одинаковым для всех покупателей, подходящих к устройству. В приложении должен быть предусмотрен [процесс очистки](#clean-up-process) для возврата в исходное состояние после каждого использования; нельзя, чтобы покупатель видел на устройстве результаты взаимодействия с ним предыдущего покупателя.  Такими результатами могут быть набранные очки, достигнутые уровни и разблокировки.
    
* Содержимое, подходящее для всех возрастов

    Все содержимое RDX-приложения должно иметь возрастную категорию «для подростков» или более низкую. Подробнее: [Getting your app rated by IARC](https://www.globalratings.com/for-developers.aspx) и [ESRB ratings](https://www.esrb.org/ratings/ratings_guide.aspx).
    
### <a name="medium-priority-requirements"></a>Среднеприоритетные требования

Если приложение не соответствует этим требованиям, сотрудники розничного магазина Windows могут связаться с разработчиком напрямую, чтобы обсудить устранения возможные способы устранения проблемы.

* Правильная работа на различных устройствах

    RDX-приложения должны хорошо работать на всех устройствах, включая бюджетные устройства с невысокими характеристиками. Если RDX-приложение устанавливается на устройства, которые не соответствуют минимальным требованиям для запуска приложения, приложение должно четко информировать пользователя об этом. Должны быть известны минимальные требования к устройствам, чтобы приложение всегда могло работать с должной производительностью.
     
* Соответствие требованиям к размеру приложений для розничных магазинов
    
    Размер приложения не должен превышать 800 МБ. Если ваше приложение не соответствует этому требованию, обратитесь непосредственно к сотрудникам розничного магазина Windows, чтобы обсудить этот вопрос.

## <a name="preparing-codebase-for-retail-demo-mode-development"></a>Подготовка базы кода для разработки режима демонстрации в розничных магазинах

Свойство [**IsDemoModeEnabled**](https://msdn.microsoft.com/library/windows/apps/windows.system.profile.retailinfo.isdemomodeenabled.aspx) в служебном классе [**RetailInfo**](https://msdn.microsoft.com/library/windows/apps/windows.system.profile.retailinfo.aspx), который входит в состав пространства имен [Windows.System.Profile](https://msdn.microsoft.com/library/windows/apps/windows.system.profile.aspx) в Windows 10 SDK, используется в качество логического индикатора для указания того, по какому пути кода работает приложение — в _обычном_ режиме или в _демонстрационном_ режиме. 

Когда свойство [**RetailInfo.IsDemoModeEnabled**](https://msdn.microsoft.com/library/windows/apps/windows.system.profile.retailinfo.isdemomodeenabled.aspx) возвращает значение true, можно запросить с помощью свойства [**RetailInfo.Properties**](https://msdn.microsoft.com/library/windows/apps/windows.system.profile.retailinfo.properties.aspx) набор свойств демонстрационного устройства для настройки приложения в соответствии с его характеристиками. К таким свойствам относятся [**ManufacturerName**](https://msdn.microsoft.com/library/windows/apps/windows.system.profile.knownretailinfoproperties.manufacturername.aspx), [**Screensize**](https://msdn.microsoft.com/library/windows/apps/windows.system.profile.knownretailinfoproperties.screensize.aspx), [**Memory**](https://msdn.microsoft.com/library/windows/apps/windows.system.profile.knownretailinfoproperties.memory.aspx) и др. 


## <a name="clean-up-process"></a>Процесс очистки

Назначение процесса очистки — обеспечить автоматический сброс демонстрационных устройств к настройкам по умолчанию, если с устройством никто не взаимодействует в течение определенного времени. Это гарантирует, что каждый пользователь, подходящий к устройству в розничном магазине, будет взаимодействовать с ним одинаковым, предусмотренным разработчиком образом. При разработке RDX-приложения важно понимать, когда и как инициируется процесс очистки, что происходит в процессе очистки по умолчанию, а также как настроить этот процесс в соответствии с вашими потребностями.

### <a name="when-does-clean-up-begin"></a>Когда начинается очистка?

Последовательность очистки начинается после определенного времени бездействия устройства. Время бездействия отсчитывается с момента последнего ввода на устройства — сенсорного, с мыши или с клавиатуры.

#### <a name="desktoppc"></a>Компьютеры

После 120 секунд бездействия на устройстве начинается воспроизведение видеоролика для привлечения покупателей. Спустя еще 5 секунд начинается процесс очистки.

#### <a name="phone"></a>Телефоны

Через 60 секунд бездействия на устройстве начинается воспроизведение видеоролика для привлечения покупателей, и сразу же начинается процесс очистки.

### <a name="what-happens-during-a-default-clean-up-process"></a>Что происходит в процессе очистки по умолчанию?

#### <a name="step-1-clean-up"></a>Шаг 1. Очистка
* Все приложения Win32 и приложения Магазина закрываются
* Все файлы в известных папках, таких как __Изображения__, __Видео__, __Музыка__, __Документы__, __Сохраненные изображения__, __Альбом камеры__, __Рабочий стол__ и __Загрузки__ удаляются
* Неструктурированные и структурированные состояния перемещения удалены
* Структурированные локальные состояния удалены

#### <a name="step-2-set-up"></a>Шаг 2. Настройка 
* Для автономных устройств: папки остаются пустыми
* Для устройств, подключенных к Интернету: на устройство могут быть отправлены демонстрационные ресурсы для розничных магазинов из Магазина Windows

### <a name="how-to-store-data-across-user-sessions"></a>Как хранить данные между сеансами пользователя?

Если вы хотите хранить данные между сеансами пользователя, вы можете сохранять информацию в папке __ApplicationData.Current.TemporaryFolder__, поскольку процесс очистки по умолчанию не удаляет данные в этой папке автоматически. Обратите внимание, что информация, хранимая с помощью *LocalState*, в процессе очистки удаляется. 

### <a name="how-to-customize-the-clean-up-process"></a>Как настроить процесс очистки?

Если вы хотите настроить процесс очистки, вам необходимо реализовать в своем приложении службу приложений `Microsoft-RetailDemo-Cleanup`. 

Пользовательскую логику очистки имеет смысл использовать в ситуациях с дорогостоящей настройкой, скачиванием и кэширование данных, а также когда удаление данных *LocalState* нежелательно.

Шаг 1. Объявите в манифесте приложения службу _Microsoft-RetailDemo-Cleanup_.
``` CSharp
  <Applications>
      <Extensions>
        <uap:Extension Category="windows.appService" EntryPoint="MyCompany.MyApp.RDXCustomCleanupTask">
          <uap:AppService Name="Microsoft-RetailDemo-Cleanup" />
        </uap:Extension>
      </Extensions>
   </Application>
  </Applications>

``` 

Шаг 2. Реализуйте свою собственную логику очистки в функции _AppdataCleanup_, руководствуясь шаблоном ниже.
``` CSharp
using System;
using System.IO;
using System.Runtime.Serialization.Json;
using System.Threading;
using System.Threading.Tasks;
using Windows.ApplicationModel.AppService;
using Windows.ApplicationModel.Background;
using Windows.Foundation.Collections;
using Windows.Storage;

namespace MyCompany.MyApp
{
    public sealed class RDXCustomCleanupTask : IBackgroundTask
    {
        BackgroundTaskCancellationReason _cancelReason = BackgroundTaskCancellationReason.Abort;
        BackgroundTaskDeferral _deferral = null;
        IBackgroundTaskInstance _taskInstance = null;
        AppServiceConnection _appServiceConnection = null;

        const string MessageCommand = "Command";

        public void Run(IBackgroundTaskInstance taskInstance)
        {
            // Get the deferral object from the task instance, and take a reference to the taskInstance;
            _deferral = taskInstance.GetDeferral();
            _taskInstance = taskInstance;
            _taskInstance.Canceled += new BackgroundTaskCanceledEventHandler(OnCanceled);

            AppServiceTriggerDetails appService = _taskInstance.TriggerDetails as AppServiceTriggerDetails;
            if ((appService != null) && (appService.Name == "Microsoft-RetailDemo-Cleanup"))
            {
                _appServiceConnection = appService.AppServiceConnection;
                _appServiceConnection.RequestReceived += _appServiceConnection_RequestReceived;
                _appServiceConnection.ServiceClosed += _appServiceConnection_ServiceClosed;
            }
            else
            {
                _deferral.Complete();
            }
        }

        void _appServiceConnection_ServiceClosed(AppServiceConnection sender, AppServiceClosedEventArgs args)
        {
        }

        async void _appServiceConnection_RequestReceived(AppServiceConnection sender, AppServiceRequestReceivedEventArgs args)
        {
            //Get a deferral because we will be calling async code 
            AppServiceDeferral requestDeferral = args.GetDeferral();
            string command = null;
            var returnData = new ValueSet();

            try
            {
                ValueSet message = args.Request.Message;
                if (message.ContainsKey(MessageCommand))
                {
                    command = message[MessageCommand] as string;
                }

                if (command != null)
                {
                    switch (command)
                    {
                        case "AppdataCleanup":
                            {
                                // Do custom clean up logic here
                                break;
                            }
                    }
                }
            }
            catch (Exception e)
            {
            }
            finally
            {
                requestDeferral.Complete();
                // Also release the task deferral since we only process one request per instance.
                _deferral.Complete();
            }
        }

        private void OnCanceled(IBackgroundTaskInstance sender, BackgroundTaskCancellationReason reason)
        {
            _cancelReason = reason;
        }
    }
}
```

## <a name="related-links"></a>Дополнительные ссылки

* [Сохранение и получение данных приложения](https://msdn.microsoft.com/windows/uwp/app-settings/store-and-retrieve-app-data)
* [Создание и использование службы приложений](https://msdn.microsoft.com/windows/uwp/launch-resume/how-to-create-and-consume-an-app-service)
* [Локализация содержимого приложения](https://msdn.microsoft.com/windows/uwp/globalizing/globalizing-portal)


 

 



<!--HONumber=Dec16_HO3-->


